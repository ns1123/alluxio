/*
 * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0
 * (the "License"). You may not use this work except in compliance with the License, which is
 * available at www.apache.org/licenses/LICENSE-2.0
 *
 * This software is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied, as more fully set forth in the License.
 *
 * See the NOTICE file distributed with this work for information regarding copyright ownership.
 */

package alluxio.web;

import alluxio.Configuration;
import alluxio.PropertyKey;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.apache.commons.codec.binary.Hex;

import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Collections;
import java.util.Map;

import javax.annotation.concurrent.ThreadSafe;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet for login.
 */
@ThreadSafe
public final class WebInterfaceLoginServlet extends HttpServlet {
  /**
   * Path for the login servlet.
   */
  public static final String PATH = "/login";
  /**
   * Path for the login jsp.
   */
  public static final String JSP_PATH = "/login.jsp";

  /**
   * POST parameter name for username.
   */
  public static final String REQUEST_PARAMETER_USERNAME = "username";
  /**
   * POST parameter name for the hashed password.
   */
  public static final String REQUEST_PARAMETER_PASSWORD = "password";

  /**
   * Request attribute representing that the username does not exist.
   */
  public static final String REQUEST_ATTRIBUTE_USERNAME_NOT_EXISTS = "usernameNotExists";
  /**
   * Request attribute representing that the password is incorrect.
   */
  public static final String REQUEST_ATTRIBUTE_PASSWORD_INCORRECT = "passwordIncorrect";

  /**
   * Name of the session attribute to store authentication token.
   */
  public static final String SESSION_ATTRIBUTE_AUTHENTICATION_TOKEN = "authToken";

  /**
   * Maximum number of active sessions.
   */
  private static final int MAX_SESSIONS = Configuration.getInt(PropertyKey.WEB_LOGIN_SESSIONS);
  /**
   * A cache for mappings from session IDs to authentication tokens.
   * The tokens are generated by {@link #generateAuthenticationToken(String, String, String)}.
   * {@link AuthenticationFilter} also needs access to this map.
   */
  public static final Cache<String, String> AUTHENTICATION_TOKENS =
      CacheBuilder.newBuilder().maximumSize(MAX_SESSIONS).build();

  /**
   * Unmodifiable map from usernames to passwords.
   */
  private final Map<String, String> mUserPasswords;

  /**
   * Creates a new instance of {@link WebInterfaceLoginServlet}.
   */
  public WebInterfaceLoginServlet(Map<String, String> userPasswords) {
    mUserPasswords = Collections.unmodifiableMap(userPasswords);
  }

  @Override
  protected void doGet(HttpServletRequest request, HttpServletResponse response)
      throws ServletException, IOException {
    getServletContext().getRequestDispatcher(JSP_PATH).include(request, response);
  }

  @Override
  protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Check username.
    String username = request.getParameter(REQUEST_PARAMETER_USERNAME);
    if (!mUserPasswords.containsKey(username)) {
      request.setAttribute(REQUEST_ATTRIBUTE_USERNAME_NOT_EXISTS, true);
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
      getServletContext().getRequestDispatcher(JSP_PATH).forward(request, response);
      return;
    }

    // Check password.
    String passwordHash = request.getParameter(REQUEST_PARAMETER_PASSWORD);
    String password = mUserPasswords.get(username);
    String sessionID = request.getSession().getId();
    String hash = generatePasswordHash(password, sessionID);
    if (!passwordHash.equals(hash)) {
      request.setAttribute(REQUEST_ATTRIBUTE_PASSWORD_INCORRECT, true);
      response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
      getServletContext().getRequestDispatcher(JSP_PATH).forward(request, response);
      return;
    }

    // Generate authentication key, cache it, and save it as client cookies.
    String token = generateAuthenticationToken(username, password, sessionID);
    AUTHENTICATION_TOKENS.put(sessionID, token);
    request.getSession().setAttribute(SESSION_ATTRIBUTE_AUTHENTICATION_TOKEN, token);
  }

  private static String md5Hex(String message) {
    try {
      MessageDigest md5 = MessageDigest.getInstance("MD5");
      return new String(Hex.encodeHex(md5.digest(message.getBytes())));
    } catch (NoSuchAlgorithmException e) {
      // MD5 message digest should always be available.
      throw new RuntimeException(e);
    }
  }

  /**
   * NOTE: login.jsp should use the same mechanism to hash the password before sending
   * HTTP POST request, so that the password is not sent as plain text.
   *
   * @param password the password
   * @param sessionID the session ID
   * @return the hash of the combination of password and session ID
   */
  private static String generatePasswordHash(String password, String sessionID) {
    return md5Hex(password + " " + sessionID);
  }

  /**
   * Generates the authentication key based on username, password, and session ID.
   *
   * The computed key is intended to be stored as value for session attribute
   * {@link #SESSION_ATTRIBUTE_AUTHENTICATION_TOKEN}.
   *
   * @param username the username
   * @param password the password
   * @param sessionID the session ID
   * @return the authentication key
   */
  private static String generateAuthenticationToken(String username, String password,
      String sessionID) {
    return md5Hex(username + " " + password + " " + sessionID);
  }
}
