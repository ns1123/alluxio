diff --git a/core/base/src/main/java/alluxio/exception/ExceptionMessage.java b/core/base/src/main/java/alluxio/exception/ExceptionMessage.java
index d5ca951cbd..4f354d6622 100644
--- a/core/base/src/main/java/alluxio/exception/ExceptionMessage.java
+++ b/core/base/src/main/java/alluxio/exception/ExceptionMessage.java
@@ -35,6 +35,7 @@ public enum ExceptionMessage {
 
   // general block
   BLOCK_UNAVAILABLE("Block {0} is unavailable in both Alluxio and UFS."),
+  BLOCK_SIZE_INVALID("Block size of {0} is invalid. Block size must be > 0 bytes."),
   CANNOT_REQUEST_SPACE("Not enough space left on worker {0} to store blockId {1,number,#}."),
   NO_LOCAL_WORKER("Local address {0} requested but there is no local worker"),
   NO_SPACE_FOR_BLOCK_ON_WORKER("There is no worker with enough space for a new block of size {0}"),
diff --git a/core/client/fs/src/main/java/alluxio/client/AbstractOutStream.java b/core/client/fs/src/main/java/alluxio/client/AbstractOutStream.java
index 95d00ea4b3..bbfa917d2a 100644
--- a/core/client/fs/src/main/java/alluxio/client/AbstractOutStream.java
+++ b/core/client/fs/src/main/java/alluxio/client/AbstractOutStream.java
@@ -29,7 +29,7 @@ public abstract class AbstractOutStream extends OutputStream implements Cancelab
 
   /**
    * @return the number of bytes written to this stream
-   * @deprecated this method will not work if more than MAX_INT bytes are written; to get a count of
+   * @deprecated this method will not work if more than MAX_INT bytes are written; to create a count of
    *             bytes written, wrap this stream in a counting output stream such as
    *             org.apache.commons.io.output.CountingOutputStream
    */
diff --git a/core/client/fs/src/main/java/alluxio/client/RetryHandlingMetaMasterClient.java b/core/client/fs/src/main/java/alluxio/client/RetryHandlingMetaMasterClient.java
index 67de240360..446b60156c 100644
--- a/core/client/fs/src/main/java/alluxio/client/RetryHandlingMetaMasterClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/RetryHandlingMetaMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.client;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.grpc.BackupPOptions;
 import alluxio.grpc.GetConfigReportPOptions;
@@ -46,8 +47,8 @@ public class RetryHandlingMetaMasterClient extends AbstractMasterClient
    *
    * @param conf master client configuration
    */
-  public RetryHandlingMetaMasterClient(MasterClientConfig conf) {
-    super(conf);
+  public RetryHandlingMetaMasterClient(MasterClientConfig conf, AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
diff --git a/core/client/fs/src/main/java/alluxio/client/block/AlluxioBlockStore.java b/core/client/fs/src/main/java/alluxio/client/block/AlluxioBlockStore.java
index 78322cca49..0a7816bb20 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/AlluxioBlockStore.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/AlluxioBlockStore.java
@@ -14,9 +14,9 @@ package alluxio.client.block;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
@@ -68,6 +68,7 @@ public final class AlluxioBlockStore {
 
   private final FileSystemContext mContext;
   private final TieredIdentity mTieredIdentity;
+  private final AlluxioConfiguration mAlluxioConf;
 
   /** Cached map for workers. */
   private List<BlockWorkerInfo> mWorkerInfoList = null;
@@ -79,8 +80,8 @@ public final class AlluxioBlockStore {
    *
    * @return the {@link AlluxioBlockStore} created
    */
-  public static AlluxioBlockStore create() {
-    return create(FileSystemContext.get());
+  public static AlluxioBlockStore create(AlluxioConfiguration alluxioConf) {
+    return create(FileSystemContext.create(), alluxioConf);
   }
 
   /**
@@ -89,8 +90,9 @@ public final class AlluxioBlockStore {
    * @param context the file system context
    * @return the {@link AlluxioBlockStore} created
    */
-  public static AlluxioBlockStore create(FileSystemContext context) {
-    return new AlluxioBlockStore(context, TieredIdentityFactory.localIdentity());
+  public static AlluxioBlockStore create(FileSystemContext context,
+      AlluxioConfiguration alluxioConf) {
+    return new AlluxioBlockStore(context, TieredIdentityFactory.localIdentity(alluxioConf), alluxioConf);
   }
 
   /**
@@ -100,11 +102,13 @@ public final class AlluxioBlockStore {
    * @param tieredIdentity the tiered identity
    */
   @VisibleForTesting
-  AlluxioBlockStore(FileSystemContext context, TieredIdentity tieredIdentity) {
+  AlluxioBlockStore(FileSystemContext context, TieredIdentity tieredIdentity,
+      AlluxioConfiguration alluxioConf) {
     mContext = context;
+    mAlluxioConf = alluxioConf;
     mTieredIdentity = tieredIdentity;
     mWorkerRefreshPolicy =
-        new TimeoutRefresh(Configuration.getMs(PropertyKey.USER_WORKER_LIST_REFRESH_INTERVAL));
+        new TimeoutRefresh(alluxioConf.getMs(PropertyKey.USER_WORKER_LIST_REFRESH_INTERVAL));
   }
 
   /**
@@ -210,7 +214,8 @@ public final class AlluxioBlockStore {
               .collect(toList());
       Collections.shuffle(tieredLocations);
       Optional<TieredIdentity> nearest =
-          TieredIdentityUtils.nearest(mTieredIdentity, tieredLocations);
+          TieredIdentityUtils.nearest(mTieredIdentity, tieredLocations,
+              mAlluxioConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP));
       if (nearest.isPresent()) {
         dataSource = locations.stream().map(BlockLocation::getWorkerAddress)
             .filter(addr -> addr.getTieredIdentity().equals(nearest.get())).findFirst().get();
@@ -222,7 +227,7 @@ public final class AlluxioBlockStore {
         }
       }
     }
-    // Can't get data from Alluxio, get it from the UFS instead
+    // Can't create data from Alluxio, create it from the UFS instead
     if (dataSource == null) {
       dataSourceType = BlockInStreamSource.UFS;
       BlockLocationPolicy policy =
@@ -239,7 +244,7 @@ public final class AlluxioBlockStore {
     }
 
     try {
-      return BlockInStream.create(mContext, info, dataSource, dataSourceType, options);
+      return BlockInStream.create(mContext, info, dataSource, dataSourceType, options, mAlluxioConf);
     } catch (UnavailableException e) {
       //When BlockInStream created failed, it will update the passed-in failedWorkers
       //to attempt to avoid reading from this failed worker in next try.
@@ -289,7 +294,7 @@ public final class AlluxioBlockStore {
     }
     LOG.debug("Create block outstream for {} of block size {} at address {}, using options: {}",
         blockId, blockSize, address, options);
-    return BlockOutStream.create(mContext, blockId, blockSize, address, options);
+    return BlockOutStream.create(mContext, blockId, blockSize, address, options, mAlluxioConf);
   }
 
   /**
@@ -353,7 +358,8 @@ public final class AlluxioBlockStore {
           workerAddressList.size(), initialReplicas));
     }
     return BlockOutStream
-        .createReplicatedBlockOutStream(mContext, blockId, blockSize, workerAddressList, options);
+        .createReplicatedBlockOutStream(mContext, blockId, blockSize, workerAddressList, options,
+            mAlluxioConf);
   }
 
   /**
diff --git a/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClient.java b/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClient.java
index f7a1835fea..9a9fc9eee0 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.client.block;
 
 import alluxio.Client;
 import alluxio.client.block.options.GetWorkerReportOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.master.MasterClientConfig;
 import alluxio.wire.BlockInfo;
 import alluxio.wire.BlockMasterInfo;
@@ -44,8 +45,9 @@ public interface BlockMasterClient extends Client {
      * @param conf master client configuration
      * @return a new {@link BlockMasterClient} instance
      */
-    public static BlockMasterClient create(MasterClientConfig conf) {
-      return new RetryHandlingBlockMasterClient(conf);
+    public static BlockMasterClient create(MasterClientConfig conf,
+        AlluxioConfiguration alluxioConf) {
+      return new RetryHandlingBlockMasterClient(conf, alluxioConf);
     }
   }
 
@@ -68,7 +70,7 @@ public interface BlockMasterClient extends Client {
   /**
    * Returns the {@link BlockInfo} for a block id.
    *
-   * @param blockId the block id to get the BlockInfo for
+   * @param blockId the block id to create the BlockInfo for
    * @return the {@link BlockInfo}
    */
   BlockInfo getBlockInfo(final long blockId) throws IOException;
diff --git a/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClientPool.java b/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClientPool.java
index af044f83af..d61b3e2119 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClientPool.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/BlockMasterClientPool.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.MasterClientConfig;
 import alluxio.master.MasterInquireClient;
 import alluxio.resource.ResourcePool;
@@ -36,6 +36,7 @@ public final class BlockMasterClientPool extends ResourcePool<BlockMasterClient>
   private final MasterInquireClient mMasterInquireClient;
   private final Queue<BlockMasterClient> mClientList;
   private final Subject mSubject;
+  private final AlluxioConfiguration mAlluxioConf;
 
   /**
    * Creates a new block master client pool.
@@ -43,8 +44,10 @@ public final class BlockMasterClientPool extends ResourcePool<BlockMasterClient>
    * @param subject the parent subject
    * @param masterInquireClient a client for determining the master address
    */
-  public BlockMasterClientPool(Subject subject, MasterInquireClient masterInquireClient) {
-    super(Configuration.getInt(PropertyKey.USER_BLOCK_MASTER_CLIENT_THREADS));
+  public BlockMasterClientPool(Subject subject, MasterInquireClient masterInquireClient,
+      AlluxioConfiguration alluxioConf) {
+    super(alluxioConf.getInt(PropertyKey.USER_BLOCK_MASTER_CLIENT_THREADS));
+    mAlluxioConf = alluxioConf;
     mSubject = subject;
     mMasterInquireClient = masterInquireClient;
     mClientList = new ConcurrentLinkedQueue<>();
@@ -62,8 +65,8 @@ public final class BlockMasterClientPool extends ResourcePool<BlockMasterClient>
 
   @Override
   protected BlockMasterClient createNewResource() {
-    BlockMasterClient client = BlockMasterClient.Factory.create(MasterClientConfig.defaults()
-        .withSubject(mSubject).withMasterInquireClient(mMasterInquireClient));
+    BlockMasterClient client = BlockMasterClient.Factory.create(MasterClientConfig.defaults(mAlluxioConf)
+        .withSubject(mSubject).withMasterInquireClient(mMasterInquireClient), mAlluxioConf);
     mClientList.add(client);
     return client;
   }
diff --git a/core/client/fs/src/main/java/alluxio/client/block/RetryHandlingBlockMasterClient.java b/core/client/fs/src/main/java/alluxio/client/block/RetryHandlingBlockMasterClient.java
index 85de9aa4d4..2ef90ebed7 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/RetryHandlingBlockMasterClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/RetryHandlingBlockMasterClient.java
@@ -14,6 +14,7 @@ package alluxio.client.block;
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
 import alluxio.client.block.options.GetWorkerReportOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.BlockMasterClientServiceGrpc;
 import alluxio.grpc.GetBlockInfoPRequest;
 import alluxio.grpc.GetBlockMasterInfoPOptions;
@@ -49,8 +50,8 @@ public final class RetryHandlingBlockMasterClient extends AbstractMasterClient
    *
    * @param conf master client configuration
    */
-  public RetryHandlingBlockMasterClient(MasterClientConfig conf) {
-    super(conf);
+  public RetryHandlingBlockMasterClient(MasterClientConfig conf, AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
@@ -102,7 +103,7 @@ public final class RetryHandlingBlockMasterClient extends AbstractMasterClient
   /**
    * Returns the {@link BlockInfo} for a block id.
    *
-   * @param blockId the block id to get the BlockInfo for
+   * @param blockId the block id to create the BlockInfo for
    * @return the {@link BlockInfo}
    */
   public BlockInfo getBlockInfo(final long blockId) throws IOException {
diff --git a/core/client/fs/src/main/java/alluxio/client/block/policy/BlockLocationPolicy.java b/core/client/fs/src/main/java/alluxio/client/block/policy/BlockLocationPolicy.java
index c68fbe82dc..0540e10c94 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/policy/BlockLocationPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/policy/BlockLocationPolicy.java
@@ -14,6 +14,7 @@ package alluxio.client.block.policy;
 import alluxio.annotation.PublicApi;
 import alluxio.client.block.policy.options.CreateOptions;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.util.CommonUtils;
 import alluxio.wire.WorkerNetAddress;
 
@@ -47,16 +48,19 @@ public interface BlockLocationPolicy {
      * @param options the block location policy creation options
      * @return a new instance of {@link BlockLocationPolicy}
      */
-    public static BlockLocationPolicy create(CreateOptions options) {
+    public static BlockLocationPolicy create(CreateOptions options,
+        AlluxioConfiguration alluxioConf) {
       int numShards = options.getDeterministicHashPolicyNumShards();
       try {
         Class<BlockLocationPolicy> clazz =
             (Class<BlockLocationPolicy>) Class.forName(options.getLocationPolicyClassName());
         if (numShards > 1) {
-          return CommonUtils.createNewClassInstance(clazz, new Class[] {Integer.class},
+          return CommonUtils.createNewClassInstance(clazz,
+              new Class[] {Integer.class},
               new Object[] {numShards});
         } else {
-          return CommonUtils.createNewClassInstance(clazz, new Class[] {}, new Object[] {});
+          return CommonUtils.createNewClassInstance(clazz, new Class[] {AlluxioConfiguration.class},
+              new Object[] {alluxioConf});
         }
       } catch (ClassNotFoundException e) {
         throw new RuntimeException(e);
@@ -67,7 +71,7 @@ public interface BlockLocationPolicy {
   /**
    * Gets the worker's network address for serving operations requested for the block.
    *
-   * @param options the options to get a block worker network address for a block
+   * @param options the options to create a block worker network address for a block
    * @return the address of the worker to write to, null if no worker can be selected
    */
   @Nullable
diff --git a/core/client/fs/src/main/java/alluxio/client/block/policy/DeterministicHashPolicy.java b/core/client/fs/src/main/java/alluxio/client/block/policy/DeterministicHashPolicy.java
index df075b538e..b3cb44ae40 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/policy/DeterministicHashPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/policy/DeterministicHashPolicy.java
@@ -13,6 +13,8 @@ package alluxio.client.block.policy;
 
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.wire.WorkerNetAddress;
 
 import com.google.common.base.MoreObjects;
@@ -41,7 +43,7 @@ import javax.annotation.concurrent.NotThreadSafe;
  *
  * This policy is useful for limiting the amount of replication that occurs when reading blocks from
  * the UFS with high concurrency. With 30 workers and 100 remote clients reading the same block
- * concurrently, the replication level for the block would get close to 30 as each workers reads
+ * concurrently, the replication level for the block would create close to 30 as each workers reads
  * and caches the block for one or more clients. If the clients use DeterministicHashPolicy with
  * 3 shards, the 100 clients will split their reads between just 3 workers, so that the replication
  * level for the block will be only 3 when the data is first loaded.
@@ -49,7 +51,6 @@ import javax.annotation.concurrent.NotThreadSafe;
 @NotThreadSafe
 public final class DeterministicHashPolicy implements BlockLocationPolicy {
   /** The default number of shards to serve a block. */
-  private static final int DEFAULT_NUM_SHARDS = 1;
   private final int mShards;
   private final Random mRandom = new Random();
   private final HashFunction mHashFunc = Hashing.md5();
@@ -57,8 +58,8 @@ public final class DeterministicHashPolicy implements BlockLocationPolicy {
   /**
    * Constructs a new {@link DeterministicHashPolicy}.
    */
-  public DeterministicHashPolicy() {
-    this(DEFAULT_NUM_SHARDS);
+  public DeterministicHashPolicy(AlluxioConfiguration alluxioConf) {
+    this(alluxioConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS));
   }
 
   /**
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java
index 3cb98a09e4..52cf1a8506 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.block.stream;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.Seekable;
 import alluxio.client.BoundedStream;
 import alluxio.client.PositionedReadable;
@@ -95,7 +95,8 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl
    * @return the {@link BlockInStream} object
    */
   public static BlockInStream create(FileSystemContext context, BlockInfo info,
-      WorkerNetAddress dataSource, BlockInStreamSource dataSourceType, InStreamOptions options)
+      WorkerNetAddress dataSource, BlockInStreamSource dataSourceType, InStreamOptions options,
+      AlluxioConfiguration alluxioConf)
       throws IOException {
     URIStatus status = options.getStatus();
     ReadType readType = ReadType.fromProto(options.getOptions().getReadType());
@@ -109,15 +110,15 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl
     // Add UFS fallback options
     builder.setOpenUfsBlockOptions(options.getOpenUfsBlockOptions(blockId));
 
-    boolean shortCircuit = Configuration.getBoolean(PropertyKey.USER_SHORT_CIRCUIT_ENABLED);
-    boolean sourceSupportsDomainSocket = NettyUtils.isDomainSocketSupported(dataSource);
+    boolean shortCircuit = alluxioConf.getBoolean(PropertyKey.USER_SHORT_CIRCUIT_ENABLED);
+    boolean sourceSupportsDomainSocket = NettyUtils.isDomainSocketSupported(dataSource, alluxioConf);
     boolean sourceIsLocal = dataSourceType == BlockInStreamSource.LOCAL;
 
     // Short circuit
     if (sourceIsLocal && shortCircuit && !sourceSupportsDomainSocket) {
       LOG.debug("Creating short circuit input stream for block {} @ {}", blockId, dataSource);
       try {
-        return createLocalBlockInStream(context, dataSource, blockId, blockSize, options);
+        return createLocalBlockInStream(context, dataSource, blockId, blockSize, options, alluxioConf);
       } catch (NotFoundException e) {
         // Failed to do short circuit read because the block is not available in Alluxio.
         // We will try to read via gRPC. So this exception is ignored.
@@ -144,9 +145,10 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl
    * @return the {@link BlockInStream} created
    */
   private static BlockInStream createLocalBlockInStream(FileSystemContext context,
-      WorkerNetAddress address, long blockId, long length, InStreamOptions options)
+      WorkerNetAddress address, long blockId, long length, InStreamOptions options,
+      AlluxioConfiguration alluxioConf)
       throws IOException {
-    long chunkSize = Configuration.getBytes(PropertyKey.USER_LOCAL_READER_CHUNK_SIZE_BYTES);
+    long chunkSize = alluxioConf.getBytes(PropertyKey.USER_LOCAL_READER_CHUNK_SIZE_BYTES);
     return new BlockInStream(
         new LocalFileDataReader.Factory(context, address, blockId, chunkSize, options),
         address, BlockInStreamSource.LOCAL, blockId, length);
@@ -160,14 +162,13 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl
    * @param blockSource the source location of the block
    * @param blockSize the block size
    * @param readRequestPartial the partial read request
-   * @param options the in stream options
    * @return the {@link BlockInStream} created
    */
   private static BlockInStream createGrpcBlockInStream(FileSystemContext context,
       WorkerNetAddress address, BlockInStreamSource blockSource,
-      ReadRequest readRequestPartial, long blockSize, InStreamOptions options) {
+      ReadRequest readRequestPartial, long blockSize, InStreamOptions options, AlluxioConfiguration alluxioConf) {
     long chunkSize =
-        Configuration.getBytes(PropertyKey.USER_NETWORK_READER_CHUNK_SIZE_BYTES);
+        alluxioConf.getBytes(PropertyKey.USER_NETWORK_READER_CHUNK_SIZE_BYTES);
     DataReader.Factory factory = new GrpcDataReader.Factory(context, address,
         readRequestPartial.toBuilder().setChunkSize(chunkSize).buildPartial());
     return new BlockInStream(factory, address, blockSource, readRequestPartial.getBlockId(),
@@ -189,9 +190,9 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl
    */
   public static BlockInStream createRemoteBlockInStream(FileSystemContext context, long blockId,
       WorkerNetAddress address, BlockInStreamSource blockSource, long blockSize,
-      Protocol.OpenUfsBlockOptions ufsOptions) {
+      Protocol.OpenUfsBlockOptions ufsOptions, AlluxioConfiguration alluxioConf) {
     long chunkSize =
-        Configuration.getBytes(PropertyKey.USER_NETWORK_READER_CHUNK_SIZE_BYTES);
+        alluxioConf.getBytes(PropertyKey.USER_NETWORK_READER_CHUNK_SIZE_BYTES);
     ReadRequest readRequest = ReadRequest.newBuilder().setBlockId(blockId)
         .setOpenUfsBlockOptions(ufsOptions).setChunkSize(chunkSize).buildPartial();
     DataReader.Factory factory = new GrpcDataReader.Factory(context, address,
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockOutStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockOutStream.java
index d12ca57568..fad0a05a6c 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockOutStream.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockOutStream.java
@@ -15,6 +15,7 @@ import alluxio.client.BoundedStream;
 import alluxio.client.Cancelable;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.OutStreamOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.PreconditionMessage;
 import alluxio.wire.WorkerNetAddress;
 
@@ -60,9 +61,9 @@ public class BlockOutStream extends OutputStream implements BoundedStream, Cance
    * @return the {@link OutputStream} object
    */
   public static BlockOutStream create(FileSystemContext context, long blockId, long blockSize,
-      WorkerNetAddress address, OutStreamOptions options) throws IOException {
+      WorkerNetAddress address, OutStreamOptions options, AlluxioConfiguration alluxioConf) throws IOException {
     DataWriter dataWriter =
-        DataWriter.Factory.create(context, blockId, blockSize, address, options);
+        DataWriter.Factory.create(context, blockId, blockSize, address, options, alluxioConf);
     return new BlockOutStream(dataWriter, blockSize, address);
   }
 
@@ -107,11 +108,11 @@ public class BlockOutStream extends OutputStream implements BoundedStream, Cance
    */
   public static BlockOutStream createReplicatedBlockOutStream(FileSystemContext context,
       long blockId, long blockSize, java.util.List<WorkerNetAddress> workerNetAddresses,
-      OutStreamOptions options) throws IOException {
+      OutStreamOptions options, AlluxioConfiguration alluxioConf) throws IOException {
     List<DataWriter> dataWriters = new ArrayList<>();
     for (WorkerNetAddress address: workerNetAddresses) {
       DataWriter dataWriter =
-            DataWriter.Factory.create(context, blockId, blockSize, address, options);
+            DataWriter.Factory.create(context, blockId, blockSize, address, options, alluxioConf);
       dataWriters.add(dataWriter);
     }
     return new BlockOutStream(dataWriters, blockSize, workerNetAddresses);
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockWorkerClient.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockWorkerClient.java
index e2b41bea22..890100c361 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockWorkerClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockWorkerClient.java
@@ -16,6 +16,7 @@ import alluxio.grpc.CreateLocalBlockRequest;
 import alluxio.grpc.CreateLocalBlockResponse;
 import alluxio.grpc.OpenLocalBlockRequest;
 import alluxio.grpc.OpenLocalBlockResponse;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.ReadRequest;
 import alluxio.grpc.ReadResponse;
 import alluxio.grpc.RemoveBlockRequest;
@@ -49,9 +50,10 @@ public interface BlockWorkerClient extends Closeable {
      * @param address the address of the worker
      * @return a new {@link BlockWorkerClient}
      */
-    public static BlockWorkerClient create(@Nullable Subject subject, SocketAddress address)
+    public static BlockWorkerClient create(@Nullable Subject subject, SocketAddress address,
+        AlluxioConfiguration alluxioConf)
         throws IOException {
-      return new DefaultBlockWorkerClient(subject, address);
+      return new DefaultBlockWorkerClient(subject, address, alluxioConf);
     }
   }
 
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/DataWriter.java b/core/client/fs/src/main/java/alluxio/client/block/stream/DataWriter.java
index f888058b17..6dd0485683 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/DataWriter.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/DataWriter.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.block.stream;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.Cancelable;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileSystemContext;
@@ -55,16 +55,16 @@ public interface DataWriter extends Closeable, Cancelable {
      * @return the {@link DataWriter} instance
      */
     public static DataWriter create(FileSystemContext context, long blockId, long blockSize,
-        WorkerNetAddress address, OutStreamOptions options) throws IOException {
-      if (CommonUtils.isLocalHost(address) && Configuration
+        WorkerNetAddress address, OutStreamOptions options, AlluxioConfiguration alluxioConf) throws IOException {
+      if (CommonUtils.isLocalHost(address, alluxioConf) && alluxioConf
           .getBoolean(PropertyKey.USER_SHORT_CIRCUIT_ENABLED) && !NettyUtils
-          .isDomainSocketSupported(address)) {
+          .isDomainSocketSupported(address, alluxioConf)) {
         if (options.getWriteType() == WriteType.ASYNC_THROUGH
-            && Configuration.getBoolean(PropertyKey.USER_FILE_UFS_TIER_ENABLED)) {
+            && alluxioConf.getBoolean(PropertyKey.USER_FILE_UFS_TIER_ENABLED)) {
           LOG.info("Creating UFS-fallback short circuit output stream for block {} @ {}", blockId,
               address);
           return UfsFallbackLocalFileDataWriter.create(
-              context, address, blockId, blockSize, options);
+              context, address, blockId, blockSize, options, alluxioConf);
         }
         LOG.debug("Creating short circuit output stream for block {} @ {}", blockId, address);
         return LocalFileDataWriter.create(context, address, blockId, options);
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java b/core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java
index 86ee114925..548b9c8118 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/DefaultBlockWorkerClient.java
@@ -11,10 +11,15 @@
 
 package alluxio.client.block.stream;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+
 import alluxio.grpc.AsyncCacheRequest;
 import alluxio.grpc.AsyncCacheResponse;
+import alluxio.conf.Configuration;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.exception.status.UnauthenticatedException;
+import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.BlockWorkerGrpc;
 import alluxio.grpc.CreateLocalBlockRequest;
 import alluxio.grpc.CreateLocalBlockResponse;
@@ -29,6 +34,7 @@ import alluxio.grpc.RemoveBlockRequest;
 import alluxio.grpc.RemoveBlockResponse;
 import alluxio.grpc.WriteRequest;
 import alluxio.grpc.WriteResponse;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NettyUtils;
 
 import io.grpc.StatusRuntimeException;
@@ -51,19 +57,11 @@ public class DefaultBlockWorkerClient implements BlockWorkerClient {
   private static final Logger LOGGER =
       LoggerFactory.getLogger(DefaultBlockWorkerClient.class.getName());
 
-  private static final long DATA_TIMEOUT =
-      Configuration.getMs(PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS);
-  private static final long KEEPALIVE_TIME_MS =
-      Configuration.getMs(PropertyKey.USER_NETWORK_KEEPALIVE_TIME_MS);
-  private static final long KEEPALIVE_TIMEOUT_MS =
-      Configuration.getMs(PropertyKey.USER_NETWORK_KEEPALIVE_TIMEOUT_MS);
-  private static final long GRPC_FLOWCONTROL_WINDOW =
-      Configuration.getBytes(PropertyKey.USER_NETWORK_FLOWCONTROL_WINDOW);
-  private static final long MAX_INBOUND_MESSAGE_SIZE =
-      Configuration.getBytes(PropertyKey.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE);
   private static final EventLoopGroup WORKER_GROUP = NettyUtils
-      .createEventLoop(NettyUtils.USER_CHANNEL_TYPE,
-          Configuration.getInt(PropertyKey.USER_NETWORK_NETTY_WORKER_THREADS),
+      .createEventLoop(
+          NettyUtils.getUserChannel(new InstancedConfiguration(ConfigurationUtils.defaults())),
+          new InstancedConfiguration(ConfigurationUtils.defaults())
+              .getInt(PropertyKey.USER_NETWORK_NETTY_WORKER_THREADS),
           "netty-client-worker-%d", true);
 
   private GrpcChannel mChannel;
@@ -77,17 +75,18 @@ public class DefaultBlockWorkerClient implements BlockWorkerClient {
    * @param subject the user subject, can be null if the user is not available
    * @param address the address of the worker
    */
-  public DefaultBlockWorkerClient(Subject subject, SocketAddress address) throws IOException {
+  public DefaultBlockWorkerClient(Subject subject, SocketAddress address,
+      AlluxioConfiguration alluxioConf) {
     try {
-      mChannel = GrpcChannelBuilder.forAddress(address).setSubject(subject)
-          .setChannelType(NettyUtils.getClientChannelClass(!(address instanceof InetSocketAddress)))
+      mChannel = GrpcChannelBuilder.forAddress(address, alluxioConf).setSubject(subject)
+          .setChannelType(NettyUtils.getClientChannelClass(!(address instanceof InetSocketAddress), alluxioConf))
           .setEventLoopGroup(WORKER_GROUP)
-          .setKeepAliveTime(KEEPALIVE_TIME_MS, TimeUnit.MILLISECONDS)
-          .setKeepAliveTimeout(KEEPALIVE_TIMEOUT_MS, TimeUnit.MILLISECONDS)
-          .setMaxInboundMessageSize((int) MAX_INBOUND_MESSAGE_SIZE)
-          .setFlowControlWindow((int) GRPC_FLOWCONTROL_WINDOW).build();
-    } catch (StatusRuntimeException e) {
-      throw GrpcExceptionUtils.fromGrpcStatusException(e);
+          .setKeepAliveTimeout(alluxioConf.getMs(PropertyKey.USER_NETWORK_KEEPALIVE_TIMEOUT_MS), TimeUnit.MILLISECONDS)
+          .setMaxInboundMessageSize((int) alluxioConf.getMs(PropertyKey.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE))
+          .setFlowControlWindow((int) alluxioConf.getMs(PropertyKey.USER_NETWORK_FLOWCONTROL_WINDOW))
+                     .build();
+    } catch (UnauthenticatedException | UnavailableException e) {
+      throw new RuntimeException("Failed to build channel.", e);
     }
     mBlockingStub = BlockWorkerGrpc.newBlockingStub(mChannel);
     mAsyncStub = BlockWorkerGrpc.newStub(mChannel);
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java
index 792829b83c..31a6e48124 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataReader.java
@@ -11,8 +11,9 @@
 
 package alluxio.client.block.stream;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.ClientContext;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.ReadType;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.InStreamOptions;
@@ -73,8 +74,8 @@ public final class LocalFileDataReader implements DataReader {
     ByteBuffer buffer = mReader.read(mPos, Math.min(mChunkSize, mEnd - mPos));
     DataBuffer dataBuffer = new DataByteBuffer(buffer, buffer.remaining());
     mPos += dataBuffer.getLength();
-    MetricsSystem.counter(ClientMetrics.BYTES_READ_LOCAL).inc(dataBuffer.getLength());
-    MetricsSystem.meter(ClientMetrics.BYTES_READ_LOCAL_THROUGHPUT).mark(dataBuffer.getLength());
+//    MetricsSystem.counter(ClientMetrics.BYTES_READ_LOCAL).inc(dataBuffer.getLength());
+//    MetricsSystem.meter(ClientMetrics.BYTES_READ_LOCAL_THROUGHPUT).mark(dataBuffer.getLength());
     return dataBuffer;
   }
 
@@ -103,7 +104,7 @@ public final class LocalFileDataReader implements DataReader {
     private final long mChunkSize;
     private final GrpcBlockingStream<OpenLocalBlockRequest, OpenLocalBlockResponse> mStream;
     private LocalFileBlockReader mReader;
-    private boolean mClosed;
+    private final long mReadTimeoutMs;
 
     /**
      * Creates an instance of {@link Factory}.
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataWriter.java b/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataWriter.java
index f71e9d040e..41128a724d 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataWriter.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/LocalFileDataWriter.java
@@ -11,8 +11,6 @@
 
 package alluxio.client.block.stream;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.OutStreamOptions;
@@ -85,7 +83,7 @@ public final class LocalFileDataWriter implements DataWriter {
           CreateLocalBlockRequest.newBuilder().setBlockId(blockId)
               .setTier(options.getWriteTier()).setSpaceToReserve(FILE_BUFFER_BYTES);
       if (options.getWriteType() == WriteType.ASYNC_THROUGH
-          && Configuration.getBoolean(PropertyKey.USER_FILE_UFS_TIER_ENABLED)) {
+          && ufsTierEnabled) {
         builder.setCleanupOnFailure(false);
       }
       CreateLocalBlockRequest createRequest = builder.build();
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriter.java b/core/client/fs/src/main/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriter.java
index b8d287ef7d..db4a0f38b0 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriter.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriter.java
@@ -13,6 +13,8 @@ package alluxio.client.block.stream;
 
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.OutStreamOptions;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.ResourceExhaustedException;
 import alluxio.grpc.RequestType;
 import alluxio.wire.WorkerNetAddress;
@@ -40,6 +42,7 @@ public final class UfsFallbackLocalFileDataWriter implements DataWriter {
   private final OutStreamOptions mOutStreamOptions;
   private GrpcDataWriter mGrpcDataWriter;
   private boolean mIsWritingToLocal;
+  private final AlluxioConfiguration mAlluxioConf;
 
   /**
    * @param context the file system context
diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/UnderFileSystemFileOutStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/UnderFileSystemFileOutStream.java
index 2df3535ae0..bd67390ade 100644
--- a/core/client/fs/src/main/java/alluxio/client/block/stream/UnderFileSystemFileOutStream.java
+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/UnderFileSystemFileOutStream.java
@@ -14,6 +14,7 @@ package alluxio.client.block.stream;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.OutStreamOptions;
 import alluxio.grpc.RequestType;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.wire.WorkerNetAddress;
 
 import java.io.IOException;
diff --git a/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java b/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java
index 1e8a9d85c7..e0b74e2db3 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java
@@ -12,10 +12,12 @@
 package alluxio.client.file;
 
 import alluxio.AlluxioURI;
+import alluxio.ClientContext;
 import alluxio.Constants;
 import alluxio.annotation.PublicApi;
 import alluxio.client.file.options.InStreamOptions;
 import alluxio.client.file.options.OutStreamOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.DirectoryNotEmptyException;
 import alluxio.exception.ExceptionMessage;
@@ -70,13 +72,14 @@ import javax.annotation.concurrent.ThreadSafe;
 public class BaseFileSystem implements FileSystem {
   private static final Logger LOG = LoggerFactory.getLogger(BaseFileSystem.class);
 
-  protected final FileSystemContext mFileSystemContext;
+  protected ClientContext mClientContext;
+  protected FileSystemContext mFileSystemContext;
 
   /**
-   * @param context file system context
+   * @param context client context
    * @return a {@link BaseFileSystem}
    */
-  public static BaseFileSystem get(FileSystemContext context) {
+  public static BaseFileSystem create(ClientContext context) {
     return new BaseFileSystem(context);
   }
 
@@ -85,8 +88,14 @@ public class BaseFileSystem implements FileSystem {
    *
    * @param context file system context
    */
-  protected BaseFileSystem(FileSystemContext context) {
-    mFileSystemContext = context;
+  protected BaseFileSystem(ClientContext context) {
+    this(context, FileSystemContext.create(context.getSubject(), context.getConfiguration()));
+  }
+
+  protected BaseFileSystem(ClientContext context, FileSystemContext fsContext) {
+    mClientContext = context;
+    mFileSystemContext = fsContext;
+
   }
 
   @Override
@@ -147,12 +156,12 @@ public class BaseFileSystem implements FileSystem {
       mFileSystemContext.releaseMasterClient(masterClient);
     }
 
-    OutStreamOptions outStreamOptions = new OutStreamOptions(options);
+    OutStreamOptions outStreamOptions = new OutStreamOptions(options, mClientContext.getConfiguration());
     outStreamOptions.setUfsPath(status.getUfsPath());
     outStreamOptions.setMountId(status.getMountId());
     outStreamOptions.setAcl(status.getAcl());
     try {
-      return new FileOutStream(path, outStreamOptions, mFileSystemContext);
+      return new FileOutStream(path, outStreamOptions, mFileSystemContext, mClientContext.getConfiguration());
     } catch (Exception e) {
       delete(path);
       throw e;
@@ -395,8 +404,10 @@ public class BaseFileSystem implements FileSystem {
       throw new FileDoesNotExistException(
           ExceptionMessage.CANNOT_READ_DIRECTORY.getMessage(status.getName()));
     }
-    InStreamOptions inStreamOptions = new InStreamOptions(status, options);
-    return new FileInStream(status, inStreamOptions, mFileSystemContext);
+    AlluxioConfiguration conf = mClientContext.getConfiguration();
+    InStreamOptions inStreamOptions = new InStreamOptions(status, options, conf);
+    return new FileInStream(status, inStreamOptions, mFileSystemContext,
+        mClientContext.getConfiguration());
   }
 
   @Override
@@ -547,7 +558,7 @@ public class BaseFileSystem implements FileSystem {
    * Checks an {@link AlluxioURI} for scheme and authority information. Warn the user and throw an
    * exception if necessary.
    */
-  private static void checkUri(AlluxioURI uri) {
+  private void checkUri(AlluxioURI uri) {
     if (uri.hasScheme()) {
       String warnMsg = "The URI scheme \"{}\" is ignored and not required in URIs passed to"
           + " the Alluxio Filesystem client.";
@@ -572,7 +583,8 @@ public class BaseFileSystem implements FileSystem {
       /* Even if we choose to log the warning, check if the Configuration host matches what the
        * user passes. If not, throw an exception letting the user know they don't match.
        */
-      Authority configured = MasterInquireClient.Factory.create().getConnectDetails().toAuthority();
+      Authority configured =
+          MasterInquireClient.Factory.create(mClientContext.getConfiguration()).getConnectDetails().toAuthority();
       if (!configured.equals(uri.getAuthority())) {
         throw new IllegalArgumentException(
             String.format("The URI authority %s does not match the configured " + "value of %s.",
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/FileInStream.java
index 9d040f965a..e406bcad15 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileInStream.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileInStream.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.Seekable;
 import alluxio.annotation.PublicApi;
 import alluxio.client.BoundedStream;
@@ -66,13 +66,14 @@ import javax.annotation.concurrent.NotThreadSafe;
 public class FileInStream extends InputStream implements BoundedStream, PositionedReadable,
     Seekable {
   private static final Logger LOG = LoggerFactory.getLogger(FileInStream.class);
-  private static final int MAX_WORKERS_TO_RETRY =
-      Configuration.getInt(PropertyKey.USER_BLOCK_WORKER_CLIENT_READ_RETRY);
 
+  private final int mBlockWorkerClientReadRetry;
   private final URIStatus mStatus;
   private final InStreamOptions mOptions;
   private final AlluxioBlockStore mBlockStore;
   private final FileSystemContext mContext;
+  private final boolean mPassiveCachingEnabled;
+  private final long mNettyTimeout;
 
   /* Convenience values derived from mStatus, use these instead of querying mStatus. */
   /** Length of the file in bytes. */
@@ -95,10 +96,14 @@ public class FileInStream extends InputStream implements BoundedStream, Position
   /** A map of worker addresses to the most recent epoch time when client fails to read from it. */
   private Map<WorkerNetAddress, Long> mFailedWorkers = new HashMap<>();
 
-  protected FileInStream(URIStatus status, InStreamOptions options, FileSystemContext context) {
+  protected FileInStream(URIStatus status, InStreamOptions options, FileSystemContext context,
+      AlluxioConfiguration conf) {
+    mPassiveCachingEnabled = conf.getBoolean(PropertyKey.USER_FILE_PASSIVE_CACHE_ENABLED);
+    mBlockWorkerClientReadRetry = conf.getInt(PropertyKey.USER_BLOCK_WORKER_CLIENT_READ_RETRY);
+    mNettyTimeout = conf.getMs(PropertyKey.USER_NETWORK_NETTY_TIMEOUT_MS);
     mStatus = status;
     mOptions = options;
-    mBlockStore = AlluxioBlockStore.create(context);
+    mBlockStore = AlluxioBlockStore.create(context, conf);
     mContext = context;
 
     mLength = mStatus.getLength();
@@ -116,7 +121,7 @@ public class FileInStream extends InputStream implements BoundedStream, Position
     if (mPosition == mLength) { // at end of file
       return -1;
     }
-    CountingRetry retry = new CountingRetry(MAX_WORKERS_TO_RETRY);
+    CountingRetry retry = new CountingRetry(mBlockWorkerClientReadRetry);
     IOException lastException = null;
     while (retry.attempt()) {
       try {
@@ -156,7 +161,7 @@ public class FileInStream extends InputStream implements BoundedStream, Position
 
     int bytesLeft = len;
     int currentOffset = off;
-    CountingRetry retry = new CountingRetry(MAX_WORKERS_TO_RETRY);
+    CountingRetry retry = new CountingRetry(mBlockWorkerClientReadRetry);
     IOException lastException = null;
     while (bytesLeft > 0 && mPosition != mLength && retry.attempt()) {
       try {
@@ -218,7 +223,7 @@ public class FileInStream extends InputStream implements BoundedStream, Position
     }
 
     int lenCopy = len;
-    CountingRetry retry = new CountingRetry(MAX_WORKERS_TO_RETRY);
+    CountingRetry retry = new CountingRetry(mBlockWorkerClientReadRetry);
     IOException lastException = null;
     while (len > 0 && retry.attempt()) {
       if (pos >= mLength) {
@@ -332,14 +337,14 @@ public class FileInStream extends InputStream implements BoundedStream, Position
         && mStatus.getFileBlockInfos().get((int) (getPos() / mBlockSize))
         .getBlockInfo().getLocations().size() >= mStatus.getReplicationMax();
     cache = cache && !overReplicated;
-    boolean passiveCache = Configuration.getBoolean(PropertyKey.USER_FILE_PASSIVE_CACHE_ENABLED);
-    long channelTimeout = Configuration.getMs(PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS);
+    boolean passiveCache = ServerConfiguration.getBoolean(PropertyKey.USER_FILE_PASSIVE_CACHE_ENABLED);
+    long channelTimeout = ServerConfiguration.getMs(PropertyKey.USER_NETWORK_DATA_TIMEOUT_MS);
     // Get relevant information from the stream.
     WorkerNetAddress dataSource = stream.getAddress();
     long blockId = stream.getId();
     if (cache && (mLastBlockIdCached != blockId)) {
       WorkerNetAddress worker;
-      if (passiveCache && mContext.hasLocalWorker()) { // send request to local worker
+      if (mPassiveCachingEnabled && mContext.hasLocalWorker()) { // send request to local worker
         worker = mContext.getLocalWorker();
       } else { // send request to data source
         worker = dataSource;
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileOutStream.java b/core/client/fs/src/main/java/alluxio/client/file/FileOutStream.java
index b8c6ee922e..443bd8d52f 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileOutStream.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileOutStream.java
@@ -20,6 +20,7 @@ import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.stream.BlockOutStream;
 import alluxio.client.block.stream.UnderFileSystemFileOutStream;
 import alluxio.client.file.options.OutStreamOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.PreconditionMessage;
 import alluxio.exception.status.UnavailableException;
@@ -81,7 +82,8 @@ public class FileOutStream extends AbstractOutStream {
    * @param options the client options
    * @param context the file system context
    */
-  public FileOutStream(AlluxioURI path, OutStreamOptions options, FileSystemContext context)
+  public FileOutStream(AlluxioURI path, OutStreamOptions options, FileSystemContext context,
+      AlluxioConfiguration conf)
       throws IOException {
     mCloser = Closer.create();
     mUri = Preconditions.checkNotNull(path, "path");
@@ -90,7 +92,7 @@ public class FileOutStream extends AbstractOutStream {
     mUnderStorageType = options.getUnderStorageType();
     mOptions = options;
     mContext = context;
-    mBlockStore = AlluxioBlockStore.create(mContext);
+    mBlockStore = AlluxioBlockStore.create(mContext, conf);
     mPreviousBlockOutStreams = new ArrayList<>();
     mClosed = false;
     mCanceled = false;
@@ -107,7 +109,8 @@ public class FileOutStream extends AbstractOutStream {
       }
       try {
         mUnderStorageOutputStream = mCloser
-            .register(UnderFileSystemFileOutStream.create(mContext, workerNetAddress, mOptions));
+            .register(UnderFileSystemFileOutStream.create(mContext, workerNetAddress, mOptions,
+                conf));
       } catch (Throwable t) {
         throw CommonUtils.closeAndRethrow(mCloser, t);
       }
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileSystem.java b/core/client/fs/src/main/java/alluxio/client/file/FileSystem.java
index e5f0f404ee..a26c41a516 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileSystem.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileSystem.java
@@ -12,8 +12,9 @@
 package alluxio.client.file;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.ClientContext;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 import alluxio.conf.Source;
 import alluxio.exception.AlluxioException;
@@ -70,21 +71,26 @@ public interface FileSystem {
     private Factory() {} // prevent instantiation
 
     public static FileSystem get() {
-      return get(FileSystemContext.get());
+      return get(ClientContext.create());
     }
 
-    public static FileSystem get(FileSystemContext context) {
+    public static FileSystem get(ClientContext context) {
       if (LOG.isDebugEnabled() && !CONF_LOGGED.getAndSet(true)) {
         // Sort properties by name to keep output ordered.
-        List<PropertyKey> keys = new ArrayList<>(Configuration.keySet());
+        AlluxioConfiguration conf = context.getConfiguration();
+        List<PropertyKey> keys = new ArrayList<>(conf.keySet());
         Collections.sort(keys, Comparator.comparing(PropertyKey::getName));
         for (PropertyKey key : keys) {
-          String value = Configuration.getOrDefault(key, null);
-          Source source = Configuration.getSource(key);
+          String value = conf.getOrDefault(key, null);
+          Source source = conf.getSource(key);
           LOG.debug("{}={} ({})", key.getName(), value, source);
         }
       }
-      return BaseFileSystem.get(context);
+      return BaseFileSystem.create(context);
+    }
+
+    public static FileSystem get(FileSystemContext fsCtx) {
+      return get(fsCtx.getClientContext());
     }
   }
 
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java b/core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java
index c7a652f9e9..c0574d3fb2 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java
@@ -11,14 +11,15 @@
 
 package alluxio.client.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.ClientContext;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.BlockMasterClient;
 import alluxio.client.block.BlockMasterClientPool;
 import alluxio.client.block.stream.BlockWorkerClient;
 import alluxio.client.metrics.ClientMasterSync;
 import alluxio.client.metrics.MetricsMasterClient;
-import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.UnavailableException;
 import alluxio.heartbeat.HeartbeatContext;
@@ -35,6 +36,10 @@ import alluxio.wire.WorkerNetAddress;
 
 import com.codahale.metrics.Gauge;
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Objects;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.channel.Channel;
+import jline.internal.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -43,13 +48,14 @@ import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.annotation.Nonnull;
 import javax.annotation.concurrent.GuardedBy;
 import javax.annotation.concurrent.ThreadSafe;
 import javax.security.auth.Subject;
@@ -69,13 +75,9 @@ import javax.security.auth.Subject;
 public final class FileSystemContext implements Closeable {
   private static final Logger LOG = LoggerFactory.getLogger(FileSystemContext.class);
 
-  @GuardedBy("CONTEXT_CACHE_LOCK")
-  private static final Map<Subject, FileSystemContext> CONTEXT_CACHE = new HashMap<>();
-  private static final Object CONTEXT_CACHE_LOCK = new Object();
-
   static {
-    MetricsSystem.startSinks();
-    Metrics.initializeGauges();
+//    MetricsSystem.startSinks();
+//    Metrics.initializeGauges();
   }
 
   // Master client pools.
@@ -109,74 +111,73 @@ public final class FileSystemContext implements Closeable {
   private WorkerNetAddress mLocalWorker;
 
   /** The parent user associated with the {@link FileSystemContext}. */
-  private final Subject mParentSubject;
+//  private final Subject mParentSubject;
+
+  private final ClientContext mClientContext;
 
   /**
    * @return the instance of file system context with no subject associated
    */
-  public static FileSystemContext get() {
-    return get(null);
+  public static FileSystemContext create() {
+    return create(null, new InstancedConfiguration(ConfigurationUtils.defaults()));
   }
 
   /**
-   * @param subject the subject associated with this context
-   * @return the instance of the file system context, possibly a shared context
+   * @param subject the parent subject, set to null if not present
+   * @return the context
    */
-  public static FileSystemContext get(Subject subject) {
-    synchronized (CONTEXT_CACHE_LOCK) {
-      FileSystemContext ctx = CONTEXT_CACHE.computeIfAbsent(subject, FileSystemContext::create);
-      ctx.mRefCount++;
-      return ctx;
-    }
+  public static FileSystemContext create(Subject subject, AlluxioConfiguration conf) {
+    FileSystemContext context = new FileSystemContext(subject, conf);
+    context.init(MasterInquireClient.Factory.create(conf));
+    return context;
   }
 
   /**
-   * @param subject the parent subject, set to null if not present
-   * @return the context
+   * @param clientContext the {@link alluxio.ClientContext} containing the subject and configuration
+   * @return the {@link alluxio.client.file.FileSystemContext}
    */
-  private static FileSystemContext create(Subject subject) {
-    FileSystemContext context = new FileSystemContext(subject);
-    context.init(MasterInquireClient.Factory.create(), Configuration.global());
-    return context;
+  public static FileSystemContext create(ClientContext clientContext) {
+    Preconditions.checkNotNull(clientContext);
+    FileSystemContext ctx = new FileSystemContext(clientContext);
+    ctx.init(MasterInquireClient.Factory.create(clientContext.mConf));
+    return ctx;
   }
 
   /**
-   * This method is provided for testing, use the {@link FileSystemContext#get} methods. The
+   * This method is provided for testing, use the {@link FileSystemContext#create} methods. The
    * returned context object will not be cached automatically.
    *
    * @param subject the parent subject, set to null if not present
    * @param masterInquireClient the client to use for determining the master; note that if the
    *        context is reset, this client will be replaced with a new masterInquireClient based on
-   *        global configuration
+   *        the original configuration.
    * @return the context
    */
   @VisibleForTesting
-  public static FileSystemContext create(Subject subject, MasterInquireClient masterInquireClient) {
-    FileSystemContext context = new FileSystemContext(subject);
-    context.init(masterInquireClient, Configuration.global());
-    synchronized (CONTEXT_CACHE_LOCK) { // Not necessary, for code consistency
-      context.mRefCount++;
-    }
+  public static FileSystemContext create(Subject subject, MasterInquireClient masterInquireClient, AlluxioConfiguration conf) {
+    FileSystemContext context = new FileSystemContext(subject, conf);
+    context.init(masterInquireClient);
     return context;
   }
 
   /**
-   * Clears the context cache. This method should only be called in test code.
+   * Creates a file system context with a subject.
+   *
+   * @param subject the parent subject, set to null if not present
    */
-  @VisibleForTesting
-  public static void clearCache() {
-    synchronized (CONTEXT_CACHE_LOCK) {
-      CONTEXT_CACHE.clear();
-    }
+  private FileSystemContext(Subject subject, AlluxioConfiguration alluxioConf) {
+    // Makes a copy of the properties so that a thread with the reference to them can't change them
+    // after instantiation.
+    this(ClientContext.create(subject, alluxioConf.getProperties()));
   }
 
   /**
    * Creates a file system context with a subject.
    *
-   * @param subject the parent subject, set to null if not present
+   * @param ctx the parent subject, set to null if not present
    */
-  private FileSystemContext(Subject subject) {
-    mParentSubject = subject;
+  private FileSystemContext(ClientContext ctx) {
+    mClientContext = ctx;
     mExecutorService = Executors.newFixedThreadPool(1,
         ThreadFactoryUtils.build("metrics-master-heartbeat-%d", true));
     mClosed = new AtomicBoolean(false);
@@ -187,26 +188,28 @@ public final class FileSystemContext implements Closeable {
    * Initializes the context. Only called in the factory methods and reset.
    *
    * @param masterInquireClient the client to use for determining the master
-   * @param configuration the instance configuration
    */
-  private synchronized void init(MasterInquireClient masterInquireClient,
-      InstancedConfiguration configuration) {
+  private synchronized void init(MasterInquireClient masterInquireClient) {
     mMasterInquireClient = masterInquireClient;
     mFileSystemMasterClientPool =
-        new FileSystemMasterClientPool(mParentSubject, mMasterInquireClient);
-    mBlockMasterClientPool = new BlockMasterClientPool(mParentSubject, mMasterInquireClient);
+        new FileSystemMasterClientPool(mClientContext.getSubject(), mMasterInquireClient,
+            mClientContext.getConfiguration());
+    mBlockMasterClientPool = new BlockMasterClientPool(mClientContext.getSubject(),
+        mMasterInquireClient, mClientContext.getConfiguration());
     mClosed.set(false);
 
-    if (configuration.getBoolean(PropertyKey.USER_METRICS_COLLECTION_ENABLED)) {
+    if (mClientContext.getConfiguration().getBoolean(PropertyKey.USER_METRICS_COLLECTION_ENABLED)) {
       // setup metrics master client sync
-      mMetricsMasterClient = new MetricsMasterClient(MasterClientConfig.defaults()
-          .withSubject(mParentSubject).withMasterInquireClient(mMasterInquireClient));
+      mMetricsMasterClient = new MetricsMasterClient(MasterClientConfig.defaults(mClientContext.getConfiguration())
+          .withSubject(mClientContext.getSubject()).withMasterInquireClient(mMasterInquireClient)
+          , mClientContext.getConfiguration());
       mClientMasterSync = new ClientMasterSync(mMetricsMasterClient, this);
       mExecutorService = Executors.newFixedThreadPool(1,
           ThreadFactoryUtils.build("metrics-master-heartbeat-%d", true));
       mExecutorService
           .submit(new HeartbeatThread(HeartbeatContext.MASTER_METRICS_SYNC, mClientMasterSync,
-              (int) configuration.getMs(PropertyKey.USER_METRICS_HEARTBEAT_INTERVAL_MS)));
+              (int) mClientContext.getConfiguration().getMs(PropertyKey.USER_METRICS_HEARTBEAT_INTERVAL_MS),
+              mClientContext.getConfiguration()));
       // register the shutdown hook
       try {
         Runtime.getRuntime().addShutdownHook(new MetricsMasterSyncShutDownHook());
@@ -228,24 +231,7 @@ public final class FileSystemContext implements Closeable {
    * that acquired from this context might fail. Only call this when you are done with using
    * the {@link FileSystem} associated with this {@link FileSystemContext}.
    */
-  @Override
   public void close() throws IOException {
-    synchronized (CONTEXT_CACHE_LOCK) {
-      if (mRefCount == 0) {
-        LOG.warn("Attempted to close FileSystem Context that is already closed, have you called "
-            + "close multiple times?");
-        return;
-      }
-      if (--mRefCount != 0) {
-        return;
-      } else {
-        CONTEXT_CACHE.remove(mParentSubject);
-      }
-    }
-    closeInternal();
-  }
-
-  private void closeInternal() throws IOException {
     mFileSystemMasterClientPool.close();
     mFileSystemMasterClientPool = null;
     mBlockMasterClientPool.close();
@@ -253,13 +239,14 @@ public final class FileSystemContext implements Closeable {
     mMasterInquireClient = null;
 
     synchronized (this) {
-      if (mMetricsMasterClient != null) {
-        ThreadUtils.shutdownAndAwaitTermination(mExecutorService,
-            Configuration.getMs(PropertyKey.METRICS_CONTEXT_SHUTDOWN_TIMEOUT));
-        mMetricsMasterClient.close();
-        mMetricsMasterClient = null;
-        mClientMasterSync = null;
-      }
+      // Commenting out to disable client metrics
+//      if (mMetricsMasterClient != null) {
+//        ThreadUtils.shutdownAndAwaitTermination(mExecutorService,
+//            Configuration.getMs(PropertyKey.METRICS_CONTEXT_SHUTDOWN_TIMEOUT));
+//        mMetricsMasterClient.close();
+//        mMetricsMasterClient = null;
+//        mClientMasterSync = null;
+//      }
       mLocalWorkerInitialized = false;
       mLocalWorker = null;
       mClosed.set(true);
@@ -270,21 +257,30 @@ public final class FileSystemContext implements Closeable {
    * Resets the context. It is only used in {@link alluxio.hadoop.AbstractFileSystem} and tests to
    * reset the default file system context.
    *
-   * @param configuration the instance configuration
-   *
    */
-  public synchronized void reset(InstancedConfiguration configuration) throws IOException {
-    closeInternal();
-    init(MasterInquireClient.Factory.create(), configuration);
+  public synchronized void reset() throws IOException {
+    close();
+    init(MasterInquireClient.Factory.create(mClientContext.getConfiguration()));
   }
 
   /**
    * @return the parent subject
    */
   public Subject getParentSubject() {
-    return mParentSubject;
+    return mClientContext.getSubject();
   }
 
+  public ClientContext getClientContext() {
+    return mClientContext;
+  }
+
+//  /**
+//   * @return the configuration used to initialize the context
+//   */
+//  public AlluxioConfiguration getConfiguration() {
+//    return mClientContext.getConfiguration();
+//  }
+
   /**
    * @return the master address
    * @throws UnavailableException if the master address cannot be determined
@@ -356,8 +352,8 @@ public final class FileSystemContext implements Closeable {
    */
   public BlockWorkerClient acquireBlockWorkerClient(final WorkerNetAddress workerNetAddress)
       throws IOException {
-    SocketAddress address = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress);
-    return BlockWorkerClient.Factory.create(mParentSubject, address);
+    SocketAddress address = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress, mClientContext.mConf);
+    return BlockWorkerClient.Factory.create(mParentSubject, address. mClientContext.mConf);
   }
 
   /**
@@ -368,7 +364,8 @@ public final class FileSystemContext implements Closeable {
    */
   public void releaseBlockWorkerClient(WorkerNetAddress workerNetAddress,
       BlockWorkerClient client) {
-    SocketAddress address = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress);
+    SocketAddress address = NetworkAddressUtils.getDataPortSocketAddress(workerNetAddress,
+        mClientContext.getConfiguration());
     try {
       client.close();
     } catch (IOException e) {
@@ -399,7 +396,7 @@ public final class FileSystemContext implements Closeable {
   private void initializeLocalWorker() throws IOException {
     List<WorkerNetAddress> addresses = getWorkerAddresses();
     if (!addresses.isEmpty()) {
-      if (addresses.get(0).getHost().equals(NetworkAddressUtils.getClientHostName())) {
+      if (addresses.get(0).getHost().equals(NetworkAddressUtils.getClientHostName(mClientContext.getConfiguration()))) {
         mLocalWorker = addresses.get(0);
       }
     }
@@ -425,7 +422,7 @@ public final class FileSystemContext implements Closeable {
     // Convert the worker infos into net addresses, if there are local addresses, only keep those
     List<WorkerNetAddress> workerNetAddresses = new ArrayList<>();
     List<WorkerNetAddress> localWorkerNetAddresses = new ArrayList<>();
-    String localHostname = NetworkAddressUtils.getClientHostName();
+    String localHostname = NetworkAddressUtils.getClientHostName(mClientContext.getConfiguration());
     for (WorkerInfo info : infos) {
       WorkerNetAddress netAddress = info.getAddress();
       if (netAddress.getHost().equals(localHostname)) {
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClient.java b/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClient.java
index 9ecd3f5367..c62bd63b55 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.client.file;
 
 import alluxio.AlluxioURI;
 import alluxio.Client;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.exception.status.AlreadyExistsException;
 import alluxio.exception.status.NotFoundException;
@@ -56,8 +57,9 @@ public interface FileSystemMasterClient extends Client {
      * @param conf master client configuration
      * @return a new {@link FileSystemMasterClient} instance
      */
-    public static FileSystemMasterClient create(MasterClientConfig conf) {
-      return new RetryHandlingFileSystemMasterClient(conf);
+    public static FileSystemMasterClient create(MasterClientConfig conf,
+        AlluxioConfiguration alluxioConf) {
+      return new RetryHandlingFileSystemMasterClient(conf, alluxioConf);
     }
   }
 
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClientPool.java b/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClientPool.java
index 18a523191c..85ab3b34b1 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClientPool.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileSystemMasterClientPool.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.MasterClientConfig;
 import alluxio.master.MasterInquireClient;
 import alluxio.resource.ResourcePool;
@@ -34,6 +34,7 @@ public final class FileSystemMasterClientPool extends ResourcePool<FileSystemMas
   private final MasterInquireClient mMasterInquireClient;
   private final Queue<FileSystemMasterClient> mClientList;
   private final Subject mSubject;
+  private final AlluxioConfiguration mAlluxioConf;
 
   /**
    * Creates a new file system master client pool.
@@ -41,11 +42,13 @@ public final class FileSystemMasterClientPool extends ResourcePool<FileSystemMas
    * @param subject the parent subject
    * @param masterInquireClient a client for determining the master address
    */
-  public FileSystemMasterClientPool(Subject subject, MasterInquireClient masterInquireClient) {
-    super(Configuration.getInt(PropertyKey.USER_FILE_MASTER_CLIENT_THREADS));
+  public FileSystemMasterClientPool(Subject subject, MasterInquireClient masterInquireClient,
+      AlluxioConfiguration conf) {
+    super(conf.getInt(PropertyKey.USER_FILE_MASTER_CLIENT_THREADS));
     mMasterInquireClient = masterInquireClient;
     mClientList = new ConcurrentLinkedQueue<>();
     mSubject = subject;
+    mAlluxioConf = conf;
   }
 
   /**
@@ -56,11 +59,12 @@ public final class FileSystemMasterClientPool extends ResourcePool<FileSystemMas
    * @param clientThreads the number of client threads to use
    */
   public FileSystemMasterClientPool(Subject subject, MasterInquireClient masterInquireClient,
-      int clientThreads) {
+      int clientThreads, AlluxioConfiguration conf) {
     super(clientThreads);
     mMasterInquireClient = masterInquireClient;
     mClientList = new ConcurrentLinkedQueue<>();
     mSubject = subject;
+    mAlluxioConf = conf;
   }
 
   @Override
@@ -76,7 +80,7 @@ public final class FileSystemMasterClientPool extends ResourcePool<FileSystemMas
   @Override
   protected FileSystemMasterClient createNewResource() {
     FileSystemMasterClient client = FileSystemMasterClient.Factory.create(MasterClientConfig
-        .defaults().withSubject(mSubject).withMasterInquireClient(mMasterInquireClient));
+        .defaults(mAlluxioConf).withSubject(mSubject).withMasterInquireClient(mMasterInquireClient), mAlluxioConf);
     mClientList.add(client);
     return client;
   }
diff --git a/core/client/fs/src/main/java/alluxio/client/file/FileSystemUtils.java b/core/client/fs/src/main/java/alluxio/client/file/FileSystemUtils.java
index b5d45533df..a229666d68 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/FileSystemUtils.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/FileSystemUtils.java
@@ -12,9 +12,8 @@
 package alluxio.client.file;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.CheckConsistencyPOptions;
 import alluxio.util.CommonUtils;
@@ -53,11 +52,11 @@ public final class FileSystemUtils {
    *         before the file was complete.
    * @throws InterruptedException if the thread receives an interrupt while waiting for file
    *         completion
-   * @see #waitCompleted(FileSystem, AlluxioURI, long, TimeUnit)
+   * @see #waitCompleted(FileSystem, AlluxioURI, long, TimeUnit, long)
    */
-  public static boolean waitCompleted(FileSystem fs, AlluxioURI uri)
+  public static boolean waitCompleted(FileSystem fs, AlluxioURI uri, long waitCompletedPollMs)
       throws IOException, AlluxioException, InterruptedException {
-    return FileSystemUtils.waitCompleted(fs, uri, -1, TimeUnit.MILLISECONDS);
+    return FileSystemUtils.waitCompleted(fs, uri, -1, TimeUnit.MILLISECONDS, waitCompletedPollMs);
   }
 
   /**
@@ -90,11 +89,10 @@ public final class FileSystemUtils {
    *         completion
    */
   public static boolean waitCompleted(final FileSystem fs, final AlluxioURI uri,
-      final long timeout, final TimeUnit tunit)
+      final long timeout, final TimeUnit tunit, long fileWaitCompletedPollMs)
           throws IOException, AlluxioException, InterruptedException {
 
     final long deadline = System.currentTimeMillis() + tunit.toMillis(timeout);
-    final long pollPeriod = Configuration.getMs(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS);
     boolean completed = false;
     long timeleft = deadline - System.currentTimeMillis();
 
@@ -112,8 +110,8 @@ public final class FileSystemUtils {
       } else if (!completed) {
         long toSleep;
 
-        if (timeout < 0 || timeleft > pollPeriod) {
-          toSleep = pollPeriod;
+        if (timeout < 0 || timeleft > fileWaitCompletedPollMs) {
+          toSleep = fileWaitCompletedPollMs;
         } else {
           toSleep = timeleft;
         }
@@ -134,7 +132,7 @@ public final class FileSystemUtils {
    */
   public static void persistFile(final FileSystem fs, final AlluxioURI uri)
       throws IOException, TimeoutException, InterruptedException {
-    FileSystemContext context = FileSystemContext.get();
+    FileSystemContext context = FileSystemContext.create();
     FileSystemMasterClient client = context.acquireMasterClient();
     try {
       client.scheduleAsyncPersist(uri);
@@ -162,7 +160,7 @@ public final class FileSystemUtils {
    */
   public static List<AlluxioURI> checkConsistency(AlluxioURI path,
       CheckConsistencyPOptions options) throws IOException {
-    FileSystemContext context = FileSystemContext.get();
+    FileSystemContext context = FileSystemContext.create();
     FileSystemMasterClient client = context.acquireMasterClient();
     try {
       return client.checkConsistency(path, options);
diff --git a/core/client/fs/src/main/java/alluxio/client/file/RetryHandlingFileSystemMasterClient.java b/core/client/fs/src/main/java/alluxio/client/file/RetryHandlingFileSystemMasterClient.java
index c506376da7..dcd75de35e 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/RetryHandlingFileSystemMasterClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/RetryHandlingFileSystemMasterClient.java
@@ -14,6 +14,7 @@ package alluxio.client.file;
 import alluxio.AbstractMasterClient;
 import alluxio.AlluxioURI;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.grpc.CheckConsistencyPOptions;
 import alluxio.grpc.CheckConsistencyPRequest;
@@ -81,8 +82,9 @@ public final class RetryHandlingFileSystemMasterClient extends AbstractMasterCli
    *
    * @param conf master client configuration
    */
-  public RetryHandlingFileSystemMasterClient(MasterClientConfig conf) {
-    super(conf);
+  public RetryHandlingFileSystemMasterClient(MasterClientConfig conf,
+      AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
diff --git a/core/client/fs/src/main/java/alluxio/client/file/options/CompleteUfsFileOptions.java b/core/client/fs/src/main/java/alluxio/client/file/options/CompleteUfsFileOptions.java
index 4dfc2ddeda..3461144a0f 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/options/CompleteUfsFileOptions.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/options/CompleteUfsFileOptions.java
@@ -11,6 +11,8 @@
 
 package alluxio.client.file.options;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authorization.Mode;
 import alluxio.util.ModeUtils;
 import alluxio.util.SecurityUtils;
@@ -30,14 +32,15 @@ public final class CompleteUfsFileOptions
    *
    * @return the default {@link CompleteUfsFileOptions}
    */
-  public static CompleteUfsFileOptions defaults() {
-    return new CompleteUfsFileOptions();
+  public static CompleteUfsFileOptions defaults(AlluxioConfiguration alluxioConf) {
+    return new CompleteUfsFileOptions(alluxioConf);
   }
 
-  private CompleteUfsFileOptions() {
-    mOwner = SecurityUtils.getOwnerFromLoginModule();
-    mGroup = SecurityUtils.getGroupFromLoginModule();
-    mMode = ModeUtils.applyFileUMask(Mode.defaults());
+  private CompleteUfsFileOptions(AlluxioConfiguration alluxioConf) {
+    mOwner = SecurityUtils.getOwnerFromLoginModule(alluxioConf);
+    mGroup = SecurityUtils.getGroupFromLoginModule(alluxioConf);
+    mMode = ModeUtils.applyFileUMask(Mode.defaults(),
+        alluxioConf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
     // TODO(chaomin): set permission based on the alluxio file. Not needed for now since the
     // file is always created with default permission.
   }
diff --git a/core/client/fs/src/main/java/alluxio/client/file/options/CreateUfsFileOptions.java b/core/client/fs/src/main/java/alluxio/client/file/options/CreateUfsFileOptions.java
index 6ff08ab499..819e782c25 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/options/CreateUfsFileOptions.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/options/CreateUfsFileOptions.java
@@ -11,6 +11,8 @@
 
 package alluxio.client.file.options;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authorization.Mode;
 import alluxio.util.ModeUtils;
 import alluxio.util.SecurityUtils;
@@ -30,14 +32,14 @@ public final class CreateUfsFileOptions
    *
    * @return the default {@link CreateUfsFileOptions}
    */
-  public static CreateUfsFileOptions defaults() {
-    return new CreateUfsFileOptions();
+  public static CreateUfsFileOptions defaults(AlluxioConfiguration alluxioConf) {
+    return new CreateUfsFileOptions(alluxioConf);
   }
 
-  private CreateUfsFileOptions() {
-    mOwner = SecurityUtils.getOwnerFromLoginModule();
-    mGroup = SecurityUtils.getGroupFromLoginModule();
-    mMode = ModeUtils.applyFileUMask(Mode.defaults());
+  private CreateUfsFileOptions(AlluxioConfiguration alluxioConf) {
+    mOwner = SecurityUtils.getOwnerFromLoginModule(alluxioConf);
+    mGroup = SecurityUtils.getGroupFromLoginModule(alluxioConf);
+    mMode = ModeUtils.applyFileUMask(Mode.defaults(), alluxioConf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
     // TODO(chaomin): set permission based on the alluxio file. Not needed for now since the
     // file is always created with default permission.
   }
diff --git a/core/client/fs/src/main/java/alluxio/client/file/options/InStreamOptions.java b/core/client/fs/src/main/java/alluxio/client/file/options/InStreamOptions.java
index 284e37b79c..3646d336d7 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/options/InStreamOptions.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/options/InStreamOptions.java
@@ -11,12 +11,12 @@
 
 package alluxio.client.file.options;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
 import alluxio.client.ReadType;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.CreateOptions;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.OpenFilePOptions;
 import alluxio.master.block.BlockId;
 import alluxio.proto.dataserver.Protocol;
@@ -47,8 +47,8 @@ public final class InStreamOptions {
    * Creates with the default {@link OpenFilePOptions}.
    * @param status the file to create the options for
    */
-  public InStreamOptions(URIStatus status) {
-    this(status, OpenFilePOptions.getDefaultInstance());
+  public InStreamOptions(URIStatus status, AlluxioConfiguration alluxioConf) {
+    this(status, OpenFilePOptions.getDefaultInstance(), alluxioConf);
   }
 
   /**
@@ -56,17 +56,16 @@ public final class InStreamOptions {
    * @param status URI status
    * @param options OpenFile options
    */
-  public InStreamOptions(URIStatus status, OpenFilePOptions options) {
+  public InStreamOptions(URIStatus status, OpenFilePOptions options,
+      AlluxioConfiguration alluxioConf) {
     // Create OpenOptions builder with default options.
     OpenFilePOptions.Builder openOptionsBuilder = OpenFilePOptions.newBuilder()
-        .setReadType(Configuration.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class)
+        .setReadType(alluxioConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class)
             .toProto())
         .setFileReadLocationPolicy(
-            Configuration.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY))
-        .setHashingNumberOfShards(Configuration
-            .getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS))
-        .setMaxUfsReadConcurrency(
-            Configuration.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX));
+            alluxioConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY))
+        .setHashingNumberOfShards(alluxioConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS))
+        .setMaxUfsReadConcurrency(alluxioConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX));
     // Merge default options with given options.
     OpenFilePOptions openOptions = openOptionsBuilder.mergeFrom(options).build();
 
@@ -75,7 +74,8 @@ public final class InStreamOptions {
     CreateOptions blockLocationPolicyCreateOptions =
         CreateOptions.defaults().setLocationPolicyClassName(openOptions.getFileReadLocationPolicy())
             .setDeterministicHashPolicyNumShards(openOptions.getHashingNumberOfShards());
-    mUfsReadLocationPolicy = BlockLocationPolicy.Factory.create(blockLocationPolicyCreateOptions);
+    mUfsReadLocationPolicy = BlockLocationPolicy.Factory.create(blockLocationPolicyCreateOptions,
+        alluxioConf);
   }
 
   /**
diff --git a/core/client/fs/src/main/java/alluxio/client/file/options/OutStreamOptions.java b/core/client/fs/src/main/java/alluxio/client/file/options/OutStreamOptions.java
index 893ab92f1a..5cfa4b6a18 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/options/OutStreamOptions.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/options/OutStreamOptions.java
@@ -11,9 +11,9 @@
 
 package alluxio.client.file.options;
 
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 import alluxio.client.AlluxioStorageType;
 import alluxio.client.UnderStorageType;
@@ -58,8 +58,8 @@ public final class OutStreamOptions {
   /**
    * @return the default {@link OutStreamOptions}
    */
-  public static OutStreamOptions defaults() {
-    return new OutStreamOptions();
+  public static OutStreamOptions defaults(AlluxioConfiguration alluxioConf) {
+    return new OutStreamOptions(alluxioConf);
   }
 
   /**
@@ -68,8 +68,8 @@ public final class OutStreamOptions {
    * @param options CreateFile options
    * @throws Exception if FileWriteLocationPolicy can't be loaded
    */
-  public OutStreamOptions(CreateFilePOptions options) {
-    this();
+  public OutStreamOptions(CreateFilePOptions options, AlluxioConfiguration alluxioConf) {
+    this(alluxioConf);
     if (options.hasBlockSizeBytes()) {
       mBlockSizeBytes = options.getBlockSizeBytes();
     }
@@ -101,23 +101,24 @@ public final class OutStreamOptions {
     }
   }
 
-  private OutStreamOptions() {
-    mBlockSizeBytes = Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+  private OutStreamOptions(AlluxioConfiguration alluxioConf) {
+    mBlockSizeBytes = alluxioConf.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
     mTtl = Constants.NO_TTL;
     mTtlAction = TtlAction.DELETE;
 
     mLocationPolicy =
-        CommonUtils.createNewClassInstance(Configuration.<FileWriteLocationPolicy>getClass(
-            PropertyKey.USER_FILE_WRITE_LOCATION_POLICY), new Class[] {}, new Object[] {});
-    mWriteTier = Configuration.getInt(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT);
-    mWriteType = Configuration.getEnum(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class);
-    mOwner = SecurityUtils.getOwnerFromLoginModule();
-    mGroup = SecurityUtils.getGroupFromLoginModule();
-    mMode = ModeUtils.applyFileUMask(Mode.defaults());
+        CommonUtils.createNewClassInstance(alluxioConf.<FileWriteLocationPolicy>getClass(
+            PropertyKey.USER_FILE_WRITE_LOCATION_POLICY), new Class[] {AlluxioConfiguration.class},
+            new Object[] {alluxioConf});
+    mWriteTier = alluxioConf.getInt(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT);
+    mWriteType = alluxioConf.getEnum(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class);
+    mOwner = SecurityUtils.getOwnerFromLoginModule(alluxioConf);
+    mGroup = SecurityUtils.getGroupFromLoginModule(alluxioConf);
+    mMode = ModeUtils.applyFileUMask(Mode.defaults(), alluxioConf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
     mMountId = IdUtils.INVALID_MOUNT_ID;
-    mReplicationDurable = Configuration.getInt(PropertyKey.USER_FILE_REPLICATION_DURABLE);
-    mReplicationMax = Configuration.getInt(PropertyKey.USER_FILE_REPLICATION_MAX);
-    mReplicationMin = Configuration.getInt(PropertyKey.USER_FILE_REPLICATION_MIN);
+    mReplicationDurable = alluxioConf.getInt(PropertyKey.USER_FILE_REPLICATION_DURABLE);
+    mReplicationMax = alluxioConf.getInt(PropertyKey.USER_FILE_REPLICATION_MAX);
+    mReplicationMin = alluxioConf.getInt(PropertyKey.USER_FILE_REPLICATION_MIN);
   }
 
   /**
diff --git a/core/client/fs/src/main/java/alluxio/client/file/policy/FileWriteLocationPolicy.java b/core/client/fs/src/main/java/alluxio/client/file/policy/FileWriteLocationPolicy.java
index 86b2e9ab7c..4c8f1568c8 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/policy/FileWriteLocationPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/policy/FileWriteLocationPolicy.java
@@ -32,6 +32,7 @@ import alluxio.wire.WorkerNetAddress;
  * </p>
  */
 @PublicApi
+@Deprecated
 // TODO(peis): Deprecate this and use BlockLocationPolicy in 2.0.
 public interface FileWriteLocationPolicy {
   /**
diff --git a/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicy.java b/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicy.java
index 2d7f54edbb..dc79c3eb11 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicy.java
@@ -11,11 +11,11 @@
 
 package alluxio.client.file.policy;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.wire.TieredIdentity;
 import alluxio.wire.WorkerNetAddress;
 
@@ -40,17 +40,21 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class LocalFirstAvoidEvictionPolicy
     implements FileWriteLocationPolicy, BlockLocationPolicy {
   private final LocalFirstPolicy mPolicy;
+  private final long mFileWriteCapacityReserved;
 
   /**
    * Constructs a {@link LocalFirstAvoidEvictionPolicy}.
    */
-  public LocalFirstAvoidEvictionPolicy() {
-    mPolicy = new LocalFirstPolicy();
+  public LocalFirstAvoidEvictionPolicy(AlluxioConfiguration conf) {
+    mPolicy = new LocalFirstPolicy(conf);
+    mFileWriteCapacityReserved = conf.getBytes(PropertyKey.USER_FILE_WRITE_AVOID_EVICTION_POLICY_RESERVED_BYTES);
   }
 
   @VisibleForTesting
-  LocalFirstAvoidEvictionPolicy(TieredIdentity localTieredIdentity) {
-    mPolicy = LocalFirstPolicy.create(localTieredIdentity);
+  LocalFirstAvoidEvictionPolicy(TieredIdentity localTieredIdentity,
+      AlluxioConfiguration conf) {
+    mPolicy = LocalFirstPolicy.create(localTieredIdentity, conf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP));
+    mFileWriteCapacityReserved = conf.getBytes(PropertyKey.USER_FILE_WRITE_AVOID_EVICTION_POLICY_RESERVED_BYTES);
   }
 
   @Override
@@ -81,11 +85,9 @@ public final class LocalFirstAvoidEvictionPolicy
    * @return the available bytes of the worker
    */
   private long getAvailableBytes(BlockWorkerInfo workerInfo) {
-    long mUserFileWriteCapacityReserved = Configuration
-            .getBytes(PropertyKey.USER_FILE_WRITE_AVOID_EVICTION_POLICY_RESERVED_BYTES);
     long mCapacityBytes = workerInfo.getCapacityBytes();
     long mUsedBytes = workerInfo.getUsedBytes();
-    return mCapacityBytes - mUsedBytes - mUserFileWriteCapacityReserved;
+    return mCapacityBytes - mUsedBytes - mFileWriteCapacityReserved;
   }
 
   @Override
diff --git a/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstPolicy.java b/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstPolicy.java
index 592e7f3f4d..a532a0bd7e 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/policy/LocalFirstPolicy.java
@@ -14,6 +14,8 @@ package alluxio.client.file.policy;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.network.TieredIdentityFactory;
 import alluxio.util.TieredIdentityUtils;
 import alluxio.wire.TieredIdentity;
@@ -39,24 +41,26 @@ import javax.annotation.concurrent.ThreadSafe;
 @ThreadSafe
 public final class LocalFirstPolicy implements FileWriteLocationPolicy, BlockLocationPolicy {
   private final TieredIdentity mTieredIdentity;
+  private final boolean mCompareNodeIps;
 
   /**
    * Constructs a {@link LocalFirstPolicy}.
    */
-  public LocalFirstPolicy() {
-    this(TieredIdentityFactory.localIdentity());
+  public LocalFirstPolicy(AlluxioConfiguration alluxioConf) {
+    this(TieredIdentityFactory.localIdentity(alluxioConf), alluxioConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP));
   }
 
   /**
    * @param localTieredIdentity the local tiered identity
    */
-  private LocalFirstPolicy(TieredIdentity localTieredIdentity) {
+  private LocalFirstPolicy(TieredIdentity localTieredIdentity, boolean compareNodeIp) {
     mTieredIdentity = localTieredIdentity;
+    mCompareNodeIps = compareNodeIp;
   }
 
   @VisibleForTesting
-  static LocalFirstPolicy create(TieredIdentity localTieredIdentity) {
-    return new LocalFirstPolicy(localTieredIdentity);
+  static LocalFirstPolicy create(TieredIdentity localTieredIdentity, boolean compareNodeIps) {
+    return new LocalFirstPolicy(localTieredIdentity, compareNodeIps);
   }
 
   @Override
@@ -75,7 +79,7 @@ public final class LocalFirstPolicy implements FileWriteLocationPolicy, BlockLoc
         .map(worker -> worker.getNetAddress().getTieredIdentity())
         .filter(Objects::nonNull)
         .collect(Collectors.toList());
-    Optional<TieredIdentity> nearest = TieredIdentityUtils.nearest(mTieredIdentity, identities);
+    Optional<TieredIdentity> nearest = TieredIdentityUtils.nearest(mTieredIdentity, identities, mCompareNodeIps);
     if (!nearest.isPresent()) {
       return null;
     }
diff --git a/core/client/fs/src/main/java/alluxio/client/file/policy/MostAvailableFirstPolicy.java b/core/client/fs/src/main/java/alluxio/client/file/policy/MostAvailableFirstPolicy.java
index 50efd9d223..c5bfd0dfb3 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/policy/MostAvailableFirstPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/policy/MostAvailableFirstPolicy.java
@@ -14,6 +14,7 @@ package alluxio.client.file.policy;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.wire.WorkerNetAddress;
 
 import com.google.common.base.MoreObjects;
@@ -32,7 +33,7 @@ public final class MostAvailableFirstPolicy
   /**
    * Constructs a new {@link MostAvailableFirstPolicy}.
    */
-  public MostAvailableFirstPolicy() {}
+  public MostAvailableFirstPolicy(AlluxioConfiguration alluxioConf) {}
 
   @Override
   public WorkerNetAddress getWorkerForNextBlock(Iterable<BlockWorkerInfo> workerInfoList,
diff --git a/core/client/fs/src/main/java/alluxio/client/file/policy/RoundRobinPolicy.java b/core/client/fs/src/main/java/alluxio/client/file/policy/RoundRobinPolicy.java
index b5f3daf487..0754bb77bd 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/policy/RoundRobinPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/policy/RoundRobinPolicy.java
@@ -14,6 +14,7 @@ package alluxio.client.file.policy;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.wire.WorkerNetAddress;
 
 import com.google.common.base.MoreObjects;
@@ -43,7 +44,7 @@ public final class RoundRobinPolicy implements FileWriteLocationPolicy, BlockLoc
   /**
    * Constructs a new {@link RoundRobinPolicy}.
    */
-  public RoundRobinPolicy() {}
+  public RoundRobinPolicy(AlluxioConfiguration alluxioConf) {}
 
   /**
    * The policy uses the first fetch of worker info list as the base, and visits each of them in a
diff --git a/core/client/fs/src/main/java/alluxio/client/file/policy/SpecificHostPolicy.java b/core/client/fs/src/main/java/alluxio/client/file/policy/SpecificHostPolicy.java
index b4ec66406b..58451364a9 100644
--- a/core/client/fs/src/main/java/alluxio/client/file/policy/SpecificHostPolicy.java
+++ b/core/client/fs/src/main/java/alluxio/client/file/policy/SpecificHostPolicy.java
@@ -14,6 +14,8 @@ package alluxio.client.file.policy;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.wire.WorkerNetAddress;
 
 import com.google.common.base.MoreObjects;
@@ -31,6 +33,10 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class SpecificHostPolicy implements FileWriteLocationPolicy, BlockLocationPolicy {
   private final String mHostname;
 
+  public SpecificHostPolicy(AlluxioConfiguration alluxioConf) {
+    this(alluxioConf.get(PropertyKey.WORKER_HOSTNAME));
+  }
+
   /**
    * Constructs the policy with the hostname.
    *
diff --git a/core/client/fs/src/main/java/alluxio/client/metrics/MetricsMasterClient.java b/core/client/fs/src/main/java/alluxio/client/metrics/MetricsMasterClient.java
index 692d712b71..349b678459 100644
--- a/core/client/fs/src/main/java/alluxio/client/metrics/MetricsMasterClient.java
+++ b/core/client/fs/src/main/java/alluxio/client/metrics/MetricsMasterClient.java
@@ -13,6 +13,8 @@ package alluxio.client.metrics;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.client.file.FileSystemContext;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.Metric;
 import alluxio.grpc.MetricsHeartbeatPOptions;
@@ -41,8 +43,8 @@ public class MetricsMasterClient extends AbstractMasterClient {
    *
    * @param conf master client configuration
    */
-  public MetricsMasterClient(MasterClientConfig conf) {
-    super(conf, null, RetryUtils::defaultMetricsClientRetry);
+  public MetricsMasterClient(MasterClientConfig conf, AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf, null, RetryUtils::defaultMetricsClientRetry);
   }
 
   @Override
@@ -74,8 +76,8 @@ public class MetricsMasterClient extends AbstractMasterClient {
     connect();
     try {
       MetricsHeartbeatPRequest.Builder request = MetricsHeartbeatPRequest.newBuilder();
-      request.setClientId(MetricsSystem.getAppId());
-      request.setHostname(NetworkAddressUtils.getClientHostName());
+      request.setClientId(FileSystemContext.create().getId());
+      request.setHostname(NetworkAddressUtils.getClientHostName(mContext.getConfiguration()));
       request.setOptions(MetricsHeartbeatPOptions.newBuilder().addAllMetrics(metrics).build());
       mClient.metricsHeartbeat(request.build());
     } catch (io.grpc.StatusRuntimeException e) {
diff --git a/core/client/fs/src/test/java/alluxio/client/block/AlluxioBlockStoreTest.java b/core/client/fs/src/test/java/alluxio/client/block/AlluxioBlockStoreTest.java
index 93a39f43fa..a381a5475f 100644
--- a/core/client/fs/src/test/java/alluxio/client/block/AlluxioBlockStoreTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/block/AlluxioBlockStoreTest.java
@@ -16,6 +16,8 @@ import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.client.ReadType;
 import alluxio.client.WriteType;
 import alluxio.client.block.policy.BlockLocationPolicy;
 import alluxio.client.block.policy.options.GetWorkerOptions;
@@ -27,6 +29,10 @@ import alluxio.client.file.URIStatus;
 import alluxio.client.file.options.InStreamOptions;
 import alluxio.client.file.options.OutStreamOptions;
 import alluxio.client.file.policy.FileWriteLocationPolicy;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.NotFoundException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.PreconditionMessage;
@@ -81,9 +87,13 @@ import javax.annotation.concurrent.ThreadSafe;
 @RunWith(PowerMockRunner.class)
 @PrepareForTest({FileSystemContext.class})
 public final class AlluxioBlockStoreTest {
+
+  private static final InstancedConfiguration sConf = ConfigurationTestUtils.defaults();
+
   private static final long BLOCK_ID = 3L;
   private static final long BLOCK_LENGTH = 100L;
-  private static final String WORKER_HOSTNAME_LOCAL = NetworkAddressUtils.getLocalHostName();
+  private static final String WORKER_HOSTNAME_LOCAL =
+      NetworkAddressUtils.getLocalHostName((int)sConf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
   private static final String WORKER_HOSTNAME_REMOTE = "remote";
   private static final WorkerNetAddress WORKER_NET_ADDRESS_LOCAL = new WorkerNetAddress()
       .setHost(WORKER_HOSTNAME_LOCAL);
@@ -92,6 +102,7 @@ public final class AlluxioBlockStoreTest {
   private ClientCallStreamObserver mStreamObserver;
   private static final ExecutorService EXECUTOR = Executors.newFixedThreadPool(4);
 
+
   /**
    * A mock class used to return controlled result when selecting workers.
    */
@@ -104,7 +115,7 @@ public final class AlluxioBlockStoreTest {
     /**
      * Cosntructs this mock location policy with empty host list.
      */
-    public MockFileWriteLocationPolicy() {
+    public MockFileWriteLocationPolicy(AlluxioConfiguration alluxioConf) {
       mIndex = 0;
       mWorkerNetAddresses =  Collections.emptyList();
     }
@@ -156,10 +167,11 @@ public final class AlluxioBlockStoreTest {
     mContext = PowerMockito.mock(FileSystemContext.class);
     when(mContext.acquireBlockMasterClientResource())
         .thenReturn(new DummyCloseableResource<>(mMasterClient));
-    mLocalAddr = new WorkerNetAddress().setHost(NetworkAddressUtils.getLocalHostName());
+    mLocalAddr =
+        new WorkerNetAddress().setHost(NetworkAddressUtils.getLocalHostName((int)sConf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)));
 
     mBlockStore = new AlluxioBlockStore(mContext,
-        TieredIdentityFactory.fromString("node=" + WORKER_HOSTNAME_LOCAL));
+        TieredIdentityFactory.fromString("node=" + WORKER_HOSTNAME_LOCAL, sConf), sConf);
 
     when(mContext.acquireBlockWorkerClient(any(WorkerNetAddress.class)))
         .thenReturn(mWorkerClient);
@@ -173,7 +185,7 @@ public final class AlluxioBlockStoreTest {
 
   @Test
   public void getOutStreamUsingLocationPolicy() throws Exception {
-    OutStreamOptions options = OutStreamOptions.defaults().setWriteType(WriteType.MUST_CACHE)
+    OutStreamOptions options = OutStreamOptions.defaults(sConf).setWriteType(WriteType.MUST_CACHE)
         .setLocationPolicy((workerInfoList, blockSizeBytes) -> {
           throw new RuntimeException("policy threw exception");
         });
@@ -184,7 +196,7 @@ public final class AlluxioBlockStoreTest {
   @Test
   public void getOutStreamMissingLocationPolicy() throws IOException {
     OutStreamOptions options =
-        OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+        OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
             .setWriteType(WriteType.MUST_CACHE).setLocationPolicy(null);
     mException.expect(NullPointerException.class);
     mException.expectMessage(PreconditionMessage.FILE_WRITE_LOCATION_POLICY_UNSPECIFIED.toString());
@@ -195,7 +207,7 @@ public final class AlluxioBlockStoreTest {
   public void getOutStreamNoWorker() throws IOException {
     OutStreamOptions options =
         OutStreamOptions
-            .defaults()
+            .defaults(sConf)
             .setBlockSizeBytes(BLOCK_LENGTH)
             .setWriteType(WriteType.MUST_CACHE)
             .setLocationPolicy(
@@ -221,7 +233,7 @@ public final class AlluxioBlockStoreTest {
           }
         });
 
-    OutStreamOptions options = OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+    OutStreamOptions options = OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
         .setLocationPolicy(new MockFileWriteLocationPolicy(
             Lists.newArrayList(WORKER_NET_ADDRESS_LOCAL)))
         .setWriteType(WriteType.MUST_CACHE);
@@ -233,7 +245,7 @@ public final class AlluxioBlockStoreTest {
   public void getOutStreamRemote() throws Exception {
     WorkerNetAddress worker1 = new WorkerNetAddress().setHost("worker1");
     WorkerNetAddress worker2 = new WorkerNetAddress().setHost("worker2");
-    OutStreamOptions options = OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+    OutStreamOptions options = OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
         .setLocationPolicy(new MockFileWriteLocationPolicy(Arrays.asList(worker1, worker2)))
         .setWriteType(WriteType.MUST_CACHE);
     BlockOutStream stream1 = mBlockStore.getOutStream(BLOCK_ID, BLOCK_LENGTH, options);
@@ -260,7 +272,7 @@ public final class AlluxioBlockStoreTest {
     when(mMasterClient.getWorkerInfoList()).thenReturn(Lists
         .newArrayList(new alluxio.wire.WorkerInfo().setAddress(WORKER_NET_ADDRESS_LOCAL),
             new alluxio.wire.WorkerInfo().setAddress(WORKER_NET_ADDRESS_REMOTE)));
-    OutStreamOptions options = OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+    OutStreamOptions options = OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
         .setLocationPolicy(new MockFileWriteLocationPolicy(
             Lists.newArrayList(WORKER_NET_ADDRESS_LOCAL, WORKER_NET_ADDRESS_REMOTE)))
         .setWriteType(WriteType.MUST_CACHE).setReplicationMin(2);
@@ -279,7 +291,7 @@ public final class AlluxioBlockStoreTest {
             .setFileBlockInfos(Collections.singletonList(new FileBlockInfo().setBlockInfo(info))));
     OpenFilePOptions readOptions = OpenFilePOptions.newBuilder()
         .setFileReadLocationPolicy(MockFileWriteLocationPolicy.class.getTypeName()).build();
-    InStreamOptions options = new InStreamOptions(dummyStatus, readOptions);
+    InStreamOptions options = new InStreamOptions(dummyStatus, readOptions, sConf);
     ((MockFileWriteLocationPolicy) options.getUfsReadLocationPolicy())
         .setHosts(Arrays.asList(worker1, worker2));
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(new BlockInfo());
@@ -297,7 +309,8 @@ public final class AlluxioBlockStoreTest {
     URIStatus dummyStatus =
         new URIStatus(new FileInfo().setPersisted(true).setBlockIds(Collections.singletonList(0L)));
     InStreamOptions options =
-        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance());
+        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance(),
+            sConf);
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(new BlockInfo());
     when(mMasterClient.getWorkerInfoList()).thenReturn(Collections.emptyList());
 
@@ -311,7 +324,7 @@ public final class AlluxioBlockStoreTest {
     URIStatus dummyStatus = new URIStatus(
         new FileInfo().setPersisted(false).setBlockIds(Collections.singletonList(0L)));
     InStreamOptions options =
-        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance());
+        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance(), sConf);
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(new BlockInfo());
     when(mMasterClient.getWorkerInfoList()).thenReturn(Collections.emptyList());
 
@@ -344,7 +357,8 @@ public final class AlluxioBlockStoreTest {
 
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(info);
     assertEquals(local, mBlockStore.getInStream(BLOCK_ID, new InStreamOptions(
-        new URIStatus(new FileInfo().setBlockIds(Lists.newArrayList(BLOCK_ID))))).getAddress());
+        new URIStatus(new FileInfo().setBlockIds(Lists.newArrayList(BLOCK_ID))), sConf))
+                            .getAddress());
   }
 
   @Test
@@ -357,11 +371,11 @@ public final class AlluxioBlockStoreTest {
             new BlockLocation().setWorkerAddress(remote2)));
 
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(info);
-    // We should sometimes get remote1 and sometimes get remote2.
+    // We should sometimes create remote1 and sometimes create remote2.
     Set<WorkerNetAddress> results = new HashSet<>();
     for (int i = 0; i < 40; i++) {
       results.add(mBlockStore.getInStream(BLOCK_ID, new InStreamOptions(
-          new URIStatus(new FileInfo().setBlockIds(Lists.newArrayList(BLOCK_ID)))))
+          new URIStatus(new FileInfo().setBlockIds(Lists.newArrayList(BLOCK_ID))), sConf))
           .getAddress());
     }
     assertEquals(Sets.newHashSet(remote1, remote2), results);
@@ -450,7 +464,7 @@ public final class AlluxioBlockStoreTest {
         .getArgumentAt(0, GetWorkerOptions.class).getBlockWorkerInfos().iterator().next()
         .getNetAddress());
     InStreamOptions options =
-        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance());
+        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance(), sConf);
     options.setUfsReadLocationPolicy(mockPolicy);
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(info);
     when(mMasterClient.getWorkerInfoList()).thenReturn(Arrays.stream(workers)
@@ -488,7 +502,7 @@ public final class AlluxioBlockStoreTest {
         .getArgumentAt(0, GetWorkerOptions.class).getBlockWorkerInfos().iterator().next()
         .getNetAddress());
     InStreamOptions options =
-        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance());
+        new InStreamOptions(dummyStatus, OpenFilePOptions.getDefaultInstance(), sConf);
     options.setUfsReadLocationPolicy(mockPolicy);
     when(mMasterClient.getBlockInfo(BLOCK_ID)).thenReturn(info);
     when(mMasterClient.getWorkerInfoList()).thenReturn(Arrays.stream(workers)
diff --git a/core/client/fs/src/test/java/alluxio/client/block/BlockMasterClientPoolTest.java b/core/client/fs/src/test/java/alluxio/client/block/BlockMasterClientPoolTest.java
index 73f338a7ce..92b4d281cb 100644
--- a/core/client/fs/src/test/java/alluxio/client/block/BlockMasterClientPoolTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/block/BlockMasterClientPoolTest.java
@@ -17,6 +17,8 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.master.MasterClientConfig;
 
 import org.junit.Test;
@@ -28,15 +30,17 @@ import org.powermock.modules.junit4.PowerMockRunner;
 @RunWith(PowerMockRunner.class)
 @PrepareForTest(BlockMasterClient.Factory.class)
 public class BlockMasterClientPoolTest {
+
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
   @Test
   public void create() throws Exception {
     BlockMasterClient expectedClient = mock(BlockMasterClient.class);
     PowerMockito.mockStatic(BlockMasterClient.Factory.class);
     when(BlockMasterClient.Factory
-        .create(any(MasterClientConfig.class)))
+        .create(any(MasterClientConfig.class), any(InstancedConfiguration.class)))
         .thenReturn(expectedClient);
     BlockMasterClient client;
-    try (BlockMasterClientPool pool = new BlockMasterClientPool(null, null)) {
+    try (BlockMasterClientPool pool = new BlockMasterClientPool(null, null, mConf)) {
       client = pool.acquire();
       assertEquals(expectedClient, client);
       pool.release(client);
diff --git a/core/client/fs/src/test/java/alluxio/client/block/policy/DeterministicHashPolicyTest.java b/core/client/fs/src/test/java/alluxio/client/block/policy/DeterministicHashPolicyTest.java
index e7dc364d38..75929a382f 100644
--- a/core/client/fs/src/test/java/alluxio/client/block/policy/DeterministicHashPolicyTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/block/policy/DeterministicHashPolicyTest.java
@@ -11,10 +11,12 @@
 
 package alluxio.client.block.policy;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.policy.options.CreateOptions;
 import alluxio.client.block.policy.options.GetWorkerOptions;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.wire.WorkerNetAddress;
 
 import org.junit.Assert;
@@ -33,6 +35,7 @@ public final class DeterministicHashPolicyTest {
   private static final int PORT = 1;
 
   private final List<BlockWorkerInfo> mWorkerInfos = new ArrayList<>();
+  private static final InstancedConfiguration sConf = ConfigurationTestUtils.defaults();
 
   @Before
   public void before() {
@@ -55,14 +58,14 @@ public final class DeterministicHashPolicyTest {
   public void getWorkerDeterministically() {
     DeterministicHashPolicy policy = (DeterministicHashPolicy) BlockLocationPolicy.Factory.create(
         CreateOptions.defaults()
-            .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName()));
+            .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName()), sConf);
     String host = policy.getWorker(
         GetWorkerOptions.defaults().setBlockWorkerInfos(mWorkerInfos).setBlockId(1)
             .setBlockSize(2 * (long) Constants.GB)).getHost();
     for (int i = 0; i < 10; i++) {
       DeterministicHashPolicy p = (DeterministicHashPolicy) BlockLocationPolicy.Factory.create(
           CreateOptions.defaults()
-              .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName()));
+              .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName()), sConf);
       // For the same block, always return the same worker.
       Assert.assertEquals(host, p.getWorker(
           GetWorkerOptions.defaults().setBlockWorkerInfos(mWorkerInfos).setBlockId(1)
@@ -77,7 +80,7 @@ public final class DeterministicHashPolicyTest {
   public void getWorkerEnoughCapacity() {
     DeterministicHashPolicy policy = (DeterministicHashPolicy) BlockLocationPolicy.Factory.create(
         CreateOptions.defaults()
-            .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName()));
+            .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName()), sConf);
     for (long blockId = 0; blockId < 100; blockId++) {
       // worker1 does not have enough capacity. It should never be picked.
       Assert.assertNotEquals("worker1", policy.getWorker(
@@ -91,7 +94,7 @@ public final class DeterministicHashPolicyTest {
     DeterministicHashPolicy policy2 = (DeterministicHashPolicy) BlockLocationPolicy.Factory.create(
         CreateOptions.defaults()
             .setLocationPolicyClassName(DeterministicHashPolicy.class.getCanonicalName())
-            .setDeterministicHashPolicyNumShards(2));
+            .setDeterministicHashPolicyNumShards(2), sConf);
     Set<String> addresses1 = new HashSet<>();
     Set<String> addresses2 = new HashSet<>();
     for (int i = 0; i < 100; i++) {
diff --git a/core/client/fs/src/test/java/alluxio/client/block/stream/BlockInStreamTest.java b/core/client/fs/src/test/java/alluxio/client/block/stream/BlockInStreamTest.java
index f1af049b34..cd18daf533 100644
--- a/core/client/fs/src/test/java/alluxio/client/block/stream/BlockInStreamTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/block/stream/BlockInStreamTest.java
@@ -15,7 +15,10 @@ import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.when;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.client.ReadType;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
 import alluxio.client.file.options.InStreamOptions;
@@ -50,6 +53,7 @@ public class BlockInStreamTest {
   private FileSystemContext mMockContext;
   private BlockInfo mInfo;
   private InStreamOptions mOptions;
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
 
   @Before
   public void before() throws Exception {
@@ -74,7 +78,7 @@ public class BlockInStreamTest {
             Matchers.any(BlockWorkerClient.class));
     mInfo = new BlockInfo().setBlockId(1);
     mOptions = new InStreamOptions(new URIStatus(new FileInfo().setBlockIds(Collections
-        .singletonList(1L))));
+        .singletonList(1L))), mConf);
   }
 
   @Test
@@ -82,7 +86,7 @@ public class BlockInStreamTest {
     WorkerNetAddress dataSource = new WorkerNetAddress();
     BlockInStream.BlockInStreamSource dataSourceType = BlockInStream.BlockInStreamSource.LOCAL;
     BlockInStream stream =
-        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions);
+        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions, mConf);
     Assert.assertTrue(stream.isShortCircuit());
   }
 
@@ -91,7 +95,7 @@ public class BlockInStreamTest {
     WorkerNetAddress dataSource = new WorkerNetAddress();
     BlockInStream.BlockInStreamSource dataSourceType = BlockInStream.BlockInStreamSource.REMOTE;
     BlockInStream stream =
-        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions);
+        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions, mConf);
     Assert.assertFalse(stream.isShortCircuit());
   }
 
@@ -100,18 +104,18 @@ public class BlockInStreamTest {
     WorkerNetAddress dataSource = new WorkerNetAddress();
     BlockInStream.BlockInStreamSource dataSourceType = BlockInStream.BlockInStreamSource.UFS;
     BlockInStream stream =
-        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions);
+        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions, mConf);
     Assert.assertFalse(stream.isShortCircuit());
   }
 
   @Test
   public void createShortCircuitDisabled() throws Exception {
     try (Closeable c =
-        new ConfigurationRule(PropertyKey.USER_SHORT_CIRCUIT_ENABLED, "false").toResource()) {
+        new ConfigurationRule(PropertyKey.USER_SHORT_CIRCUIT_ENABLED, "false", mConf).toResource()) {
       WorkerNetAddress dataSource = new WorkerNetAddress();
       BlockInStream.BlockInStreamSource dataSourceType = BlockInStream.BlockInStreamSource.LOCAL;
       BlockInStream stream =
-          BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions);
+          BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions, mConf);
       Assert.assertFalse(stream.isShortCircuit());
     }
   }
@@ -119,12 +123,13 @@ public class BlockInStreamTest {
   @Test
   public void createDomainSocketEnabled() throws Exception {
     PowerMockito.mockStatic(NettyUtils.class);
-    PowerMockito.when(NettyUtils.isDomainSocketSupported(Matchers.any(WorkerNetAddress.class)))
+    PowerMockito.when(NettyUtils.isDomainSocketSupported(Matchers.any(WorkerNetAddress.class),
+        Matchers.any(InstancedConfiguration.class)))
         .thenReturn(true);
     WorkerNetAddress dataSource = new WorkerNetAddress();
     BlockInStream.BlockInStreamSource dataSourceType = BlockInStream.BlockInStreamSource.LOCAL;
     BlockInStream stream =
-        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions);
+        BlockInStream.create(mMockContext, mInfo, dataSource, dataSourceType, mOptions, mConf);
     Assert.assertFalse(stream.isShortCircuit());
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/block/stream/GrpcDataWriterTest.java b/core/client/fs/src/test/java/alluxio/client/block/stream/GrpcDataWriterTest.java
index d4e8dc7b08..31e6784fb8 100644
--- a/core/client/fs/src/test/java/alluxio/client/block/stream/GrpcDataWriterTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/block/stream/GrpcDataWriterTest.java
@@ -17,7 +17,11 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.Constants;
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.OutStreamOptions;
 import alluxio.grpc.Chunk;
@@ -72,7 +76,7 @@ public final class GrpcDataWriterTest {
   @Rule
   public ConfigurationRule mConfigurationRule =
       new ConfigurationRule(PropertyKey.USER_NETWORK_WRITER_CHUNK_SIZE_BYTES,
-          String.valueOf(CHUNK_SIZE));
+          String.valueOf(CHUNK_SIZE), mConf);
 
   @Before
   public void before() throws Exception {
@@ -180,7 +184,7 @@ public final class GrpcDataWriterTest {
     DataWriter writer =
         GrpcDataWriter.create(mContext, mAddress, BLOCK_ID, length,
             RequestType.ALLUXIO_BLOCK,
-            OutStreamOptions.defaults().setWriteTier(TIER));
+            OutStreamOptions.defaults(mConf).setWriteTier(TIER));
     return writer;
   }
 
diff --git a/core/client/fs/src/test/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriterTest.java b/core/client/fs/src/test/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriterTest.java
index 0df6cc1cc7..aa343d827b 100644
--- a/core/client/fs/src/test/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriterTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/block/stream/UfsFallbackLocalFileDataWriterTest.java
@@ -20,7 +20,10 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.Constants;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.options.OutStreamOptions;
 import alluxio.exception.status.ResourceExhaustedException;
@@ -142,7 +145,7 @@ public class UfsFallbackLocalFileDataWriterTest {
   @Rule
   public ConfigurationRule mConfigurationRule =
       new ConfigurationRule(PropertyKey.USER_NETWORK_WRITER_CHUNK_SIZE_BYTES,
-          String.valueOf(CHUNK_SIZE));
+          String.valueOf(CHUNK_SIZE), mConf);
 
   @Before
   public void before() throws Exception {
@@ -174,7 +177,7 @@ public class UfsFallbackLocalFileDataWriterTest {
     mLocalWriter = new FixedCapacityTestDataWriter(mBuffer);
     DataWriter writer =
         new UfsFallbackLocalFileDataWriter(mLocalWriter, null, mContext, mAddress, BLOCK_ID,
-            blockSize, OutStreamOptions.defaults().setMountId(MOUNT_ID));
+            blockSize, OutStreamOptions.defaults(mConf).setMountId(MOUNT_ID), mConf);
     return writer;
   }
 
diff --git a/core/client/fs/src/test/java/alluxio/client/file/BaseFileSystemTest.java b/core/client/fs/src/test/java/alluxio/client/file/BaseFileSystemTest.java
index bbdfc5d9f4..e282aab7f8 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/BaseFileSystemTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/BaseFileSystemTest.java
@@ -25,9 +25,11 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.ClientContext;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.TestLoggerRule;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
@@ -66,16 +68,19 @@ public final class BaseFileSystemTest {
   private static final String SHOULD_HAVE_PROPAGATED_MESSAGE =
       "Exception should have been propagated";
 
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+
   @Rule
   private TestLoggerRule mTestLogger = new TestLoggerRule();
 
   private FileSystem mFileSystem;
   private FileSystemContext mFileContext;
+  private ClientContext mClientContext;
   private FileSystemMasterClient mFileSystemMasterClient;
 
   private class DummyAlluxioFileSystem extends BaseFileSystem {
-    public DummyAlluxioFileSystem(FileSystemContext context) {
-      super(context);
+    public DummyAlluxioFileSystem(ClientContext context, FileSystemContext fsContext) {
+      super(context, fsContext);
     }
   }
 
@@ -84,15 +89,16 @@ public final class BaseFileSystemTest {
    */
   @Before
   public void before() {
+    mClientContext = ClientContext.create(mConf.getProperties());
     mFileContext = PowerMockito.mock(FileSystemContext.class);
-    mFileSystem = new DummyAlluxioFileSystem(mFileContext);
+    mFileSystem = new DummyAlluxioFileSystem(mClientContext, mFileContext);
     mFileSystemMasterClient = PowerMockito.mock(FileSystemMasterClient.class);
     when(mFileContext.acquireMasterClient()).thenReturn(mFileSystemMasterClient);
   }
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    mConf = ConfigurationTestUtils.defaults();
   }
 
   /**
@@ -499,8 +505,8 @@ public final class BaseFileSystemTest {
    */
   @Test
   public void uriCheckBadAuthority() throws Exception {
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "localhost");
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, "19998");
+    mConf.set(PropertyKey.MASTER_HOSTNAME, "localhost");
+    mConf.set(PropertyKey.MASTER_RPC_PORT, "19998");
 
     assertBadAuthority("localhost:1234", "Should fail on bad host and port");
     assertBadAuthority("zk@localhost:19998", "Should fail on zk authority");
@@ -514,8 +520,8 @@ public final class BaseFileSystemTest {
    */
   @Test
   public void uriCheckBadScheme() throws Exception {
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "localhost");
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, "19998");
+    mConf.set(PropertyKey.MASTER_HOSTNAME, "localhost");
+    mConf.set(PropertyKey.MASTER_RPC_PORT, "19998");
 
     AlluxioURI uri = new AlluxioURI("hdfs://localhost:19998/root");
     try {
@@ -531,8 +537,9 @@ public final class BaseFileSystemTest {
    */
   @Test
   public void uriCheckGoodSchemeAndAuthority() throws Exception {
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "localhost");
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, "19998");
+    mConf.set(PropertyKey.MASTER_HOSTNAME, "localhost");
+    mConf.set(PropertyKey.MASTER_RPC_PORT, "19998");
+    before(); // Resets the filesystem and contexts to use proper configuration.
 
     useUriWithAuthority("localhost:19998");
 
@@ -546,8 +553,8 @@ public final class BaseFileSystemTest {
    */
   @Test
   public void uriCheckNoSchemeAuthority() throws Exception {
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "localhost");
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, "19998");
+    mConf.set(PropertyKey.MASTER_HOSTNAME, "localhost");
+    mConf.set(PropertyKey.MASTER_RPC_PORT, "19998");
 
     AlluxioURI uri = new AlluxioURI("/root");
     mFileSystem.createDirectory(uri);
@@ -594,7 +601,8 @@ public final class BaseFileSystemTest {
   }
 
   private void configureZk(String addrs) {
-    Configuration.set(PropertyKey.ZOOKEEPER_ENABLED, true);
-    Configuration.set(PropertyKey.ZOOKEEPER_ADDRESS, addrs);
+    mConf.set(PropertyKey.ZOOKEEPER_ENABLED, true);
+    mConf.set(PropertyKey.ZOOKEEPER_ADDRESS, addrs);
+    before(); // Resets the filesystem and contexts to use proper configuration
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/file/FileInStreamTest.java b/core/client/fs/src/test/java/alluxio/client/file/FileInStreamTest.java
index 8699c880e6..31e2854fee 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/FileInStreamTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/FileInStreamTest.java
@@ -24,6 +24,8 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.client.ReadType;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.stream.BlockInStream;
@@ -31,6 +33,9 @@ import alluxio.client.block.stream.BlockInStream.BlockInStreamSource;
 import alluxio.client.block.stream.TestBlockInStream;
 import alluxio.client.file.options.InStreamOptions;
 import alluxio.client.util.ClientTestUtils;
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.PreconditionMessage;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.OpenFilePOptions;
@@ -80,6 +85,9 @@ public final class FileInStreamTest {
   private FileInfo mInfo;
   private URIStatus mStatus;
 
+
+  private static InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+
   private List<TestBlockInStream> mInStreams;
 
   private FileInStream mTestStream;
@@ -112,15 +120,16 @@ public final class FileInStreamTest {
    */
   @Before
   public void before() throws Exception {
+    mConf = ConfigurationTestUtils.defaults();
     mInfo = new FileInfo().setBlockSizeBytes(BLOCK_LENGTH).setLength(FILE_LENGTH);
 
-    ClientTestUtils.setSmallBufferSizes();
+    ClientTestUtils.setSmallBufferSizes(mConf);
 
     mContext = PowerMockito.mock(FileSystemContext.class);
     PowerMockito.when(mContext.getLocalWorker()).thenReturn(new WorkerNetAddress());
     mBlockStore = mock(AlluxioBlockStore.class);
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    PowerMockito.when(AlluxioBlockStore.create(mContext)).thenReturn(mBlockStore);
+    PowerMockito.when(AlluxioBlockStore.create(mContext, mConf)).thenReturn(mBlockStore);
     PowerMockito.when(mBlockStore.getEligibleWorkers()).thenReturn(new ArrayList<>());
 
     // Set up BufferedBlockInStreams and caching streams
@@ -152,12 +161,13 @@ public final class FileInStreamTest {
 
     OpenFilePOptions readOptions =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, readOptions), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, readOptions,
+        mConf), mContext, mConf);
   }
 
   @After
   public void after() {
-    ClientTestUtils.resetClient();
+    ClientTestUtils.resetClient(mConf);
   }
 
   /**
@@ -334,7 +344,11 @@ public final class FileInStreamTest {
   public void longSeekBackwardCachingPartiallyReadBlocks() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class),
+        mConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX)), mContext, mConf);
     int seekAmount = (int) (BLOCK_LENGTH / 4 + BLOCK_LENGTH);
     int readAmount = (int) (BLOCK_LENGTH * 3 - BLOCK_LENGTH / 2);
     byte[] buffer = new byte[readAmount];
@@ -352,11 +366,15 @@ public final class FileInStreamTest {
    */
   @Test
   public void testSeekWithNoLocalWorker() throws IOException {
-    // Overrides the get local worker call
+    // Overrides the create local worker call
     PowerMockito.when(mContext.getLocalWorker()).thenReturn(null);
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class),
+        mConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX)), mContext, mConf);
     int readAmount = (int) (BLOCK_LENGTH / 2);
     byte[] buffer = new byte[readAmount];
     // read and seek several times
@@ -374,7 +392,11 @@ public final class FileInStreamTest {
   public void seekAndClose() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class),
+        mConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX)), mContext, mConf);
     int seekAmount = (int) (BLOCK_LENGTH / 2);
     mTestStream.seek(seekAmount);
     mTestStream.close();
@@ -390,7 +412,12 @@ public final class FileInStreamTest {
   public void shortSeekBackwardCachingPartiallyReadBlocks() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class),
+        mConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX)
+        ), mContext, mConf);
     int seekAmount = (int) (BLOCK_LENGTH / 4);
     int readAmount = (int) (BLOCK_LENGTH * 2 - BLOCK_LENGTH / 2);
     byte[] buffer = new byte[readAmount];
@@ -416,7 +443,11 @@ public final class FileInStreamTest {
   public void longSeekForwardCachingPartiallyReadBlocks() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class),
+        mConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX)), mContext, mConf);
     int seekAmount = (int) (BLOCK_LENGTH / 4 + BLOCK_LENGTH);
     int readAmount = (int) (BLOCK_LENGTH / 2);
     byte[] buffer = new byte[readAmount];
@@ -441,7 +472,8 @@ public final class FileInStreamTest {
   public void shortSeekForwardCachingPartiallyReadBlocks() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf), mContext, mConf);
     int seekAmount = (int) (BLOCK_LENGTH / 4);
     int readAmount = (int) (BLOCK_LENGTH * 2 - BLOCK_LENGTH / 2);
     byte[] buffer = new byte[readAmount];
@@ -467,7 +499,12 @@ public final class FileInStreamTest {
   public void seekBackwardSmallSeekBuffer() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf.getEnum(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, ReadType.class),
+        mConf.get(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_LOCATION_POLICY_DETERMINISTIC_HASH_SHARDS),
+        mConf.getInt(PropertyKey.USER_UFS_BLOCK_READ_CONCURRENCY_MAX)),
+        mContext, mConf);
     int readAmount = (int) (BLOCK_LENGTH / 2);
     byte[] buffer = new byte[readAmount];
     mTestStream.read(buffer);
@@ -485,7 +522,8 @@ public final class FileInStreamTest {
   public void seekBackwardToFileBeginning() throws IOException {
     OpenFilePOptions options =
         OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
-    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options), mContext);
+    mTestStream = new FileInStream(mStatus, new InStreamOptions(mStatus, options,
+        mConf), mContext, mConf);
     int seekAmount = (int) (BLOCK_LENGTH / 4 + BLOCK_LENGTH);
 
     // Seek forward.
diff --git a/core/client/fs/src/test/java/alluxio/client/file/FileOutStreamTest.java b/core/client/fs/src/test/java/alluxio/client/file/FileOutStreamTest.java
index d167109aea..3837601d29 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/FileOutStreamTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/FileOutStreamTest.java
@@ -37,6 +37,7 @@ import alluxio.client.block.stream.UnderFileSystemFileOutStream;
 import alluxio.client.file.options.OutStreamOptions;
 import alluxio.client.file.policy.FileWriteLocationPolicy;
 import alluxio.client.util.ClientTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.PreconditionMessage;
 import alluxio.exception.status.UnavailableException;
@@ -76,8 +77,11 @@ import java.util.concurrent.atomic.AtomicBoolean;
 @PrepareForTest({FileSystemContext.class, FileSystemMasterClient.class, AlluxioBlockStore.class,
     UnderFileSystemFileOutStream.class})
 public class FileOutStreamTest {
+
+  private InstancedConfiguration sConf = ConfigurationTestUtils.defaults();
+
   @Rule
-  public LoginUserRule mLoginUser = new LoginUserRule("Test");
+  public LoginUserRule mLoginUser = new LoginUserRule("Test", sConf);
 
   @Rule
   public ExpectedException mException = ExpectedException.none();
@@ -101,7 +105,7 @@ public class FileOutStreamTest {
   @Before
   public void before() throws Exception {
     GroupMappingServiceTestUtils.resetCache();
-    ClientTestUtils.setSmallBufferSizes();
+    ClientTestUtils.setSmallBufferSizes(sConf);
 
     // PowerMock enums and final classes
     mFileSystemContext = PowerMockito.mock(FileSystemContext.class);
@@ -109,7 +113,7 @@ public class FileOutStreamTest {
     mFileSystemMasterClient = PowerMockito.mock(FileSystemMasterClient.class);
 
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    PowerMockito.when(AlluxioBlockStore.create(mFileSystemContext)).thenReturn(mBlockStore);
+    PowerMockito.when(AlluxioBlockStore.create(mFileSystemContext, sConf)).thenReturn(mBlockStore);
 
     when(mFileSystemContext.acquireMasterClientResource())
         .thenReturn(new DummyCloseableResource<>(mFileSystemMasterClient));
@@ -144,7 +148,7 @@ public class FileOutStreamTest {
         });
     BlockWorkerInfo workerInfo =
         new BlockWorkerInfo(new WorkerNetAddress().setHost("localhost")
-            .setTieredIdentity(TieredIdentityFactory.fromString("node=localhost"))
+            .setTieredIdentity(TieredIdentityFactory.fromString("node=localhost", sConf))
             .setRpcPort(1).setDataPort(2).setWebPort(3), Constants.GB, 0);
     when(mBlockStore.getEligibleWorkers()).thenReturn(Lists.newArrayList(workerInfo));
     mAlluxioOutStreamMap = outStreamMap;
@@ -164,18 +168,18 @@ public class FileOutStreamTest {
     PowerMockito.mockStatic(UnderFileSystemFileOutStream.class);
     PowerMockito.when(
         UnderFileSystemFileOutStream.create(any(FileSystemContext.class),
-            any(WorkerNetAddress.class), any(OutStreamOptions.class))).thenReturn(
+            any(WorkerNetAddress.class), any(OutStreamOptions.class),
+            any(InstancedConfiguration.class))).thenReturn(
         mUnderStorageOutputStream);
 
-    OutStreamOptions options = OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+    OutStreamOptions options = OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
         .setWriteType(WriteType.CACHE_THROUGH).setUfsPath(FILE_NAME.getPath());
     mTestStream = createTestStream(FILE_NAME, options);
   }
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
-    ClientTestUtils.resetClient();
+    ClientTestUtils.resetClient(sConf);
   }
 
   /**
@@ -276,7 +280,7 @@ public class FileOutStreamTest {
   @Test
   public void cacheWriteExceptionNonSyncPersist() throws IOException {
     OutStreamOptions options =
-        OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+        OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
             .setWriteType(WriteType.MUST_CACHE);
     BlockOutStream stream = mock(BlockOutStream.class);
     when(mBlockStore.getOutStream(anyInt(), anyLong(), any(OutStreamOptions.class)))
@@ -372,7 +376,7 @@ public class FileOutStreamTest {
   @Test
   public void asyncWrite() throws Exception {
     OutStreamOptions options =
-        OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH)
+        OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH)
             .setWriteType(WriteType.ASYNC_THROUGH);
     mTestStream = createTestStream(FILE_NAME, options);
 
@@ -390,7 +394,7 @@ public class FileOutStreamTest {
   public void getBytesWrittenWithDifferentUnderStorageType() throws IOException {
     for (WriteType type : WriteType.values()) {
       OutStreamOptions options =
-          OutStreamOptions.defaults().setBlockSizeBytes(BLOCK_LENGTH).setWriteType(type)
+          OutStreamOptions.defaults(sConf).setBlockSizeBytes(BLOCK_LENGTH).setWriteType(type)
               .setUfsPath(FILE_NAME.getPath());
       mTestStream = createTestStream(FILE_NAME, options);
       mTestStream.write(BufferUtils.getIncreasingByteArray((int) BLOCK_LENGTH));
@@ -402,7 +406,7 @@ public class FileOutStreamTest {
   @Test
   public void createWithNoWorker() throws Exception {
     OutStreamOptions options =
-        OutStreamOptions.defaults().setLocationPolicy(new FileWriteLocationPolicy() {
+        OutStreamOptions.defaults(sConf).setLocationPolicy(new FileWriteLocationPolicy() {
           @Override
           public WorkerNetAddress getWorkerForNextBlock(Iterable<BlockWorkerInfo> workerInfoList,
               long blockSizeBytes) {
@@ -451,6 +455,6 @@ public class FileOutStreamTest {
    */
   private FileOutStream createTestStream(AlluxioURI path, OutStreamOptions options)
       throws IOException {
-    return new FileOutStream(path, options, mFileSystemContext);
+    return new FileOutStream(path, options, mFileSystemContext, sConf);
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/file/FileSystemContextTest.java b/core/client/fs/src/test/java/alluxio/client/file/FileSystemContextTest.java
index 04130af12b..8ea2b751f8 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/FileSystemContextTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/FileSystemContextTest.java
@@ -15,11 +15,14 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;
 
-import alluxio.Configuration;
+import alluxio.ClientContext;
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 import javax.security.auth.Subject;
@@ -30,6 +33,14 @@ import java.util.List;
  * Tests {@link FileSystemContext}.
  */
 public final class FileSystemContextTest {
+
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+
+  @Before
+  public void before() {
+    mConf = ConfigurationTestUtils.defaults();
+  }
+
   /**
    * This test ensures acquiring all the available FileSystem master clients blocks further
    * requests for clients. It also ensures clients are available for reuse after they are released
@@ -41,10 +52,12 @@ public final class FileSystemContextTest {
     final List<FileSystemMasterClient> clients = new ArrayList<>();
 
     // Acquire all the clients
-    for (int i = 0; i < Configuration.getInt(PropertyKey.USER_FILE_MASTER_CLIENT_THREADS); i++) {
-      clients.add(FileSystemContext.get().acquireMasterClient());
+    FileSystemContext fsContext = FileSystemContext.create(
+        ClientContext.create(mConf.getProperties()));
+    for (int i = 0; i < mConf.getInt(PropertyKey.USER_FILE_MASTER_CLIENT_THREADS); i++) {
+      clients.add(fsContext.acquireMasterClient());
     }
-    Thread acquireThread = new Thread(new AcquireClient());
+    Thread acquireThread = new Thread(new AcquireClient(fsContext));
     acquireThread.start();
 
     // Wait for the spawned thread to complete. If it is able to acquire a master client before
@@ -58,7 +71,7 @@ public final class FileSystemContextTest {
 
     // Release all the clients
     for (FileSystemMasterClient client : clients) {
-      FileSystemContext.get().releaseMasterClient(client);
+      fsContext.releaseMasterClient(client);
     }
 
     // Wait for the spawned thread to complete. If it is unable to acquire a master client before
@@ -71,42 +84,17 @@ public final class FileSystemContextTest {
     }
   }
 
-  @Test
-  public void getCache() throws Exception {
-    FileSystemContext ctx1 = FileSystemContext.get();
-    FileSystemContext ctx2 = FileSystemContext.get();
-    assertEquals(ctx1, ctx2);
-  }
-
-  @Test
-  public void getDifferentSubjects() throws Exception {
-    Subject sub = new Subject();
-    FileSystemContext ctx1 = FileSystemContext.get();
-    FileSystemContext ctx2 = FileSystemContext.get(sub);
-    FileSystemContext ctx3 = FileSystemContext.get(sub);
-    assertNotSame(ctx1, ctx2);
-    assertSame(ctx2, ctx3);
-  }
+  class AcquireClient implements Runnable {
+    private final FileSystemContext mFsCtx;
+    public AcquireClient(FileSystemContext fsContext) {
+      mFsCtx = fsContext;
+    }
 
-  @Test
-  public void refCount() throws Exception {
-    FileSystemContext ctx1 = FileSystemContext.get();
-    FileSystemContext ctx2 = FileSystemContext.get();
-    ctx1.close();
-    FileSystemContext ctx3 = FileSystemContext.get();
-    assertSame(ctx1, ctx3); // Same context
-    assertSame(ctx2, ctx3); // Same context
-    ctx2.close();
-    ctx3.close(); // All references closed, so context should be destroyed
-    FileSystemContext ctx4 = FileSystemContext.get();
-    assertNotSame(ctx1, ctx4); // Different context
-  }
 
-  class AcquireClient implements Runnable {
     @Override
     public void run() {
-      FileSystemMasterClient client = FileSystemContext.get().acquireMasterClient();
-      FileSystemContext.get().releaseMasterClient(client);
+      FileSystemMasterClient client = mFsCtx.acquireMasterClient();
+      mFsCtx.releaseMasterClient(client);
     }
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/file/FileSystemMasterClientPoolTest.java b/core/client/fs/src/test/java/alluxio/client/file/FileSystemMasterClientPoolTest.java
index 671456a90f..115e28a404 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/FileSystemMasterClientPoolTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/FileSystemMasterClientPoolTest.java
@@ -13,6 +13,10 @@ package alluxio.client.file;
 
 import static org.junit.Assert.assertEquals;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.master.MasterClientConfig;
 
 import org.junit.Test;
@@ -27,13 +31,14 @@ import org.powermock.modules.junit4.PowerMockRunner;
 public class FileSystemMasterClientPoolTest {
   @Test
   public void create() throws Exception {
+    AlluxioConfiguration conf = ConfigurationTestUtils.defaults();
     FileSystemMasterClient expectedClient = Mockito.mock(FileSystemMasterClient.class);
     PowerMockito.mockStatic(FileSystemMasterClient.Factory.class);
     Mockito.when(FileSystemMasterClient.Factory
-        .create(Mockito.any(MasterClientConfig.class)))
+        .create(Mockito.any(MasterClientConfig.class), Mockito.any(InstancedConfiguration.class)))
         .thenReturn(expectedClient);
     FileSystemMasterClient client;
-    try (FileSystemMasterClientPool pool = new FileSystemMasterClientPool(null, null)) {
+    try (FileSystemMasterClientPool pool = new FileSystemMasterClientPool(null, null, conf)) {
       client = pool.acquire();
       assertEquals(expectedClient, client);
       pool.release(client);
diff --git a/core/client/fs/src/test/java/alluxio/client/file/MockFileInStream.java b/core/client/fs/src/test/java/alluxio/client/file/MockFileInStream.java
index d74485c7a9..3370f4a21d 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/MockFileInStream.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/MockFileInStream.java
@@ -11,7 +11,10 @@
 
 package alluxio.client.file;
 
+import alluxio.client.ReadType;
 import alluxio.client.file.options.InStreamOptions;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.wire.FileInfo;
 
 import java.io.ByteArrayInputStream;
@@ -29,9 +32,9 @@ public final class MockFileInStream extends FileInStream {
    * @param context file system context
    * @param bytes the bytes to supply
    */
-  public MockFileInStream(FileSystemContext context, byte[] bytes) {
-    super(new URIStatus(new FileInfo()), new InStreamOptions(new URIStatus(new FileInfo())),
-        context);
+  public MockFileInStream(FileSystemContext context, byte[] bytes, AlluxioConfiguration conf) {
+    super(new URIStatus(new FileInfo()), new InStreamOptions(new URIStatus(new FileInfo()),
+        conf), context, conf);
     mStream = new ByteArrayInputStream(bytes);
   }
 
diff --git a/core/client/fs/src/test/java/alluxio/client/file/MockFileOutStream.java b/core/client/fs/src/test/java/alluxio/client/file/MockFileOutStream.java
index 728f6d0ab3..64ff902efe 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/MockFileOutStream.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/MockFileOutStream.java
@@ -13,6 +13,7 @@ package alluxio.client.file;
 
 import alluxio.AlluxioURI;
 import alluxio.client.file.options.OutStreamOptions;
+import alluxio.conf.AlluxioConfiguration;
 
 import java.io.ByteArrayOutputStream;
 import java.io.FileOutputStream;
@@ -28,8 +29,8 @@ public final class MockFileOutStream extends FileOutStream {
    * Creates a mock {@link FileOutputStream} which will store any bytes written to it for later
    * inspection during tests.
    */
-  public MockFileOutStream() throws IOException {
-    super(new AlluxioURI("/"), OutStreamOptions.defaults(), FileSystemContext.get());
+  public MockFileOutStream(AlluxioConfiguration conf) throws IOException {
+    super(new AlluxioURI("/"), OutStreamOptions.defaults(conf), FileSystemContext.create(), conf);
     mStream = new ByteArrayOutputStream();
   }
 
diff --git a/core/client/fs/src/test/java/alluxio/client/file/options/OutStreamOptionsTest.java b/core/client/fs/src/test/java/alluxio/client/file/options/OutStreamOptionsTest.java
index bdde858ef0..5945e08e78 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/options/OutStreamOptionsTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/options/OutStreamOptionsTest.java
@@ -14,12 +14,13 @@ package alluxio.client.file.options;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationRule;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.LoginUserRule;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.AlluxioStorageType;
 import alluxio.client.UnderStorageType;
 import alluxio.client.WriteType;
@@ -34,6 +35,8 @@ import alluxio.util.ModeUtils;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
+import org.junit.After;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
@@ -45,6 +48,9 @@ import java.util.Random;
  * Tests for the {@link OutStreamOptions} class.
  */
 public class OutStreamOptionsTest {
+
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+
   /**
    * A mapping from a user to its corresponding group.
    */
@@ -62,10 +68,15 @@ public class OutStreamOptionsTest {
   @Rule
   public ConfigurationRule mConfiguration = new ConfigurationRule(ImmutableMap.of(
       PropertyKey.SECURITY_GROUP_MAPPING_CLASS, FakeUserGroupsMapping.class.getName()
-  ));
+  ), mConf);
 
   @Rule
-  public LoginUserRule mRule = new LoginUserRule("test_user");
+  public LoginUserRule mRule = new LoginUserRule("test_user", mConf);
+
+  @After
+  public void before(){
+    mConf = ConfigurationTestUtils.defaults();
+  }
 
   /**
    * Tests that building an {@link OutStreamOptions} with the defaults works.
@@ -74,24 +85,24 @@ public class OutStreamOptionsTest {
   public void defaults() throws IOException {
     AlluxioStorageType alluxioType = AlluxioStorageType.STORE;
     UnderStorageType ufsType = UnderStorageType.SYNC_PERSIST;
-    Configuration.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, "64MB");
-    Configuration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.CACHE_THROUGH.toString());
-    Configuration.set(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT, Constants.LAST_TIER);
+    mConf.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, "64MB");
+    mConf.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.CACHE_THROUGH.toString());
+    mConf.set(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT, Constants.LAST_TIER);
 
-    OutStreamOptions options = OutStreamOptions.defaults();
+    OutStreamOptions options = OutStreamOptions.defaults(mConf);
 
     assertEquals(alluxioType, options.getAlluxioStorageType());
     assertEquals(64 * Constants.MB, options.getBlockSizeBytes());
     assertTrue(options.getLocationPolicy() instanceof LocalFirstPolicy);
     assertEquals("test_user", options.getOwner());
     assertEquals("test_group", options.getGroup());
-    assertEquals(ModeUtils.applyFileUMask(Mode.defaults()), options.getMode());
+    assertEquals(ModeUtils.applyFileUMask(Mode.defaults(),
+        mConf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)), options.getMode());
     assertEquals(Constants.NO_TTL, options.getTtl());
     assertEquals(TtlAction.DELETE, options.getTtlAction());
     assertEquals(ufsType, options.getUnderStorageType());
     assertEquals(WriteType.CACHE_THROUGH, options.getWriteType());
     assertEquals(Constants.LAST_TIER, options.getWriteTier());
-    ConfigurationTestUtils.resetConfiguration();
   }
 
   /**
@@ -101,7 +112,7 @@ public class OutStreamOptionsTest {
   public void fields() throws Exception {
     Random random = new Random();
     long blockSize = random.nextLong();
-    FileWriteLocationPolicy locationPolicy = new RoundRobinPolicy();
+    FileWriteLocationPolicy locationPolicy = new RoundRobinPolicy(mConf);
     String owner = CommonUtils.randomAlphaNumString(10);
     String group = CommonUtils.randomAlphaNumString(10);
     Mode mode = new Mode((short) random.nextInt());
@@ -109,7 +120,7 @@ public class OutStreamOptionsTest {
     int writeTier = random.nextInt();
     WriteType writeType = WriteType.NONE;
 
-    OutStreamOptions options = OutStreamOptions.defaults();
+    OutStreamOptions options = OutStreamOptions.defaults(mConf);
     options.setBlockSizeBytes(blockSize);
     options.setLocationPolicy(locationPolicy);
     options.setOwner(owner);
@@ -134,6 +145,11 @@ public class OutStreamOptionsTest {
 
   @Test
   public void equalsTest() throws Exception {
-    alluxio.test.util.CommonUtils.testEquals(OutStreamOptions.class);
+    OutStreamOptions o1 = OutStreamOptions.defaults(mConf);
+    OutStreamOptions o2 = OutStreamOptions.defaults(mConf);
+    assertEquals(o1, o2);
+    assertEquals(o1.hashCode(), o2.hashCode());
+//    alluxio.test.util.CommonUtils.testEquals(OutStreamOptions.class, new Class[]{
+//        AlluxioConfiguration.class}, new Object[]{mConf});
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicyTest.java b/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicyTest.java
index 051f062ee5..a18924af1f 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicyTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstAvoidEvictionPolicyTest.java
@@ -13,10 +13,11 @@ package alluxio.client.file.policy;
 
 import static org.junit.Assert.assertEquals;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.client.block.BlockWorkerInfo;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.network.TieredIdentityFactory;
-import alluxio.test.util.CommonUtils;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.wire.TieredIdentity;
 import alluxio.wire.TieredIdentity.LocalityTier;
@@ -33,6 +34,8 @@ import java.util.List;
  */
 public class LocalFirstAvoidEvictionPolicyTest {
 
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+
   @Test
   public void chooseClosestTierAvoidEviction() throws Exception {
     List<BlockWorkerInfo> workers = new ArrayList<>();
@@ -43,7 +46,7 @@ public class LocalFirstAvoidEvictionPolicyTest {
     WorkerNetAddress chosen;
     // local rack with enough availability
     policy = new LocalFirstAvoidEvictionPolicy(
-        TieredIdentityFactory.fromString("node=node2,rack=rack3"));
+        TieredIdentityFactory.fromString("node=node2,rack=rack3", mConf), mConf);
     chosen = policy.getWorkerForNextBlock(workers, Constants.GB);
     assertEquals("node4", chosen.getTieredIdentity().getTier(0).getValue());
   }
@@ -53,8 +56,8 @@ public class LocalFirstAvoidEvictionPolicyTest {
    */
   @Test
   public void getOthersWhenNotEnoughAvailabilityOnLocal() {
-    String localhostName = NetworkAddressUtils.getLocalHostName();
-    FileWriteLocationPolicy policy = new LocalFirstAvoidEvictionPolicy();
+    String localhostName = NetworkAddressUtils.getLocalHostName(1000);
+    FileWriteLocationPolicy policy = new LocalFirstAvoidEvictionPolicy(mConf);
     List<BlockWorkerInfo> workers = new ArrayList<>();
     workers.add(worker(Constants.GB, 0, "worker1", ""));
     workers.add(worker(Constants.MB, Constants.MB, localhostName, ""));
@@ -66,8 +69,8 @@ public class LocalFirstAvoidEvictionPolicyTest {
    */
   @Test
   public void getLocalWhenNoneHasAvailability() {
-    String localhostName = NetworkAddressUtils.getLocalHostName();
-    FileWriteLocationPolicy policy = new LocalFirstAvoidEvictionPolicy();
+    String localhostName = NetworkAddressUtils.getLocalHostName(1000);
+    FileWriteLocationPolicy policy = new LocalFirstAvoidEvictionPolicy(mConf);
     List<BlockWorkerInfo> workers = new ArrayList<>();
     workers.add(worker(Constants.GB, Constants.MB, "worker1", ""));
     workers.add(worker(Constants.GB, Constants.MB, localhostName, ""));
@@ -77,7 +80,13 @@ public class LocalFirstAvoidEvictionPolicyTest {
 
   @Test
   public void equalsTest() throws Exception {
-    CommonUtils.testEquals(LocalFirstAvoidEvictionPolicy.class);
+    LocalFirstAvoidEvictionPolicy p1 = new LocalFirstAvoidEvictionPolicy(mConf);
+    LocalFirstAvoidEvictionPolicy p2 = new LocalFirstAvoidEvictionPolicy(mConf);
+    assertEquals(p1, p2);
+    assertEquals(p1.hashCode(), p2.hashCode());
+//    CommonUtils.testEquals(LocalFirstAvoidEvictionPolicy.class,
+//        new Class[] {AlluxioConfiguration.class}, new Object[]{mConf},
+//        "mFileWriteCapacityReserved");
   }
 
   private BlockWorkerInfo worker(long capacity, long used, String node, String rack) {
diff --git a/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstPolicyTest.java b/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstPolicyTest.java
index 48d5df4132..cac4d3ecae 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstPolicyTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/policy/LocalFirstPolicyTest.java
@@ -13,8 +13,11 @@ package alluxio.client.file.policy;
 
 import static org.junit.Assert.assertEquals;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.client.block.BlockWorkerInfo;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.network.TieredIdentityFactory;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.wire.TieredIdentity;
@@ -33,13 +36,19 @@ import java.util.List;
  */
 public final class LocalFirstPolicyTest {
 
+  private static InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+  private static int sResolutionTimeout =
+      (int)mConf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
+
+
   /**
    * Tests that the local host is returned first.
    */
   @Test
   public void getLocalFirst() {
-    String localhostName = NetworkAddressUtils.getLocalHostName();
-    LocalFirstPolicy policy = new LocalFirstPolicy();
+    String localhostName =
+        NetworkAddressUtils.getLocalHostName(sResolutionTimeout);
+    LocalFirstPolicy policy = new LocalFirstPolicy(mConf);
     List<BlockWorkerInfo> workers = new ArrayList<>();
     workers.add(worker(Constants.GB, "worker1", ""));
     workers.add(worker(Constants.GB, localhostName, ""));
@@ -51,8 +60,8 @@ public final class LocalFirstPolicyTest {
    */
   @Test
   public void getOthersWhenNotEnoughCapacityOnLocal() {
-    String localhostName = NetworkAddressUtils.getLocalHostName();
-    LocalFirstPolicy policy = new LocalFirstPolicy();
+    String localhostName = NetworkAddressUtils.getLocalHostName(sResolutionTimeout);
+    LocalFirstPolicy policy = new LocalFirstPolicy(mConf);
     List<BlockWorkerInfo> workers = new ArrayList<>();
     workers.add(worker(Constants.GB, "worker1", ""));
     workers.add(worker(Constants.MB, localhostName, ""));
@@ -64,7 +73,7 @@ public final class LocalFirstPolicyTest {
    */
   @Test
   public void getOthersRandomly() {
-    LocalFirstPolicy policy = new LocalFirstPolicy();
+    LocalFirstPolicy policy = new LocalFirstPolicy(mConf);
     List<BlockWorkerInfo> workers = new ArrayList<>();
     workers.add(worker(Constants.GB, "worker1", ""));
     workers.add(worker(Constants.GB, "worker2", ""));
@@ -89,12 +98,14 @@ public final class LocalFirstPolicyTest {
     LocalFirstPolicy policy;
     WorkerNetAddress chosen;
     // local rack
-    policy = LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=node1,rack=rack2"));
+    policy = LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=node1,rack=rack2",
+        mConf), mConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP));
     chosen = policy.getWorkerForNextBlock(workers, Constants.GB);
     assertEquals("rack2", chosen.getTieredIdentity().getTier(1).getValue());
 
     // local node
-    policy = LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=node4,rack=rack3"));
+    policy = LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=node4,rack=rack3", mConf),
+        mConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP));
     chosen = policy.getWorkerForNextBlock(workers, Constants.GB);
     assertEquals("node4", chosen.getTieredIdentity().getTier(0).getValue());
   }
@@ -108,7 +119,8 @@ public final class LocalFirstPolicyTest {
     // Local rack has enough space
     workers.add(worker(Constants.GB, "node4", "rack3"));
     LocalFirstPolicy policy =
-        LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=node2,rack=rack3"));
+        LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=node2,rack=rack3", mConf),
+            mConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP));
     WorkerNetAddress chosen = policy.getWorkerForNextBlock(workers, Constants.GB);
     assertEquals(workers.get(2).getNetAddress(), chosen);
   }
@@ -117,9 +129,11 @@ public final class LocalFirstPolicyTest {
   public void equalsTest() throws Exception {
     new EqualsTester()
         .addEqualityGroup(
-            LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=x,rack=y")))
+            LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=x,rack=y", mConf),
+                mConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP)))
         .addEqualityGroup(
-            LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=x,rack=z")))
+            LocalFirstPolicy.create(TieredIdentityFactory.fromString("node=x,rack=z", mConf),
+                mConf.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP)))
         .testEquals();
   }
 
diff --git a/core/client/fs/src/test/java/alluxio/client/file/policy/MostAvailableFirstPolicyTest.java b/core/client/fs/src/test/java/alluxio/client/file/policy/MostAvailableFirstPolicyTest.java
index 748d3d3275..2f1dd2287a 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/policy/MostAvailableFirstPolicyTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/policy/MostAvailableFirstPolicyTest.java
@@ -11,8 +11,10 @@
 
 package alluxio.client.file.policy;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.client.block.BlockWorkerInfo;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.test.util.CommonUtils;
 import alluxio.wire.WorkerNetAddress;
 
@@ -40,13 +42,14 @@ public final class MostAvailableFirstPolicyTest {
         .setRpcPort(PORT).setDataPort(PORT).setWebPort(PORT), 2 * (long) Constants.GB, 0));
     workerInfoList.add(new BlockWorkerInfo(new WorkerNetAddress().setHost("worker3")
         .setRpcPort(PORT).setDataPort(PORT).setWebPort(PORT), 3 * (long) Constants.GB, 0));
-    MostAvailableFirstPolicy policy = new MostAvailableFirstPolicy();
+    MostAvailableFirstPolicy policy = new MostAvailableFirstPolicy(ConfigurationTestUtils.defaults());
     Assert.assertEquals("worker3",
         policy.getWorkerForNextBlock(workerInfoList, Constants.MB).getHost());
   }
 
   @Test
   public void equalsTest() throws Exception {
-    CommonUtils.testEquals(MostAvailableFirstPolicy.class);
+    CommonUtils.testEquals(MostAvailableFirstPolicy.class,
+        new Class[]{AlluxioConfiguration.class}, new Object[]{ConfigurationTestUtils.defaults()});
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/file/policy/RoundRobinPolicyTest.java b/core/client/fs/src/test/java/alluxio/client/file/policy/RoundRobinPolicyTest.java
index 4aba7a1e4b..f6bebdc4f0 100644
--- a/core/client/fs/src/test/java/alluxio/client/file/policy/RoundRobinPolicyTest.java
+++ b/core/client/fs/src/test/java/alluxio/client/file/policy/RoundRobinPolicyTest.java
@@ -11,8 +11,10 @@
 
 package alluxio.client.file.policy;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.client.block.BlockWorkerInfo;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.test.util.CommonUtils;
 import alluxio.wire.WorkerNetAddress;
 
@@ -40,7 +42,7 @@ public final class RoundRobinPolicyTest {
         .setRpcPort(PORT).setDataPort(PORT).setWebPort(PORT), 2 * (long) Constants.GB, 0));
     workerInfoList.add(new BlockWorkerInfo(new WorkerNetAddress().setHost("worker3")
         .setRpcPort(PORT).setDataPort(PORT).setWebPort(PORT), 3 * (long) Constants.GB, 0));
-    RoundRobinPolicy policy = new RoundRobinPolicy();
+    RoundRobinPolicy policy = new RoundRobinPolicy(ConfigurationTestUtils.defaults());
 
     Assert.assertNotEquals(
         policy.getWorkerForNextBlock(workerInfoList, 2 * (long) Constants.GB).getHost(),
@@ -49,6 +51,8 @@ public final class RoundRobinPolicyTest {
 
   @Test
   public void equalsTest() throws Exception {
-    CommonUtils.testEquals(RoundRobinPolicy.class);
+    AlluxioConfiguration conf = ConfigurationTestUtils.defaults();
+    CommonUtils.testEquals(RoundRobinPolicy.class, new Class[]{AlluxioConfiguration.class},
+        new Object[]{conf});
   }
 }
diff --git a/core/client/fs/src/test/java/alluxio/client/util/ClientTestUtils.java b/core/client/fs/src/test/java/alluxio/client/util/ClientTestUtils.java
index 6b6e34911b..bd6f0801ff 100644
--- a/core/client/fs/src/test/java/alluxio/client/util/ClientTestUtils.java
+++ b/core/client/fs/src/test/java/alluxio/client/util/ClientTestUtils.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.util;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemContext;
 
 import java.io.IOException;
@@ -25,9 +25,9 @@ public final class ClientTestUtils {
   /**
    * Sets small buffer sizes so that Alluxio does not run out of heap space.
    */
-  public static void setSmallBufferSizes() {
-    Configuration.set(PropertyKey.USER_BLOCK_REMOTE_READ_BUFFER_SIZE_BYTES, "4KB");
-    Configuration.set(PropertyKey.USER_FILE_BUFFER_BYTES, "4KB");
+  public static void setSmallBufferSizes(InstancedConfiguration conf) {
+    conf.set(PropertyKey.USER_BLOCK_REMOTE_READ_BUFFER_SIZE_BYTES, "4KB");
+    conf.set(PropertyKey.USER_FILE_BUFFER_BYTES, "4KB");
   }
 
   /**
@@ -35,16 +35,16 @@ public final class ClientTestUtils {
    *
    * This method should only be used as a cleanup mechanism between tests.
    */
-  public static void resetClient() {
+  public static void resetClient(InstancedConfiguration conf) {
     try {
-      resetContexts();
+      resetContexts(conf);
     } catch (Exception e) {
       throw new RuntimeException(e);
     }
   }
 
-  private static void resetContexts() throws IOException {
-    Configuration.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
-    FileSystemContext.get().reset(Configuration.global());
+  private static void resetContexts(InstancedConfiguration conf) throws IOException {
+    conf.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
+    FileSystemContext.create().reset();
   }
 }
diff --git a/core/client/hdfs/src/main/java/alluxio/hadoop/AbstractFileSystem.java b/core/client/hdfs/src/main/java/alluxio/hadoop/AbstractFileSystem.java
index a0459b689b..0af9152aab 100644
--- a/core/client/hdfs/src/main/java/alluxio/hadoop/AbstractFileSystem.java
+++ b/core/client/hdfs/src/main/java/alluxio/hadoop/AbstractFileSystem.java
@@ -14,17 +14,17 @@ package alluxio.hadoop;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toMap;
 
-import alluxio.AlluxioConfiguration;
+import alluxio.ClientContext;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioProperties;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
-import alluxio.conf.InstancedConfiguration;
 import alluxio.conf.Source;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
@@ -99,7 +99,8 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
   @GuardedBy("INIT_LOCK")
   private static volatile boolean sInitialized = false;
 
-  private FileSystemContext mContext = null;
+  protected ClientContext mClientContext = null;
+  private FileSystemContext mFsContext = null;
   private FileSystem mFileSystem = null;
 
   private URI mUri = null;
@@ -151,8 +152,8 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
     // org.apache.hadoop.fs.FileSystem.close may check the existence of certain temp files before
     // closing
     super.close();
-    if (mContext != null) {
-      mContext.close();
+    if (mFsContext != null) {
+      mFsContext.close();
     }
   }
 
@@ -273,7 +274,7 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
 
   @Override
   public long getDefaultBlockSize() {
-    return Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+    return mClientContext.getConfiguration().getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
   }
 
   @Nullable
@@ -306,7 +307,7 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
                 location -> finalWorkerHosts.get(HostAndPort.fromString(location).getHost()))
                 .filter(Objects::nonNull).collect(toList());
           }
-          if (locations.isEmpty() && Configuration
+          if (locations.isEmpty() && mClientContext.getConfiguration()
               .getBoolean(PropertyKey.USER_UFS_BLOCK_LOCATION_ALL_FALLBACK_ENABLED)) {
             // Case 2: Fallback to add all workers to locations so some apps (Impala) won't panic.
             locations.addAll(getHostToWorkerMap().values());
@@ -502,7 +503,7 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
       if (sInitialized) {
         if (!connectDetailsMatch(uriConfProperties, conf)) {
           LOG.warn(ExceptionMessage.DIFFERENT_CONNECTION_DETAILS.getMessage(
-              FileSystemContext.get().getMasterInquireClient().getConnectDetails()));
+              FileSystemContext.create().getMasterInquireClient().getConnectDetails()));
           initializeInternal(uriConfProperties, conf);
         }
       } else {
@@ -527,15 +528,17 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
     // Load Alluxio configuration if any and merge to the one in Alluxio file system. These
     // modifications to ClientContext are global, affecting all Alluxio clients in this JVM.
     // We assume here that all clients use the same configuration.
-    HadoopConfigurationUtils.mergeHadoopConfiguration(conf, Configuration.global());
+    AlluxioConfiguration alluxioConf = HadoopConfigurationUtils.mergeHadoopConfiguration(conf, mClientContext.getConfiguration());
 
     // Connection details in the URI has the highest priority
-    Configuration.global().merge(uriConfProperties, Source.RUNTIME);
+    AlluxioProperties props = alluxioConf.getProperties();
+    props.merge(uriConfProperties, Source.RUNTIME);
+    mClientContext = ClientContext.create(mClientContext.getSubject(), props);
 
     // This must be reset to pick up the change to the master address.
     LOG.info("Initializing filesystem context with connect details {}",
-        Factory.getConnectDetails(Configuration.global()));
-    FileSystemContext.get().reset(Configuration.global());
+        Factory.getConnectDetails(mClientContext.getConfiguration()));
+    FileSystemContext.create().reset();
   }
 
   /**
@@ -584,16 +587,16 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
    */
   private boolean connectDetailsMatch(Map<String, Object> uriConfProperties,
       org.apache.hadoop.conf.Configuration conf) {
-    AlluxioConfiguration alluxioConf = new InstancedConfiguration(Configuration.global());
-
     // Merge hadoop configuration into Alluxio configuration
-    HadoopConfigurationUtils.mergeHadoopConfiguration(conf, alluxioConf);
+    AlluxioConfiguration alluxioConf = HadoopConfigurationUtils.mergeHadoopConfiguration(conf,
+        mClientContext.getConfiguration());
 
     // Merge connection details in URI into Alluxio configuration
-    alluxioConf.merge(uriConfProperties, Source.RUNTIME);
+    AlluxioProperties props = alluxioConf.getProperties();
+    props.merge(uriConfProperties, Source.RUNTIME);
 
     ConnectDetails newDetails = Factory.getConnectDetails(alluxioConf);
-    ConnectDetails oldDetails = FileSystemContext.get()
+    ConnectDetails oldDetails = FileSystemContext.create()
         .getMasterInquireClient().getConnectDetails();
 
     return newDetails.equals(oldDetails);
@@ -605,14 +608,16 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
    */
   private void updateFileSystemAndContext() {
     Subject subject = getHadoopSubject();
+    mClientContext = ClientContext.create(subject,
+        mClientContext.getConfiguration().getProperties());
     if (subject != null) {
       LOG.debug("Using Hadoop subject: {}", subject);
-      mContext = FileSystemContext.get(subject);
-      mFileSystem = FileSystem.Factory.get(mContext);
+      mFsContext = FileSystemContext.create(subject, mClientContext.mConf);
+      mFileSystem = FileSystem.Factory.get(mClientContext);
     } else {
       LOG.debug("No Hadoop subject. Using FileSystem Context without subject.");
-      mContext = FileSystemContext.get();
-      mFileSystem = FileSystem.Factory.get(mContext);
+      mFsContext = FileSystemContext.create(null, mClientContext.mConf);
+      mFileSystem = FileSystem.Factory.get(mClientContext);
     }
   }
 
@@ -719,7 +724,8 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
     }
 
     AlluxioURI uri = new AlluxioURI(HadoopUtils.getPathWithoutScheme(path));
-    return new FSDataInputStream(new HdfsFileInputStream(mContext, uri, mStatistics));
+    return new FSDataInputStream(new HdfsFileInputStream(mFsContext, uri, mStatistics,
+        mClientContext.getConfiguration()));
   }
 
   @Override
@@ -798,7 +804,8 @@ abstract class AbstractFileSystem extends org.apache.hadoop.fs.FileSystem {
   }
 
   private Map<String, WorkerNetAddress> getHostToWorkerMap() throws IOException {
-    List<BlockWorkerInfo> workers = AlluxioBlockStore.create(mContext).getEligibleWorkers();
+    List<BlockWorkerInfo> workers =
+        AlluxioBlockStore.create(mFsContext, mClientContext.getConfiguration()).getEligibleWorkers();
     return workers.stream().collect(
         toMap(worker -> worker.getNetAddress().getHost(), BlockWorkerInfo::getNetAddress,
             (worker1, worker2) -> worker1));
diff --git a/core/client/hdfs/src/main/java/alluxio/hadoop/AlluxioFileSystem.java b/core/client/hdfs/src/main/java/alluxio/hadoop/AlluxioFileSystem.java
index f8ce0e6325..f7217c03dd 100644
--- a/core/client/hdfs/src/main/java/alluxio/hadoop/AlluxioFileSystem.java
+++ b/core/client/hdfs/src/main/java/alluxio/hadoop/AlluxioFileSystem.java
@@ -12,7 +12,7 @@
 package alluxio.hadoop;
 
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.DelegateToFileSystem;
diff --git a/core/client/hdfs/src/main/java/alluxio/hadoop/FileSystem.java b/core/client/hdfs/src/main/java/alluxio/hadoop/FileSystem.java
index 3de8da91b0..1349c2af84 100644
--- a/core/client/hdfs/src/main/java/alluxio/hadoop/FileSystem.java
+++ b/core/client/hdfs/src/main/java/alluxio/hadoop/FileSystem.java
@@ -11,9 +11,8 @@
 
 package alluxio.hadoop;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 
 import javax.annotation.concurrent.NotThreadSafe;
@@ -51,6 +50,6 @@ public final class FileSystem extends AbstractFileSystem {
 
   @Override
   protected boolean isZookeeperMode() {
-    return Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED);
+    return mClientContext.getConfiguration().getBoolean(PropertyKey.ZOOKEEPER_ENABLED);
   }
 }
diff --git a/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopConfigurationUtils.java b/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopConfigurationUtils.java
index 0d95a91f68..b76e12ec4b 100644
--- a/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopConfigurationUtils.java
+++ b/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopConfigurationUtils.java
@@ -11,11 +11,11 @@
 
 package alluxio.hadoop;
 
-import alluxio.AlluxioConfiguration;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.conf.Source;
 
+import alluxio.util.ConfigurationUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -25,7 +25,7 @@ import java.util.Properties;
 import javax.annotation.concurrent.ThreadSafe;
 
 /**
- * Utility class for merging Alluxio {@link Configuration} with Hadoop's Configuration class.
+ * Utility class for merging {@link AlluxioConfiguration} with Hadoop's Configuration class.
  */
 @ThreadSafe
 public final class HadoopConfigurationUtils {
@@ -39,7 +39,7 @@ public final class HadoopConfigurationUtils {
    * @param source the {@link org.apache.hadoop.conf.Configuration} to merge
    * @param alluxioConfiguration the Alluxio configuration to merge to
    */
-  public static void mergeHadoopConfiguration(org.apache.hadoop.conf.Configuration source,
+  public static AlluxioConfiguration mergeHadoopConfiguration(org.apache.hadoop.conf.Configuration source,
       AlluxioConfiguration alluxioConfiguration) {
     // Load Alluxio configuration if any and merge to the one in Alluxio file system
     // Push Alluxio configuration to the Job configuration
@@ -54,7 +54,9 @@ public final class HadoopConfigurationUtils {
     LOG.info("Loading Alluxio properties from Hadoop configuration: {}", alluxioConfProperties);
     // Merge the relevant Hadoop configuration into Alluxio's configuration.
     // TODO(jiri): support multiple client configurations (ALLUXIO-2034)
-    alluxioConfiguration.merge(alluxioConfProperties, Source.RUNTIME);
-    alluxioConfiguration.validate();
+    AlluxioConfiguration conf = ConfigurationUtils.merge(alluxioConfiguration,
+        alluxioConfProperties, Source.RUNTIME);
+    conf.validate();
+    return conf;
   }
 }
diff --git a/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopUtils.java b/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopUtils.java
index 63072b6e5b..e9c8123723 100644
--- a/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopUtils.java
+++ b/core/client/hdfs/src/main/java/alluxio/hadoop/HadoopUtils.java
@@ -12,7 +12,7 @@
 package alluxio.hadoop;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileStatus;
diff --git a/core/client/hdfs/src/main/java/alluxio/hadoop/HdfsFileInputStream.java b/core/client/hdfs/src/main/java/alluxio/hadoop/HdfsFileInputStream.java
index 3c5eb21f08..9aa6e60423 100644
--- a/core/client/hdfs/src/main/java/alluxio/hadoop/HdfsFileInputStream.java
+++ b/core/client/hdfs/src/main/java/alluxio/hadoop/HdfsFileInputStream.java
@@ -11,10 +11,11 @@
 
 package alluxio.hadoop;
 
-import alluxio.AlluxioURI;
+import alluxio.*;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileDoesNotExistException;
@@ -53,12 +54,14 @@ public class HdfsFileInputStream extends InputStream implements Seekable, Positi
    * @param uri the Alluxio file URI
    * @param stats filesystem statistics
    */
-  public HdfsFileInputStream(FileSystemContext context, AlluxioURI uri, Statistics stats)
+  public HdfsFileInputStream(FileSystemContext context, AlluxioURI uri, Statistics stats,
+      AlluxioConfiguration conf)
       throws IOException {
     LOG.debug("HdfsFileInputStream({}, {})", uri, stats);
 
     mStatistics = stats;
-    FileSystem fs = FileSystem.Factory.get(context);
+    FileSystem fs = FileSystem.Factory.get(ClientContext.create(context.getParentSubject(),
+        conf.getProperties()));
     try {
       mInputStream = fs.openFile(uri, OpenFilePOptions.getDefaultInstance());
     } catch (FileDoesNotExistException e) {
diff --git a/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemApiTest.java b/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemApiTest.java
index 01a6e35c12..f8ef8e7775 100644
--- a/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemApiTest.java
+++ b/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemApiTest.java
@@ -15,9 +15,9 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.TestLoggerRule;
 
 import org.junit.After;
@@ -37,16 +37,18 @@ public final class AbstractFileSystemApiTest {
   @Rule
   public TestLoggerRule mTestLogger = new TestLoggerRule();
 
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
+
   @Before
   public void before() {
     // To make the test run faster.
-    Configuration.set(PropertyKey.METRICS_CONTEXT_SHUTDOWN_TIMEOUT, "0sec");
+    mConf.set(PropertyKey.METRICS_CONTEXT_SHUTDOWN_TIMEOUT, "0sec");
   }
 
   @After
   public void after() {
-    HadoopClientTestUtils.resetClient();
-    ConfigurationTestUtils.resetConfiguration();
+    HadoopClientTestUtils.resetClient(mConf);
+    mConf = ConfigurationTestUtils.defaults();
   }
 
   @Test
@@ -74,8 +76,8 @@ public final class AbstractFileSystemApiTest {
   public void parseZkUriWithPlusDelimiters() throws Exception {
     FileSystem.get(URI.create("alluxio://zk@a:0+b:1+c:2/"),
         new org.apache.hadoop.conf.Configuration());
-    assertTrue(Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-    assertEquals("a:0,b:1,c:2", Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+    assertTrue(mConf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertEquals("a:0,b:1,c:2", mConf.get(PropertyKey.ZOOKEEPER_ADDRESS));
   }
 
   private boolean loggedAuthorityWarning() {
diff --git a/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemTest.java b/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemTest.java
index 858d7a378b..d8eb42e7c3 100644
--- a/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemTest.java
+++ b/core/client/hdfs/src/test/java/alluxio/hadoop/AbstractFileSystemTest.java
@@ -24,11 +24,10 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
-import alluxio.AlluxioURI;
-import alluxio.ConfigurationRule;
-import alluxio.Constants;
-import alluxio.PropertyKey;
-import alluxio.SystemPropertyRule;
+import alluxio.*;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.FileSystemContext;
@@ -96,6 +95,7 @@ import javax.security.auth.Subject;
 public class AbstractFileSystemTest {
   private static final Logger LOG = LoggerFactory.getLogger(AbstractFileSystemTest.class);
 
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
   private FileSystemContext mMockFileSystemContext;
   private FileSystemContext mMockFileSystemContextCustomized;
   private FileSystemMasterClient mMockFileSystemMasterClient;
@@ -109,6 +109,7 @@ public class AbstractFileSystemTest {
    */
   @Before
   public void before() throws Exception {
+    mConfiguration = ConfigurationTestUtils.defaults();
     mockFileSystemContextAndMasterClient();
     mockUserGroupInformation("");
 
@@ -124,7 +125,7 @@ public class AbstractFileSystemTest {
 
   @After
   public void after() {
-    HadoopClientTestUtils.resetClient();
+    HadoopClientTestUtils.resetClient(mConfiguration);
   }
 
   @Test
@@ -135,7 +136,7 @@ public class AbstractFileSystemTest {
         PropertyKey.MASTER_HOSTNAME, uri.getHost(),
         PropertyKey.MASTER_RPC_PORT, Integer.toString(uri.getPort()),
         PropertyKey.ZOOKEEPER_ENABLED, "true",
-        PropertyKey.ZOOKEEPER_ADDRESS, "ignored")).toResource()) {
+        PropertyKey.ZOOKEEPER_ADDRESS, "ignored"), mConfiguration).toResource()) {
       final org.apache.hadoop.fs.FileSystem fs =
           org.apache.hadoop.fs.FileSystem.get(uri, getConf());
       assertTrue(fs instanceof FaultTolerantFileSystem);
@@ -148,8 +149,8 @@ public class AbstractFileSystemTest {
     URI uri = URI.create(Constants.HEADER + "zk@zkHost:2181/tmp/path.txt");
     org.apache.hadoop.fs.FileSystem fs = org.apache.hadoop.fs.FileSystem.get(uri, conf);
 
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-    assertEquals("zkHost:2181", alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertEquals("zkHost:2181", mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
     assertTrue(fs instanceof FileSystem);
   }
 
@@ -159,16 +160,16 @@ public class AbstractFileSystemTest {
     URI uri = URI.create(Constants.HEADER + "zk@host1:2181,host2:2181,host3:2181/tmp/path.txt");
     org.apache.hadoop.fs.FileSystem fs = org.apache.hadoop.fs.FileSystem.get(uri, conf);
 
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
     assertEquals("host1:2181,host2:2181,host3:2181",
-        alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+        mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
     assertTrue(fs instanceof FileSystem);
 
     uri = URI.create(Constants.HEADER + "zk@host1:2181;host2:2181;host3:2181/tmp/path.txt");
     fs = org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
     assertEquals("host1:2181,host2:2181,host3:2181",
-        alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+        mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
     assertTrue(fs instanceof FileSystem);
   }
 
@@ -196,17 +197,17 @@ public class AbstractFileSystemTest {
     URI uri = URI.create(Constants.HEADER + "dummyHost:19998/");
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         PropertyKey.ZOOKEEPER_ENABLED, "true",
-        PropertyKey.ZOOKEEPER_ADDRESS, "zkAddress")).toResource()) {
+        PropertyKey.ZOOKEEPER_ADDRESS, "zkAddress"), mConfiguration).toResource()) {
       Configuration conf = getConf();
       conf.set("fs.alluxio.impl.disable.cache", "true");
       org.apache.hadoop.fs.FileSystem fs1 = org.apache.hadoop.fs.FileSystem.get(uri, conf);
-      verify(mMockFileSystemContext, times(1)).reset(alluxio.Configuration.global());
+      verify(mMockFileSystemContext, times(1)).reset();
       // The filesystem context should return a master inquire client based on the latest config
       when(mMockFileSystemContext.getMasterInquireClient())
-          .thenReturn(MasterInquireClient.Factory.create());
+          .thenReturn(MasterInquireClient.Factory.create(mConfiguration));
       // The first initialize should reset the context, but later initializes should not.
       org.apache.hadoop.fs.FileSystem.get(uri, conf);
-      verify(mMockFileSystemContext, times(1)).reset(alluxio.Configuration.global());
+      verify(mMockFileSystemContext, times(1)).reset();
     }
   }
 
@@ -218,7 +219,7 @@ public class AbstractFileSystemTest {
     URI uri = URI.create(Constants.HEADER_FT + "/tmp/path.txt");
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         PropertyKey.ZOOKEEPER_ENABLED, "true",
-        PropertyKey.ZOOKEEPER_ADDRESS, "ignored")).toResource()) {
+        PropertyKey.ZOOKEEPER_ADDRESS, "ignored"), mConfiguration).toResource()) {
       final org.apache.hadoop.fs.FileSystem fs =
           org.apache.hadoop.fs.FileSystem.get(uri, getConf());
       assertTrue(fs instanceof FaultTolerantFileSystem);
@@ -233,7 +234,7 @@ public class AbstractFileSystemTest {
   public void loadRegularThenFaultTolerant() throws Exception {
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         PropertyKey.ZOOKEEPER_ENABLED, "true",
-        PropertyKey.ZOOKEEPER_ADDRESS, "host:2")).toResource()) {
+        PropertyKey.ZOOKEEPER_ADDRESS, "host:2"), mConfiguration).toResource()) {
       org.apache.hadoop.fs.FileSystem.get(URI.create(Constants.HEADER + "host:1/"), getConf());
       org.apache.hadoop.fs.FileSystem fs =
           org.apache.hadoop.fs.FileSystem.get(URI.create(Constants.HEADER_FT + "/"), getConf());
@@ -252,7 +253,7 @@ public class AbstractFileSystemTest {
     properties.put(PropertyKey.MASTER_RPC_PORT, Integer.toString(uri.getPort()));
     properties.put(PropertyKey.ZOOKEEPER_ENABLED, "false");
     properties.put(PropertyKey.ZOOKEEPER_ADDRESS, null);
-    try (Closeable c = new ConfigurationRule(properties).toResource()) {
+    try (Closeable c = new ConfigurationRule(properties, mConfiguration).toResource()) {
       final org.apache.hadoop.fs.FileSystem fs = org.apache.hadoop.fs.FileSystem.get(uri, conf);
       assertTrue(fs instanceof FileSystem);
     }
@@ -268,7 +269,7 @@ public class AbstractFileSystemTest {
     URI uri = URI.create(Constants.HEADER + "otherhost:410/");
     org.apache.hadoop.fs.FileSystem.get(uri, getConf());
 
-    verify(mMockFileSystemContext).reset(alluxio.Configuration.global());
+    verify(mMockFileSystemContext).reset();
   }
 
   @Test
@@ -277,23 +278,23 @@ public class AbstractFileSystemTest {
     URI uri = URI.create(Constants.HEADER + "zk@zkHost:2181/");
     org.apache.hadoop.fs.FileSystem.get(uri, getConf());
 
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-    assertEquals("zkHost:2181", alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertEquals("zkHost:2181", mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
 
     uri = URI.create(Constants.HEADER + "zk@host1:2181,host2:2181,host3:2181/tmp/path.txt");
     org.apache.hadoop.fs.FileSystem.get(uri, getConf());
 
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
     assertEquals("host1:2181,host2:2181,host3:2181",
-        alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+        mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
 
     uri = URI.create(Constants.HEADER + "zk@host1:2181;host2:2181;host3:2181/tmp/path.txt");
     org.apache.hadoop.fs.FileSystem.get(uri, getConf());
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
     assertEquals("host1:2181,host2:2181,host3:2181",
-        alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+        mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
 
-    verify(mMockFileSystemContext, times(3)).reset(alluxio.Configuration.global());
+    verify(mMockFileSystemContext, times(3)).reset();
   }
 
   @Test
@@ -301,16 +302,16 @@ public class AbstractFileSystemTest {
     org.apache.hadoop.conf.Configuration conf = getConf();
     URI uri = URI.create(Constants.HEADER + "zk@zkHost:2181/tmp/path.txt");
     org.apache.hadoop.fs.FileSystem fs = org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-    assertEquals("zkHost:2181", alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertEquals("zkHost:2181", mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
 
     URI otherUri = URI.create(Constants.HEADER + "alluxioHost:19998/tmp/path.txt");
     org.apache.hadoop.fs.FileSystem otherFs = org.apache.hadoop.fs.FileSystem.get(otherUri, conf);
-    assertEquals("alluxioHost", alluxio.Configuration.get(PropertyKey.MASTER_HOSTNAME));
-    assertEquals("19998", alluxio.Configuration.get(PropertyKey.MASTER_RPC_PORT));
-    assertFalse(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-    assertFalse(alluxio.Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
-    verify(mMockFileSystemContext, times(2)).reset(alluxio.Configuration.global());
+    assertEquals("alluxioHost", mConfiguration.get(PropertyKey.MASTER_HOSTNAME));
+    assertEquals("19998", mConfiguration.get(PropertyKey.MASTER_RPC_PORT));
+    assertFalse(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    assertFalse(mConfiguration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
+    verify(mMockFileSystemContext, times(2)).reset();
   }
 
   @Test
@@ -405,13 +406,13 @@ public class AbstractFileSystemTest {
     org.apache.hadoop.conf.Configuration conf = getConf();
     URI uri = URI.create("alluxio://host1:1");
     org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    assertEquals("host1", alluxio.Configuration.get(PropertyKey.MASTER_HOSTNAME));
-    assertEquals("1", alluxio.Configuration.get(PropertyKey.MASTER_RPC_PORT));
+    assertEquals("host1", mConfiguration.get(PropertyKey.MASTER_HOSTNAME));
+    assertEquals("1", mConfiguration.get(PropertyKey.MASTER_RPC_PORT));
 
     uri = URI.create("alluxio://host2:2");
     org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    assertEquals("host2", alluxio.Configuration.get(PropertyKey.MASTER_HOSTNAME));
-    assertEquals("2", alluxio.Configuration.get(PropertyKey.MASTER_RPC_PORT));
+    assertEquals("host2", mConfiguration.get(PropertyKey.MASTER_HOSTNAME));
+    assertEquals("2", mConfiguration.get(PropertyKey.MASTER_RPC_PORT));
   }
 
   /**
@@ -502,7 +503,7 @@ public class AbstractFileSystemTest {
     final org.apache.hadoop.conf.Configuration conf = getConf();
     URI uri = URI.create(Constants.HEADER + "host:1");
     org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    // FileSystem.get would have thrown an exception if the initialization failed.
+    // FileSystem.create would have thrown an exception if the initialization failed.
   }
 
   @Test
@@ -512,7 +513,7 @@ public class AbstractFileSystemTest {
     final org.apache.hadoop.conf.Configuration conf = getConf();
     URI uri = URI.create(Constants.HEADER + "host:1");
     org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    // FileSystem.get would have thrown an exception if the initialization failed.
+    // FileSystem.create would have thrown an exception if the initialization failed.
   }
 
   @Test
@@ -521,11 +522,10 @@ public class AbstractFileSystemTest {
     sysProps.put(PropertyKey.ZOOKEEPER_ENABLED.getName(), "true");
     sysProps.put(PropertyKey.ZOOKEEPER_ADDRESS.getName(), "zkHost:2181");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      alluxio.Configuration.reset();
       URI uri = URI.create("alluxio:///");
       org.apache.hadoop.fs.FileSystem.get(uri, getConf());
-      assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-      assertEquals("zkHost:2181", alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+      assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+      assertEquals("zkHost:2181", mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
     }
   }
 
@@ -535,22 +535,20 @@ public class AbstractFileSystemTest {
     // those in the URI has the highest priority.
     try (Closeable p = new SystemPropertyRule(
          PropertyKey.ZOOKEEPER_ENABLED.getName(), "false").toResource()) {
-      alluxio.Configuration.reset();
       URI uri = URI.create("alluxio://zk@zkHost:2181");
       org.apache.hadoop.fs.FileSystem.get(uri, getConf());
-      assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-      assertEquals("zkHost:2181", alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+      assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+      assertEquals("zkHost:2181", mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
     }
 
     HashMap<String, String> sysProps = new HashMap<>();
     sysProps.put(PropertyKey.ZOOKEEPER_ENABLED.getName(), "true");
     sysProps.put(PropertyKey.ZOOKEEPER_ADDRESS.getName(), "zkHost1:2181");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      alluxio.Configuration.reset();
       URI uri = URI.create("alluxio://zk@zkHost2:2181");
       org.apache.hadoop.fs.FileSystem.get(uri, getConf());
-      assertTrue(alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
-      assertEquals("zkHost2:2181", alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+      assertTrue(mConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+      assertEquals("zkHost2:2181", mConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS));
     }
   }
 
@@ -630,7 +628,7 @@ public class AbstractFileSystemTest {
     List<WorkerNetAddress> expectedWorkers = Arrays.asList(worker1, worker2);
 
     try (Closeable conf =
-        new ConfigurationRule(PropertyKey.USER_UFS_BLOCK_LOCATION_ALL_FALLBACK_ENABLED, "true")
+        new ConfigurationRule(PropertyKey.USER_UFS_BLOCK_LOCATION_ALL_FALLBACK_ENABLED, "true", mConfiguration)
             .toResource()) {
       verifyBlockLocations(blockWorkers, ufsLocations, allWorkers, expectedWorkers);
     }
@@ -660,7 +658,7 @@ public class AbstractFileSystemTest {
     List<WorkerNetAddress> expectedWorkers = Arrays.asList(worker1, worker2);
 
     try (Closeable conf =
-        new ConfigurationRule(PropertyKey.USER_UFS_BLOCK_LOCATION_ALL_FALLBACK_ENABLED, "true")
+        new ConfigurationRule(PropertyKey.USER_UFS_BLOCK_LOCATION_ALL_FALLBACK_ENABLED, "true", mConfiguration)
             .toResource()) {
       verifyBlockLocations(blockWorkers, ufsLocations, allWorkers, expectedWorkers);
     }
@@ -726,10 +724,10 @@ public class AbstractFileSystemTest {
     when(mMockMasterInquireClient.getConnectDetails()).thenReturn(
         new SingleMasterConnectDetails(new InetSocketAddress("defaultHost", 1)));
     PowerMockito.mockStatic(FileSystemContext.class);
-    PowerMockito.when(FileSystemContext.get()).thenReturn(mMockFileSystemContext);
-    PowerMockito.when(FileSystemContext.get(any(Subject.class)))
+    PowerMockito.when(FileSystemContext.create()).thenReturn(mMockFileSystemContext);
+    PowerMockito.when(FileSystemContext.create(any(Subject.class), any(AlluxioConfiguration.class)))
         .thenReturn(mMockFileSystemContextCustomized);
-    PowerMockito.when(FileSystemContext.get()).thenReturn(mMockFileSystemContext);
+    PowerMockito.when(FileSystemContext.create()).thenReturn(mMockFileSystemContext);
     mMockFileSystemMasterClient = mock(FileSystemMasterClient.class);
     when(mMockFileSystemContext.acquireMasterClient())
         .thenReturn(mMockFileSystemMasterClient);
@@ -742,7 +740,7 @@ public class AbstractFileSystemTest {
   }
 
   private void mockUserGroupInformation(String username) throws IOException {
-    // need to mock out since FileSystem.get calls UGI, which some times has issues on some systems
+    // need to mock out since FileSystem.create calls UGI, which some times has issues on some systems
     PowerMockito.mockStatic(UserGroupInformation.class);
     final UserGroupInformation ugi = mock(UserGroupInformation.class);
     when(UserGroupInformation.getCurrentUser()).thenReturn(ugi);
diff --git a/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopClientTestUtils.java b/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopClientTestUtils.java
index 3b5895306a..1e4d9f3c2c 100644
--- a/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopClientTestUtils.java
+++ b/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopClientTestUtils.java
@@ -11,9 +11,9 @@
 
 package alluxio.hadoop;
 
-import alluxio.Configuration;
 import alluxio.ProjectConstants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemContext;
 
 import org.powermock.core.classloader.MockClassLoader;
@@ -32,10 +32,10 @@ public final class HadoopClientTestUtils {
    *
    * This method should only be used as a cleanup mechanism between tests.
    */
-  public static void resetClient() {
+  public static void resetClient(InstancedConfiguration conf) {
     try {
-      Configuration.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
-      FileSystemContext.get().reset(Configuration.global());
+      conf.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
+      FileSystemContext.create().reset();
       Whitebox.setInternalState(AbstractFileSystem.class, "sInitialized", false);
     } catch (Exception e) {
       throw new RuntimeException(e);
diff --git a/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopConfigurationUtilsTest.java b/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopConfigurationUtilsTest.java
index cbbe27616f..e11f5bf2ce 100644
--- a/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopConfigurationUtilsTest.java
+++ b/core/client/hdfs/src/test/java/alluxio/hadoop/HadoopConfigurationUtilsTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.hadoop;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.conf.Source;
 
 import org.junit.After;
@@ -28,10 +28,11 @@ public final class HadoopConfigurationUtilsTest {
   private static final String TEST_S3_SECRET_KEY = "TEST SECRET KEY";
   private static final String TEST_ALLUXIO_PROPERTY = "alluxio.unsupported.parameter";
   private static final String TEST_ALLUXIO_VALUE = "alluxio.unsupported.value";
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    mConf = ConfigurationTestUtils.defaults();
   }
 
   /**
@@ -41,11 +42,11 @@ public final class HadoopConfigurationUtilsTest {
   @Test
   public void mergeEmptyHadoopConfiguration() {
     org.apache.hadoop.conf.Configuration hadoopConfig = new org.apache.hadoop.conf.Configuration();
-    long beforeSize = Configuration.toMap().size();
-    HadoopConfigurationUtils.mergeHadoopConfiguration(hadoopConfig, Configuration.global());
-    long afterSize = Configuration.toMap().size();
+    long beforeSize = mConf.toMap().size();
+    HadoopConfigurationUtils.mergeHadoopConfiguration(hadoopConfig, mConf);
+    long afterSize = mConf.toMap().size();
     Assert.assertEquals(beforeSize, afterSize);
-    Assert.assertFalse(Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    Assert.assertFalse(mConf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
   }
 
   /**
@@ -63,13 +64,13 @@ public final class HadoopConfigurationUtilsTest {
 
     // This hadoop config will not be loaded into Alluxio configuration.
     hadoopConfig.set("hadoop.config.parameter", "hadoop config value");
-    HadoopConfigurationUtils.mergeHadoopConfiguration(hadoopConfig, Configuration.global());
-    Assert.assertEquals(TEST_S3_ACCCES_KEY, Configuration.get(PropertyKey.S3A_ACCESS_KEY));
-    Assert.assertEquals(TEST_S3_SECRET_KEY, Configuration.get(PropertyKey.S3A_SECRET_KEY));
-    Assert.assertEquals(Source.RUNTIME, Configuration.getSource(PropertyKey.S3A_ACCESS_KEY));
-    Assert.assertEquals(Source.RUNTIME, Configuration.getSource(PropertyKey.S3A_SECRET_KEY));
-    Assert.assertTrue(Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
+    HadoopConfigurationUtils.mergeHadoopConfiguration(hadoopConfig, mConf);
+    Assert.assertEquals(TEST_S3_ACCCES_KEY, mConf.get(PropertyKey.S3A_ACCESS_KEY));
+    Assert.assertEquals(TEST_S3_SECRET_KEY, mConf.get(PropertyKey.S3A_SECRET_KEY));
+    Assert.assertEquals(Source.RUNTIME, mConf.getSource(PropertyKey.S3A_ACCESS_KEY));
+    Assert.assertEquals(Source.RUNTIME, mConf.getSource(PropertyKey.S3A_SECRET_KEY));
+    Assert.assertTrue(mConf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED));
     Assert.assertEquals("host1:port1,host2:port2;host3:port3",
-        Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+        mConf.get(PropertyKey.ZOOKEEPER_ADDRESS));
   }
 }
diff --git a/core/common/src/main/java/alluxio/AbstractClient.java b/core/common/src/main/java/alluxio/AbstractClient.java
index 44f6db9d05..0df7eafcb0 100644
--- a/core/common/src/main/java/alluxio/AbstractClient.java
+++ b/core/common/src/main/java/alluxio/AbstractClient.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.PreconditionMessage;
 import alluxio.exception.status.AlluxioStatusException;
@@ -28,6 +30,7 @@ import alluxio.retry.RetryPolicy;
 import alluxio.retry.RetryUtils;
 import alluxio.security.LoginUser;
 import alluxio.grpc.GrpcChannel;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.SecurityUtils;
 import alluxio.grpc.GrpcExceptionUtils;
 
@@ -39,6 +42,7 @@ import org.slf4j.LoggerFactory;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
+import java.util.function.Consumer;
 import java.util.function.Supplier;
 
 import javax.annotation.concurrent.ThreadSafe;
@@ -75,7 +79,7 @@ public abstract class AbstractClient implements Client {
    */
   protected long mServiceVersion;
 
-  private final Subject mParentSubject;
+  protected ClientContext mContext;
 
   /**
    * Creates a new client base.
@@ -83,8 +87,11 @@ public abstract class AbstractClient implements Client {
    * @param subject the parent subject, set to null if not present
    * @param address the address
    */
-  public AbstractClient(Subject subject, InetSocketAddress address) {
-    this(subject, address, RetryUtils::defaultClientRetry);
+  public AbstractClient(Subject subject, AlluxioConfiguration conf, InetSocketAddress address) {
+    this(subject, conf, address, () -> RetryUtils.defaultClientRetry(
+          conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_NUM_RETRY),
+          conf.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS),
+          conf.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS)));
   }
 
   /**
@@ -94,10 +101,10 @@ public abstract class AbstractClient implements Client {
    * @param address the address
    * @param retryPolicySupplier factory for retry policies to be used when performing RPCs
    */
-  public AbstractClient(Subject subject, InetSocketAddress address,
+  public AbstractClient(Subject subject, AlluxioConfiguration conf, InetSocketAddress address,
       Supplier<RetryPolicy> retryPolicySupplier) {
     mAddress = address;
-    mParentSubject = subject;
+    mContext = ClientContext.create(subject, conf.getProperties());
     mRetryPolicySupplier = retryPolicySupplier;
     mServiceVersion = Constants.UNKNOWN_SERVICE_VERSION;
   }
@@ -154,10 +161,17 @@ public abstract class AbstractClient implements Client {
    * This method is called before the connection is connected. Implementations should add any
    * additional operations before the connection is connected.
    */
-  protected void beforeConnect() throws IOException {
+  protected void beforeConnect(Consumer<AlluxioConfiguration> configurationUpdateCallback)
+      throws IOException {
     // Bootstrap once for clients
     if (!isConnected()) {
-      Configuration.loadClusterDefault(mAddress);
+      // Unfortunately not as simple as before..... we'll need to pass some kind of callback which
+      // updates the configuration within the client context.
+      if (!mContext.getConfiguration().clusterDefaultsLoaded()) {
+        AlluxioConfiguration conf = ConfigurationUtils.loadClusterDefaults(mAddress, mContext.getConfiguration());
+        configurationUpdateCallback.accept(conf);
+      }
+
     }
   }
 
@@ -203,10 +217,15 @@ public abstract class AbstractClient implements Client {
         continue;
       }
       try {
-        beforeConnect();
+        beforeConnect((AlluxioConfiguration conf) -> {
+          mContext = ClientContext.create(mContext.getSubject(), conf.getProperties());
+        });
         LOG.info("Alluxio client (version {}) is trying to connect with {} @ {}",
             RuntimeConstants.VERSION, getServiceName(), mAddress);
-        mChannel = GrpcChannelBuilder.forAddress(mAddress).setSubject(mParentSubject).build();
+        mChannel = GrpcChannelBuilder
+            .forAddress(mAddress, mContext.getConfiguration())
+            .setSubject(mContext.getSubject())
+            .build();
         // Create stub for version service on host
         mVersionService = ServiceVersionClientServiceGrpc.newBlockingStub(mChannel);
         mConnected = true;
@@ -353,9 +372,10 @@ public abstract class AbstractClient implements Client {
   // TODO(calvin): General tag logic should be in getMetricName
   private String getQualifiedMetricName(String metricName) {
     try {
-      if (SecurityUtils.isAuthenticationEnabled() && LoginUser.get() != null) {
-        return Metric.getMetricNameWithTags(metricName, CommonMetrics.TAG_USER, LoginUser.get()
-            .getName());
+      if (SecurityUtils.isAuthenticationEnabled(mContext.getConfiguration())
+          && LoginUser.get(mContext.getConfiguration()) != null) {
+        return Metric.getMetricNameWithTags(metricName, CommonMetrics.TAG_USER,
+            LoginUser.get(mContext.getConfiguration()).getName());
       } else {
         return metricName;
       }
diff --git a/core/common/src/main/java/alluxio/AbstractMasterClient.java b/core/common/src/main/java/alluxio/AbstractMasterClient.java
index 1fb40fa019..adfad7f3c6 100644
--- a/core/common/src/main/java/alluxio/AbstractMasterClient.java
+++ b/core/common/src/main/java/alluxio/AbstractMasterClient.java
@@ -11,6 +11,7 @@
 
 package alluxio;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterClientConfig;
 import alluxio.master.MasterInquireClient;
@@ -32,24 +33,24 @@ public abstract class AbstractMasterClient extends AbstractClient {
   /**
    * Creates a new master client base.
    *
-   * @param conf master client configuration
+   * @param clientConf master client configuration
    */
-  public AbstractMasterClient(MasterClientConfig conf) {
-    super(conf.getSubject(), null);
-    mMasterInquireClient = conf.getMasterInquireClient();
+  public AbstractMasterClient(MasterClientConfig clientConf, AlluxioConfiguration alluxioConf) {
+    super(clientConf.getSubject(), alluxioConf, null);
+    mMasterInquireClient = clientConf.getMasterInquireClient();
   }
 
   /**
    * Creates a new master client base.
    *
-   * @param conf master client configuration
+   * @param clientConf master client configuration
    * @param address address to connect to
    * @param retryPolicySupplier retry policy to use
    */
-  public AbstractMasterClient(MasterClientConfig conf, InetSocketAddress address,
-      Supplier<RetryPolicy> retryPolicySupplier) {
-    super(conf.getSubject(), address, retryPolicySupplier);
-    mMasterInquireClient = conf.getMasterInquireClient();
+  public AbstractMasterClient(MasterClientConfig clientConf, AlluxioConfiguration alluxioConf,
+      InetSocketAddress address, Supplier<RetryPolicy> retryPolicySupplier) {
+    super(clientConf.getSubject(), alluxioConf, address, retryPolicySupplier);
+    mMasterInquireClient = clientConf.getMasterInquireClient();
   }
 
   @Override
diff --git a/core/common/src/main/java/alluxio/ClientContext.java b/core/common/src/main/java/alluxio/ClientContext.java
new file mode 100644
index 0000000000..adeae1bd2b
--- /dev/null
+++ b/core/common/src/main/java/alluxio/ClientContext.java
@@ -0,0 +1,68 @@
+package alluxio;
+
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.AlluxioProperties;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
+
+import javax.annotation.Nullable;
+import javax.security.auth.Subject;
+
+public class ClientContext {
+
+  public final AlluxioConfiguration mConf;
+  public final Subject mSubject;
+
+  /**
+   * A client context with information about the subject and configuration of the client.
+   *
+   * This class accepts {@link AlluxioProperties} instead of {@link AlluxioConfiguration} because
+   * AlluxioProperties is a mutable object that should be able to be created and modified easily by
+   * a user. Meanwhile, the {@link AlluxioConfiguration} interface is read only and doesn't allow
+   * the user to change values once instantiated. The ClientContext class is designed to be
+   * immutable. This forces any changes to a configuration to initialize a new Context.
+   *
+   * @param subject The security subject to use
+   * @param props The AlluxioProperties to use. If null,
+   * @return A new client context with the specified properties and subject
+   */
+  public static ClientContext create(@Nullable Subject subject, @Nullable AlluxioProperties props) {
+    return new ClientContext(subject, props);
+  }
+
+  /**
+   * @param props The specified {@link AlluxioProperties} to use.
+   * @return
+   */
+  public static ClientContext create(@Nullable AlluxioProperties props) {
+    return new ClientContext(null, props);
+  }
+
+  /**
+   * @return a new {@link ClientContext} with values loaded from the alluxio-site properties and a
+   * null subject
+   */
+  public static ClientContext create() {
+    return new ClientContext(null, null);
+  }
+
+  private ClientContext(@Nullable Subject subject, @Nullable AlluxioProperties props) {
+    mSubject = subject;
+    // Copy the properties so that future modification doesn't affect this ClientContext.
+    if (props != null) {
+      mConf = new InstancedConfiguration(props.copy());
+    } else {
+      mConf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    }
+
+  }
+
+  public AlluxioConfiguration getConfiguration() {
+    return mConf;
+  }
+
+  public Subject getSubject() {
+    return mSubject;
+  }
+
+}
diff --git a/core/common/src/main/java/alluxio/cli/AbstractShell.java b/core/common/src/main/java/alluxio/cli/AbstractShell.java
index 4ad842ee73..f96d745f66 100644
--- a/core/common/src/main/java/alluxio/cli/AbstractShell.java
+++ b/core/common/src/main/java/alluxio/cli/AbstractShell.java
@@ -11,6 +11,7 @@
 
 package alluxio.cli;
 
+import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import org.apache.commons.cli.CommandLine;
@@ -39,15 +40,17 @@ public abstract class AbstractShell implements Closeable {
 
   private Map<String, String[]> mCommandAlias;
   private Map<String, Command> mCommands;
+  protected InstancedConfiguration mConfiguration;
 
   /**
    * Creates a new instance of {@link AbstractShell}.
    *
    * @param commandAlias replacements for commands
    */
-  public AbstractShell(Map<String, String[]> commandAlias) {
+  public AbstractShell(Map<String, String[]> commandAlias, InstancedConfiguration conf) {
     mCommands = loadCommands();
     mCommandAlias = commandAlias;
+    mConfiguration = conf;
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/AlluxioConfiguration.java b/core/common/src/main/java/alluxio/conf/AlluxioConfiguration.java
similarity index 92%
rename from core/common/src/main/java/alluxio/AlluxioConfiguration.java
rename to core/common/src/main/java/alluxio/conf/AlluxioConfiguration.java
index 5e6d584cca..a0039dec8e 100644
--- a/core/common/src/main/java/alluxio/AlluxioConfiguration.java
+++ b/core/common/src/main/java/alluxio/conf/AlluxioConfiguration.java
@@ -9,20 +9,20 @@
  * See the NOTICE file distributed with this work for information regarding copyright ownership.
  */
 
-package alluxio;
-
-import alluxio.conf.Source;
+package alluxio.conf;
 
 import java.time.Duration;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * Alluxio configuration.
  */
 public interface AlluxioConfiguration {
+
   /**
    * Gets the value for the given key in the {@link Properties}; if this key is not found, a
    * RuntimeException is thrown.
@@ -178,20 +178,17 @@ public interface AlluxioConfiguration {
   Map<String, String> getNestedProperties(PropertyKey prefixKey);
 
   /**
-   * @param key the property key
-   * @return the source for the given key
+   * Gets a copy of the AlluioxProperties which back the AlluxioConfiguration
+   *
    */
-  Source getSource(PropertyKey key);
+  AlluxioProperties getProperties();
+
 
   /**
-   * Merges the current configuration properties with new properties. If a property exists
-   * both in the new and current configuration, the one from the new configuration wins if
-   * its priority is higher or equal than the existing one.
-   *
-   * @param properties the source {@link Properties} to be merged
-   * @param source the source of the the properties (e.g., system property, default and etc)
+   * @param key the property key
+   * @return the source for the given key
    */
-  void merge(Map<?, ?> properties, Source source);
+  Source getSource(PropertyKey key);
 
   /**
    * @return a map from all configuration property names to their values; values may potentially be
@@ -214,4 +211,11 @@ public interface AlluxioConfiguration {
    * @throws IllegalStateException if invalid configuration is encountered
    */
   void validate();
+
+  /**
+   * Determines whether or not the cluster defaults have been loaded into this configuration.
+   * @return
+   */
+  boolean clusterDefaultsLoaded();
+
 }
diff --git a/core/common/src/main/java/alluxio/conf/AlluxioProperties.java b/core/common/src/main/java/alluxio/conf/AlluxioProperties.java
index 2fb3486dad..5aea07d6da 100644
--- a/core/common/src/main/java/alluxio/conf/AlluxioProperties.java
+++ b/core/common/src/main/java/alluxio/conf/AlluxioProperties.java
@@ -13,8 +13,6 @@ package alluxio.conf;
 
 import static java.util.stream.Collectors.toSet;
 
-import alluxio.PropertyKey;
-
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Maps;
 import org.slf4j.Logger;
@@ -100,13 +98,23 @@ public class AlluxioProperties {
    * @param value value to put
    * @param source the source of this value for the key
    */
-  public void put(PropertyKey key, String value, Source source) {
+  protected void put(PropertyKey key, String value, Source source) {
     if (!mUserProps.containsKey(key) || source.compareTo(getSource(key)) >= 0) {
       mUserProps.put(key, Optional.ofNullable(value));
       mSources.put(key, source);
     }
   }
 
+  /**
+   * Puts the key value pair specified by users.
+   *
+   * @param key key to put
+   * @param value value to put
+   */
+  public void set(PropertyKey key, String value) {
+    put(key, value, Source.RUNTIME);
+  }
+
   /**
    * Merges the current configuration properties with new properties. If a property exists
    * both in the new and current configuration, the one from the new configuration wins if
@@ -189,6 +197,10 @@ public class AlluxioProperties {
     }
   }
 
+  public AlluxioProperties copy() {
+    return new AlluxioProperties(this);
+  }
+
   /**
    * Sets the source for a given key.
    *
diff --git a/core/common/src/main/java/alluxio/ConfigurationValueOptions.java b/core/common/src/main/java/alluxio/conf/ConfigurationValueOptions.java
similarity index 98%
rename from core/common/src/main/java/alluxio/ConfigurationValueOptions.java
rename to core/common/src/main/java/alluxio/conf/ConfigurationValueOptions.java
index bc6b6de796..af73bff03c 100644
--- a/core/common/src/main/java/alluxio/ConfigurationValueOptions.java
+++ b/core/common/src/main/java/alluxio/conf/ConfigurationValueOptions.java
@@ -9,7 +9,7 @@
  * See the NOTICE file distributed with this work for information regarding copyright ownership.
  */
 
-package alluxio;
+package alluxio.conf;
 
 /**
  * Options for getting configuration values.
diff --git a/core/common/src/main/java/alluxio/conf/InstancedConfiguration.java b/core/common/src/main/java/alluxio/conf/InstancedConfiguration.java
index d968a1df7c..da64803fea 100644
--- a/core/common/src/main/java/alluxio/conf/InstancedConfiguration.java
+++ b/core/common/src/main/java/alluxio/conf/InstancedConfiguration.java
@@ -11,10 +11,7 @@
 
 package alluxio.conf;
 
-import alluxio.AlluxioConfiguration;
-import alluxio.ConfigurationValueOptions;
-import alluxio.PropertyKey;
-import alluxio.PropertyKey.Template;
+import alluxio.conf.PropertyKey.Template;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.PreconditionMessage;
 import alluxio.util.FormatUtils;
@@ -33,7 +30,9 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Properties;
 import java.util.Set;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -50,6 +49,8 @@ public class InstancedConfiguration implements AlluxioConfiguration {
   /** Source of the truth of all property values (default or customized). */
   protected AlluxioProperties mProperties;
 
+  private AtomicBoolean mClusterDefaultsLoaded = new AtomicBoolean(false);
+
   /**
    * @param properties alluxio properties underlying this configuration
    */
@@ -57,11 +58,20 @@ public class InstancedConfiguration implements AlluxioConfiguration {
     mProperties = properties;
   }
 
+  /**
+   * @param properties alluxio properties underlying this configuration
+   */
+  public InstancedConfiguration(AlluxioProperties properties, boolean clusterDefaultsLoaded) {
+    mProperties = properties;
+    mClusterDefaultsLoaded.set(clusterDefaultsLoaded);
+  }
+
   /**
    * @param conf configuration to copy
    */
   public InstancedConfiguration(InstancedConfiguration conf) {
     mProperties = new AlluxioProperties(conf.mProperties);
+    mClusterDefaultsLoaded.set(conf.clusterDefaultsLoaded());
   }
 
   /**
@@ -123,6 +133,46 @@ public class InstancedConfiguration implements AlluxioConfiguration {
     }
   }
 
+  /**
+   * Sets the value for the appropriate key in the {@link Properties}.
+   *
+   * @param key the key to set
+   * @param value the value for the key
+   */
+  public void set(PropertyKey key, Object value) {
+    set(key, String.valueOf(value), Source.RUNTIME);
+  }
+
+  /**
+   * Sets the value for the appropriate key in the {@link Properties} by source.
+   *
+   * @param key the key to set
+   * @param value the value for the key
+   * @param source the source of the the properties (e.g., system property, default and etc)
+   */
+  public void set(PropertyKey key, Object value, Source source) {
+    Preconditions.checkArgument(key != null && value != null && !value.equals(""),
+        String.format("The key value pair (%s, %s) cannot be null", key, value));
+    Preconditions.checkArgument(!value.equals(""),
+        String.format("The key \"%s\" cannot be have an empty string as a value. Use "
+            + "ServerConfiguration.unset to remove a key from the configuration.", key));
+   mProperties.put(key, String.valueOf(value), source);
+  }
+
+  /**
+   * Unsets the value for the appropriate key in the {@link Properties}.
+   *
+   * @param key the key to unset
+   */
+  public void unset(PropertyKey key) {
+    Preconditions.checkNotNull(key, "key");
+    mProperties.remove(key);
+  }
+
+  public void merge(Map<?, ?> properties, Source source) {
+    mProperties.merge(properties, source);
+  }
+
   @Override
   public Set<PropertyKey> keySet() {
     return mProperties.keySet();
@@ -265,11 +315,6 @@ public class InstancedConfiguration implements AlluxioConfiguration {
     return mProperties.getSource(key);
   }
 
-  @Override
-  public void merge(Map<?, ?> properties, Source source) {
-    mProperties.merge(properties, source);
-  }
-
   @Override
   public Map<String, String> toMap(ConfigurationValueOptions opts) {
     Map<String, String> map = new HashMap<>();
@@ -298,6 +343,11 @@ public class InstancedConfiguration implements AlluxioConfiguration {
     checkTieredLocality();
   }
 
+  @Override
+  public boolean clusterDefaultsLoaded(){
+    return mClusterDefaultsLoaded.get();
+  }
+
   /**
    * Lookup key names to handle ${key} stuff.
    *
diff --git a/core/common/src/main/java/alluxio/PropertyKey.java b/core/common/src/main/java/alluxio/conf/PropertyKey.java
similarity index 99%
rename from core/common/src/main/java/alluxio/PropertyKey.java
rename to core/common/src/main/java/alluxio/conf/PropertyKey.java
index b548d6b181..681fc016c5 100644
--- a/core/common/src/main/java/alluxio/PropertyKey.java
+++ b/core/common/src/main/java/alluxio/conf/PropertyKey.java
@@ -9,8 +9,12 @@
  * See the NOTICE file distributed with this work for information regarding copyright ownership.
  */
 
-package alluxio;
+package alluxio.conf;
 
+import alluxio.Constants;
+import alluxio.DefaultSupplier;
+import alluxio.ProjectConstants;
+import alluxio.RuntimeConstants;
 import alluxio.exception.ExceptionMessage;
 import alluxio.grpc.Scope;
 import alluxio.util.OSUtils;
diff --git a/core/common/src/main/java/alluxio/extensions/ExtensionFactory.java b/core/common/src/main/java/alluxio/extensions/ExtensionFactory.java
index 67d78c85f4..c4b94d51fd 100644
--- a/core/common/src/main/java/alluxio/extensions/ExtensionFactory.java
+++ b/core/common/src/main/java/alluxio/extensions/ExtensionFactory.java
@@ -11,6 +11,9 @@
 
 package alluxio.extensions;
 
+import alluxio.conf.AlluxioConfiguration;
+
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 /**
@@ -28,11 +31,11 @@ public interface ExtensionFactory<T, S> {
    * @param conf optional configuration object for the extension, may be null
    * @return the new extension
    */
-  T create(String path, @Nullable S conf);
+  T create(String path, @Nullable S conf, @Nonnull AlluxioConfiguration alluxioConf);
 
   /**
    * Gets whether this factory supports the given path and thus whether calling the
-   * {@link #create(String, S)} can succeed for this path.
+   * {@link #create(String, S, AlluxioConfiguration)} can succeed for this path.
    *
    * @param path file path with scheme for which the extension will be created
    * @param conf optional configuration object for the extension, may be null
diff --git a/core/common/src/main/java/alluxio/extensions/ExtensionFactoryRegistry.java b/core/common/src/main/java/alluxio/extensions/ExtensionFactoryRegistry.java
index 520d1e626a..04eb6bfc28 100644
--- a/core/common/src/main/java/alluxio/extensions/ExtensionFactoryRegistry.java
+++ b/core/common/src/main/java/alluxio/extensions/ExtensionFactoryRegistry.java
@@ -11,8 +11,8 @@
 
 package alluxio.extensions;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.ExtensionUtils;
 import alluxio.util.io.PathUtils;
 
@@ -78,9 +78,6 @@ import javax.annotation.concurrent.NotThreadSafe;
 public class ExtensionFactoryRegistry<T extends ExtensionFactory<?, S>, S> {
   private static final Logger LOG = LoggerFactory.getLogger(ExtensionFactoryRegistry.class);
 
-  public static final String LIB_DIR =
-      PathUtils.concatPath(Configuration.get(PropertyKey.HOME), "lib");
-
   /**
    * The base list of factories, which does not include any lib or extension factories. The only
    * factories in the base list will be built-in factories, and any additional factories
@@ -130,12 +127,14 @@ public class ExtensionFactoryRegistry<T extends ExtensionFactory<?, S>, S> {
    * @param conf configuration of the extension
    * @return list of factories that support the given path which may be an empty list
    */
-  public List<T> findAll(String path, @Nullable S conf) {
+  public List<T> findAll(String path, @Nullable S conf, AlluxioConfiguration alluxioConf) {
     Preconditions.checkArgument(path != null, "path may not be null");
 
     List<T> factories = new ArrayList<>(mFactories);
-    scanLibs(factories);
-    scanExtensions(factories);
+    String libDir = PathUtils.concatPath(alluxioConf.get(PropertyKey.HOME), "lib");
+    String extensionDir = alluxioConf.get(PropertyKey.EXTENSIONS_DIR);
+    scanLibs(factories, libDir);
+    scanExtensions(factories, extensionDir);
 
     List<T> eligibleFactories = new ArrayList<>();
     for (T factory : factories) {
@@ -156,9 +155,9 @@ public class ExtensionFactoryRegistry<T extends ExtensionFactory<?, S>, S> {
    *
    * @param factories list of factories to add to
    */
-  private void scanExtensions(List<T> factories) {
-    LOG.info("Loading extension jars from {}", Configuration.get(PropertyKey.EXTENSIONS_DIR));
-    scan(Arrays.asList(ExtensionUtils.listExtensions()), factories);
+  private void scanExtensions(List<T> factories, String extensionsDir) {
+    LOG.info("Loading extension jars from {}", extensionsDir);
+    scan(Arrays.asList(ExtensionUtils.listExtensions(extensionsDir)), factories);
   }
 
   /**
@@ -166,11 +165,11 @@ public class ExtensionFactoryRegistry<T extends ExtensionFactory<?, S>, S> {
    *
    * @param factories list of factories to add to
    */
-  private void scanLibs(List<T> factories) {
-    LOG.info("Loading core jars from {}", LIB_DIR);
+  private void scanLibs(List<T> factories, String libDir) {
+    LOG.info("Loading core jars from {}", libDir);
     List<File> files = new ArrayList<>();
     try (DirectoryStream<Path> stream =
-        Files.newDirectoryStream(Paths.get(LIB_DIR), mExtensionPattern)) {
+        Files.newDirectoryStream(Paths.get(libDir), mExtensionPattern)) {
       for (Path entry : stream) {
         if (entry.toFile().isFile()) {
           files.add(entry.toFile());
diff --git a/core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java b/core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java
index 0bb9a4cda9..04e69923d5 100644
--- a/core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java
+++ b/core/common/src/main/java/alluxio/grpc/GrpcChannelBuilder.java
@@ -11,8 +11,8 @@
 
 package alluxio.grpc;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.security.authentication.AuthType;
@@ -45,15 +45,15 @@ public final class GrpcChannelBuilder {
 
   /** Whether to authenticate the channel with the server. */
   protected boolean mAuthenticateChannel;
-  /** Authentication type to use. */
-  protected AuthType mAuthType;
 
-  private GrpcChannelBuilder(SocketAddress address) {
+  protected AlluxioConfiguration mConfiguration;
+
+  private GrpcChannelBuilder(SocketAddress address, AlluxioConfiguration conf) {
     mChannelKey = GrpcManagedChannelPool.ChannelKey.create();
     mChannelKey.setAddress(address).usePlaintext();
     mUseSubject = true;
     mAuthenticateChannel = true;
-    mAuthType = Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
+    mConfiguration = conf;
   }
 
   /**
@@ -62,8 +62,8 @@ public final class GrpcChannelBuilder {
    * @param address the host address
    * @return a new instance of {@link GrpcChannelBuilder}
    */
-  public static GrpcChannelBuilder forAddress(SocketAddress address) {
-    return new GrpcChannelBuilder(address);
+  public static GrpcChannelBuilder forAddress(SocketAddress address, AlluxioConfiguration conf) {
+    return new GrpcChannelBuilder(address, conf);
   }
 
   /**
@@ -184,16 +184,20 @@ public final class GrpcChannelBuilder {
     Channel clientChannel = underlyingChannel;
 
     if (mAuthenticateChannel) {
+
       // Create channel authenticator based on provided content.
       ChannelAuthenticator channelAuthenticator;
+      // Authentication type.
+      AuthType authType = mConfiguration
+          .getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
       if (mUseSubject) {
-        channelAuthenticator = new ChannelAuthenticator(mParentSubject, mAuthType);
+        channelAuthenticator = new ChannelAuthenticator(mParentSubject, mConfiguration);
       } else {
         channelAuthenticator =
-            new ChannelAuthenticator(mUserName, mPassword, mImpersonationUser, mAuthType);
+            new ChannelAuthenticator(mUserName, mPassword, mImpersonationUser, authType);
       }
       // Get an authenticated wrapper channel over given managed channel.
-      clientChannel = channelAuthenticator.authenticate(underlyingChannel);
+      clientChannel = channelAuthenticator.authenticate(underlyingChannel, mConfiguration);
     }
     // Create the channel after authentication with the target.
     return new GrpcChannel(mChannelKey, clientChannel);
diff --git a/core/common/src/main/java/alluxio/grpc/GrpcServerBuilder.java b/core/common/src/main/java/alluxio/grpc/GrpcServerBuilder.java
index 31fcfc0f71..ed13d98328 100644
--- a/core/common/src/main/java/alluxio/grpc/GrpcServerBuilder.java
+++ b/core/common/src/main/java/alluxio/grpc/GrpcServerBuilder.java
@@ -11,6 +11,7 @@
 
 package alluxio.grpc;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.security.authentication.AuthenticationServer;
 import alluxio.security.authentication.DefaultAuthenticationServer;
 import alluxio.util.SecurityUtils;
@@ -43,11 +44,15 @@ public final class GrpcServerBuilder {
   /** Authentication server instance that will be used by this server. */
   private AuthenticationServer mAuthenticationServer;
 
-  private GrpcServerBuilder(NettyServerBuilder nettyServerBuilder) {
+  /** Configuration object used for  */
+  private AlluxioConfiguration mConfiguration;
+
+  private GrpcServerBuilder(NettyServerBuilder nettyServerBuilder, AlluxioConfiguration conf) {
+    mConfiguration = conf;
     mServices = new HashSet<>();
     mNettyServerBuilder = nettyServerBuilder;
-    if (SecurityUtils.isAuthenticationEnabled()) {
-      mAuthenticationServer = new DefaultAuthenticationServer();
+    if (SecurityUtils.isAuthenticationEnabled(conf)) {
+      mAuthenticationServer = new DefaultAuthenticationServer(conf);
       addService(new GrpcService(mAuthenticationServer).disableAuthentication());
     }
   }
@@ -58,8 +63,8 @@ public final class GrpcServerBuilder {
    * @param address the address
    * @return a new instance of {@link GrpcServerBuilder}
    */
-  public static GrpcServerBuilder forAddress(SocketAddress address) {
-    return new GrpcServerBuilder(NettyServerBuilder.forAddress(address));
+  public static GrpcServerBuilder forAddress(SocketAddress address, AlluxioConfiguration conf) {
+    return new GrpcServerBuilder(NettyServerBuilder.forAddress(address), conf);
   }
 
   /**
@@ -173,7 +178,7 @@ public final class GrpcServerBuilder {
    */
   public GrpcServerBuilder addService(GrpcService serviceDefinition) {
     ServerServiceDefinition service = serviceDefinition.getServiceDefinition();
-    if (SecurityUtils.isAuthenticationEnabled() && serviceDefinition.isAuthenticated()) {
+    if (SecurityUtils.isAuthenticationEnabled(mConfiguration) && serviceDefinition.isAuthenticated()) {
       service = ServerInterceptors.intercept(service, mAuthenticationServer.getInterceptors());
     }
     mNettyServerBuilder = mNettyServerBuilder.addService(service);
diff --git a/core/common/src/main/java/alluxio/heartbeat/HeartbeatThread.java b/core/common/src/main/java/alluxio/heartbeat/HeartbeatThread.java
index 4624f66bc4..56d49e5c0a 100644
--- a/core/common/src/main/java/alluxio/heartbeat/HeartbeatThread.java
+++ b/core/common/src/main/java/alluxio/heartbeat/HeartbeatThread.java
@@ -11,6 +11,7 @@
 
 package alluxio.heartbeat;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.security.LoginUser;
 import alluxio.security.authentication.AuthenticatedClientUser;
 import alluxio.util.CommonUtils;
@@ -35,6 +36,7 @@ public final class HeartbeatThread implements Runnable {
   private final String mThreadName;
   private final HeartbeatExecutor mExecutor;
   private HeartbeatTimer mTimer;
+  private AlluxioConfiguration mConfiguration;
 
   /**
    * Creates a {@link Runnable} to execute heartbeats for the given {@link HeartbeatExecutor}.
@@ -46,19 +48,20 @@ public final class HeartbeatThread implements Runnable {
    *        implements the HeartbeatExecutor interface
    * @param intervalMs Sleep time between different heartbeat
    */
-  public HeartbeatThread(String threadName, HeartbeatExecutor executor, long intervalMs) {
+  public HeartbeatThread(String threadName, HeartbeatExecutor executor, long intervalMs, AlluxioConfiguration conf) {
     mThreadName = threadName;
     mExecutor = Preconditions.checkNotNull(executor, "executor");
     Class<? extends HeartbeatTimer> timerClass = HeartbeatContext.getTimerClass(threadName);
     mTimer = CommonUtils.createNewClassInstance(timerClass, new Class[] {String.class, long.class},
         new Object[] {threadName, intervalMs});
+    mConfiguration = conf;
   }
 
   @Override
   public void run() {
     try {
-      if (SecurityUtils.isSecurityEnabled() && AuthenticatedClientUser.get() == null) {
-        AuthenticatedClientUser.set(LoginUser.get().getName());
+      if (SecurityUtils.isSecurityEnabled(mConfiguration) && AuthenticatedClientUser.get(mConfiguration) == null) {
+        AuthenticatedClientUser.set(LoginUser.get(mConfiguration).getName());
       }
     } catch (IOException e) {
       LOG.error("Failed to set AuthenticatedClientUser in HeartbeatThread.");
diff --git a/core/common/src/main/java/alluxio/master/MasterClientConfig.java b/core/common/src/main/java/alluxio/master/MasterClientConfig.java
index 77b23660ca..c02ac55622 100644
--- a/core/common/src/main/java/alluxio/master/MasterClientConfig.java
+++ b/core/common/src/main/java/alluxio/master/MasterClientConfig.java
@@ -11,6 +11,8 @@
 
 package alluxio.master;
 
+import alluxio.conf.AlluxioConfiguration;
+
 import javax.security.auth.Subject;
 
 /**
@@ -23,8 +25,8 @@ public class MasterClientConfig {
   /**
    * @return a master client configuration with default values
    */
-  public static MasterClientConfig defaults() {
-    return new MasterClientConfig().withMasterInquireClient(MasterInquireClient.Factory.create());
+  public static MasterClientConfig defaults(AlluxioConfiguration conf) {
+    return new MasterClientConfig().withMasterInquireClient(MasterInquireClient.Factory.create(conf));
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/master/MasterInquireClient.java b/core/common/src/main/java/alluxio/master/MasterInquireClient.java
index 4163a8e17e..8dce15b9c7 100644
--- a/core/common/src/main/java/alluxio/master/MasterInquireClient.java
+++ b/core/common/src/main/java/alluxio/master/MasterInquireClient.java
@@ -11,9 +11,8 @@
 
 package alluxio.master;
 
-import alluxio.AlluxioConfiguration;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.SingleMasterInquireClient.SingleMasterConnectDetails;
 import alluxio.master.ZkMasterInquireClient.ZkMasterConnectDetails;
@@ -69,16 +68,6 @@ public interface MasterInquireClient {
    * Factory for getting a master inquire client.
    */
   class Factory {
-    /**
-     * Creates an instance of {@link MasterInquireClient} based on the current configuration. The
-     * returned instance may be shared, so it should not be closed by callers of this method.
-     *
-     * @return a master inquire client
-     */
-    public static MasterInquireClient create() {
-      return create(Configuration.global());
-    }
-
     /**
      * @param conf configuration for creating the master inquire client
      * @return a master inquire client
@@ -98,17 +87,17 @@ public interface MasterInquireClient {
     }
 
     public static MasterInquireClient createForJobMaster() {
-      if (Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
-        return ZkMasterInquireClient.getClient(Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS),
-            Configuration.get(PropertyKey.ZOOKEEPER_JOB_ELECTION_PATH),
-            Configuration.get(PropertyKey.ZOOKEEPER_JOB_LEADER_PATH));
+      if (ServerConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
+        return ZkMasterInquireClient.getClient(ServgerConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS),
+            ServerConfiguration.get(PropertyKey.ZOOKEEPER_JOB_ELECTION_PATH),
+            ServerConfiguration.get(PropertyKey.ZOOKEEPER_JOB_LEADER_PATH));
       } else if (ConfigurationUtils.getJobMasterRpcAddresses(Configuration.global())
           .size() > 1) {
         return new PollingMasterInquireClient(
             ConfigurationUtils.getJobMasterRpcAddresses(Configuration.global()));
       } else {
         return new SingleMasterInquireClient(
-            NetworkAddressUtils.getConnectAddress(ServiceType.JOB_MASTER_RPC));
+            NetworkAddressUtils.getConnectAddress(ServiceType.JOB_MASTER_RPC, conf));
       }
     }
     /**
diff --git a/core/common/src/main/java/alluxio/master/PollingMasterInquireClient.java b/core/common/src/main/java/alluxio/master/PollingMasterInquireClient.java
index ffbc313eca..8d53dfaab4 100644
--- a/core/common/src/main/java/alluxio/master/PollingMasterInquireClient.java
+++ b/core/common/src/main/java/alluxio/master/PollingMasterInquireClient.java
@@ -13,6 +13,7 @@ package alluxio.master;
 
 import static java.util.stream.Collectors.joining;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.retry.ExponentialBackoffRetry;
@@ -22,6 +23,7 @@ import alluxio.grpc.GrpcChannelBuilder;
 import alluxio.grpc.ServiceType;
 import alluxio.grpc.ServiceVersionClientServiceGrpc;
 import alluxio.retry.RetryPolicy;
+import alluxio.security.authentication.AuthType;
 import alluxio.uri.Authority;
 import alluxio.uri.MultiMasterAuthority;
 
@@ -45,6 +47,7 @@ public class PollingMasterInquireClient implements MasterInquireClient {
 
   private final MultiMasterConnectDetails mConnectDetails;
   private final Supplier<RetryPolicy> mRetryPolicySupplier;
+  private final AlluxioConfiguration mConfiguration;
 
   /**
    * @param masterAddresses the potential master addresses
@@ -58,9 +61,11 @@ public class PollingMasterInquireClient implements MasterInquireClient {
    * @param retryPolicySupplier the retry policy supplier
    */
   public PollingMasterInquireClient(List<InetSocketAddress> masterAddresses,
-      Supplier<RetryPolicy> retryPolicySupplier) {
+      Supplier<RetryPolicy> retryPolicySupplier,
+      AlluxioConfiguration conf) {
     mConnectDetails = new MultiMasterConnectDetails(masterAddresses);
     mRetryPolicySupplier = retryPolicySupplier;
+    mConfiguration = conf;
   }
 
   @Override
@@ -98,7 +103,7 @@ public class PollingMasterInquireClient implements MasterInquireClient {
 
   private void pingMetaService(InetSocketAddress address)
       throws UnauthenticatedException, UnavailableException {
-    GrpcChannel channel = GrpcChannelBuilder.forAddress(address).build();
+    GrpcChannel channel = GrpcChannelBuilder.forAddress(address, mConfiguration).build();
     ServiceVersionClientServiceGrpc.ServiceVersionClientServiceBlockingStub versionClient =
         ServiceVersionClientServiceGrpc.newBlockingStub(channel);
     versionClient.getServiceVersion(GetServiceVersionPRequest.newBuilder()
diff --git a/core/common/src/main/java/alluxio/master/ZkMasterInquireClient.java b/core/common/src/main/java/alluxio/master/ZkMasterInquireClient.java
index 83b7a245d3..feaa827ee4 100644
--- a/core/common/src/main/java/alluxio/master/ZkMasterInquireClient.java
+++ b/core/common/src/main/java/alluxio/master/ZkMasterInquireClient.java
@@ -11,9 +11,7 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
 import alluxio.exception.status.UnavailableException;
 import alluxio.uri.Authority;
 import alluxio.uri.ZookeeperAuthority;
@@ -64,11 +62,11 @@ public final class ZkMasterInquireClient implements MasterInquireClient, Closeab
    * @return the client
    */
   public static synchronized ZkMasterInquireClient getClient(String zookeeperAddress,
-      String electionPath, String leaderPath) {
+      String electionPath, String leaderPath, int inquireRetryCount) {
     ZkMasterConnectDetails connectDetails =
         new ZkMasterConnectDetails(zookeeperAddress, leaderPath);
     if (!sCreatedClients.containsKey(connectDetails)) {
-      sCreatedClients.put(connectDetails, new ZkMasterInquireClient(connectDetails, electionPath));
+      sCreatedClients.put(connectDetails, new ZkMasterInquireClient(connectDetails, electionPath, inquireRetryCount));
     }
     return sCreatedClients.get(connectDetails);
   }
@@ -79,7 +77,7 @@ public final class ZkMasterInquireClient implements MasterInquireClient, Closeab
    * @param connectDetails connect details
    * @param electionPath the path of the master election
    */
-  private ZkMasterInquireClient(ZkMasterConnectDetails connectDetails, String electionPath) {
+  private ZkMasterInquireClient(ZkMasterConnectDetails connectDetails, String electionPath, int inquireRetryCount) {
     mConnectDetails = connectDetails;
     mElectionPath = electionPath;
 
@@ -88,7 +86,7 @@ public final class ZkMasterInquireClient implements MasterInquireClient, Closeab
     mClient = CuratorFrameworkFactory.newClient(connectDetails.getZkAddress(),
         new ExponentialBackoffRetry(Constants.SECOND_MS, 3));
 
-    mMaxTry = Configuration.getInt(PropertyKey.ZOOKEEPER_LEADER_INQUIRY_RETRY_COUNT);
+    mMaxTry = inquireRetryCount;
   }
 
   @Override
diff --git a/core/common/src/main/java/alluxio/metrics/MetricsSystem.java b/core/common/src/main/java/alluxio/metrics/MetricsSystem.java
index 72ebceeb67..e09428d525 100644
--- a/core/common/src/main/java/alluxio/metrics/MetricsSystem.java
+++ b/core/common/src/main/java/alluxio/metrics/MetricsSystem.java
@@ -12,11 +12,12 @@
 package alluxio.metrics;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.metrics.sink.Sink;
 import alluxio.util.CommonUtils;
 import alluxio.util.IdUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
 import com.codahale.metrics.Counter;
@@ -55,6 +56,9 @@ public final class MetricsSystem {
 
   private static final ConcurrentHashMap<String, String> CACHED_METRICS = new ConcurrentHashMap<>();
   private static String sAppId;
+  private static int sResolveTimeout =
+      (int)new InstancedConfiguration(ConfigurationUtils.defaults())
+               .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
 
   /**
    * An enum of supported instance type.
@@ -123,14 +127,13 @@ public final class MetricsSystem {
    * Starts sinks specified in the configuration. This is an no-op if the sinks have already been
    * started. Note: This has to be called after Alluxio configuration is initialized.
    */
-  public static void startSinks() {
+  public static void startSinks(String metricsConfFile) {
     synchronized (MetricsSystem.class) {
       if (sSinks != null) {
         LOG.info("Sinks have already been started.");
         return;
       }
     }
-    String metricsConfFile = Configuration.get(PropertyKey.METRICS_CONF_FILE);
     if (metricsConfFile.isEmpty()) {
       LOG.info("Metrics is not enabled.");
       return;
@@ -212,7 +215,7 @@ public final class MetricsSystem {
       case JOB_MASTER:
         return getJobMasterMetricName(name);
       case JOB_WORKER:
-        return getJobWorkerMetricName(name);
+        return getJobWorkerMetricName(name, sResolveTimeout);
       default:
         throw new IllegalStateException("Unknown process type");
     }
@@ -299,7 +302,7 @@ public final class MetricsSystem {
    * @param name the metric name
    * @return the metric registry name
    */
-  public static String getJobWorkerMetricName(String name) {
+  public static String getJobWorkerMetricName(String name, int resolveTimeoutMs) {
     return getMetricNameWithUniqueId(InstanceType.JOB_WORKER, name);
   }
 
@@ -312,7 +315,10 @@ public final class MetricsSystem {
    * @return the metric registry name
    */
   private static String getMetricNameWithUniqueId(InstanceType instance, String name) {
-    return instance + "." + NetworkAddressUtils.getLocalHostMetricName() + "." + name;
+    return instance
+        + "."
+        + NetworkAddressUtils.getLocalHostMetricName(sResolveTimeout)
+        + "." + name;
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/network/TieredIdentityFactory.java b/core/common/src/main/java/alluxio/network/TieredIdentityFactory.java
index 284cb62161..ab9b4e419f 100644
--- a/core/common/src/main/java/alluxio/network/TieredIdentityFactory.java
+++ b/core/common/src/main/java/alluxio/network/TieredIdentityFactory.java
@@ -11,10 +11,10 @@
 
 package alluxio.network;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
-import alluxio.PropertyKey.Template;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.PropertyKey.Template;
 import alluxio.util.ShellUtils;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.wire.TieredIdentity;
@@ -54,11 +54,11 @@ public final class TieredIdentityFactory {
   /**
    * @return the singleton tiered identity instance for this JVM
    */
-  public static TieredIdentity localIdentity() {
+  public static TieredIdentity localIdentity(AlluxioConfiguration conf) {
     if (sInstance == null) {
       synchronized (LOCK) {
         if (sInstance == null) {
-          sInstance = create();
+          sInstance = create(conf);
           LOG.info("Initialized tiered identity {}", sInstance);
         }
       }
@@ -72,11 +72,11 @@ public final class TieredIdentityFactory {
    * @return the created tiered identity
    */
   @VisibleForTesting
-  static TieredIdentity create() {
-    TieredIdentity scriptIdentity = fromScript();
+  static TieredIdentity create(AlluxioConfiguration conf) {
+    TieredIdentity scriptIdentity = fromScript(conf);
 
     List<LocalityTier> tiers = new ArrayList<>();
-    List<String> orderedTierNames = Configuration.getList(PropertyKey.LOCALITY_ORDER, ",");
+    List<String> orderedTierNames = conf.getList(PropertyKey.LOCALITY_ORDER, ",");
     for (int i = 0; i < orderedTierNames.size(); i++) {
       String tierName = orderedTierNames.get(i);
       String value = null;
@@ -86,15 +86,15 @@ public final class TieredIdentityFactory {
         value = scriptTier.getValue();
       }
       // Explicit configuration overrides script output.
-      if (Configuration.isSet(Template.LOCALITY_TIER.format(tierName))) {
-        value = Configuration.get(Template.LOCALITY_TIER.format(tierName));
+      if (conf.isSet(Template.LOCALITY_TIER.format(tierName))) {
+        value = conf.get(Template.LOCALITY_TIER.format(tierName));
       }
       tiers.add(new LocalityTier(tierName, value));
     }
     // If the user doesn't specify the value of the "node" tier, we fill in a sensible default.
     if (tiers.size() > 0 && tiers.get(0).getTierName().equals(Constants.LOCALITY_NODE)
         && tiers.get(0).getValue() == null) {
-      String name = NetworkAddressUtils.getLocalNodeName();
+      String name = NetworkAddressUtils.getLocalNodeName(conf);
       tiers.set(0, new LocalityTier(Constants.LOCALITY_NODE, name));
     }
     return new TieredIdentity(tiers);
@@ -104,8 +104,8 @@ public final class TieredIdentityFactory {
    * @return a tiered identity created from running the user-provided script
    */
   @Nullable
-  private static TieredIdentity fromScript() {
-    String scriptName = Configuration.get(PropertyKey.LOCALITY_SCRIPT);
+  private static TieredIdentity fromScript(AlluxioConfiguration conf) {
+    String scriptName = conf.get(PropertyKey.LOCALITY_SCRIPT);
     Path script = Paths.get(scriptName);
     if (!Files.exists(script)) {
       URL resource = TieredIdentityFactory.class.getClassLoader().getResource(scriptName);
@@ -124,7 +124,7 @@ public final class TieredIdentityFactory {
           String.format("Failed to run script %s: %s", script, e.toString()), e);
     }
     try {
-      return fromString(identityString);
+      return fromString(identityString, conf);
     } catch (IOException e) {
       throw new RuntimeException(
           String.format("Failed to parse output of running %s: %s", script, e.getMessage()), e);
@@ -135,8 +135,8 @@ public final class TieredIdentityFactory {
    * @param identityString tiered identity string to parse
    * @return the parsed tiered identity
    */
-  public static TieredIdentity fromString(String identityString) throws IOException {
-    Set<String> allTiers = Sets.newHashSet(Configuration.getList(PropertyKey.LOCALITY_ORDER, ","));
+  public static TieredIdentity fromString(String identityString, AlluxioConfiguration conf) throws IOException {
+    Set<String> allTiers = Sets.newHashSet(conf.getList(PropertyKey.LOCALITY_ORDER, ","));
     Map<String, String> tiers = new HashMap<>();
     for (String tier : identityString.split(",")) {
       String[] parts = tier.split("=");
@@ -159,7 +159,7 @@ public final class TieredIdentityFactory {
       tiers.put(key, parts[1].trim());
     }
     List<LocalityTier> tieredIdentity = new ArrayList<>();
-    for (String localityTier : Configuration.getList(PropertyKey.LOCALITY_ORDER, ",")) {
+    for (String localityTier : conf.getList(PropertyKey.LOCALITY_ORDER, ",")) {
       String value = tiers.containsKey(localityTier) ? tiers.get(localityTier) : null;
       tieredIdentity.add(new LocalityTier(localityTier, value));
     }
diff --git a/core/common/src/main/java/alluxio/retry/RetryUtils.java b/core/common/src/main/java/alluxio/retry/RetryUtils.java
index e3e9c21acb..664feea082 100644
--- a/core/common/src/main/java/alluxio/retry/RetryUtils.java
+++ b/core/common/src/main/java/alluxio/retry/RetryUtils.java
@@ -11,8 +11,7 @@
 
 package alluxio.retry;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -52,10 +51,10 @@ public final class RetryUtils {
   /**
    * @return the default client retry
    */
-  public static RetryPolicy defaultClientRetry() {
-    Duration maxRetryDuration = Configuration.getDuration(PropertyKey.USER_RPC_RETRY_MAX_DURATION);
-    Duration baseSleepMs = Configuration.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS);
-    Duration maxSleepMs = Configuration.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS);
+  public static RetryPolicy defaultClientRetry(Duration maxRetryDuration, Duration baseSleepMs, Duration maxSleepMs) {
+//    Duration maxRetryDuration = Configuration.getDuration(PropertyKey.USER_RPC_RETRY_MAX_DURATION);
+//    Duration baseSleepMs = Configuration.getDuration(PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS);
+//    Duration maxSleepMs = Configuration.getDuration(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS);
     return ExponentialTimeBoundedRetry.builder()
         .withMaxDuration(maxRetryDuration)
         .withInitialSleep(baseSleepMs)
@@ -66,10 +65,10 @@ public final class RetryUtils {
   /**
    * @return the default worker to master client retry
    */
-  public static RetryPolicy defaultWorkerMasterClientRetry() {
+  public static RetryPolicy defaultWorkerMasterClientRetry(
+      Duration workerMasterConnectRetryTimeout) {
     return ExponentialTimeBoundedRetry.builder()
-        .withMaxDuration(Duration
-            .ofMillis(Configuration.getMs(PropertyKey.WORKER_MASTER_CONNECT_RETRY_TIMEOUT)))
+        .withMaxDuration(workerMasterConnectRetryTimeout)
         .withInitialSleep(Duration.ofMillis(100))
         .withMaxSleep(Duration.ofSeconds(5))
         .build();
diff --git a/core/common/src/main/java/alluxio/security/LoginUser.java b/core/common/src/main/java/alluxio/security/LoginUser.java
index 5c6359128b..b1fe3ef25f 100644
--- a/core/common/src/main/java/alluxio/security/LoginUser.java
+++ b/core/common/src/main/java/alluxio/security/LoginUser.java
@@ -11,8 +11,8 @@
 
 package alluxio.security;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.security.authentication.AuthType;
 import alluxio.security.login.AppLoginModule;
@@ -53,11 +53,11 @@ public final class LoginUser {
    *
    * @return the login user
    */
-  public static User get() throws UnauthenticatedException {
+  public static User get(AlluxioConfiguration conf) throws UnauthenticatedException {
     if (sLoginUser == null) {
       synchronized (LoginUser.class) {
         if (sLoginUser == null) {
-          sLoginUser = login();
+          sLoginUser = login(conf);
         }
       }
     }
@@ -69,9 +69,8 @@ public final class LoginUser {
    *
    * @return the login user
    */
-  private static User login() throws UnauthenticatedException {
-    AuthType authType =
-        Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
+  private static User login(AlluxioConfiguration conf) throws UnauthenticatedException {
+    AuthType authType = conf.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
     checkSecurityEnabled(authType);
     Subject subject = new Subject();
 
@@ -80,7 +79,7 @@ public final class LoginUser {
       // class loader to dynamically instantiate login modules. This enables
       // Subject#getPrincipals to use reflection to search for User.class instances.
       LoginContext loginContext = createLoginContext(authType, subject, User.class.getClassLoader(),
-          new LoginModuleConfiguration());
+          new LoginModuleConfiguration(), conf);
       loginContext.login();
     } catch (LoginException e) {
       throw new UnauthenticatedException("Failed to login: " + e.getMessage(), e);
@@ -127,11 +126,12 @@ public final class LoginUser {
    * @throws LoginException if LoginContext cannot be created
    */
   private static LoginContext createLoginContext(AuthType authType, Subject subject,
-      ClassLoader classLoader, javax.security.auth.login.Configuration configuration)
+      ClassLoader classLoader, javax.security.auth.login.Configuration configuration,
+      AlluxioConfiguration alluxioConf)
       throws LoginException {
     CallbackHandler callbackHandler = null;
     if (authType.equals(AuthType.SIMPLE) || authType.equals(AuthType.CUSTOM)) {
-      callbackHandler = new AppLoginModule.AppCallbackHandler();
+      callbackHandler = new AppLoginModule.AppCallbackHandler(alluxioConf);
     }
 
     ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();
diff --git a/core/common/src/main/java/alluxio/security/authentication/AuthenticatedClientUser.java b/core/common/src/main/java/alluxio/security/authentication/AuthenticatedClientUser.java
index 2ab92fe297..0ff9c5e5ba 100644
--- a/core/common/src/main/java/alluxio/security/authentication/AuthenticatedClientUser.java
+++ b/core/common/src/main/java/alluxio/security/authentication/AuthenticatedClientUser.java
@@ -11,6 +11,7 @@
 
 package alluxio.security.authentication;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.security.User;
@@ -62,8 +63,8 @@ public final class AuthenticatedClientUser {
    * @return the client user, null if the user is not present
    */
   // TODO(peis): Fail early if the user is not able to be set to avoid returning null.
-  public static User get() throws IOException {
-    if (!SecurityUtils.isAuthenticationEnabled()) {
+  public static User get(AlluxioConfiguration conf) throws IOException {
+    if (!SecurityUtils.isAuthenticationEnabled(conf)) {
       throw new IOException(ExceptionMessage.AUTHENTICATION_IS_NOT_ENABLED.getMessage());
     }
     return sUserThreadLocal.get();
@@ -83,9 +84,9 @@ public final class AuthenticatedClientUser {
    * @throws AccessControlException there is no authenticated user for this thread or
    *         the authentication is not enabled
    */
-  public static String getClientUser() throws AccessControlException {
+  public static String getClientUser(AlluxioConfiguration conf) throws AccessControlException {
     try {
-      User user = get();
+      User user = get(conf);
       if (user == null) {
         throw new AccessControlException(
             ExceptionMessage.AUTHORIZED_CLIENT_USER_IS_NULL.getMessage());
diff --git a/core/common/src/main/java/alluxio/security/authentication/AuthenticationProvider.java b/core/common/src/main/java/alluxio/security/authentication/AuthenticationProvider.java
index 13ba465897..b3c33fe490 100644
--- a/core/common/src/main/java/alluxio/security/authentication/AuthenticationProvider.java
+++ b/core/common/src/main/java/alluxio/security/authentication/AuthenticationProvider.java
@@ -11,8 +11,8 @@
 
 package alluxio.security.authentication;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authentication.plain.CustomAuthenticationProvider;
 import alluxio.security.authentication.plain.PlainSaslServer;
 import alluxio.security.authentication.plain.PlainSaslServerCallbackHandler;
@@ -39,14 +39,14 @@ public interface AuthenticationProvider {
      * @return the generated {@link AuthenticationProvider}
      * @throws AuthenticationException when unsupported authentication type is used
      */
-    public static AuthenticationProvider create(AuthType authType)
+    public static AuthenticationProvider create(AuthType authType, AlluxioConfiguration conf)
         throws AuthenticationException {
       switch (authType) {
         case SIMPLE:
           return new SimpleAuthenticationProvider();
         case CUSTOM:
           String customProviderName =
-              Configuration.get(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS);
+              conf.get(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS);
           return new CustomAuthenticationProvider(customProviderName);
         default:
           throw new AuthenticationException("Unsupported AuthType: " + authType.getAuthName());
diff --git a/core/common/src/main/java/alluxio/security/authentication/AuthenticationServer.java b/core/common/src/main/java/alluxio/security/authentication/AuthenticationServer.java
index faf184b05b..c669a764ee 100644
--- a/core/common/src/main/java/alluxio/security/authentication/AuthenticationServer.java
+++ b/core/common/src/main/java/alluxio/security/authentication/AuthenticationServer.java
@@ -11,6 +11,7 @@
 
 package alluxio.security.authentication;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnauthenticatedException;
 
 import io.grpc.BindableService;
diff --git a/core/common/src/main/java/alluxio/security/authentication/ChannelAuthenticator.java b/core/common/src/main/java/alluxio/security/authentication/ChannelAuthenticator.java
index 80dd6aab6f..38ea1a373a 100644
--- a/core/common/src/main/java/alluxio/security/authentication/ChannelAuthenticator.java
+++ b/core/common/src/main/java/alluxio/security/authentication/ChannelAuthenticator.java
@@ -11,6 +11,8 @@
 
 package alluxio.security.authentication;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.SaslAuthenticationServiceGrpc;
@@ -27,6 +29,7 @@ import io.grpc.stub.StreamObserver;
 
 import javax.security.auth.Subject;
 import javax.security.sasl.SaslClient;
+import java.security.Security;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -53,17 +56,19 @@ public class ChannelAuthenticator {
   /** Internal ID used to identify the channel that is being authenticated. */
   protected UUID mChannelId;
 
+  private boolean mSecurityEnabled;
+
   /**
    * Creates {@link ChannelAuthenticator} instance.
    *
    * @param subject javax subject to use for authentication
-   * @param authType authentication type
    */
-  public ChannelAuthenticator(Subject subject, AuthType authType) {
+  public ChannelAuthenticator(Subject subject, AlluxioConfiguration conf) {
     mUseSubject = true;
     mChannelId = UUID.randomUUID();
     mParentSubject = subject;
-    mAuthType = authType;
+    mAuthType = conf.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
+    mSecurityEnabled = SecurityUtils.isSecurityEnabled(conf);
   }
 
   /**
@@ -92,7 +97,7 @@ public class ChannelAuthenticator {
    * @return channel that is augmented for authentication
    * @throws UnauthenticatedException
    */
-  public Channel authenticate(ManagedChannel managedChannel)
+  public Channel authenticate(ManagedChannel managedChannel, AlluxioConfiguration conf)
       throws UnauthenticatedException, UnavailableException {
     if (mAuthType == AuthType.NOSASL) {
       return managedChannel;
@@ -103,7 +108,7 @@ public class ChannelAuthenticator {
     SaslClient saslClient;
     if (mUseSubject) {
       saslClient =
-          SaslParticipantProvider.Factory.create(mAuthType).createSaslClient(mParentSubject);
+          SaslParticipantProvider.Factory.create(mAuthType).createSaslClient(mParentSubject, conf);
     } else {
       saslClient = SaslParticipantProvider.Factory.create(mAuthType).createSaslClient(mUserName,
           mPassword, mImpersonationUser);
@@ -133,7 +138,7 @@ public class ChannelAuthenticator {
    * @return the list of interceptors that are required for configured authentication
    */
   private List<ClientInterceptor> getInterceptors(SaslClient saslClient) {
-    if (!SecurityUtils.isSecurityEnabled()) {
+    if (mSecurityEnabled) {
       return Collections.emptyList();
     }
     List<ClientInterceptor> interceptorsList = new ArrayList<>();
diff --git a/core/common/src/main/java/alluxio/security/authentication/DefaultAuthenticationServer.java b/core/common/src/main/java/alluxio/security/authentication/DefaultAuthenticationServer.java
index 033f620b13..6c4585da42 100644
--- a/core/common/src/main/java/alluxio/security/authentication/DefaultAuthenticationServer.java
+++ b/core/common/src/main/java/alluxio/security/authentication/DefaultAuthenticationServer.java
@@ -11,8 +11,8 @@
 
 package alluxio.security.authentication;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.grpc.SaslAuthenticationServiceGrpc;
 import alluxio.grpc.SaslMessage;
@@ -59,11 +59,14 @@ public class DefaultAuthenticationServer
   protected final long mCleanupIntervalMs =
       Configuration.getMs(PropertyKey.AUTHENTICATION_STALE_CHANNEL_PURGE_INTERVAL);
 
+  private final AlluxioConfiguration mConfiguration;
+
   /**
    * Creates {@link DefaultAuthenticationServer} instance.
    */
-  public DefaultAuthenticationServer() {
-    checkSupported(Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class));
+  public DefaultAuthenticationServer(AlluxioConfiguration conf) {
+    checkSupported(conf.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class));
+    mConfiguration = conf;
     mChannels = new ConcurrentHashMap<>();
     mScheduler = Executors.newScheduledThreadPool(1,
         ThreadFactoryUtils.build("auth-cleanup", true));
@@ -75,7 +78,7 @@ public class DefaultAuthenticationServer
   @Override
   public StreamObserver<SaslMessage> authenticate(StreamObserver<SaslMessage> responseObserver) {
     // Create and return server sasl driver that will coordinate authentication traffic.
-    SaslStreamServerDriver driver = new SaslStreamServerDriver(this);
+    SaslStreamServerDriver driver = new SaslStreamServerDriver(this, mConfiguration);
     driver.setClientObserver(responseObserver);
     return driver;
   }
@@ -158,12 +161,11 @@ public class DefaultAuthenticationServer
 
   @Override
   public List<ServerInterceptor> getInterceptors() {
-    if (!SecurityUtils.isSecurityEnabled()) {
+    if (!SecurityUtils.isSecurityEnabled(mConfiguration)) {
       return Collections.emptyList();
     }
     List<ServerInterceptor> interceptorsList = new ArrayList<>();
-    AuthType authType =
-        Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
+    AuthType authType = mConfiguration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
     checkSupported(authType);
     switch (authType) {
       case SIMPLE:
diff --git a/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java b/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java
index 348b581d29..c8fe4e7e47 100644
--- a/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java
+++ b/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java
@@ -11,8 +11,8 @@
 
 package alluxio.security.authentication;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.util.CommonUtils;
 
@@ -45,14 +45,18 @@ public final class ImpersonationAuthenticator {
   // Maps users configured for impersonation to the set of users which they can impersonate.
   private final Map<String, Set<String>> mImpersonationUsers;
 
+  private AlluxioConfiguration mConfiguration;
+
   /**
    * Constructs a new {@link ImpersonationAuthenticator}.
    */
-  public ImpersonationAuthenticator() {
+  public ImpersonationAuthenticator(AlluxioConfiguration conf) {
     mImpersonationGroups = new HashMap<>();
     mImpersonationUsers = new HashMap<>();
-    for (PropertyKey key : Configuration.keySet()) {
-      String value = Configuration.getOrDefault(key, null);
+    mConfiguration = conf;
+
+    for (PropertyKey key : conf.keySet()) {
+      String value = conf.getOrDefault(key, null);
       // Process impersonation groups
       Matcher matcher =
           PropertyKey.Template.MASTER_IMPERSONATION_GROUPS_OPTION.match(key.getName());
@@ -110,7 +114,7 @@ public final class ImpersonationAuthenticator {
         return;
       }
       try {
-        for (String impersonationGroup : CommonUtils.getGroups(impersonationUser)) {
+        for (String impersonationGroup : CommonUtils.getGroups(impersonationUser, mConfiguration)) {
           if (allowedGroups.contains(impersonationGroup)) {
             // Impersonation is allowed for this group
             return;
diff --git a/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProvider.java b/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProvider.java
index ed532e7e89..e129ca2eb6 100644
--- a/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProvider.java
+++ b/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProvider.java
@@ -11,6 +11,7 @@
 
 package alluxio.security.authentication;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.security.authentication.plain.SaslParticipantProviderPlain;
 
@@ -31,7 +32,8 @@ public interface SaslParticipantProvider {
    * @return created {@link SaslClient}
    * @throws UnauthenticatedException
    */
-  public SaslClient createSaslClient(Subject subject) throws UnauthenticatedException;
+  public SaslClient createSaslClient(Subject subject, AlluxioConfiguration conf)
+      throws UnauthenticatedException;
 
   /**
    * Creates {@link SaslClient} for given authentication info.
@@ -52,7 +54,8 @@ public interface SaslParticipantProvider {
    * @return created {@link SaslServer}
    * @throws SaslException
    */
-  public SaslServer createSaslServer(String serverName) throws SaslException;
+  public SaslServer createSaslServer(String serverName, AlluxioConfiguration conf)
+      throws SaslException;
 
   /**
    * Creates {@link SaslServer}.
@@ -62,7 +65,8 @@ public interface SaslParticipantProvider {
    * @return created {@link SaslServer}
    * @throws SaslException
    */
-  public SaslServer createSaslServer(Runnable runnable, String serverName) throws SaslException;
+  public SaslServer createSaslServer(Runnable runnable, String serverName,
+      AlluxioConfiguration conf) throws SaslException;
 
   /**
    * Factory for {@link SaslParticipantProvider}.
diff --git a/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProviderUtils.java b/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProviderUtils.java
index 863b3537e8..4e648f10fc 100644
--- a/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProviderUtils.java
+++ b/core/common/src/main/java/alluxio/security/authentication/SaslParticipantProviderUtils.java
@@ -11,9 +11,9 @@
 
 package alluxio.security.authentication;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.User;
 
 import org.slf4j.Logger;
@@ -37,7 +37,7 @@ public final class SaslParticipantProviderUtils {
    * @return the configured impersonation user, or null if impersonation is not used
    */
   @Nullable
-  public static String getImpersonationUser(Subject subject) {
+  public static String getImpersonationUser(Subject subject, AlluxioConfiguration conf) {
     // The user of the hdfs client
     String hdfsUser = null;
 
@@ -52,8 +52,8 @@ public final class SaslParticipantProviderUtils {
 
     // Determine the impersonation user
     String impersonationUser = null;
-    if (Configuration.isSet(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME)) {
-      impersonationUser = Configuration.get(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME);
+    if (conf.isSet(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME)) {
+      impersonationUser = conf.get(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME);
       LOG.debug("Impersonation: configured: {}", impersonationUser);
       if (Constants.IMPERSONATION_HDFS_USER.equals(impersonationUser)) {
         // Impersonate as the hdfs client user
diff --git a/core/common/src/main/java/alluxio/security/authentication/SaslStreamServerDriver.java b/core/common/src/main/java/alluxio/security/authentication/SaslStreamServerDriver.java
index b70cfac13f..7326a67aab 100644
--- a/core/common/src/main/java/alluxio/security/authentication/SaslStreamServerDriver.java
+++ b/core/common/src/main/java/alluxio/security/authentication/SaslStreamServerDriver.java
@@ -11,6 +11,7 @@
 
 package alluxio.security.authentication;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.grpc.GrpcExceptionUtils;
 import alluxio.grpc.SaslMessage;
@@ -35,14 +36,16 @@ public class SaslStreamServerDriver implements StreamObserver<SaslMessage> {
   private UUID mChannelId;
   /** Sasl server that will be used for authentication. */
   private SaslServer mSaslServer = null;
+  private final AlluxioConfiguration mConfiguration;
 
   /**
    * Creates {@link SaslStreamServerDriver} for given {@link AuthenticationServer}.
    *
    * @param authenticationServer authentication server
    */
-  public SaslStreamServerDriver(AuthenticationServer authenticationServer) {
+  public SaslStreamServerDriver(AuthenticationServer authenticationServer, AlluxioConfiguration conf) {
     mAuthenticationServer = authenticationServer;
+    mConfiguration = conf;
   }
 
   /**
@@ -65,7 +68,7 @@ public class SaslStreamServerDriver implements StreamObserver<SaslMessage> {
         AuthType authType = AuthType.valueOf(saslMessage.getAuthenticationName());
         // TODO(ggezer) wire server name?
         mSaslServer =
-            SaslParticipantProvider.Factory.create(authType).createSaslServer("localhost");
+            SaslParticipantProvider.Factory.create(authType).createSaslServer("localhost", mConfiguration);
         mSaslHandshakeServerHandler =
             SaslHandshakeServerHandler.Factory.create(authType, mSaslServer);
         // Unregister from registry if in case it was authenticated before.
diff --git a/core/common/src/main/java/alluxio/security/authentication/plain/CustomAuthenticationProvider.java b/core/common/src/main/java/alluxio/security/authentication/plain/CustomAuthenticationProvider.java
index 80cb7466fa..61b15d0ddd 100644
--- a/core/common/src/main/java/alluxio/security/authentication/plain/CustomAuthenticationProvider.java
+++ b/core/common/src/main/java/alluxio/security/authentication/plain/CustomAuthenticationProvider.java
@@ -11,7 +11,6 @@
 
 package alluxio.security.authentication.plain;
 
-import alluxio.Configuration;
 import alluxio.security.authentication.AuthType;
 import alluxio.security.authentication.AuthenticationProvider;
 import alluxio.util.CommonUtils;
@@ -22,9 +21,9 @@ import javax.security.sasl.AuthenticationException;
 /**
  * An authentication provider implementation that allows {@link AuthenticationProvider} to be
  * customized at configuration time. This authentication provider is created if authentication type
- * specified in {@link Configuration} is {@link AuthType#CUSTOM}. It requires the property
- * {@code alluxio.security.authentication.custom.provider} to be set in {@link Configuration
- * Configuration} to determine which provider to load.
+ * specified in {@link alluxio.conf.AlluxioConfiguration} is {@link AuthType#CUSTOM}. It requires
+ * the property {@code alluxio.security.authentication.custom.provider} to be set in
+ * {@link alluxio.conf.AlluxioConfiguration} to determine which provider to load.
  */
 @NotThreadSafe
 public final class CustomAuthenticationProvider implements AuthenticationProvider {
diff --git a/core/common/src/main/java/alluxio/security/authentication/plain/PlainSaslServerCallbackHandler.java b/core/common/src/main/java/alluxio/security/authentication/plain/PlainSaslServerCallbackHandler.java
index 493a87342a..bf817eead9 100644
--- a/core/common/src/main/java/alluxio/security/authentication/plain/PlainSaslServerCallbackHandler.java
+++ b/core/common/src/main/java/alluxio/security/authentication/plain/PlainSaslServerCallbackHandler.java
@@ -11,6 +11,7 @@
 
 package alluxio.security.authentication.plain;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.security.authentication.AuthenticatedClientUser;
 import alluxio.security.authentication.AuthenticationProvider;
 import alluxio.security.authentication.ImpersonationAuthenticator;
@@ -43,11 +44,11 @@ public final class PlainSaslServerCallbackHandler implements CallbackHandler {
    * @param callback the callback runs when the authentication is established
    */
   public PlainSaslServerCallbackHandler(AuthenticationProvider authenticationProvider,
-      Runnable callback) {
+      Runnable callback, AlluxioConfiguration conf) {
     mAuthenticationProvider = Preconditions.checkNotNull(authenticationProvider,
         "authenticationProvider");
     mCallback = callback;
-    mImpersonationAuthenticator = new ImpersonationAuthenticator();
+    mImpersonationAuthenticator = new ImpersonationAuthenticator(conf);
   }
 
   @Override
diff --git a/core/common/src/main/java/alluxio/security/authentication/plain/SaslParticipantProviderPlain.java b/core/common/src/main/java/alluxio/security/authentication/plain/SaslParticipantProviderPlain.java
index d9ee2a3ec4..76e68ef1ef 100644
--- a/core/common/src/main/java/alluxio/security/authentication/plain/SaslParticipantProviderPlain.java
+++ b/core/common/src/main/java/alluxio/security/authentication/plain/SaslParticipantProviderPlain.java
@@ -11,9 +11,9 @@
 
 package alluxio.security.authentication.plain;
 
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.security.LoginUser;
 import alluxio.security.User;
@@ -41,7 +41,7 @@ public class SaslParticipantProviderPlain implements SaslParticipantProvider {
   }
 
   @Override
-  public SaslClient createSaslClient(Subject subject) throws UnauthenticatedException {
+  public SaslClient createSaslClient(Subject subject, AlluxioConfiguration conf) throws UnauthenticatedException {
     String username = null;
     String password = "noPassword";
 
@@ -52,21 +52,21 @@ public class SaslParticipantProviderPlain implements SaslParticipantProvider {
       }
     }
     if (username == null || username.isEmpty()) {
-      username = LoginUser.get().getName();
+      username = LoginUser.get(conf).getName();
     }
 
     // Determine the impersonation user
-    String impersonationUser = SaslParticipantProviderUtils.getImpersonationUser(subject);
+    String impersonationUser = SaslParticipantProviderUtils.getImpersonationUser(subject, conf);
 
     if (impersonationUser != null
-        && Configuration.isSet(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME)
+        && conf.isSet(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME)
         && Constants.IMPERSONATION_HDFS_USER
-            .equals(Configuration.get(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME))) {
+            .equals(conf.get(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME))) {
       // If impersonation is configured to use the HDFS user, the connection user should
       // be not be the HDFS user, but the LoginUser.
       // If the HDFS user is really supposed to be the connection user, that can be achieved by
       // not enabling impersonation for the client.
-      username = LoginUser.get().getName();
+      username = LoginUser.get(conf).getName();
     }
     return createSaslClient(username, password, impersonationUser);
   }
@@ -84,19 +84,19 @@ public class SaslParticipantProviderPlain implements SaslParticipantProvider {
   }
 
   @Override
-  public SaslServer createSaslServer(String serverName) throws SaslException {
+  public SaslServer createSaslServer(String serverName, AlluxioConfiguration conf) throws SaslException {
     return createSaslServer(new Runnable() {
       @Override
       public void run() {}
-    }, serverName);
+    }, serverName, conf);
   }
 
   @Override
-  public SaslServer createSaslServer(Runnable runnable, String serverName) throws SaslException {
+  public SaslServer createSaslServer(Runnable runnable, String serverName, AlluxioConfiguration conf) throws SaslException {
     AuthType authType =
-        Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
-    AuthenticationProvider provider = AuthenticationProvider.Factory.create(authType);
+        conf.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
+    AuthenticationProvider provider = AuthenticationProvider.Factory.create(authType, conf);
     return Sasl.createSaslServer(PlainSaslServerProvider.MECHANISM, null, serverName,
-        new HashMap<String, String>(), new PlainSaslServerCallbackHandler(provider, runnable));
+        new HashMap<String, String>(), new PlainSaslServerCallbackHandler(provider, runnable, conf));
   }
 }
diff --git a/core/common/src/main/java/alluxio/security/group/CachedGroupMapping.java b/core/common/src/main/java/alluxio/security/group/CachedGroupMapping.java
index 0a0078ab53..0f7efe1a68 100644
--- a/core/common/src/main/java/alluxio/security/group/CachedGroupMapping.java
+++ b/core/common/src/main/java/alluxio/security/group/CachedGroupMapping.java
@@ -11,9 +11,6 @@
 
 package alluxio.security.group;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
-
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
@@ -56,20 +53,20 @@ public class CachedGroupMapping implements GroupMappingService {
    *
    * @param service group mapping service
    */
-  public CachedGroupMapping(GroupMappingService service) {
+  public CachedGroupMapping(GroupMappingService service, long groupMappingCacheTimeout) {
     mService = service;
-    long timeoutMs = Configuration.getMs(PropertyKey.SECURITY_GROUP_MAPPING_CACHE_TIMEOUT_MS);
-    mCacheEnabled = timeoutMs > 0;
+//    long groupMappingCacheTimeout = Configuration.getMs(PropertyKey.SECURITY_GROUP_MAPPING_CACHE_TIMEOUT_MS);
+    mCacheEnabled = groupMappingCacheTimeout > 0;
     if (mCacheEnabled) {
       mCache = CacheBuilder.newBuilder()
           // the maximum number of entries the cache may contain.
           .maximumSize(MAXSIZE)
           // active entries are eligible for automatic refresh once the specified time duration has
           // elapsed after the entry was last modified.
-          .refreshAfterWrite(timeoutMs, TimeUnit.MILLISECONDS)
+          .refreshAfterWrite(groupMappingCacheTimeout, TimeUnit.MILLISECONDS)
           // each entry should be automatically removed from the cache once the specified time
           // duration has elapsed after the entry was last modified.
-          .expireAfterWrite(10 * timeoutMs, TimeUnit.MILLISECONDS)
+          .expireAfterWrite(10 * groupMappingCacheTimeout, TimeUnit.MILLISECONDS)
           .build(new GroupMappingCacheLoader());
     }
   }
diff --git a/core/common/src/main/java/alluxio/security/group/GroupMappingService.java b/core/common/src/main/java/alluxio/security/group/GroupMappingService.java
index ab36e767d7..5aad214d53 100644
--- a/core/common/src/main/java/alluxio/security/group/GroupMappingService.java
+++ b/core/common/src/main/java/alluxio/security/group/GroupMappingService.java
@@ -11,8 +11,8 @@
 
 package alluxio.security.group;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 import alluxio.util.CommonUtils;
 
@@ -50,15 +50,16 @@ public interface GroupMappingService {
      *
      * @return the groups mapping service being used to map user-to-groups
      */
-    public static GroupMappingService get() {
+    public static GroupMappingService get(AlluxioConfiguration conf) {
       if (sCachedGroupMapping == null) {
         synchronized (Factory.class) {
           if (sCachedGroupMapping == null) {
             LOG.debug("Creating new Groups object");
             GroupMappingService groupMappingService =
-                CommonUtils.createNewClassInstance(Configuration.<GroupMappingService>getClass(
+                CommonUtils.createNewClassInstance(conf.<GroupMappingService>getClass(
                     PropertyKey.SECURITY_GROUP_MAPPING_CLASS), null, null);
-            sCachedGroupMapping = new CachedGroupMapping(groupMappingService);
+            long cacheTimeout = conf.getMs(PropertyKey.SECURITY_GROUP_MAPPING_CACHE_TIMEOUT_MS);
+            sCachedGroupMapping = new CachedGroupMapping(groupMappingService, cacheTimeout);
           }
         }
       }
diff --git a/core/common/src/main/java/alluxio/security/login/AppLoginModule.java b/core/common/src/main/java/alluxio/security/login/AppLoginModule.java
index ebe4f28dcf..a45b479e54 100644
--- a/core/common/src/main/java/alluxio/security/login/AppLoginModule.java
+++ b/core/common/src/main/java/alluxio/security/login/AppLoginModule.java
@@ -11,8 +11,8 @@
 
 package alluxio.security.login;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.User;
 
 import java.io.IOException;
@@ -152,9 +152,9 @@ public final class AppLoginModule implements LoginModule {
     /**
      * Creates a new instance of {@link AppCallbackHandler}.
      */
-    public AppCallbackHandler() {
-      if (Configuration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME)) {
-        mUserName = Configuration.get(PropertyKey.SECURITY_LOGIN_USERNAME);
+    public AppCallbackHandler(AlluxioConfiguration conf) {
+      if (conf.isSet(PropertyKey.SECURITY_LOGIN_USERNAME)) {
+        mUserName = conf.get(PropertyKey.SECURITY_LOGIN_USERNAME);
       } else {
         mUserName = "";
       }
diff --git a/core/common/src/main/java/alluxio/underfs/BaseUnderFileSystem.java b/core/common/src/main/java/alluxio/underfs/BaseUnderFileSystem.java
index bca286e695..8673dd53be 100644
--- a/core/common/src/main/java/alluxio/underfs/BaseUnderFileSystem.java
+++ b/core/common/src/main/java/alluxio/underfs/BaseUnderFileSystem.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.Constants;
 import alluxio.SyncInfo;
 import alluxio.collections.Pair;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.security.authorization.AccessControlList;
 import alluxio.security.authorization.AclEntry;
 import alluxio.security.authorization.DefaultAccessControlList;
@@ -55,20 +56,24 @@ public abstract class BaseUnderFileSystem implements UnderFileSystem {
   /** UFS Configuration options. */
   protected final UnderFileSystemConfiguration mUfsConf;
 
+  protected final AlluxioConfiguration mAlluxioConf;
+
+
   /**
    * Constructs an {@link BaseUnderFileSystem}.
    *
    * @param uri the {@link AlluxioURI} used to create this ufs
    * @param ufsConf UFS configuration
    */
-  protected BaseUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration ufsConf) {
+  protected BaseUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
     mUri = Preconditions.checkNotNull(uri, "uri");
     mUfsConf = Preconditions.checkNotNull(ufsConf, "ufsConf");
+    mAlluxioConf = Preconditions.checkNotNull(alluxioConf, "alluxioConf");
   }
 
   @Override
   public OutputStream create(String path) throws IOException {
-    return create(path, CreateOptions.defaults().setCreateParent(true));
+    return create(path, CreateOptions.defaults(mUfsConf).setCreateParent(true));
   }
 
   @Override
@@ -181,7 +186,7 @@ public abstract class BaseUnderFileSystem implements UnderFileSystem {
 
   @Override
   public boolean mkdirs(String path) throws IOException {
-    return mkdirs(path, MkdirsOptions.defaults());
+    return mkdirs(path, MkdirsOptions.defaults(mUfsConf));
   }
 
   @Override
diff --git a/core/common/src/main/java/alluxio/underfs/MultiRangeObjectInputStream.java b/core/common/src/main/java/alluxio/underfs/MultiRangeObjectInputStream.java
index 8aec69bc45..4739a05ae2 100644
--- a/core/common/src/main/java/alluxio/underfs/MultiRangeObjectInputStream.java
+++ b/core/common/src/main/java/alluxio/underfs/MultiRangeObjectInputStream.java
@@ -11,8 +11,7 @@
 
 package alluxio.underfs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.exception.ExceptionMessage;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -34,6 +33,9 @@ public abstract class MultiRangeObjectInputStream extends InputStream {
   /** Position the current stream was open till (exclusive). */
   protected long mEndPos;
 
+  /** The block size to read with. */
+  protected long mBlockSize = -1L;
+
   @Override
   public void close() throws IOException {
     if (!mClosed) {
@@ -112,16 +114,17 @@ public abstract class MultiRangeObjectInputStream extends InputStream {
    * @param endPos end position in bytes (exclusive)
    * @return a new {@link InputStream}
    */
-  protected abstract InputStream createStream(long startPos, long endPos) throws IOException;
+  protected abstract InputStream createStream(long startPos, long endPos, long blockSize) throws IOException;
 
   /**
    * Block size for reading an object in chunks.
    *
    * @return block size in bytes
    */
-  private long getBlockSize() {
-    return Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
-  }
+//  private long getBlockSize() {
+//    return Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+//
+//  }
 
   /**
    * Opens a new stream at mPos if the wrapped stream mStream is null.
@@ -130,12 +133,15 @@ public abstract class MultiRangeObjectInputStream extends InputStream {
     if (mClosed) {
       throw new IOException("Stream closed");
     }
+    if (mBlockSize <= 0) {
+      throw new IOException(ExceptionMessage.BLOCK_SIZE_INVALID.getMessage(mBlockSize));
+    }
+
     if (mStream != null) { // stream is already open
       return;
     }
-    final long blockSize = getBlockSize();
-    final long endPos = mPos + blockSize - (mPos % blockSize);
+    final long endPos = mPos + mBlockSize - (mPos % mBlockSize);
     mEndPos = endPos;
-    mStream = createStream(mPos, endPos);
+    mStream = createStream(mPos, endPos, mBlockSize);
   }
 }
diff --git a/core/common/src/main/java/alluxio/underfs/ObjectUnderFileSystem.java b/core/common/src/main/java/alluxio/underfs/ObjectUnderFileSystem.java
index d89efd69eb..38f05a24b0 100644
--- a/core/common/src/main/java/alluxio/underfs/ObjectUnderFileSystem.java
+++ b/core/common/src/main/java/alluxio/underfs/ObjectUnderFileSystem.java
@@ -12,8 +12,8 @@
 package alluxio.underfs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.retry.ExponentialBackoffRetry;
 import alluxio.retry.RetryPolicy;
@@ -78,10 +78,9 @@ public abstract class ObjectUnderFileSystem extends BaseUnderFileSystem {
    * @param uri the {@link AlluxioURI} used to create this ufs
    * @param ufsConf UFS configuration
    */
-  protected ObjectUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration ufsConf) {
-    super(uri, ufsConf);
-
-    int numThreads = Configuration.getInt(PropertyKey.UNDERFS_OBJECT_STORE_SERVICE_THREADS);
+  protected ObjectUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
+    super(uri, ufsConf, alluxioConf);
+    int numThreads = mAlluxioConf.getInt(PropertyKey.UNDERFS_OBJECT_STORE_SERVICE_THREADS);
     mExecutorService = ExecutorServiceFactories.fixedThreadPool(
         "alluxio-underfs-object-service-worker", numThreads).create();
   }
@@ -324,7 +323,7 @@ public abstract class ObjectUnderFileSystem extends BaseUnderFileSystem {
      */
     public void add(String path) throws IOException {
       // Delete batch size is same as listing length
-      if (mCurrentBatchBuffer.size() == getListingChunkLength()) {
+      if (mCurrentBatchBuffer.size() == getListingChunkLength(mAlluxioConf)) {
         // Batch is full
         submitBatch();
       }
@@ -407,7 +406,7 @@ public abstract class ObjectUnderFileSystem extends BaseUnderFileSystem {
    */
   @Override
   public long getBlockSizeByte(String path) throws IOException {
-    return Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+    return mAlluxioConf.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
   }
 
   @Override
@@ -544,9 +543,9 @@ public abstract class ObjectUnderFileSystem extends BaseUnderFileSystem {
   public InputStream open(String path, OpenOptions options) throws IOException {
     IOException thrownException = null;
     RetryPolicy retryPolicy = new ExponentialBackoffRetry(
-        (int) Configuration.getMs(PropertyKey.UNDERFS_OBJECT_STORE_READ_RETRY_BASE_SLEEP_MS),
-        (int) Configuration.getMs(PropertyKey.UNDERFS_OBJECT_STORE_READ_RETRY_MAX_SLEEP_MS),
-        Configuration.getInt(PropertyKey.UNDERFS_OBJECT_STORE_READ_RETRY_MAX_NUM));
+        (int)  mAlluxioConf.getMs(PropertyKey.UNDERFS_OBJECT_STORE_READ_RETRY_BASE_SLEEP_MS),
+        (int) mAlluxioConf.getMs(PropertyKey.UNDERFS_OBJECT_STORE_READ_RETRY_MAX_SLEEP_MS),
+        mAlluxioConf.getInt(PropertyKey.UNDERFS_OBJECT_STORE_READ_RETRY_MAX_NUM));
     while (retryPolicy.attempt()) {
       try {
         return openObject(stripPrefixIfPresent(path), options);
@@ -703,9 +702,9 @@ public abstract class ObjectUnderFileSystem extends BaseUnderFileSystem {
    *
    * @return length of each list request
    */
-  protected int getListingChunkLength() {
-    return Configuration.getInt(PropertyKey.UNDERFS_LISTING_LENGTH) > getListingChunkLengthMax()
-        ? getListingChunkLengthMax() : Configuration.getInt(PropertyKey.UNDERFS_LISTING_LENGTH);
+  protected int getListingChunkLength(AlluxioConfiguration conf) {
+    return conf.getInt(PropertyKey.UNDERFS_LISTING_LENGTH) > getListingChunkLengthMax()
+        ? getListingChunkLengthMax() : conf.getInt(PropertyKey.UNDERFS_LISTING_LENGTH);
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/underfs/UnderFileSystem.java b/core/common/src/main/java/alluxio/underfs/UnderFileSystem.java
index f06186c445..c61436eb91 100644
--- a/core/common/src/main/java/alluxio/underfs/UnderFileSystem.java
+++ b/core/common/src/main/java/alluxio/underfs/UnderFileSystem.java
@@ -12,8 +12,8 @@
 package alluxio.underfs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 import alluxio.SyncInfo;
 import alluxio.collections.Pair;
@@ -65,8 +65,8 @@ public interface UnderFileSystem extends Closeable {
      * @param path the file path storing over the ufs
      * @return instance of the under layer file system
      */
-    public static UnderFileSystem create(String path) {
-      return create(path, UnderFileSystemConfiguration.defaults());
+    public static UnderFileSystem create(String path, AlluxioConfiguration conf) {
+      return create(path, UnderFileSystemConfiguration.defaults(), conf);
     }
 
     /**
@@ -76,8 +76,8 @@ public interface UnderFileSystem extends Closeable {
      * @param path journal path in ufs
      * @return the instance of under file system for Alluxio journal directory
      */
-    public static UnderFileSystem create(URI path) {
-      return create(path.toString());
+    public static UnderFileSystem create(URI path, AlluxioConfiguration conf) {
+      return create(path.toString(), conf);
     }
 
     /**
@@ -89,10 +89,10 @@ public interface UnderFileSystem extends Closeable {
      * @param ufsConf optional configuration object for the UFS, may be null
      * @return client for the under file system
      */
-    public static UnderFileSystem create(String path, UnderFileSystemConfiguration ufsConf) {
+    public static UnderFileSystem create(String path, UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
       // Try to obtain the appropriate factory
       List<UnderFileSystemFactory> factories =
-          UnderFileSystemFactoryRegistry.findAll(path, ufsConf);
+          UnderFileSystemFactoryRegistry.findAll(path, ufsConf, alluxioConf);
       if (factories.isEmpty()) {
         throw new IllegalArgumentException("No Under File System Factory found for: " + path);
       }
@@ -106,7 +106,7 @@ public interface UnderFileSystem extends Closeable {
           // when creation is done.
           Thread.currentThread().setContextClassLoader(factory.getClass().getClassLoader());
           // Use the factory to create the actual client for the Under File System
-          return new UnderFileSystemWithLogging(path, factory.create(path, ufsConf));
+          return new UnderFileSystemWithLogging(path, factory.create(path, ufsConf, alluxioConf), alluxioConf);
         } catch (Throwable e) {
           // Catching Throwable rather than Exception to catch service loading errors
           errors.add(e);
@@ -131,14 +131,14 @@ public interface UnderFileSystem extends Closeable {
     /**
      * @return the instance of under file system for Alluxio root directory
      */
-    public static UnderFileSystem createForRoot() {
-      String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
-      boolean readOnly = Configuration.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_READONLY);
-      boolean shared = Configuration.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_SHARED);
+    public static UnderFileSystem createForRoot(AlluxioConfiguration conf) {
+      String ufsRoot = conf.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+      boolean readOnly = conf.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_READONLY);
+      boolean shared = conf.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_SHARED);
       Map<String, String> ufsConf =
-          Configuration.getNestedProperties(PropertyKey.MASTER_MOUNT_TABLE_ROOT_OPTION);
-      return create(ufsRoot, UnderFileSystemConfiguration.defaults().setReadOnly(readOnly)
-          .setShared(shared).setMountSpecificConf(ufsConf));
+          conf.getNestedProperties(PropertyKey.MASTER_MOUNT_TABLE_ROOT_OPTION);
+      return create(ufsRoot, UnderFileSystemConfiguration.defaults(conf).setReadOnly(readOnly)
+          .setShared(shared).createMountSpecificConf(ufsConf));
     }
   }
 
diff --git a/core/common/src/main/java/alluxio/underfs/UnderFileSystemConfiguration.java b/core/common/src/main/java/alluxio/underfs/UnderFileSystemConfiguration.java
index 0487c2bad0..5dc8a5b678 100644
--- a/core/common/src/main/java/alluxio/underfs/UnderFileSystemConfiguration.java
+++ b/core/common/src/main/java/alluxio/underfs/UnderFileSystemConfiguration.java
@@ -11,10 +11,12 @@
 
 package alluxio.underfs;
 
-import alluxio.Configuration;
 import alluxio.annotation.PublicApi;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.AlluxioProperties;
 import alluxio.conf.InstancedConfiguration;
 import alluxio.conf.Source;
+import alluxio.util.ConfigurationUtils;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -46,14 +48,21 @@ public final class UnderFileSystemConfiguration extends InstancedConfiguration {
    * @return default UFS configuration
    */
   public static UnderFileSystemConfiguration defaults() {
-    return new UnderFileSystemConfiguration();
+    return new UnderFileSystemConfiguration(ConfigurationUtils.defaults());
+  }
+
+  /**
+   * @return UFS configuration from a given alluxio configuration
+   */
+  public static UnderFileSystemConfiguration defaults(AlluxioConfiguration alluxioConf) {
+    return new UnderFileSystemConfiguration(alluxioConf.getProperties());
   }
 
   /**
    * Constructs a new instance of {@link UnderFileSystemConfiguration} with defaults.
    */
-  private UnderFileSystemConfiguration() {
-    super(Configuration.copyProperties());
+  private UnderFileSystemConfiguration(AlluxioProperties props) {
+    super(props);
     mReadOnly = false;
     mShared = false;
   }
@@ -85,7 +94,7 @@ public final class UnderFileSystemConfiguration extends InstancedConfiguration {
     return mShared;
   }
 
-  /**
+  /**≤
    * @param readOnly whether only read operations are permitted
    * @return the updated configuration object
    */
@@ -104,12 +113,15 @@ public final class UnderFileSystemConfiguration extends InstancedConfiguration {
   }
 
   /**
+   * Creates a new instance from the current configuration and adds in new properties.
    * @param mountConf the mount specific configuration map
    * @return the updated configuration object
    */
-  public UnderFileSystemConfiguration setMountSpecificConf(Map<String, String> mountConf) {
-    mProperties = Configuration.copyProperties();
-    merge(mountConf, Source.MOUNT_OPTION);
-    return this;
+  public UnderFileSystemConfiguration createMountSpecificConf(Map<String, String> mountConf) {
+    UnderFileSystemConfiguration ufsConf = new UnderFileSystemConfiguration(mProperties.copy());
+    ufsConf.mProperties.merge(mountConf, Source.MOUNT_OPTION);
+    ufsConf.mReadOnly = mReadOnly;
+    ufsConf.mShared = mShared;
+    return ufsConf;
   }
 }
diff --git a/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactory.java b/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactory.java
index 585d834008..3b1c106293 100644
--- a/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactory.java
+++ b/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactory.java
@@ -12,8 +12,10 @@
 package alluxio.underfs;
 
 import alluxio.annotation.PublicApi;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.extensions.ExtensionFactory;
 
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 /**
@@ -30,13 +32,14 @@ public interface UnderFileSystemFactory
    *
    * @param path file path
    * @param conf optional configuration object for the UFS, may be null
+   * @param alluxioConf configuration object for alluxio
    * @return the client
    */
-  UnderFileSystem create(String path, @Nullable UnderFileSystemConfiguration conf);
+  UnderFileSystem create(String path, @Nullable UnderFileSystemConfiguration conf, @Nonnull AlluxioConfiguration alluxioConf);
 
   /**
    * Gets whether this factory supports the given path and thus whether calling the
-   * {@link #create(String, UnderFileSystemConfiguration)} can succeed for this path.
+   * {@link #create(String, UnderFileSystemConfiguration, AlluxioConfiguration)} can succeed for this path.
    *
    * @param path file path
    * @return true if the path is supported, false otherwise
@@ -45,7 +48,7 @@ public interface UnderFileSystemFactory
 
   /**
    * Gets whether this factory supports the given path and thus whether calling the
-   * {@link #create(String, UnderFileSystemConfiguration)} can succeed for this path.
+   * {@link #create(String, UnderFileSystemConfiguration, AlluxioConfiguration)} can succeed for this path.
    *
    * @param path file path
    * @param conf optional configuration object for the UFS, may be null
diff --git a/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactoryRegistry.java b/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactoryRegistry.java
index d9f9cc4951..d50fb2d720 100644
--- a/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactoryRegistry.java
+++ b/core/common/src/main/java/alluxio/underfs/UnderFileSystemFactoryRegistry.java
@@ -11,6 +11,7 @@
 
 package alluxio.underfs;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.extensions.ExtensionFactoryRegistry;
 
 import org.slf4j.Logger;
@@ -67,8 +68,8 @@ public final class UnderFileSystemFactoryRegistry {
    * @return factory if available, null otherwise
    */
   @Nullable
-  public static UnderFileSystemFactory find(String path) {
-    return find(path, null);
+  public static UnderFileSystemFactory find(String path, AlluxioConfiguration alluxioConf) {
+    return find(path, null, alluxioConf);
   }
 
   /**
@@ -80,8 +81,8 @@ public final class UnderFileSystemFactoryRegistry {
    */
   @Nullable
   public static UnderFileSystemFactory find(
-      String path, @Nullable UnderFileSystemConfiguration ufsConf) {
-    List<UnderFileSystemFactory> factories = findAll(path, ufsConf);
+      String path, @Nullable UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
+    List<UnderFileSystemFactory> factories = findAll(path, ufsConf, alluxioConf);
     if (factories.isEmpty()) {
       LOG.warn("No Under File System Factory implementation supports the path {}. Please check if "
           + "the under storage path is valid.", path);
@@ -100,8 +101,8 @@ public final class UnderFileSystemFactoryRegistry {
    * @return list of factories that support the given path which may be an empty list
    */
   public static List<UnderFileSystemFactory> findAll(String path,
-      UnderFileSystemConfiguration ufsConf) {
-    return sRegistryInstance.findAll(path, ufsConf);
+      UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
+    return sRegistryInstance.findAll(path, ufsConf, alluxioConf);
   }
 
   private static synchronized void init() {
diff --git a/core/common/src/main/java/alluxio/underfs/UnderFileSystemWithLogging.java b/core/common/src/main/java/alluxio/underfs/UnderFileSystemWithLogging.java
index 11202ff0cc..7b6dc3e19f 100644
--- a/core/common/src/main/java/alluxio/underfs/UnderFileSystemWithLogging.java
+++ b/core/common/src/main/java/alluxio/underfs/UnderFileSystemWithLogging.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.Constants;
 import alluxio.SyncInfo;
 import alluxio.collections.Pair;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnimplementedException;
 import alluxio.security.authorization.AccessControlList;
 import alluxio.metrics.CommonMetrics;
@@ -56,6 +57,8 @@ public class UnderFileSystemWithLogging implements UnderFileSystem {
 
   private final UnderFileSystem mUnderFileSystem;
   private final String mPath;
+  private final AlluxioConfiguration mConfiguration;
+
 
   /**
    * Creates a new {@link UnderFileSystemWithLogging} which forwards all calls to the provided
@@ -65,10 +68,12 @@ public class UnderFileSystemWithLogging implements UnderFileSystem {
    * @param ufs the implementation which will handle all the calls
    */
   // TODO(adit): Remove this method. ALLUXIO-2643.
-  UnderFileSystemWithLogging(String path, UnderFileSystem ufs) {
+  UnderFileSystemWithLogging(String path, UnderFileSystem ufs, AlluxioConfiguration conf) {
     Preconditions.checkNotNull(path, "path");
     mPath = path;
     mUnderFileSystem = ufs;
+    mConfiguration = conf;
+
   }
 
   @Override
@@ -760,9 +765,9 @@ public class UnderFileSystemWithLogging implements UnderFileSystem {
   // TODO(calvin): General tag logic should be in getMetricName
   private String getQualifiedMetricName(String metricName) {
     try {
-      if (SecurityUtils.isAuthenticationEnabled() && AuthenticatedClientUser.get() != null) {
+      if (SecurityUtils.isAuthenticationEnabled(mConfiguration) && AuthenticatedClientUser.get(mConfiguration) != null) {
         return Metric.getMetricNameWithTags(metricName, CommonMetrics.TAG_USER,
-            AuthenticatedClientUser.get().getName(), WorkerMetrics.TAG_UFS,
+            AuthenticatedClientUser.get(mConfiguration).getName(), WorkerMetrics.TAG_UFS,
             MetricsSystem.escape(new AlluxioURI(mPath)), WorkerMetrics.TAG_UFS_TYPE,
             mUnderFileSystem.getUnderFSType());
       }
diff --git a/core/common/src/main/java/alluxio/underfs/options/CreateOptions.java b/core/common/src/main/java/alluxio/underfs/options/CreateOptions.java
index 92e330ea6e..a3d6a0207d 100644
--- a/core/common/src/main/java/alluxio/underfs/options/CreateOptions.java
+++ b/core/common/src/main/java/alluxio/underfs/options/CreateOptions.java
@@ -12,6 +12,8 @@
 package alluxio.underfs.options;
 
 import alluxio.annotation.PublicApi;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authorization.AccessControlList;
 import alluxio.security.authorization.Mode;
 import alluxio.util.ModeUtils;
@@ -42,21 +44,21 @@ public final class CreateOptions {
   /**
    * @return the default {@link CreateOptions}
    */
-  public static CreateOptions defaults() {
-    return new CreateOptions();
+  public static CreateOptions defaults(AlluxioConfiguration conf) {
+    return new CreateOptions(conf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
   }
 
   /**
    * Constructs a default {@link CreateOptions}.
    */
-  private CreateOptions() {
+  private CreateOptions(String authUmask) {
     mAcl = null;
     mCreateParent = false;
     mEnsureAtomic = false;
     // default owner and group are null (unset)
     mOwner = null;
     mGroup = null;
-    mMode = ModeUtils.applyFileUMask(Mode.defaults());
+    mMode = ModeUtils.applyFileUMask(Mode.defaults(), authUmask);
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/underfs/options/MkdirsOptions.java b/core/common/src/main/java/alluxio/underfs/options/MkdirsOptions.java
index 62fc741041..0e7370d576 100644
--- a/core/common/src/main/java/alluxio/underfs/options/MkdirsOptions.java
+++ b/core/common/src/main/java/alluxio/underfs/options/MkdirsOptions.java
@@ -12,6 +12,8 @@
 package alluxio.underfs.options;
 
 import alluxio.annotation.PublicApi;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authorization.Mode;
 import alluxio.util.ModeUtils;
 
@@ -36,20 +38,20 @@ public final class MkdirsOptions {
   /**
    * @return the default {@link MkdirsOptions}
    */
-  public static MkdirsOptions defaults() {
-    return new MkdirsOptions();
+  public static MkdirsOptions defaults(AlluxioConfiguration conf) {
+    return new MkdirsOptions(conf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
   }
 
   /**
    * Constructs a default {@link MkdirsOptions}.
    */
-  private MkdirsOptions() {
+  private MkdirsOptions(String authUmask) {
     // By default create parent is true.
     mCreateParent = true;
     // default owner and group are null (unset)
     mOwner = null;
     mGroup = null;
-    mMode = ModeUtils.applyDirectoryUMask(Mode.defaults());
+    mMode = ModeUtils.applyDirectoryUMask(Mode.defaults(), authUmask);
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/util/CommonUtils.java b/core/common/src/main/java/alluxio/util/CommonUtils.java
index 9d7fd3b70d..c2831ba8d5 100644
--- a/core/common/src/main/java/alluxio/util/CommonUtils.java
+++ b/core/common/src/main/java/alluxio/util/CommonUtils.java
@@ -11,9 +11,9 @@
 
 package alluxio.util;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.exception.status.Status;
 import alluxio.proto.dataserver.Protocol;
@@ -65,9 +65,6 @@ public final class CommonUtils {
 
   private static final String ALPHANUM =
       "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
-  private static final String DATE_FORMAT_PATTERN =
-      Configuration.get(PropertyKey.USER_DATE_FORMAT_PATTERN);
-  private static final List<String> TMP_DIRS = Configuration.getList(PropertyKey.TMP_DIRS, ",");
   private static final Random RANDOM = new Random();
 
   /**
@@ -80,13 +77,13 @@ public final class CommonUtils {
   /**
    * @return a path to a temporary directory based on the user configuration
    */
-  public static String getTmpDir() {
-    Preconditions.checkState(!TMP_DIRS.isEmpty(), "No temporary directories configured");
-    if (TMP_DIRS.size() == 1) {
-      return TMP_DIRS.get(0);
+  public static String getTmpDir(List<String> tmpDirs) {
+    Preconditions.checkState(!tmpDirs.isEmpty(), "No temporary directories configured");
+    if (tmpDirs.size() == 1) {
+      return tmpDirs.get(0);
     }
     // Use existing random instead of ThreadLocal because contention is not expected to be high.
-    return TMP_DIRS.get(RANDOM.nextInt(TMP_DIRS.size()));
+    return tmpDirs.get(RANDOM.nextInt(tmpDirs.size()));
   }
 
   /**
@@ -96,9 +93,9 @@ public final class CommonUtils {
    * "/mnt/ramdisk/alluxioworker" for storage dir "/mnt/ramdisk" by appending
    * {@link PropertyKey#WORKER_DATA_FOLDER).
    */
-  public static String getWorkerDataDirectory(String storageDir) {
+  public static String getWorkerDataDirectory(String storageDir, AlluxioConfiguration conf) {
     return PathUtils.concatPath(
-        storageDir.trim(), Configuration.get(PropertyKey.WORKER_DATA_FOLDER));
+        storageDir.trim(), conf.get(PropertyKey.WORKER_DATA_FOLDER));
   }
 
   /**
@@ -317,8 +314,8 @@ public final class CommonUtils {
    * @param userName Alluxio user name
    * @return primary group name
    */
-  public static String getPrimaryGroupName(String userName) throws IOException {
-    List<String> groups = getGroups(userName);
+  public static String getPrimaryGroupName(String userName, AlluxioConfiguration conf) throws IOException {
+    List<String> groups = getGroups(userName, conf);
     return (groups != null && groups.size() > 0) ? groups.get(0) : "";
   }
 
@@ -328,8 +325,9 @@ public final class CommonUtils {
    * @param userName Alluxio user name
    * @return the group list of the user
    */
-  public static List<String> getGroups(String userName) throws IOException {
-    GroupMappingService groupMappingService = GroupMappingService.Factory.get();
+  public static List<String> getGroups(String userName, AlluxioConfiguration conf)
+      throws IOException {
+    GroupMappingService groupMappingService = GroupMappingService.Factory.get(conf);
     return groupMappingService.getGroups(userName);
   }
 
@@ -586,8 +584,8 @@ public final class CommonUtils {
    * @param address the Alluxio worker network address
    * @return true if the worker is local
    */
-  public static boolean isLocalHost(WorkerNetAddress address) {
-    return address.getHost().equals(NetworkAddressUtils.getClientHostName());
+  public static boolean isLocalHost(WorkerNetAddress address, AlluxioConfiguration conf) {
+    return address.getHost().equals(NetworkAddressUtils.getClientHostName(conf));
   }
 
   /**
@@ -596,8 +594,8 @@ public final class CommonUtils {
    * @param millis a long millisecond number
    * @return formatted date String
    */
-  public static String convertMsToDate(long millis) {
-    DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
+  public static String convertMsToDate(long millis, String dateFormatPattern) {
+    DateFormat dateFormat = new SimpleDateFormat(dateFormatPattern);
     return dateFormat.format(new Date(millis));
   }
 
diff --git a/core/common/src/main/java/alluxio/util/ConfigurationUtils.java b/core/common/src/main/java/alluxio/util/ConfigurationUtils.java
index f940e86fe7..768c5cc7f1 100644
--- a/core/common/src/main/java/alluxio/util/ConfigurationUtils.java
+++ b/core/common/src/main/java/alluxio/util/ConfigurationUtils.java
@@ -13,11 +13,22 @@ package alluxio.util;
 
 import static java.util.stream.Collectors.toList;
 
-import alluxio.AlluxioConfiguration;
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
-import alluxio.PropertyKey;
+import alluxio.Constants;
+import alluxio.RuntimeConstants;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.AlluxioProperties;
+import alluxio.conf.ConfigurationValueOptions;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.Source;
+import alluxio.exception.status.AlluxioStatusException;
+import alluxio.exception.status.UnauthenticatedException;
+import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.ConfigProperty;
+import alluxio.grpc.GetConfigurationPOptions;
+import alluxio.grpc.GrpcChannel;
+import alluxio.grpc.GrpcChannelBuilder;
+import alluxio.grpc.MetaMasterClientServiceGrpc;
 import alluxio.grpc.Scope;
 import alluxio.grpc.GrpcUtils;
 import alluxio.util.io.PathUtils;
@@ -34,9 +45,11 @@ import java.net.InetSocketAddress;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.util.Properties;
 
 import javax.annotation.Nullable;
+import javax.annotation.concurrent.GuardedBy;
 
 /**
  * Utilities for working with Alluxio configurations.
@@ -44,6 +57,14 @@ import javax.annotation.Nullable;
 public final class ConfigurationUtils {
   private static final Logger LOG = LoggerFactory.getLogger(ConfigurationUtils.class);
 
+  @GuardedBy("sDefaultPropertiesLock")
+  private static AlluxioProperties sDefaultProperties = null;
+  private static String sSourcePropertyFile = null;
+
+  private static Object sDefaultPropertiesLock = new Object();
+
+
+
   private ConfigurationUtils() {} // prevent instantiation
 
   /**
@@ -194,46 +215,46 @@ public final class ConfigurationUtils {
    * @return whether the configuration describes how to find the job master host, either through
    *         explicit configuration or through zookeeper
    */
-  public static boolean jobMasterHostConfigured() {
-    boolean usingZk = Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)
-        && Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS);
-    return Configuration.isSet(PropertyKey.JOB_MASTER_HOSTNAME) || usingZk
-        || getJobMasterRpcAddresses(Configuration.global()).size() > 1;
+  public static boolean jobMasterHostConfigured(AlluxioConfiguration conf) {
+    boolean usingZk = conf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)
+        && conf.isSet(PropertyKey.ZOOKEEPER_ADDRESS);
+    return conf.isSet(PropertyKey.JOB_MASTER_HOSTNAME) || usingZk
+        || getJobMasterRpcAddresses(conf).size() > 1;
   }
 
   /**
    * @return whether the configuration describes how to find the master host, either through
    *         explicit configuration or through zookeeper
    */
-  public static boolean masterHostConfigured() {
-    boolean usingZk = Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)
-        && Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS);
-    return Configuration.isSet(PropertyKey.MASTER_HOSTNAME) || usingZk
-        || getMasterRpcAddresses(Configuration.global()).size() > 1;
+  public static boolean masterHostConfigured(AlluxioConfiguration conf) {
+    boolean usingZk = conf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)
+        && conf.isSet(PropertyKey.ZOOKEEPER_ADDRESS);
+    return conf.isSet(PropertyKey.MASTER_HOSTNAME) || usingZk
+        || getMasterRpcAddresses(conf).size() > 1;
   }
 
   /**
-   * Gets all global configuration properties filtered by the specified scope.
+   * Gets all configuration properties filtered by the specified scope.
    *
    * @param scope the scope to filter by
    * @return the properties
    */
-  public static List<ConfigProperty> getConfiguration(Scope scope) {
+  public static List<ConfigProperty> getConfiguration(AlluxioConfiguration conf, Scope scope) {
     ConfigurationValueOptions useRawDisplayValue =
         ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(true);
 
     List<ConfigProperty> configs = new ArrayList<>();
     List<PropertyKey> selectedKeys =
-        Configuration.keySet().stream()
+        conf.keySet().stream()
             .filter(key -> GrpcUtils.contains(key.getScope(), scope))
             .filter(key -> key.isValid(key.getName()))
             .collect(toList());
 
     for (PropertyKey key : selectedKeys) {
       ConfigProperty.Builder configProp = ConfigProperty.newBuilder().setName(key.getName())
-          .setSource(Configuration.getSource(key).toString());
-      if (Configuration.isSet(key)) {
-        configProp.setValue(Configuration.get(key, useRawDisplayValue));
+          .setSource(conf.getSource(key).toString());
+      if (conf.isSet(key)) {
+        configProp.setValue(conf.get(key, useRawDisplayValue));
       }
       configs.add(configProp.build());
     }
@@ -247,4 +268,164 @@ public final class ConfigurationUtils {
   public static String valueAsString(String value) {
     return value == null ? "(no value set)" : value;
   }
+
+  /**
+   * Returns an instance of {@link AlluxioConfiguration} with the defaults and values from
+   * alluxio-site properties.
+   */
+  public static AlluxioProperties defaults() {
+
+    if (sDefaultProperties == null) {
+      synchronized (sDefaultPropertiesLock) { // We don't want multiple threads to reload
+        // properties at the same time.
+
+        // Check if properties are still null so we don't reload a second time.
+        if (sDefaultProperties == null) {
+          reloadProperties();
+        }
+      }
+    }
+    return sDefaultProperties.copy();
+  }
+
+  public synchronized static void reloadProperties(){
+    // Step1: bootstrap the configuration. This is necessary because we need to resolve alluxio.home
+    // (likely to be in system properties) to locate the conf dir to search for the site property
+    // file.
+    AlluxioProperties properties = new AlluxioProperties();
+    InstancedConfiguration conf = new InstancedConfiguration(properties);
+    properties.merge(System.getProperties(), Source.SYSTEM_PROPERTY);
+    Properties siteProps = null;
+
+    // Step2: Load site specific properties file if not in test mode. Note that we decide whether in
+    // test mode by default properties and system properties (via getBoolean).
+    if (conf.getBoolean(PropertyKey.TEST_MODE)) {
+      conf.validate();
+      sDefaultProperties = properties;
+      return;
+    }
+
+    // we are not in test mode, load site properties
+    String confPaths = conf.get(PropertyKey.SITE_CONF_DIR);
+    String[] confPathList = confPaths.split(",");
+    String sitePropertyFile = ConfigurationUtils
+            .searchPropertiesFile(Constants.SITE_PROPERTIES, confPathList);
+    if (sitePropertyFile != null) {
+      siteProps = loadPropertiesFromFile(sitePropertyFile);
+      sSourcePropertyFile = sitePropertyFile;
+    } else {
+      URL resource =
+          ConfigurationUtils.class.getClassLoader().getResource(Constants.SITE_PROPERTIES);
+      if (resource != null) {
+        siteProps = loadPropertiesFromResource(resource);
+        if (siteProps != null) {
+          sSourcePropertyFile = resource.getPath();
+        }
+      }
+    }
+    properties.merge(siteProps, Source.siteProperty(sSourcePropertyFile));
+    conf.validate();
+    sDefaultProperties = properties;
+  }
+
+  /**
+   * Validates the configuration.
+   *
+   * @throws IllegalStateException if invalid configuration is encountered
+   */
+  public static void validate(AlluxioProperties conf) {
+    new InstancedConfiguration(conf).validate();
+  }
+
+
+  /**
+   * Merges the current configuration properties with new properties. If a property exists
+   * both in the new and current configuration, the one from the new configuration wins if
+   * its priority is higher or equal than the existing one.
+   *
+   * @param properties the source {@link Properties} to be merged
+   * @param source the source of the the properties (e.g., system property, default and etc)
+   */
+  public static AlluxioConfiguration merge(AlluxioConfiguration conf, Map<?, ?> properties, Source source) {
+    AlluxioProperties props = conf.getProperties();
+    props.merge(properties, source);
+    return new InstancedConfiguration(props);
+  }
+
+
+
+  /**
+   * Loads cluster default values from the meta master.
+   *
+   * @param address the master address
+   */
+  public static AlluxioConfiguration loadClusterDefaults(InetSocketAddress address, AlluxioConfiguration conf)
+      throws UnavailableException {
+    if (!conf.getBoolean(PropertyKey.USER_CONF_CLUSTER_DEFAULT_ENABLED)
+        || conf.clusterDefaultsLoaded()) {
+      return conf;
+    }
+    synchronized (conf) {
+      if (conf.clusterDefaultsLoaded()) {
+        return conf;
+      }
+      LOG.info("Alluxio client (version {}) is trying to bootstrap-connect with {}",
+          RuntimeConstants.VERSION, address);
+
+      GrpcChannel channel = null;
+      List<alluxio.grpc.ConfigProperty> clusterConfig;
+
+      try {
+        channel = GrpcChannelBuilder.forAddress(address, conf)
+            .disableAuthentication().build();
+        MetaMasterClientServiceGrpc.MetaMasterClientServiceBlockingStub client =
+            MetaMasterClientServiceGrpc.newBlockingStub(channel);
+        clusterConfig =
+            client.getConfiguration(GetConfigurationPOptions.newBuilder().setRawValue(true).build())
+                .getConfigsList();
+      } catch (io.grpc.StatusRuntimeException e) {
+        throw new UnavailableException(String.format(
+            "Failed to handshake with master %s to load cluster default configuration values",
+            address), e);
+      } catch (UnauthenticatedException e) {
+        throw new RuntimeException(String.format(
+            "Received authentication exception with authentication disabled. Host:%s", address), e);
+      } finally {
+        channel.shutdown();
+      }
+
+      // merge conf returned by master as the cluster default into ServerConfiguration
+      Properties clusterProps = new Properties();
+      for (ConfigProperty property : clusterConfig) {
+        String name = property.getName();
+        // TODO(binfan): support propagating unsetting properties from master
+        if (PropertyKey.isValid(name) && property.hasValue()) {
+          PropertyKey key = PropertyKey.fromString(name);
+          if (!GrpcUtils.contains(key.getScope(), Scope.CLIENT)) {
+            // Only propagate client properties.
+            continue;
+          }
+          String value = property.getValue();
+          clusterProps.put(key, value);
+          LOG.debug("Loading cluster default: {} ({}) -> {}", key, key.getScope(), value);
+        }
+      }
+
+      String clientVersion = conf.get(PropertyKey.VERSION);
+      String clusterVersion = clusterProps.get(PropertyKey.VERSION).toString();
+      if (!clientVersion.equals(clusterVersion)) {
+        LOG.warn("Alluxio client version ({}) does not match Alluxio cluster version ({})",
+            clientVersion, clusterVersion);
+        clusterProps.remove(PropertyKey.VERSION);
+      }
+      AlluxioProperties props = conf.getProperties();
+      props.merge(clusterProps, Source.CLUSTER_DEFAULT);
+      // Use the constructor to set cluster defaults as being laoded.
+      InstancedConfiguration updatedConf = new InstancedConfiguration(props, true);
+      updatedConf.validate();
+      LOG.info("Alluxio client has bootstrap-connected with {}", address);
+      return updatedConf;
+    }
+  }
+
 }
diff --git a/core/common/src/main/java/alluxio/util/ExtensionUtils.java b/core/common/src/main/java/alluxio/util/ExtensionUtils.java
index e1a7554de5..701fbd9c8b 100644
--- a/core/common/src/main/java/alluxio/util/ExtensionUtils.java
+++ b/core/common/src/main/java/alluxio/util/ExtensionUtils.java
@@ -11,9 +11,7 @@
 
 package alluxio.util;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
 
 import java.io.File;
 import java.io.FileFilter;
@@ -33,8 +31,7 @@ public final class ExtensionUtils {
    *
    * @return an array of files (one file per jar)
    */
-  public static File[] listExtensions() {
-    String extensionDir = Configuration.get(PropertyKey.EXTENSIONS_DIR);
+  public static File[] listExtensions(String extensionDir) {
     File[] extensions = new File(extensionDir).listFiles(new FileFilter() {
       public boolean accept(File file) {
         return file.getPath().toLowerCase().endsWith(Constants.EXTENSION_JAR);
diff --git a/core/common/src/main/java/alluxio/util/JvmPauseMonitor.java b/core/common/src/main/java/alluxio/util/JvmPauseMonitor.java
index 5c1cb5613f..9ba776b1cd 100644
--- a/core/common/src/main/java/alluxio/util/JvmPauseMonitor.java
+++ b/core/common/src/main/java/alluxio/util/JvmPauseMonitor.java
@@ -11,9 +11,6 @@
 
 package alluxio.util;
 
-import alluxio.PropertyKey;
-import alluxio.Configuration;
-
 import com.google.common.base.Joiner;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.Lists;
@@ -62,10 +59,10 @@ public final class JvmPauseMonitor {
   /**
    * Constructs JvmPauseMonitor.
    */
-  public JvmPauseMonitor() {
-    mGcSleepIntervalMs = Configuration.getMs(PropertyKey.JVM_MONITOR_SLEEP_INTERVAL_MS);
-    mWarnThresholdMs = Configuration.getMs(PropertyKey.JVM_MONITOR_WARN_THRESHOLD_MS);
-    mInfoThresholdMs = Configuration.getMs(PropertyKey.JVM_MONITOR_INFO_THRESHOLD_MS);
+  public JvmPauseMonitor(long gcSleepIntervalMs, long warnThresholdMs, long infoThresholdMs) {
+    mGcSleepIntervalMs = gcSleepIntervalMs;
+    mWarnThresholdMs = warnThresholdMs;
+    mInfoThresholdMs = infoThresholdMs;
   }
 
   /**
diff --git a/core/common/src/main/java/alluxio/util/ModeUtils.java b/core/common/src/main/java/alluxio/util/ModeUtils.java
index deaf5e7c91..45bd3cc51a 100644
--- a/core/common/src/main/java/alluxio/util/ModeUtils.java
+++ b/core/common/src/main/java/alluxio/util/ModeUtils.java
@@ -11,9 +11,8 @@
 
 package alluxio.util;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.grpc.PMode;
 import alluxio.security.authorization.Mode;
@@ -35,8 +34,8 @@ public final class ModeUtils {
    * @param mode the mode to update
    * @return the updated object
    */
-  public static Mode applyFileUMask(Mode mode) {
-    mode = applyUMask(mode, getUMask());
+  public static Mode applyFileUMask(Mode mode, String authUmask) {
+    mode = applyUMask(mode, getUMask(authUmask));
     mode = applyUMask(mode, FILE_UMASK);
     return mode;
   }
@@ -47,8 +46,8 @@ public final class ModeUtils {
    * @param mode the mode to update
    * @return the updated object
    */
-  public static Mode applyDirectoryUMask(Mode mode) {
-    return applyUMask(mode, getUMask());
+  public static Mode applyDirectoryUMask(Mode mode, String authUmask) {
+    return applyUMask(mode, getUMask(authUmask));
   }
 
   /**
@@ -80,9 +79,8 @@ public final class ModeUtils {
    *
    * @return the umask {@link Mode}
    */
-  private static Mode getUMask() {
+  private static Mode getUMask(String confUmask) {
     int umask = Constants.DEFAULT_FILE_SYSTEM_UMASK;
-    String confUmask = Configuration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK);
     if (confUmask != null) {
       if ((confUmask.length() > 4) || !isValid(confUmask)) {
         throw new IllegalArgumentException(ExceptionMessage.INVALID_CONFIGURATION_VALUE
diff --git a/core/common/src/main/java/alluxio/util/SecurityUtils.java b/core/common/src/main/java/alluxio/util/SecurityUtils.java
index 501e33f07d..39877bd530 100644
--- a/core/common/src/main/java/alluxio/util/SecurityUtils.java
+++ b/core/common/src/main/java/alluxio/util/SecurityUtils.java
@@ -11,8 +11,8 @@
 
 package alluxio.util;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.security.LoginUser;
 import alluxio.security.User;
@@ -35,8 +35,8 @@ public final class SecurityUtils {
    *
    * @return true if security is enabled, false otherwise
    */
-  public static boolean isSecurityEnabled() {
-    return isAuthenticationEnabled() && isAuthorizationEnabled();
+  public static boolean isSecurityEnabled(AlluxioConfiguration conf) {
+    return isAuthenticationEnabled(conf) && isAuthorizationEnabled(conf);
   }
 
   /**
@@ -44,8 +44,8 @@ public final class SecurityUtils {
    *
    * @return true if authentication is enabled, false otherwise
    */
-  public static boolean isAuthenticationEnabled() {
-    return !Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class)
+  public static boolean isAuthenticationEnabled(AlluxioConfiguration conf) {
+    return !conf.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class)
         .equals(AuthType.NOSASL);
   }
 
@@ -54,17 +54,17 @@ public final class SecurityUtils {
    *
    * @return true if authorization is enabled, false otherwise
    */
-  public static boolean isAuthorizationEnabled() {
-    return Configuration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED);
+  public static boolean isAuthorizationEnabled(AlluxioConfiguration conf) {
+    return conf.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED);
   }
 
   /**
    * @return the owner fetched from the login module, or empty string if the fetch fails or
    *         authentication is disabled
    */
-  public static String getOwnerFromLoginModule() {
+  public static String getOwnerFromLoginModule(AlluxioConfiguration conf) {
     try {
-      return LoginUser.get().getName();
+      return LoginUser.get(conf).getName();
     } catch (UnauthenticatedException | UnsupportedOperationException e) {
       return "";
     }
@@ -74,9 +74,9 @@ public final class SecurityUtils {
    * @return the owner fetched from the gRPC client, or empty string if the fetch fails or
    *         authentication is disabled
    */
-  public static String getOwnerFromGrpcClient() {
+  public static String getOwnerFromGrpcClient(AlluxioConfiguration conf) {
     try {
-      User user = AuthenticatedClientUser.get();
+      User user = AuthenticatedClientUser.get(conf);
       if (user == null) {
         return "";
       }
@@ -90,9 +90,9 @@ public final class SecurityUtils {
    * @return the group fetched from the login module, or empty string if the fetch fails or
    *         authentication is disabled
    */
-  public static String getGroupFromLoginModule() {
+  public static String getGroupFromLoginModule(AlluxioConfiguration conf) {
     try {
-      return CommonUtils.getPrimaryGroupName(LoginUser.get().getName());
+      return CommonUtils.getPrimaryGroupName(LoginUser.get(conf).getName(), conf);
     } catch (IOException | UnsupportedOperationException e) {
       return "";
     }
@@ -102,13 +102,13 @@ public final class SecurityUtils {
    * @return the group fetched from the gRPC client, or empty string if the fetch fails or
    *         authentication is disabled
    */
-  public static String getGroupFromGrpcClient() {
+  public static String getGroupFromGrpcClient(AlluxioConfiguration conf) {
     try {
-      User user = AuthenticatedClientUser.get();
+      User user = AuthenticatedClientUser.get(conf);
       if (user == null) {
         return "";
       }
-      return CommonUtils.getPrimaryGroupName(user.getName());
+      return CommonUtils.getPrimaryGroupName(user.getName(), conf);
     } catch (IOException e) {
       return "";
     }
diff --git a/core/common/src/main/java/alluxio/util/TieredIdentityUtils.java b/core/common/src/main/java/alluxio/util/TieredIdentityUtils.java
index 3efb703547..90d610b012 100644
--- a/core/common/src/main/java/alluxio/util/TieredIdentityUtils.java
+++ b/core/common/src/main/java/alluxio/util/TieredIdentityUtils.java
@@ -11,9 +11,8 @@
 
 package alluxio.util;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.wire.TieredIdentity;
 
@@ -38,7 +37,7 @@ public final class TieredIdentityUtils {
    * @return true if the wire type locality tier matches the given tier
    */
   public static boolean matches(TieredIdentity.LocalityTier tier,
-      TieredIdentity.LocalityTier otherTier) {
+      TieredIdentity.LocalityTier otherTier, boolean resolveIpAddress) {
     String otherTierName = otherTier.getTierName();
     if (!tier.getTierName().equals(otherTierName)) {
       return false;
@@ -50,7 +49,7 @@ public final class TieredIdentityUtils {
     // For node tiers, attempt to resolve hostnames to IP addresses, this avoids common
     // misconfiguration errors where a worker is using one hostname and the client is using
     // another.
-    if (Configuration.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP)) {
+    if (resolveIpAddress) {
       if (Constants.LOCALITY_NODE.equals(tier.getTierName())) {
         try {
           String tierIpAddress = NetworkAddressUtils.resolveIpAddress(tier.getValue());
@@ -73,14 +72,14 @@ public final class TieredIdentityUtils {
    *         is returned
    */
   public static Optional<TieredIdentity> nearest(TieredIdentity tieredIdentity,
-      List<TieredIdentity> identities) {
+      List<TieredIdentity> identities, boolean resolveIpAddress) {
     if (identities.isEmpty()) {
       return Optional.empty();
     }
     for (TieredIdentity.LocalityTier tier : tieredIdentity.getTiers()) {
       for (TieredIdentity identity : identities) {
         for (TieredIdentity.LocalityTier otherTier : identity.getTiers()) {
-          if (tier != null && matches(tier, otherTier)) {
+          if (tier != null && matches(tier, otherTier, resolveIpAddress)) {
             return Optional.of(identity);
           }
         }
diff --git a/core/common/src/main/java/alluxio/util/io/FileUtils.java b/core/common/src/main/java/alluxio/util/io/FileUtils.java
index a13e63ee2c..a5018c1a39 100644
--- a/core/common/src/main/java/alluxio/util/io/FileUtils.java
+++ b/core/common/src/main/java/alluxio/util/io/FileUtils.java
@@ -12,8 +12,7 @@
 package alluxio.util.io;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.InvalidPathException;
 
 import org.slf4j.Logger;
@@ -185,9 +184,9 @@ public final class FileUtils {
    *
    * @param path the path of the block
    */
-  public static void createBlockPath(String path) throws IOException {
+  public static void createBlockPath(String path, String workerDataFolderPermissions) throws IOException {
     try {
-      createStorageDirPath(PathUtils.getParent(path));
+      createStorageDirPath(PathUtils.getParent(path), workerDataFolderPermissions);
     } catch (InvalidPathException e) {
       throw new IOException("Failed to create block path, get parent path of " + path + "failed",
           e);
@@ -253,7 +252,7 @@ public final class FileUtils {
    * @param path storage directory path to create
    * @return true if the directory is created and false if the directory already exists
    */
-  public static boolean createStorageDirPath(String path) throws IOException {
+  public static boolean createStorageDirPath(String path, String workerDataFolderPermissions) throws IOException {
     if (Files.exists(Paths.get(path))) {
       return false;
     }
@@ -264,8 +263,7 @@ public final class FileUtils {
       throw new IOException("Failed to create folder " + path, e);
     }
     String absolutePath = storagePath.toAbsolutePath().toString();
-    String perms = Configuration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);
-    changeLocalFilePermission(absolutePath, perms);
+    changeLocalFilePermission(absolutePath, workerDataFolderPermissions);
     setLocalDirStickyBit(absolutePath);
     return true;
   }
diff --git a/core/common/src/main/java/alluxio/util/network/NettyUtils.java b/core/common/src/main/java/alluxio/util/network/NettyUtils.java
index 63d50e18d9..394bcad561 100644
--- a/core/common/src/main/java/alluxio/util/network/NettyUtils.java
+++ b/core/common/src/main/java/alluxio/util/network/NettyUtils.java
@@ -11,8 +11,8 @@
 
 package alluxio.util.network;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.network.ChannelType;
 import alluxio.util.ThreadFactoryUtils;
 import alluxio.util.io.FileUtils;
@@ -46,10 +46,10 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class NettyUtils {
   private static final Logger LOG = LoggerFactory.getLogger(NettyUtils.class);
 
-  public static final ChannelType USER_CHANNEL_TYPE =
-      getChannelType(PropertyKey.USER_NETWORK_NETTY_CHANNEL);
-  public static final ChannelType WORKER_CHANNEL_TYPE =
-      getChannelType(PropertyKey.WORKER_NETWORK_NETTY_CHANNEL);
+//  public static final ChannelType USER_CHANNEL_TYPE =
+//      getChannelType(PropertyKey.USER_NETWORK_NETTY_CHANNEL);
+//  public static final ChannelType WORKER_CHANNEL_TYPE =
+//      getChannelType(PropertyKey.WORKER_NETWORK_NETTY_CHANNEL);
 
   private static Boolean sNettyEpollAvailable = null;
 
@@ -87,19 +87,20 @@ public final class NettyUtils {
    * @param isDomainSocket whether this is a domain socket server
    * @return ServerSocketChannel matching the requirements
    */
-  public static Class<? extends ServerChannel> getServerChannelClass(boolean isDomainSocket) {
+  public static Class<? extends ServerChannel> getServerChannelClass(boolean isDomainSocket, AlluxioConfiguration conf) {
+    ChannelType workerChannelType = getWorkerChannel(conf);
     if (isDomainSocket) {
-      Preconditions.checkState(WORKER_CHANNEL_TYPE == ChannelType.EPOLL,
+      Preconditions.checkState(workerChannelType == ChannelType.EPOLL,
           "Domain sockets are only supported with EPOLL channel type.");
       return EpollServerDomainSocketChannel.class;
     }
-    switch (WORKER_CHANNEL_TYPE) {
+    switch (workerChannelType) {
       case NIO:
         return NioServerSocketChannel.class;
       case EPOLL:
         return EpollServerSocketChannel.class;
       default:
-        throw new IllegalArgumentException("Unknown io type: " + WORKER_CHANNEL_TYPE);
+        throw new IllegalArgumentException("Unknown io type: " + workerChannelType);
     }
   }
 
@@ -109,19 +110,20 @@ public final class NettyUtils {
    * @param isDomainSocket whether this is to connect to a domain socket server
    * @return Channel matching the requirements
    */
-  public static Class<? extends Channel> getClientChannelClass(boolean isDomainSocket) {
+  public static Class<? extends Channel> getClientChannelClass(boolean isDomainSocket, AlluxioConfiguration conf) {
+    ChannelType userChannelType = getUserChannel(conf);
     if (isDomainSocket) {
-      Preconditions.checkState(USER_CHANNEL_TYPE == ChannelType.EPOLL,
+      Preconditions.checkState(userChannelType == ChannelType.EPOLL,
           "Domain sockets are only supported with EPOLL channel type.");
       return EpollDomainSocketChannel.class;
     }
-    switch (USER_CHANNEL_TYPE) {
+    switch (userChannelType) {
       case NIO:
         return NioSocketChannel.class;
       case EPOLL:
         return EpollSocketChannel.class;
       default:
-        throw new IllegalArgumentException("Unknown io type: " + USER_CHANNEL_TYPE);
+        throw new IllegalArgumentException("Unknown io type: " + userChannelType);
     }
   }
 
@@ -150,15 +152,15 @@ public final class NettyUtils {
    * @param workerNetAddress the worker address
    * @return true if the domain socket is enabled on this client
    */
-  public static boolean isDomainSocketSupported(WorkerNetAddress workerNetAddress) {
+  public static boolean isDomainSocketSupported(WorkerNetAddress workerNetAddress, AlluxioConfiguration conf) {
     if (workerNetAddress.getDomainSocketPath().isEmpty()
-        || USER_CHANNEL_TYPE != ChannelType.EPOLL) {
+        || getUserChannel(conf) != ChannelType.EPOLL) {
       return false;
     }
-    if (Configuration.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
+    if (conf.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
       return FileUtils.exists(workerNetAddress.getDomainSocketPath());
     } else {
-      return workerNetAddress.getHost().equals(NetworkAddressUtils.getClientHostName());
+      return workerNetAddress.getHost().equals(NetworkAddressUtils.getClientHostName(conf));
     }
   }
 
@@ -188,14 +190,22 @@ public final class NettyUtils {
     }
   }
 
+  public static ChannelType getUserChannel(AlluxioConfiguration conf) {
+    return getChannelType(PropertyKey.USER_NETWORK_NETTY_CHANNEL, conf);
+  }
+
+  public static ChannelType getWorkerChannel(AlluxioConfiguration conf) {
+    return getChannelType(PropertyKey.WORKER_NETWORK_NETTY_CHANNEL, conf);
+  }
+
   /**
    * @param key the property key for looking up the configured channel type
    * @return the channel type to use
    */
-  private static ChannelType getChannelType(PropertyKey key) {
+  private static ChannelType getChannelType(PropertyKey key, AlluxioConfiguration conf) {
     if (!isNettyEpollAvailable()) {
       return ChannelType.NIO;
     }
-    return Configuration.getEnum(key, ChannelType.class);
+    return conf.getEnum(key, ChannelType.class);
   }
 }
diff --git a/core/common/src/main/java/alluxio/util/network/NetworkAddressUtils.java b/core/common/src/main/java/alluxio/util/network/NetworkAddressUtils.java
index 4ff9dc2e9a..9a1dbaec8c 100644
--- a/core/common/src/main/java/alluxio/util/network/NetworkAddressUtils.java
+++ b/core/common/src/main/java/alluxio/util/network/NetworkAddressUtils.java
@@ -11,15 +11,15 @@
 
 package alluxio.util.network;
 
-import alluxio.AlluxioConfiguration;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.GetServiceVersionPRequest;
 import alluxio.grpc.GrpcChannel;
 import alluxio.grpc.GrpcChannelBuilder;
 import alluxio.grpc.ServiceVersionClientServiceGrpc;
+import alluxio.security.authentication.AuthType;
 import alluxio.util.CommonUtils;
 import alluxio.util.OSUtils;
 import alluxio.wire.WorkerNetAddress;
@@ -222,17 +222,17 @@ public final class NetworkAddressUtils {
     assertValidPort(address.getPort());
   }
 
-  /**
-   * Helper method to get the {@link InetSocketAddress} address for client to communicate with the
-   * service.
-   *
-   * @param service the service name used to connect
-   * @return the service address that a client (typically outside the service machine) uses to
-   *         communicate with service.
-   */
-  public static InetSocketAddress getConnectAddress(ServiceType service) {
-    return getConnectAddress(service, Configuration.global());
-  }
+//  /**
+//   * Helper method to get the {@link InetSocketAddress} address for client to communicate with the
+//   * service.
+//   *
+//   * @param service the service name used to connect
+//   * @return the service address that a client (typically outside the service machine) uses to
+//   *         communicate with service.
+//   */
+//  public static InetSocketAddress getConnectAddress(ServiceType service, AlluxioConfiguration conf) {
+//    return getConnectAddress(service, conf);
+//  }
 
   /**
    * Helper method to get the {@link InetSocketAddress} address for client to communicate with the
@@ -247,50 +247,50 @@ public final class NetworkAddressUtils {
       AlluxioConfiguration conf) {
     return new InetSocketAddress(getConnectHost(service, conf), getPort(service, conf));
   }
-
-  /**
-   * Provides an externally resolvable hostname for client to communicate with the service. If the
-   * hostname is not explicitly specified, Alluxio will try to use the bind host. If the bind host
-   * is wildcard, Alluxio will automatically determine an appropriate hostname from local machine.
-   * The various possibilities shown in the following table:
-   * <table>
-   * <caption>Hostname Scenarios</caption> <thead>
-   * <tr>
-   * <th>Specified Hostname</th>
-   * <th>Specified Bind Host</th>
-   * <th>Returned Connect Host</th>
-   * </tr>
-   * </thead> <tbody>
-   * <tr>
-   * <td>hostname</td>
-   * <td>hostname</td>
-   * <td>hostname</td>
-   * </tr>
-   * <tr>
-   * <td>not defined</td>
-   * <td>hostname</td>
-   * <td>hostname</td>
-   * </tr>
-   * <tr>
-   * <td>hostname</td>
-   * <td>0.0.0.0 or not defined</td>
-   * <td>hostname</td>
-   * </tr>
-   * <tr>
-   * <td>not defined</td>
-   * <td>0.0.0.0 or not defined</td>
-   * <td>localhost</td>
-   * </tr>
-   * </tbody>
-   * </table>
-   *
-   * @param service Service type used to connect
-   * @return the externally resolvable hostname that the client can use to communicate with the
-   *         service.
-   */
-  public static String getConnectHost(ServiceType service) {
-    return getConnectHost(service, Configuration.global());
-  }
+//
+//  /**
+//   * Provides an externally resolvable hostname for client to communicate with the service. If the
+//   * hostname is not explicitly specified, Alluxio will try to use the bind host. If the bind host
+//   * is wildcard, Alluxio will automatically determine an appropriate hostname from local machine.
+//   * The various possibilities shown in the following table:
+//   * <table>
+//   * <caption>Hostname Scenarios</caption> <thead>
+//   * <tr>
+//   * <th>Specified Hostname</th>
+//   * <th>Specified Bind Host</th>
+//   * <th>Returned Connect Host</th>
+//   * </tr>
+//   * </thead> <tbody>
+//   * <tr>
+//   * <td>hostname</td>
+//   * <td>hostname</td>
+//   * <td>hostname</td>
+//   * </tr>
+//   * <tr>
+//   * <td>not defined</td>
+//   * <td>hostname</td>
+//   * <td>hostname</td>
+//   * </tr>
+//   * <tr>
+//   * <td>hostname</td>
+//   * <td>0.0.0.0 or not defined</td>
+//   * <td>hostname</td>
+//   * </tr>
+//   * <tr>
+//   * <td>not defined</td>
+//   * <td>0.0.0.0 or not defined</td>
+//   * <td>localhost</td>
+//   * </tr>
+//   * </tbody>
+//   * </table>
+//   *
+//   * @param service Service type used to connect
+//   * @return the externally resolvable hostname that the client can use to communicate with the
+//   *         service.
+//   */
+//  public static String getConnectHost(ServiceType service) {
+//    return getConnectHost(service, Configuration.global());
+//  }
 
   /**
    * Provides an externally resolvable hostname for client to communicate with the service. If the
@@ -348,7 +348,7 @@ public final class NetworkAddressUtils {
         return bindHost;
       }
     }
-    return getLocalHostName();
+    return getLocalHostName((int)conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
   }
 
   /**
@@ -356,22 +356,11 @@ public final class NetworkAddressUtils {
    * specified, Alluxio will use the default service port.
    *
    * @param service Service type used to connect
+   * @param conf configuration
    * @return the service port number
    */
-  public static int getPort(ServiceType service) {
-    return getPort(service, Configuration.global());
-  }
-
-  /**
-   * Gets the port number on a given service type. If user defined port number is not explicitly
-   * specified, Alluxio will use the default service port.
-   *
-   * @param service Service type used to connect
-   * @param config configuration
-   * @return the service port number
-   */
-  public static int getPort(ServiceType service, AlluxioConfiguration config) {
-    return config.getInt(service.mPortKey);
+  public static int getPort(ServiceType service, AlluxioConfiguration conf) {
+    return conf.getInt(service.mPortKey);
   }
 
   /**
@@ -380,10 +369,10 @@ public final class NetworkAddressUtils {
    * @param service the service name
    * @return the InetSocketAddress the service will bind to
    */
-  public static InetSocketAddress getBindAddress(ServiceType service) {
-    int port = getPort(service);
+  public static InetSocketAddress getBindAddress(ServiceType service, AlluxioConfiguration conf) {
+    int port = getPort(service, conf);
     assertValidPort(port);
-    return new InetSocketAddress(getBindHost(service), getPort(service));
+    return new InetSocketAddress(getBindHost(service, conf), getPort(service, conf));
   }
 
   /**
@@ -399,12 +388,12 @@ public final class NetworkAddressUtils {
    * @param service the service name
    * @return the bind hostname
    */
-  public static String getBindHost(ServiceType service) {
-    if (Configuration.isSet(service.mBindHostKey) && !Configuration.get(service.mBindHostKey)
+  public static String getBindHost(ServiceType service, AlluxioConfiguration conf) {
+    if (conf.isSet(service.mBindHostKey) && !conf.get(service.mBindHostKey)
         .isEmpty()) {
-      return Configuration.get(service.mBindHostKey);
+      return conf.get(service.mBindHostKey);
     } else {
-      return getLocalHostName();
+      return getLocalHostName((int)conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
     }
   }
 
@@ -414,11 +403,12 @@ public final class NetworkAddressUtils {
    *
    * @return the local hostname for the client
    */
-  public static String getClientHostName() {
-    if (Configuration.isSet(PropertyKey.USER_HOSTNAME)) {
-      return Configuration.get(PropertyKey.USER_HOSTNAME);
+  @Deprecated
+  public static String getClientHostName(AlluxioConfiguration conf) {
+    if (conf.isSet(PropertyKey.USER_HOSTNAME)) {
+      return conf.get(PropertyKey.USER_HOSTNAME);
     }
-    return getLocalHostName();
+    return getLocalHostName((int)conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
   }
 
   // TODO(zac): Handle the JOB_WORKER case in this method.
@@ -427,46 +417,32 @@ public final class NetworkAddressUtils {
    *
    * @return the local node name
    */
-  public static String getLocalNodeName() {
+  public static String getLocalNodeName(AlluxioConfiguration conf) {
     switch (CommonUtils.PROCESS_TYPE.get()) {
       case JOB_MASTER:
-        if (Configuration.containsKey(PropertyKey.JOB_MASTER_HOSTNAME)) {
-          return Configuration.get(PropertyKey.JOB_MASTER_HOSTNAME);
+        if (conf.isSet(PropertyKey.JOB_MASTER_HOSTNAME)) {
+          return conf.get(PropertyKey.JOB_MASTER_HOSTNAME);
         }
         break;
       case CLIENT:
-        if (Configuration.isSet(PropertyKey.USER_HOSTNAME)) {
-          return Configuration.get(PropertyKey.USER_HOSTNAME);
+        if (conf.isSet(PropertyKey.USER_HOSTNAME)) {
+          return conf.get(PropertyKey.USER_HOSTNAME);
         }
         break;
       case MASTER:
-        if (Configuration.isSet(PropertyKey.MASTER_HOSTNAME)) {
-          return Configuration.get(PropertyKey.MASTER_HOSTNAME);
+        if (conf.isSet(PropertyKey.MASTER_HOSTNAME)) {
+          return conf.get(PropertyKey.MASTER_HOSTNAME);
         }
         break;
       case WORKER:
-        if (Configuration.isSet(PropertyKey.WORKER_HOSTNAME)) {
-          return Configuration.get(PropertyKey.WORKER_HOSTNAME);
+        if (conf.isSet(PropertyKey.WORKER_HOSTNAME)) {
+          return conf.get(PropertyKey.WORKER_HOSTNAME);
         }
         break;
       default:
         break;
     }
-    return getLocalHostName();
-  }
-
-  /**
-   * Gets a local hostname for the host this JVM is running on.
-   *
-   * @return the local host name, which is not based on a loopback ip address
-   */
-  public static synchronized String getLocalHostName() {
-    if (sLocalHost != null) {
-      return sLocalHost;
-    }
-    int hostResolutionTimeout =
-        (int) Configuration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
-    return getLocalHostName(hostResolutionTimeout);
+    return getLocalHostName((int)conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
   }
 
   /**
@@ -495,28 +471,14 @@ public final class NetworkAddressUtils {
    *
    * @return the metrics system friendly local host name
    */
-  public static synchronized String getLocalHostMetricName() {
+  public static synchronized String getLocalHostMetricName(int timeoutMs) {
     if (sLocalHostMetricName != null) {
       return sLocalHostMetricName;
     }
-    sLocalHostMetricName = getLocalHostName().replace('.', '_');
+    sLocalHostMetricName = getLocalHostName(timeoutMs).replace('.', '_');
     return sLocalHostMetricName;
   }
 
-  /**
-   * Gets a local IP address for the host this JVM is running on.
-   *
-   * @return the local ip address, which is not a loopback address and is reachable
-   */
-  public static synchronized String getLocalIpAddress() {
-    if (sLocalIP != null) {
-      return sLocalIP;
-    }
-    int hostResolutionTimeout =
-        (int) Configuration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
-    return getLocalIpAddress(hostResolutionTimeout);
-  }
-
   /**
    * Gets a local IP address for the host this JVM is running on.
    *
@@ -701,9 +663,9 @@ public final class NetworkAddressUtils {
    * @param netAddress the input network address representation
    * @return the socket address
    */
-  public static SocketAddress getDataPortSocketAddress(WorkerNetAddress netAddress) {
+  public static SocketAddress getDataPortSocketAddress(WorkerNetAddress netAddress, AlluxioConfiguration conf) {
     SocketAddress address;
-    if (NettyUtils.isDomainSocketSupported(netAddress)) {
+    if (NettyUtils.isDomainSocketSupported(netAddress, conf)) {
       address = new DomainSocketAddress(netAddress.getDomainSocketPath());
     } else {
       String host = netAddress.getHost();
@@ -722,11 +684,11 @@ public final class NetworkAddressUtils {
    * @throws UnauthenticatedException If the user is not authenticated
    * @throws StatusRuntimeException If the host not reachable or does not serve the given service
    */
-  public static void pingService(InetSocketAddress address, alluxio.grpc.ServiceType serviceType)
+  public static void pingService(InetSocketAddress address, alluxio.grpc.ServiceType serviceType, AlluxioConfiguration conf)
       throws UnauthenticatedException, UnavailableException {
     Preconditions.checkNotNull(address, "address");
     Preconditions.checkNotNull(serviceType, "serviceType");
-    GrpcChannel channel = GrpcChannelBuilder.forAddress(address).build();
+    GrpcChannel channel = GrpcChannelBuilder.forAddress(address, conf).build();
     ServiceVersionClientServiceGrpc.ServiceVersionClientServiceBlockingStub versionClient =
         ServiceVersionClientServiceGrpc.newBlockingStub(channel);
     versionClient.getServiceVersion(
diff --git a/core/common/src/test/java/alluxio/AbstractClientTest.java b/core/common/src/test/java/alluxio/AbstractClientTest.java
index 0ff8cc7789..19333598d3 100644
--- a/core/common/src/test/java/alluxio/AbstractClientTest.java
+++ b/core/common/src/test/java/alluxio/AbstractClientTest.java
@@ -15,9 +15,12 @@ import static alluxio.exception.ExceptionMessage.INCOMPATIBLE_VERSION;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.ServiceType;
 import alluxio.retry.CountingRetry;
+import alluxio.util.ConfigurationUtils;
 
 import org.junit.Ignore;
 import org.junit.Rule;
@@ -37,7 +40,7 @@ public final class AbstractClientTest {
 
   private static class BaseTestClient extends AbstractClient {
     protected BaseTestClient() {
-      super(null, null, () -> new CountingRetry(1));
+      super(null, new InstancedConfiguration(ConfigurationUtils.defaults()), null, () -> new CountingRetry(1));
     }
 
     @Override
diff --git a/core/common/src/test/java/alluxio/AuthenticatedClientUserResource.java b/core/common/src/test/java/alluxio/AuthenticatedClientUserResource.java
index fce1e3e50e..6a3d8bfcbe 100644
--- a/core/common/src/test/java/alluxio/AuthenticatedClientUserResource.java
+++ b/core/common/src/test/java/alluxio/AuthenticatedClientUserResource.java
@@ -11,6 +11,7 @@
 
 package alluxio;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.security.User;
 import alluxio.security.authentication.AuthenticatedClientUser;
 
@@ -25,8 +26,8 @@ import javax.annotation.concurrent.NotThreadSafe;
 public final class AuthenticatedClientUserResource implements Closeable {
   User mOriginal;
 
-  public AuthenticatedClientUserResource(String user) throws Exception {
-    mOriginal = AuthenticatedClientUser.get();
+  public AuthenticatedClientUserResource(String user, AlluxioConfiguration conf) throws Exception {
+    mOriginal = AuthenticatedClientUser.get(conf);
     AuthenticatedClientUser.set(user);
   }
 
diff --git a/core/common/src/test/java/alluxio/AuthenticatedClientUserResourceTest.java b/core/common/src/test/java/alluxio/AuthenticatedClientUserResourceTest.java
index 48a5264796..d808631797 100644
--- a/core/common/src/test/java/alluxio/AuthenticatedClientUserResourceTest.java
+++ b/core/common/src/test/java/alluxio/AuthenticatedClientUserResourceTest.java
@@ -13,6 +13,8 @@ package alluxio;
 
 import static org.junit.Assert.assertSame;
 
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.security.User;
 import alluxio.security.authentication.AuthenticatedClientUser;
 
@@ -33,9 +35,10 @@ public final class AuthenticatedClientUserResourceTest {
 
   @Test
   public void userRestored() throws Exception {
+    InstancedConfiguration conf = ConfigurationTestUtils.defaults();
     AuthenticatedClientUser.set(ORIGINAL_USER);
-    User original = AuthenticatedClientUser.get();
-    new AuthenticatedClientUserResource(TESTCASE_USER).close();
-    assertSame(original, AuthenticatedClientUser.get());
+    User original = AuthenticatedClientUser.get(conf);
+    new AuthenticatedClientUserResource(TESTCASE_USER, conf).close();
+    assertSame(original, AuthenticatedClientUser.get(conf));
   }
 }
diff --git a/core/common/src/test/java/alluxio/AuthenticatedUserRule.java b/core/common/src/test/java/alluxio/AuthenticatedUserRule.java
index 165c0e7e84..53a44dfc66 100644
--- a/core/common/src/test/java/alluxio/AuthenticatedUserRule.java
+++ b/core/common/src/test/java/alluxio/AuthenticatedUserRule.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.security.User;
 import alluxio.security.authentication.AuthenticatedClientUser;
 
@@ -29,17 +31,19 @@ import javax.annotation.concurrent.NotThreadSafe;
 public final class AuthenticatedUserRule extends AbstractResourceRule {
   private final String mUser;
   private User mPreviousUser;
+  private final InstancedConfiguration mConfiguration;
 
   /**
    * @param user the user name to set as authenticated user
    */
-  public AuthenticatedUserRule(String user) {
+  public AuthenticatedUserRule(String user, InstancedConfiguration conf) {
     mUser = user;
+    mConfiguration = conf;
   }
 
   @Override
   protected void before() throws Exception {
-    mPreviousUser = AuthenticatedClientUser.get();
+    mPreviousUser = AuthenticatedClientUser.get(mConfiguration);
     AuthenticatedClientUser.set(mUser);
   }
 
diff --git a/core/common/src/test/java/alluxio/AuthenticatedUserRuleTest.java b/core/common/src/test/java/alluxio/AuthenticatedUserRuleTest.java
index c2003fd6af..67091aa5e6 100644
--- a/core/common/src/test/java/alluxio/AuthenticatedUserRuleTest.java
+++ b/core/common/src/test/java/alluxio/AuthenticatedUserRuleTest.java
@@ -13,6 +13,7 @@ package alluxio;
 
 import static org.junit.Assert.assertEquals;
 
+import alluxio.conf.InstancedConfiguration;
 import alluxio.security.authentication.AuthenticatedClientUser;
 
 import org.junit.After;
@@ -27,12 +28,15 @@ public final class AuthenticatedUserRuleTest {
   private static final String RULE_USER = "rule-user";
   private static final String OUTSIDE_RULE_USER = "outside-rule-user";
 
+
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
   private final Statement mStatement = new Statement() {
     @Override
     public void evaluate() throws Throwable {
-      assertEquals(RULE_USER, AuthenticatedClientUser.get().getName());
+      assertEquals(RULE_USER, AuthenticatedClientUser.get(mConfiguration).getName());
       AuthenticatedClientUser.set(TESTCASE_USER);
-      assertEquals(TESTCASE_USER, AuthenticatedClientUser.get().getName());
+      assertEquals(TESTCASE_USER, AuthenticatedClientUser.get(mConfiguration).getName());
     }
   };
 
@@ -44,14 +48,14 @@ public final class AuthenticatedUserRuleTest {
   @Test
   public void userSetBeforeRule() throws Throwable {
     AuthenticatedClientUser.set(OUTSIDE_RULE_USER);
-    new AuthenticatedUserRule(RULE_USER).apply(mStatement, null).evaluate();
-    assertEquals(OUTSIDE_RULE_USER, AuthenticatedClientUser.get().getName());
+    new AuthenticatedUserRule(RULE_USER, mConfiguration).apply(mStatement, null).evaluate();
+    assertEquals(OUTSIDE_RULE_USER, AuthenticatedClientUser.get(mConfiguration).getName());
   }
 
   @Test
   public void noUserBeforeRule() throws Throwable {
     AuthenticatedClientUser.remove();
-    new AuthenticatedUserRule(RULE_USER).apply(mStatement, null).evaluate();
-    assertEquals(null, AuthenticatedClientUser.get());
+    new AuthenticatedUserRule(RULE_USER, mConfiguration).apply(mStatement, null).evaluate();
+    assertEquals(null, AuthenticatedClientUser.get(mConfiguration));
   }
 }
diff --git a/core/common/src/test/java/alluxio/ConfigurationRule.java b/core/common/src/test/java/alluxio/ConfigurationRule.java
index 46809cc76d..3a9d194a07 100644
--- a/core/common/src/test/java/alluxio/ConfigurationRule.java
+++ b/core/common/src/test/java/alluxio/ConfigurationRule.java
@@ -11,6 +11,9 @@
 
 package alluxio;
 
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+
 import java.util.HashMap;
 import java.util.Map;
 
@@ -20,25 +23,27 @@ import java.util.Map;
 public final class ConfigurationRule extends AbstractResourceRule {
   private final Map<PropertyKey, String> mKeyValuePairs;
   private final Map<PropertyKey, String> mStashedProperties = new HashMap<>();
+  private final InstancedConfiguration mConfiguration;
 
   /**
    * @param keyValuePairs map from configuration keys to the values to set them to
    */
-  public ConfigurationRule(Map<PropertyKey, String> keyValuePairs) {
+  public ConfigurationRule(Map<PropertyKey, String> keyValuePairs, InstancedConfiguration conf) {
     mKeyValuePairs = keyValuePairs;
+    mConfiguration = conf;
   }
 
   /**
    * @param key the key of the configuration property to set
    * @param value the value to set it to, can be null to unset this key
    */
-  public ConfigurationRule(final PropertyKey key, final String value) {
+  public ConfigurationRule(final PropertyKey key, final String value, InstancedConfiguration conf) {
     // ImmutableMap does not support nullable value, create a map literals
     this(new HashMap<PropertyKey, String>() {
       {
         put(key, value);
       }
-    });
+    }, conf);
   }
 
   @Override
@@ -46,15 +51,15 @@ public final class ConfigurationRule extends AbstractResourceRule {
     for (Map.Entry<PropertyKey, String> entry : mKeyValuePairs.entrySet()) {
       PropertyKey key = entry.getKey();
       String value = entry.getValue();
-      if (Configuration.isSet(key)) {
-        mStashedProperties.put(key, Configuration.get(key));
+      if (mConfiguration.isSet(key)) {
+        mStashedProperties.put(key, mConfiguration.get(key));
       } else {
         mStashedProperties.put(key, null);
       }
       if (value != null) {
-        Configuration.set(key, value);
+        mConfiguration.set(key, value);
       } else {
-        Configuration.unset(key);
+        mConfiguration.unset(key);
       }
     }
   }
@@ -64,9 +69,9 @@ public final class ConfigurationRule extends AbstractResourceRule {
     for (Map.Entry<PropertyKey, String> entry : mStashedProperties.entrySet()) {
       String value = entry.getValue();
       if (value != null) {
-        Configuration.set(entry.getKey(), value);
+        mConfiguration.set(entry.getKey(), value);
       } else {
-        Configuration.unset(entry.getKey());
+        mConfiguration.unset(entry.getKey());
       }
     }
   }
diff --git a/core/common/src/test/java/alluxio/ConfigurationRuleTest.java b/core/common/src/test/java/alluxio/ConfigurationRuleTest.java
index 2aab581947..d8f841caab 100644
--- a/core/common/src/test/java/alluxio/ConfigurationRuleTest.java
+++ b/core/common/src/test/java/alluxio/ConfigurationRuleTest.java
@@ -14,6 +14,8 @@ package alluxio;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import com.google.common.collect.ImmutableMap;
 import org.junit.Test;
 import org.junit.runners.model.Statement;
@@ -25,27 +27,30 @@ public final class ConfigurationRuleTest {
 
   @Test
   public void changeConfiguration() throws Throwable {
+    InstancedConfiguration conf = ConfigurationTestUtils.defaults();
     Statement statement = new Statement() {
       @Override
       public void evaluate() throws Throwable {
-        assertEquals("testValue", Configuration.get(PropertyKey.MASTER_HOSTNAME));
+        assertEquals("testValue", conf.get(PropertyKey.MASTER_HOSTNAME));
       }
     };
-    new ConfigurationRule(ImmutableMap.of(PropertyKey.MASTER_HOSTNAME, "testValue"))
+    new ConfigurationRule(ImmutableMap.of(PropertyKey.MASTER_HOSTNAME, "testValue"), conf)
         .apply(statement, null).evaluate();
   }
 
   @Test
   public void changeConfigurationForDefaultNullValue() throws Throwable {
+    InstancedConfiguration conf = ConfigurationTestUtils.defaults();
+
     Statement statement = new Statement() {
       @Override
       public void evaluate() throws Throwable {
-        assertEquals("testValue", Configuration.get(PropertyKey.SECURITY_LOGIN_USERNAME));
+        assertEquals("testValue", conf.get(PropertyKey.SECURITY_LOGIN_USERNAME));
       }
     };
-    assertFalse(Configuration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
-    new ConfigurationRule(ImmutableMap.of(PropertyKey.SECURITY_LOGIN_USERNAME, "testValue"))
+    assertFalse(conf.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
+    new ConfigurationRule(ImmutableMap.of(PropertyKey.SECURITY_LOGIN_USERNAME, "testValue"), conf)
         .apply(statement, null).evaluate();
-    assertFalse(Configuration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
+    assertFalse(conf.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
   }
 }
diff --git a/core/common/src/test/java/alluxio/ConfigurationTestUtils.java b/core/common/src/test/java/alluxio/ConfigurationTestUtils.java
index e174943f76..eaa975c8c8 100644
--- a/core/common/src/test/java/alluxio/ConfigurationTestUtils.java
+++ b/core/common/src/test/java/alluxio/ConfigurationTestUtils.java
@@ -11,6 +11,10 @@
 
 package alluxio;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.PathUtils;
 
 import com.google.common.base.Joiner;
@@ -25,14 +29,9 @@ import java.util.Map;
  */
 public final class ConfigurationTestUtils {
 
-  /**
-   * Resets the configuration to its initial state.
-   *
-   * This method should only be used as a cleanup mechanism between tests. It should not be used
-   * while any object may be using the {@link Configuration}.
-   */
-  public static void resetConfiguration() {
-    Configuration.reset();
+
+  public static InstancedConfiguration defaults(){
+    return new InstancedConfiguration(ConfigurationUtils.defaults());
   }
 
   /**
@@ -45,7 +44,7 @@ public final class ConfigurationTestUtils {
    * @param workDirectory the work directory in which to configure the journal and tiered storage
    * @return the configuration
    */
-  public static Map<PropertyKey, String> testConfigurationDefaults(String hostname,
+  public static Map<PropertyKey, String> testConfigurationDefaults(AlluxioConfiguration alluxioConf, String hostname,
       String workDirectory) {
     Map<PropertyKey, String> conf = new HashMap<>();
     conf.put(PropertyKey.MASTER_HOSTNAME, hostname);
@@ -60,11 +59,11 @@ public final class ConfigurationTestUtils {
     String ramdiskPath = PathUtils.concatPath(workDirectory, "ramdisk");
     conf.put(PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(0), ramdiskPath);
 
-    int numLevel = Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
+    int numLevel = alluxioConf.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
     for (int level = 1; level < numLevel; level++) {
       PropertyKey tierLevelDirPath =
           PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(level);
-      String[] dirPaths = Configuration.get(tierLevelDirPath).split(",");
+      String[] dirPaths = alluxioConf.get(tierLevelDirPath).split(",");
       List<String> newPaths = new ArrayList<>();
       for (String dirPath : dirPaths) {
         String newPath = workDirectory + dirPath;
diff --git a/core/common/src/test/java/alluxio/LoginUserRule.java b/core/common/src/test/java/alluxio/LoginUserRule.java
index 83b0bd9972..1e24eb8644 100644
--- a/core/common/src/test/java/alluxio/LoginUserRule.java
+++ b/core/common/src/test/java/alluxio/LoginUserRule.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.LoginUser;
 import alluxio.security.LoginUserTestUtils;
 import alluxio.security.User;
@@ -29,17 +31,19 @@ import javax.annotation.concurrent.NotThreadSafe;
 public final class LoginUserRule extends AbstractResourceRule {
   private final String mUser;
   private User mPreviousLoginUser = null;
+  private final InstancedConfiguration mConfiguration;
 
   /**
    * @param user the user name to set as authenticated user
    */
-  public LoginUserRule(String user) {
+  public LoginUserRule(String user, InstancedConfiguration conf) {
     mUser = user;
+    mConfiguration = conf;
   }
 
   @Override
   public void before() throws Exception {
-    mPreviousLoginUser = LoginUser.get();
+    mPreviousLoginUser = LoginUser.get(mConfiguration);
     LoginUserTestUtils.resetLoginUser(mUser);
   }
 
diff --git a/core/common/src/test/java/alluxio/LoginUserRuleTest.java b/core/common/src/test/java/alluxio/LoginUserRuleTest.java
index 9a960bafc4..460adea6cf 100644
--- a/core/common/src/test/java/alluxio/LoginUserRuleTest.java
+++ b/core/common/src/test/java/alluxio/LoginUserRuleTest.java
@@ -11,6 +11,7 @@
 
 package alluxio;
 
+import alluxio.conf.InstancedConfiguration;
 import alluxio.security.LoginUser;
 import alluxio.security.LoginUserTestUtils;
 
@@ -27,12 +28,14 @@ public final class LoginUserRuleTest {
   private static final String RULE_USER = "rule-user";
   private static final String OUTSIDE_RULE_USER = "outside-rule-user";
 
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
   private final Statement mStatement = new Statement() {
     @Override
     public void evaluate() throws Throwable {
-      Assert.assertEquals(RULE_USER, LoginUser.get().getName());
+      Assert.assertEquals(RULE_USER, LoginUser.get(mConfiguration).getName());
       LoginUserTestUtils.resetLoginUser(TESTCASE_USER);
-      Assert.assertEquals(TESTCASE_USER, LoginUser.get().getName());
+      Assert.assertEquals(TESTCASE_USER, LoginUser.get(mConfiguration).getName());
     }
   };
 
@@ -44,15 +47,15 @@ public final class LoginUserRuleTest {
   @Test
   public void userSetBeforeRule() throws Throwable {
     LoginUserTestUtils.resetLoginUser(OUTSIDE_RULE_USER);
-    new LoginUserRule(RULE_USER).apply(mStatement, null).evaluate();
-    Assert.assertEquals(OUTSIDE_RULE_USER, LoginUser.get().getName());
+    new LoginUserRule(RULE_USER, mConfiguration).apply(mStatement, null).evaluate();
+    Assert.assertEquals(OUTSIDE_RULE_USER, LoginUser.get(mConfiguration).getName());
   }
 
   @Test
   public void noUserBeforeRule() throws Throwable {
     LoginUserTestUtils.resetLoginUser();
-    String user = LoginUser.get().getName();
-    new LoginUserRule(RULE_USER).apply(mStatement, null).evaluate();
-    Assert.assertEquals(user, LoginUser.get().getName());
+    String user = LoginUser.get(mConfiguration).getName();
+    new LoginUserRule(RULE_USER, mConfiguration).apply(mStatement, null).evaluate();
+    Assert.assertEquals(user, LoginUser.get(mConfiguration).getName());
   }
 }
diff --git a/core/common/src/test/java/alluxio/PropertyKeyTest.java b/core/common/src/test/java/alluxio/PropertyKeyTest.java
index 77e32185ae..9970edfb4a 100644
--- a/core/common/src/test/java/alluxio/PropertyKeyTest.java
+++ b/core/common/src/test/java/alluxio/PropertyKeyTest.java
@@ -16,8 +16,9 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.PropertyKey.Builder;
-import alluxio.PropertyKey.Template;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.PropertyKey.Builder;
+import alluxio.conf.PropertyKey.Template;
 import alluxio.exception.ExceptionMessage;
 
 import org.junit.After;
diff --git a/core/common/src/test/java/alluxio/UnderFileSystemFactoryRegistryRuleTest.java b/core/common/src/test/java/alluxio/UnderFileSystemFactoryRegistryRuleTest.java
index f21eaf1b9c..a7299e5e1a 100644
--- a/core/common/src/test/java/alluxio/UnderFileSystemFactoryRegistryRuleTest.java
+++ b/core/common/src/test/java/alluxio/UnderFileSystemFactoryRegistryRuleTest.java
@@ -14,6 +14,7 @@ package alluxio;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
+import alluxio.conf.InstancedConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
@@ -28,12 +29,13 @@ public class UnderFileSystemFactoryRegistryRuleTest {
   private static final String UFS_PATH = "test://foo";
 
   private UnderFileSystemFactory mUnderFileSystemFactory;
+  private final InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
 
   private Statement mStatement = new Statement() {
     @Override
     public void evaluate() throws Throwable {
       Assert.assertEquals(mUnderFileSystemFactory, UnderFileSystemFactoryRegistry
-          .find(UFS_PATH));
+          .find(UFS_PATH, mConfiguration));
     }
   };
 
@@ -42,10 +44,10 @@ public class UnderFileSystemFactoryRegistryRuleTest {
     mUnderFileSystemFactory = mock(UnderFileSystemFactory.class);
     when(mUnderFileSystemFactory.supportsPath(UFS_PATH, null)).thenReturn(true);
     // check before
-    Assert.assertEquals(null, UnderFileSystemFactoryRegistry.find(UFS_PATH));
+    Assert.assertEquals(null, UnderFileSystemFactoryRegistry.find(UFS_PATH, mConfiguration));
     new UnderFileSystemFactoryRegistryRule(mUnderFileSystemFactory)
         .apply(mStatement, null).evaluate();
     // check after
-    Assert.assertEquals(null, UnderFileSystemFactoryRegistry.find(UFS_PATH));
+    Assert.assertEquals(null, UnderFileSystemFactoryRegistry.find(UFS_PATH, mConfiguration));
   }
 }
diff --git a/core/common/src/test/java/alluxio/cli/AbstractShellTest.java b/core/common/src/test/java/alluxio/cli/AbstractShellTest.java
index 70607ec6b5..10184024ad 100644
--- a/core/common/src/test/java/alluxio/cli/AbstractShellTest.java
+++ b/core/common/src/test/java/alluxio/cli/AbstractShellTest.java
@@ -17,6 +17,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 import static org.mockito.Mockito.any;
 
+import alluxio.ConfigurationTestUtils;
 import com.google.common.collect.ImmutableMap;
 import org.apache.commons.cli.CommandLine;
 import org.junit.Rule;
@@ -39,7 +40,7 @@ public final class AbstractShellTest {
 
     public TestShell() {
       super(ImmutableMap.<String, String[]>builder().put("cmdAlias", new String[] {"cmd", "-O"})
-          .build());
+          .build(), ConfigurationTestUtils.defaults());
     }
 
     @Override
diff --git a/core/common/src/test/java/alluxio/conf/AlluxioPropertiesTest.java b/core/common/src/test/java/alluxio/conf/AlluxioPropertiesTest.java
index 50acfb2ec5..a511089f80 100644
--- a/core/common/src/test/java/alluxio/conf/AlluxioPropertiesTest.java
+++ b/core/common/src/test/java/alluxio/conf/AlluxioPropertiesTest.java
@@ -18,8 +18,6 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.PropertyKey;
-
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import org.junit.After;
diff --git a/core/common/src/test/java/alluxio/ConfigurationTest.java b/core/common/src/test/java/alluxio/conf/ConfigurationTest.java
similarity index 60%
rename from core/common/src/test/java/alluxio/ConfigurationTest.java
rename to core/common/src/test/java/alluxio/conf/ConfigurationTest.java
index be96786a19..ab0813e306 100644
--- a/core/common/src/test/java/alluxio/ConfigurationTest.java
+++ b/core/common/src/test/java/alluxio/conf/ConfigurationTest.java
@@ -9,7 +9,7 @@
  * See the NOTICE file distributed with this work for information regarding copyright ownership.
  */
 
-package alluxio;
+package alluxio.conf;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -17,13 +17,19 @@ import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.PropertyKey.Template;
-import alluxio.conf.Source;
+import alluxio.AlluxioTestDirectory;
+import alluxio.ConfigurationTestUtils;
+import alluxio.Constants;
+import alluxio.DefaultSupplier;
+import alluxio.SystemPropertyRule;
+import alluxio.conf.PropertyKey.Template;
 
+import alluxio.util.ConfigurationUtils;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 import org.hamcrest.CoreMatchers;
-import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -42,26 +48,39 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.regex.Pattern;
 
 /**
- * Unit tests for the {@link Configuration} class.
+ * Unit tests for the {@link alluxio.conf.InstancedConfiguration} class.
  */
 public class ConfigurationTest {
+
+  private  InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
   @Rule
   public final ExpectedException mThrown = ExpectedException.none();
 
   @Rule
   public final TemporaryFolder mFolder = new TemporaryFolder();
 
-  @After
-  public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+  @Before
+  public void before() {
+    resetConf();
+  }
+
+  public void resetConf() {
+    ConfigurationUtils.reloadProperties();
+    mConfiguration = ConfigurationTestUtils.defaults();
   }
 
+  @AfterClass
+  public static void after() {
+    ConfigurationUtils.reloadProperties();
+  }
+
+
   @Test
   public void defaultLoggerCorrectlyLoaded() throws Exception {
     // Avoid interference from system properties. site-properties will not be loaded during tests
     try (Closeable p =
         new SystemPropertyRule(PropertyKey.LOGGER_TYPE.toString(), null).toResource()) {
-      String loggerType = Configuration.get(PropertyKey.LOGGER_TYPE);
+      String loggerType = mConfiguration.get(PropertyKey.LOGGER_TYPE);
       assertEquals("Console", loggerType);
     }
   }
@@ -70,144 +89,144 @@ public class ConfigurationTest {
   public void alias() throws Exception {
     try (Closeable p =
         new SystemPropertyRule("alluxio.master.worker.timeout.ms", "100").toResource()) {
-      Configuration.reset();
-      assertEquals(100, Configuration.getMs(PropertyKey.MASTER_WORKER_TIMEOUT_MS));
+      resetConf();
+      assertEquals(100, mConfiguration.getMs(PropertyKey.MASTER_WORKER_TIMEOUT_MS));
     }
   }
 
   @Test
   public void containsKey() {
-    assertFalse(Configuration.containsKey(PropertyKey.ZOOKEEPER_ADDRESS));
-    Configuration.set(PropertyKey.ZOOKEEPER_ADDRESS, "address");
-    assertTrue(Configuration.containsKey(PropertyKey.ZOOKEEPER_ADDRESS));
+    assertFalse(mConfiguration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
+    mConfiguration.set(PropertyKey.ZOOKEEPER_ADDRESS, "address");
+    assertTrue(mConfiguration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
   }
 
   @Test
   public void isSet() {
-    assertFalse(Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
-    Configuration.set(PropertyKey.ZOOKEEPER_ADDRESS, "address");
-    assertTrue(Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
+    assertFalse(mConfiguration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
+    mConfiguration.set(PropertyKey.ZOOKEEPER_ADDRESS, "address");
+    assertTrue(mConfiguration.isSet(PropertyKey.ZOOKEEPER_ADDRESS));
   }
 
   @Test
   public void isSetResolve() {
-    Configuration.unset(PropertyKey.MASTER_HOSTNAME);
-    Configuration.set(PropertyKey.MASTER_WEB_HOSTNAME, "${alluxio.master.hostname}");
-    assertFalse(Configuration.isSet(PropertyKey.MASTER_WEB_HOSTNAME));
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "localhost");
-    assertTrue(Configuration.isSet(PropertyKey.MASTER_WEB_HOSTNAME));
+    mConfiguration.unset(PropertyKey.MASTER_HOSTNAME);
+    mConfiguration.set(PropertyKey.MASTER_WEB_HOSTNAME, "${alluxio.master.hostname}");
+    assertFalse(mConfiguration.isSet(PropertyKey.MASTER_WEB_HOSTNAME));
+    mConfiguration.set(PropertyKey.MASTER_HOSTNAME, "localhost");
+    assertTrue(mConfiguration.isSet(PropertyKey.MASTER_WEB_HOSTNAME));
   }
 
   @Test
   public void getInt() {
-    Configuration.set(PropertyKey.WEB_THREADS, "1");
-    assertEquals(1, Configuration.getInt(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "1");
+    assertEquals(1, mConfiguration.getInt(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getIntResolve() {
-    Configuration.set(PropertyKey.LOGSERVER_THREADS_MAX, "${alluxio.master.worker.threads.max}");
-    Configuration.set(PropertyKey.MASTER_WORKER_THREADS_MAX, "${alluxio.worker.block.threads.max}");
-    Configuration.set(PropertyKey.WORKER_BLOCK_THREADS_MAX, "10");
-    assertEquals(10, Configuration.getInt(PropertyKey.LOGSERVER_THREADS_MAX));
+    mConfiguration.set(PropertyKey.LOGSERVER_THREADS_MAX, "${alluxio.master.worker.threads.max}");
+    mConfiguration.set(PropertyKey.MASTER_WORKER_THREADS_MAX, "${alluxio.worker.block.threads.max}");
+    mConfiguration.set(PropertyKey.WORKER_BLOCK_THREADS_MAX, "10");
+    assertEquals(10, mConfiguration.getInt(PropertyKey.LOGSERVER_THREADS_MAX));
   }
 
   @Test
   public void getMalformedIntThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS, "9448367483758473854738"); // bigger than MAX_INT
+    mConfiguration.set(PropertyKey.WEB_THREADS, "9448367483758473854738"); // bigger than MAX_INT
     mThrown.expect(RuntimeException.class);
-    Configuration.getInt(PropertyKey.WEB_THREADS);
+    mConfiguration.getInt(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getLong() {
-    Configuration.set(PropertyKey.WEB_THREADS, "12345678910"); // bigger than MAX_INT
-    assertEquals(12345678910L, Configuration.getLong(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "12345678910"); // bigger than MAX_INT
+    assertEquals(12345678910L, mConfiguration.getLong(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getMalformedLongThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS,
+    mConfiguration.set(PropertyKey.WEB_THREADS,
         "999999999999999999999999999999999999"); // bigger than MAX_LONG
     mThrown.expect(RuntimeException.class);
-    Configuration.getLong(PropertyKey.WEB_THREADS);
+    mConfiguration.getLong(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getDouble() {
-    Configuration.set(PropertyKey.WEB_THREADS, "1.1");
-    assertEquals(1.1, Configuration.getDouble(PropertyKey.WEB_THREADS),
+    mConfiguration.set(PropertyKey.WEB_THREADS, "1.1");
+    assertEquals(1.1, mConfiguration.getDouble(PropertyKey.WEB_THREADS),
         /*tolerance=*/0.0001);
   }
 
   @Test
   public void getMalformedDoubleThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS, "1a");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "1a");
     mThrown.expect(RuntimeException.class);
-    Configuration.getDouble(PropertyKey.WEB_THREADS);
+    mConfiguration.getDouble(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getFloat() {
-    Configuration.set(PropertyKey.WEB_THREADS, "1.1");
-    assertEquals(1.1, Configuration.getFloat(PropertyKey.WEB_THREADS), /*tolerance=*/0.0001);
+    mConfiguration.set(PropertyKey.WEB_THREADS, "1.1");
+    assertEquals(1.1, mConfiguration.getFloat(PropertyKey.WEB_THREADS), /*tolerance=*/0.0001);
   }
 
   @Test
   public void getMalformedFloatThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS, "1a");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "1a");
     mThrown.expect(RuntimeException.class);
-    Configuration.getFloat(PropertyKey.WEB_THREADS);
+    mConfiguration.getFloat(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getTrueBoolean() {
-    Configuration.set(PropertyKey.WEB_THREADS, "true");
-    assertTrue(Configuration.getBoolean(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "true");
+    assertTrue(mConfiguration.getBoolean(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getTrueBooleanUppercase() {
-    Configuration.set(PropertyKey.WEB_THREADS, "True");
-    assertTrue(Configuration.getBoolean(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "True");
+    assertTrue(mConfiguration.getBoolean(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getTrueBooleanMixcase() {
-    Configuration.set(PropertyKey.WEB_THREADS, "tRuE");
-    assertTrue(Configuration.getBoolean(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "tRuE");
+    assertTrue(mConfiguration.getBoolean(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getFalseBoolean() {
-    Configuration.set(PropertyKey.WEB_THREADS, "false");
-    assertFalse(Configuration.getBoolean(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "false");
+    assertFalse(mConfiguration.getBoolean(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getFalseBooleanUppercase() {
-    Configuration.set(PropertyKey.WEB_THREADS, "False");
-    assertFalse(Configuration.getBoolean(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "False");
+    assertFalse(mConfiguration.getBoolean(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getFalseBooleanMixcase() {
-    Configuration.set(PropertyKey.WEB_THREADS, "fAlSe");
-    assertFalse(Configuration.getBoolean(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "fAlSe");
+    assertFalse(mConfiguration.getBoolean(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getMalformedBooleanThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS, "x");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "x");
     mThrown.expect(RuntimeException.class);
-    Configuration.getBoolean(PropertyKey.WEB_THREADS);
+    mConfiguration.getBoolean(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getList() {
-    Configuration.set(PropertyKey.WEB_THREADS, "a,b,c");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "a,b,c");
     assertEquals(
-        Lists.newArrayList("a", "b", "c"), Configuration.getList(PropertyKey.WEB_THREADS, ","));
+        Lists.newArrayList("a", "b", "c"), mConfiguration.getList(PropertyKey.WEB_THREADS, ","));
   }
 
   private enum TestEnum {
@@ -216,304 +235,304 @@ public class ConfigurationTest {
 
   @Test
   public void getEnum() {
-    Configuration.set(PropertyKey.WEB_THREADS, "VALUE");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "VALUE");
     assertEquals(
-        TestEnum.VALUE, Configuration.getEnum(PropertyKey.WEB_THREADS, TestEnum.class));
+        TestEnum.VALUE, mConfiguration.getEnum(PropertyKey.WEB_THREADS, TestEnum.class));
   }
 
   @Test
   public void getMalformedEnum() {
-    Configuration.set(PropertyKey.WEB_THREADS, "not_a_value");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "not_a_value");
     mThrown.expect(RuntimeException.class);
-    Configuration.getEnum(PropertyKey.WEB_THREADS, TestEnum.class);
+    mConfiguration.getEnum(PropertyKey.WEB_THREADS, TestEnum.class);
   }
 
   @Test
   public void getBytes() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10b");
-    assertEquals(10, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10b");
+    assertEquals(10, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getBytesKb() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10kb");
-    assertEquals(10 * Constants.KB, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10kb");
+    assertEquals(10 * Constants.KB, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getBytesMb() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10mb");
-    assertEquals(10 * Constants.MB, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10mb");
+    assertEquals(10 * Constants.MB, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getBytesGb() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10gb");
-    assertEquals(10 * (long) Constants.GB, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10gb");
+    assertEquals(10 * (long) Constants.GB, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getBytesGbUppercase() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10GB");
-    assertEquals(10 * (long) Constants.GB, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10GB");
+    assertEquals(10 * (long) Constants.GB, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getBytesTb() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10tb");
-    assertEquals(10 * Constants.TB, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10tb");
+    assertEquals(10 * Constants.TB, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getBytespT() {
-    Configuration.set(PropertyKey.WEB_THREADS, "10pb");
-    assertEquals(10 * Constants.PB, Configuration.getBytes(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "10pb");
+    assertEquals(10 * Constants.PB, mConfiguration.getBytes(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getMalformedBytesThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS, "100a");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "100a");
     mThrown.expect(RuntimeException.class);
-    Configuration.getBoolean(PropertyKey.WEB_THREADS);
+    mConfiguration.getBoolean(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getMs() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "100");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "100");
     assertEquals(100,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsMS() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "100ms");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "100ms");
     assertEquals(100,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsMillisecond() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "100millisecond");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "100millisecond");
     assertEquals(100,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsS() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10s");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10s");
     assertEquals(10 * Constants.SECOND,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsSUppercase() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10S");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10S");
     assertEquals(10 * Constants.SECOND,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsSEC() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10sec");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10sec");
     assertEquals(10 * Constants.SECOND,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsSecond() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10second");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10second");
     assertEquals(10 * Constants.SECOND,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsM() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10m");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10m");
     assertEquals(10 * Constants.MINUTE,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsMIN() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10min");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10min");
     assertEquals(10 * Constants.MINUTE,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsMinute() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10minute");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10minute");
     assertEquals(10 * Constants.MINUTE,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsH() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10h");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10h");
     assertEquals(10 * Constants.HOUR,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsHR() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10hr");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10hr");
     assertEquals(10 * Constants.HOUR,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsHour() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10hour");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10hour");
     assertEquals(10 * Constants.HOUR,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsD() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10d");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10d");
     assertEquals(10 * Constants.DAY,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getMsDay() {
-    Configuration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10day");
+    mConfiguration.set(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS, "10day");
     assertEquals(10 * Constants.DAY,
-        Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
+        mConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS));
   }
 
   @Test
   public void getNegativeSyncInterval() {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
-    assertEquals(-1, Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
+    mConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
+    assertEquals(-1, mConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
   }
 
   @Test
   public void getNegativeSyncIntervalS() {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1s");
-    assertTrue(Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL) < 0);
+    mConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1s");
+    assertTrue(mConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL) < 0);
   }
 
   @Test
   public void getZeroSyncInterval() {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
-    assertEquals(0, Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
+    mConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
+    assertEquals(0, mConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
   }
 
   @Test
   public void getZeroSyncIntervalS() {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0s");
-    assertEquals(0, Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
+    mConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0s");
+    assertEquals(0, mConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
   }
 
   @Test
   public void getPositiveSyncInterval() {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "10");
-    assertEquals(10, Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
+    mConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "10");
+    assertEquals(10, mConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
   }
 
   @Test
   public void getPosiviteSyncIntervalS() {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "10s");
+    mConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "10s");
     assertEquals(10 * Constants.SECOND_MS,
-        Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
+        mConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL));
   }
 
   @Test
   public void getUnsetValueThrowsException() {
     mThrown.expect(RuntimeException.class);
-    Configuration.get(PropertyKey.S3A_ACCESS_KEY);
+    mConfiguration.get(PropertyKey.S3A_ACCESS_KEY);
   }
 
   @Test
   public void getNestedProperties() {
-    Configuration.set(
+    mConfiguration.set(
         PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION_PROPERTY.format("foo",
             PropertyKey.WEB_THREADS.toString()), "val1");
-    Configuration.set(
+    mConfiguration.set(
         PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION_PROPERTY.format("foo",
             "alluxio.unknown.property"), "val2");
     Map<String, String> expected = new HashMap<>();
     expected.put(PropertyKey.WEB_THREADS.toString(), "val1");
     expected.put("alluxio.unknown.property", "val2");
-    assertThat(Configuration.getNestedProperties(
+    assertThat(mConfiguration.getNestedProperties(
         PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION.format("foo")),
         CoreMatchers.is(expected));
   }
 
   @Test
   public void getNestedPropertiesEmptyTrailingProperty() {
-    Configuration.set(PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION_PROPERTY
+    mConfiguration.set(PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION_PROPERTY
         .format("foo", ""), "val");
     Map<String, String> empty = new HashMap<>();
-    assertThat(Configuration.getNestedProperties(
+    assertThat(mConfiguration.getNestedProperties(
         PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION.format("foo")),
         CoreMatchers.is(empty));
   }
 
   @Test
   public void getNestedPropertiesWrongPrefix() {
-    Configuration.set(
+    mConfiguration.set(
         PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION_PROPERTY.format("foo",
             PropertyKey.WEB_THREADS.toString()),
         "val");
     Map<String, String> empty = new HashMap<>();
-    assertThat(Configuration.getNestedProperties(PropertyKey.HOME),
+    assertThat(mConfiguration.getNestedProperties(PropertyKey.HOME),
         CoreMatchers.is(empty));
-    assertThat(Configuration.getNestedProperties(
+    assertThat(mConfiguration.getNestedProperties(
         PropertyKey.Template.MASTER_MOUNT_TABLE_OPTION.format("bar")),
         CoreMatchers.is(empty));
   }
 
   @Test
   public void getClassTest() { // The name getClass is already reserved.
-    Configuration.set(PropertyKey.WEB_THREADS, "java.lang.String");
-    assertEquals(String.class, Configuration.getClass(PropertyKey.WEB_THREADS));
+    mConfiguration.set(PropertyKey.WEB_THREADS, "java.lang.String");
+    assertEquals(String.class, mConfiguration.getClass(PropertyKey.WEB_THREADS));
   }
 
   @Test
   public void getMalformedClassThrowsException() {
-    Configuration.set(PropertyKey.WEB_THREADS, "java.util.not.a.class");
+    mConfiguration.set(PropertyKey.WEB_THREADS, "java.util.not.a.class");
     mThrown.expect(RuntimeException.class);
-    Configuration.getClass(PropertyKey.WEB_THREADS);
+    mConfiguration.getClass(PropertyKey.WEB_THREADS);
   }
 
   @Test
   public void getTemplatedKey() {
-    Configuration.set(PropertyKey.MASTER_TIERED_STORE_GLOBAL_LEVEL0_ALIAS, "test");
+    mConfiguration.set(PropertyKey.MASTER_TIERED_STORE_GLOBAL_LEVEL0_ALIAS, "test");
     assertEquals("test",
-        Configuration.get(PropertyKey.Template.MASTER_TIERED_STORE_GLOBAL_LEVEL_ALIAS.format(0)));
+        mConfiguration.get(PropertyKey.Template.MASTER_TIERED_STORE_GLOBAL_LEVEL_ALIAS.format(0)));
   }
 
   @Test
   public void variableSubstitution() {
-    Configuration.merge(ImmutableMap.of(
+    mConfiguration.merge(ImmutableMap.of(
         PropertyKey.WORK_DIR, "value",
         PropertyKey.LOGS_DIR, "${alluxio.work.dir}/logs"),
         Source.SYSTEM_PROPERTY);
-    String substitution = Configuration.get(PropertyKey.LOGS_DIR);
+    String substitution = mConfiguration.get(PropertyKey.LOGS_DIR);
     assertEquals("value/logs", substitution);
   }
 
   @Test
   public void twoVariableSubstitution() {
-    Configuration.merge(ImmutableMap.of(
+    mConfiguration.merge(ImmutableMap.of(
         PropertyKey.MASTER_HOSTNAME, "value1",
         PropertyKey.MASTER_RPC_PORT, "value2",
         PropertyKey.MASTER_JOURNAL_FOLDER, "${alluxio.master.hostname}-${alluxio.master.port}"),
         Source.SYSTEM_PROPERTY);
-    String substitution = Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
+    String substitution = mConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
     assertEquals("value1-value2", substitution);
   }
 
   @Test
   public void recursiveVariableSubstitution() {
-    Configuration.merge(ImmutableMap.of(
+    mConfiguration.merge(ImmutableMap.of(
         PropertyKey.WORK_DIR, "value",
         PropertyKey.LOGS_DIR, "${alluxio.work.dir}/logs",
         PropertyKey.SITE_CONF_DIR, "${alluxio.logs.dir}/conf"),
         Source.SYSTEM_PROPERTY);
-    String substitution2 = Configuration.get(PropertyKey.SITE_CONF_DIR);
+    String substitution2 = mConfiguration.get(PropertyKey.SITE_CONF_DIR);
     assertEquals("value/logs/conf", substitution2);
   }
 
@@ -521,85 +540,86 @@ public class ConfigurationTest {
   public void systemVariableSubstitution() throws Exception {
     try (Closeable p =
         new SystemPropertyRule(PropertyKey.MASTER_HOSTNAME.toString(), "new_master").toResource()) {
-      Configuration.reset();
-      assertEquals("new_master", Configuration.get(PropertyKey.MASTER_HOSTNAME));
+
+      resetConf();
+      assertEquals("new_master", mConfiguration.get(PropertyKey.MASTER_HOSTNAME));
     }
   }
 
   @Test
   public void systemPropertySubstitution() throws Exception {
     try (Closeable p = new SystemPropertyRule("user.home", "/home").toResource()) {
-      Configuration.reset();
-      Configuration.set(PropertyKey.WORK_DIR, "${user.home}/work");
-      assertEquals("/home/work", Configuration.get(PropertyKey.WORK_DIR));
+      resetConf();
+      mConfiguration.set(PropertyKey.WORK_DIR, "${user.home}/work");
+      assertEquals("/home/work", mConfiguration.get(PropertyKey.WORK_DIR));
     }
   }
 
   @Test
   public void circularSubstitution() throws Exception {
-    Configuration.set(PropertyKey.HOME, String.format("${%s}", PropertyKey.HOME.toString()));
+    mConfiguration.set(PropertyKey.HOME, String.format("${%s}", PropertyKey.HOME.toString()));
     mThrown.expect(RuntimeException.class);
     mThrown.expectMessage(PropertyKey.HOME.toString());
-    Configuration.get(PropertyKey.HOME);
+    mConfiguration.get(PropertyKey.HOME);
   }
 
   @Test
   public void userFileBufferBytesOverFlowException() {
-    Configuration.set(PropertyKey.USER_FILE_BUFFER_BYTES,
+    mConfiguration.set(PropertyKey.USER_FILE_BUFFER_BYTES,
         String.valueOf(Integer.MAX_VALUE + 1) + "B");
     mThrown.expect(IllegalStateException.class);
-    Configuration.validate();
+    mConfiguration.validate();
   }
 
   @Test
   public void shortMasterHeartBeatTimeout() {
-    Configuration.set(PropertyKey.MASTER_MASTER_HEARTBEAT_INTERVAL, "5min");
-    Configuration.set(PropertyKey.MASTER_HEARTBEAT_TIMEOUT, "4min");
+    mConfiguration.set(PropertyKey.MASTER_MASTER_HEARTBEAT_INTERVAL, "5min");
+    mConfiguration.set(PropertyKey.MASTER_HEARTBEAT_TIMEOUT, "4min");
     mThrown.expect(IllegalStateException.class);
-    Configuration.validate();
+    mConfiguration.validate();
   }
 
   @Test
   public void setUserFileBufferBytesMaxInteger() {
-    Configuration.set(PropertyKey.USER_FILE_BUFFER_BYTES, String.valueOf(Integer.MAX_VALUE) + "B");
+    mConfiguration.set(PropertyKey.USER_FILE_BUFFER_BYTES, String.valueOf(Integer.MAX_VALUE) + "B");
     assertEquals(Integer.MAX_VALUE,
-        (int) Configuration.getBytes(PropertyKey.USER_FILE_BUFFER_BYTES));
+        (int) mConfiguration.getBytes(PropertyKey.USER_FILE_BUFFER_BYTES));
   }
 
   @Test
   public void setUserFileBufferBytes1GB() {
-    Configuration.set(PropertyKey.USER_FILE_BUFFER_BYTES, "1GB");
+    mConfiguration.set(PropertyKey.USER_FILE_BUFFER_BYTES, "1GB");
     assertEquals(1073741824,
-        (int) Configuration.getBytes(PropertyKey.USER_FILE_BUFFER_BYTES));
+        (int) mConfiguration.getBytes(PropertyKey.USER_FILE_BUFFER_BYTES));
   }
 
   @Test
   public void unset() {
-    assertFalse(Configuration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "test");
-    assertTrue(Configuration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
-    Configuration.unset(PropertyKey.SECURITY_LOGIN_USERNAME);
-    assertFalse(Configuration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
+    assertFalse(mConfiguration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "test");
+    assertTrue(mConfiguration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
+    mConfiguration.unset(PropertyKey.SECURITY_LOGIN_USERNAME);
+    assertFalse(mConfiguration.isSet(PropertyKey.SECURITY_LOGIN_USERNAME));
   }
 
   @Test
   public void validateTieredLocality() throws Exception {
     // Pre-load the Configuration class so that the exception is thrown when we call init(), not
     // during class loading.
-    Configuration.reset();
+    resetConf();
     HashMap<String, String> sysProps = new HashMap<>();
     sysProps.put(Template.LOCALITY_TIER.format("unknownTier").toString(), "val");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
       mThrown.expect(IllegalStateException.class);
       mThrown.expectMessage("Tier unknownTier is configured by alluxio.locality.unknownTier, but "
           + "does not exist in the tier list [node, rack] configured by alluxio.locality.order");
-      Configuration.reset();
+      resetConf();
     }
   }
 
   @Test
   public void propertyTestModeEqualsTrue() throws Exception {
-    assertTrue(Configuration.getBoolean(PropertyKey.TEST_MODE));
+    assertTrue(mConfiguration.getBoolean(PropertyKey.TEST_MODE));
   }
 
   @Test
@@ -614,9 +634,9 @@ public class ConfigurationTest {
     sysProps.put(PropertyKey.LOGGER_TYPE.toString(), null);
     sysProps.put(PropertyKey.SITE_CONF_DIR.toString(), mFolder.getRoot().getAbsolutePath());
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      Configuration.reset();
+      mConfiguration = ConfigurationTestUtils.defaults();
       assertEquals(PropertyKey.LOGGER_TYPE.getDefaultValue(),
-          Configuration.get(PropertyKey.LOGGER_TYPE));
+          mConfiguration.get(PropertyKey.LOGGER_TYPE));
     }
   }
 
@@ -633,16 +653,14 @@ public class ConfigurationTest {
     sysProps.put(PropertyKey.SITE_CONF_DIR.toString(), mFolder.getRoot().getAbsolutePath());
     sysProps.put(PropertyKey.TEST_MODE.toString(), "false");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      Configuration.reset();
-      assertEquals("TEST_LOGGER", Configuration.get(PropertyKey.LOGGER_TYPE));
+      resetConf();
+      assertEquals("TEST_LOGGER", mConfiguration.get(PropertyKey.LOGGER_TYPE));
     }
   }
 
   @Test
   public void setIgnoredPropertiesInSiteProperties() throws Exception {
-    // Need to initialize the configuration instance first, other wise in after
-    // ConfigurationTestUtils.resetConfiguration() will fail due to failed class init.
-    Configuration.reset();
+    resetConf();
     Properties siteProps = new Properties();
     siteProps.setProperty(PropertyKey.LOGS_DIR.toString(), "/tmp/logs1");
     File propsFile = mFolder.newFile(Constants.SITE_PROPERTIES);
@@ -652,7 +670,7 @@ public class ConfigurationTest {
     sysProps.put(PropertyKey.TEST_MODE.toString(), "false");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
       mThrown.expect(IllegalStateException.class);
-      Configuration.reset();
+      resetConf();
     }
   }
 
@@ -666,10 +684,10 @@ public class ConfigurationTest {
     sysProps.put(PropertyKey.SITE_CONF_DIR.toString(), mFolder.getRoot().getAbsolutePath());
     sysProps.put(PropertyKey.TEST_MODE.toString(), "false");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      Configuration.reset();
+      resetConf();
       assertEquals(
-          Source.SYSTEM_PROPERTY, Configuration.getSource(PropertyKey.LOGS_DIR));
-      assertEquals("/tmp/logs1", Configuration.get(PropertyKey.LOGS_DIR));
+          Source.SYSTEM_PROPERTY, mConfiguration.getSource(PropertyKey.LOGS_DIR));
+      assertEquals("/tmp/logs1", mConfiguration.get(PropertyKey.LOGS_DIR));
     }
   }
 
@@ -686,9 +704,9 @@ public class ConfigurationTest {
     sysProps.put(PropertyKey.SITE_CONF_DIR.toString(), mFolder.getRoot().getAbsolutePath());
     sysProps.put(PropertyKey.TEST_MODE.toString(), "false");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      Configuration.reset();
-      assertEquals("host-1", Configuration.get(PropertyKey.MASTER_HOSTNAME));
-      assertEquals("123", Configuration.get(PropertyKey.WEB_THREADS));
+      resetConf();
+      assertEquals("host-1", mConfiguration.get(PropertyKey.MASTER_HOSTNAME));
+      assertEquals("123", mConfiguration.get(PropertyKey.WEB_THREADS));
     }
   }
 
@@ -705,19 +723,19 @@ public class ConfigurationTest {
     sysProps.put(PropertyKey.SITE_CONF_DIR.toString(), mFolder.getRoot().getAbsolutePath());
     sysProps.put(PropertyKey.TEST_MODE.toString(), "false");
     try (Closeable p = new SystemPropertyRule(sysProps).toResource()) {
-      Configuration.reset();
+      resetConf();
       // set only in site prop
       assertEquals(Source.Type.SITE_PROPERTY,
-          Configuration.getSource(PropertyKey.MASTER_HOSTNAME).getType());
+          mConfiguration.getSource(PropertyKey.MASTER_HOSTNAME).getType());
       // set both in site and system prop
       assertEquals(Source.SYSTEM_PROPERTY,
-          Configuration.getSource(PropertyKey.MASTER_WEB_PORT));
+          mConfiguration.getSource(PropertyKey.MASTER_WEB_PORT));
       // set only in system prop
       assertEquals(Source.SYSTEM_PROPERTY,
-          Configuration.getSource(PropertyKey.LOGS_DIR));
+          mConfiguration.getSource(PropertyKey.LOGS_DIR));
       // set neither in system prop
       assertEquals(Source.DEFAULT,
-          Configuration.getSource(PropertyKey.MASTER_RPC_PORT));
+          mConfiguration.getSource(PropertyKey.MASTER_RPC_PORT));
     }
   }
 
@@ -727,9 +745,9 @@ public class ConfigurationTest {
     PropertyKey key = new PropertyKey.Builder("testKey")
         .setDefaultSupplier(new DefaultSupplier(() -> x.get(), "finds x"))
         .build();
-    assertEquals(100, Configuration.getInt(key));
+    assertEquals(100, mConfiguration.getInt(key));
     x.set(20);
-    assertEquals(20, Configuration.getInt(key));
+    assertEquals(20, mConfiguration.getInt(key));
   }
 
   @Test
@@ -738,12 +756,12 @@ public class ConfigurationTest {
     String testKeyName = "alluxio.extensions.dir";
     PropertyKey nestedKey = PropertyKey.SECURITY_LOGIN_USERNAME;
     String nestedValue = String.format("${%s}.test", testKeyName);
-    Configuration.set(nestedKey, nestedValue);
+    mConfiguration.set(nestedKey, nestedValue);
 
-    Map<String, String> resolvedMap = Configuration.toMap();
+    Map<String, String> resolvedMap = mConfiguration.toMap();
 
     // Test if the value of the created nested property is correct
-    assertEquals(Configuration.get(PropertyKey.fromString(testKeyName)),
+    assertEquals(mConfiguration.get(PropertyKey.fromString(testKeyName)),
         resolvedMap.get(testKeyName));
     String nestedResolvedValue = String.format("%s.test", resolvedMap.get(testKeyName));
     assertEquals(nestedResolvedValue, resolvedMap.get(nestedKey.toString()));
@@ -771,10 +789,10 @@ public class ConfigurationTest {
     // Create a nested property to test
     PropertyKey testKey = PropertyKey.SECURITY_LOGIN_USERNAME;
     String testValue = String.format("${%s}.test", "alluxio.extensions.dir");
-    Configuration.set(testKey, testValue);
+    mConfiguration.set(testKey, testValue);
 
     Map<String, String> rawMap =
-        Configuration.toMap(ConfigurationValueOptions.defaults().useRawValue(true));
+        mConfiguration.toMap(ConfigurationValueOptions.defaults().useRawValue(true));
 
     // Test if the value of the created nested property remains raw
     assertEquals(testValue, rawMap.get(testKey.toString()));
@@ -790,11 +808,11 @@ public class ConfigurationTest {
     PropertyKey testKey = PropertyKey.S3A_SECRET_KEY;
     String testValue = "12345";
     assertEquals(PropertyKey.DisplayType.CREDENTIALS, testKey.getDisplayType());
-    Configuration.set(testKey, testValue);
+    mConfiguration.set(testKey, testValue);
 
-    assertNotEquals(testValue, Configuration.get(testKey,
+    assertNotEquals(testValue, mConfiguration.get(testKey,
         ConfigurationValueOptions.defaults().useDisplayValue(true)));
-    assertNotEquals(testValue, Configuration.toMap(
+    assertNotEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true))
         .get(testKey.getName()));
   }
@@ -804,11 +822,11 @@ public class ConfigurationTest {
     PropertyKey testKey = PropertyKey.SECURITY_LOGIN_USERNAME;
     String testValue = "12345";
     assertEquals(PropertyKey.DisplayType.DEFAULT, testKey.getDisplayType());
-    Configuration.set(testKey, testValue);
+    mConfiguration.set(testKey, testValue);
 
-    assertEquals(testValue, Configuration.get(testKey,
+    assertEquals(testValue, mConfiguration.get(testKey,
         ConfigurationValueOptions.defaults().useDisplayValue(true)));
-    assertEquals(testValue, Configuration.toMap(
+    assertEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true))
         .get(testKey.getName()));
   }
@@ -818,14 +836,14 @@ public class ConfigurationTest {
     PropertyKey nestedProperty =
         PropertyKey.fromString("alluxio.master.journal.ufs.option.aws.secretKey");
     String testValue = "12345";
-    Configuration.set(nestedProperty, testValue);
+    mConfiguration.set(nestedProperty, testValue);
 
-    assertNotEquals(testValue, Configuration.get(nestedProperty,
+    assertNotEquals(testValue, mConfiguration.get(nestedProperty,
         ConfigurationValueOptions.defaults().useDisplayValue(true)));
-    assertNotEquals(testValue, Configuration.toMap(
+    assertNotEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true))
         .get(nestedProperty.getName()));
-    assertNotEquals(testValue, Configuration.toMap(
+    assertNotEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(true))
         .get(nestedProperty.getName()));
   }
@@ -835,14 +853,14 @@ public class ConfigurationTest {
     PropertyKey nestedProperty = PropertyKey.fromString(
         "alluxio.master.journal.ufs.option.alluxio.underfs.hdfs.configuration");
     String testValue = "conf/core-site.xml:conf/hdfs-site.xml";
-    Configuration.set(nestedProperty, testValue);
+    mConfiguration.set(nestedProperty, testValue);
 
-    assertEquals(testValue, Configuration.get(nestedProperty,
+    assertEquals(testValue, mConfiguration.get(nestedProperty,
         ConfigurationValueOptions.defaults().useDisplayValue(true)));
-    assertEquals(testValue, Configuration.toMap(
+    assertEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true))
         .get(nestedProperty.getName()));
-    assertEquals(testValue, Configuration.toMap(
+    assertEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(true))
         .get(nestedProperty.getName()));
   }
@@ -852,14 +870,14 @@ public class ConfigurationTest {
     PropertyKey templateProperty = PropertyKey.fromString(
         "fs.azure.account.key.someone.blob.core.windows.net");
     String testValue = "12345";
-    Configuration.set(templateProperty, testValue);
+    mConfiguration.set(templateProperty, testValue);
 
-    assertNotEquals(testValue, Configuration.get(templateProperty,
+    assertNotEquals(testValue, mConfiguration.get(templateProperty,
         ConfigurationValueOptions.defaults().useDisplayValue(true)));
-    assertNotEquals(testValue, Configuration.toMap(
+    assertNotEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true))
         .get(templateProperty.getName()));
-    assertNotEquals(testValue, Configuration.toMap(
+    assertNotEquals(testValue, mConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(true))
         .get(templateProperty.getName()));
   }
@@ -870,14 +888,14 @@ public class ConfigurationTest {
     String testValue = "12345";
     assertEquals(PropertyKey.DisplayType.CREDENTIALS, testKey.getDisplayType());
 
-    Configuration.set(testKey, testValue);
-    String displayValue1 = Configuration.get(testKey,
+    mConfiguration.set(testKey, testValue);
+    String displayValue1 = mConfiguration.get(testKey,
         ConfigurationValueOptions.defaults().useDisplayValue(true));
 
     String testValue2 = "abc";
-    Configuration.set(testKey, testValue2);
+    mConfiguration.set(testKey, testValue2);
 
-    String displayValue2 = Configuration.get(testKey,
+    String displayValue2 = mConfiguration.get(testKey,
         ConfigurationValueOptions.defaults().useDisplayValue(true));
     assertEquals(displayValue1, displayValue2);
   }
@@ -886,11 +904,11 @@ public class ConfigurationTest {
   public void extensionProperty() {
     // simulate the case a ext key is picked by site property, unrecognized
     String fakeKeyName = "fake.extension.key";
-    Configuration.merge(ImmutableMap.of(fakeKeyName, "value"), Source.siteProperty("ignored"));
+    mConfiguration.merge(ImmutableMap.of(fakeKeyName, "value"), Source.siteProperty("ignored"));
     assertFalse(PropertyKey.fromString(fakeKeyName).isBuiltIn());
     // simulate the case the same key is built again inside the extension
     PropertyKey fakeExtensionKey = new PropertyKey.Builder(fakeKeyName).build();
-    assertEquals("value", Configuration.get(fakeExtensionKey));
+    assertEquals("value", mConfiguration.get(fakeExtensionKey));
     assertTrue(PropertyKey.fromString(fakeKeyName).isBuiltIn());
   }
 
@@ -904,10 +922,10 @@ public class ConfigurationTest {
       try (BufferedWriter writer = Files.newBufferedWriter(props.toPath())) {
         writer.write(String.format("%s=%s", PropertyKey.MASTER_HOSTNAME, "test_hostname"));
       }
-      Configuration.reset();
-      assertEquals("test_hostname", Configuration.get(PropertyKey.MASTER_HOSTNAME));
+      resetConf();
+      assertEquals("test_hostname", mConfiguration.get(PropertyKey.MASTER_HOSTNAME));
       assertEquals(Source.siteProperty(props.getPath()),
-          Configuration.getSource(PropertyKey.MASTER_HOSTNAME));
+          mConfiguration.getSource(PropertyKey.MASTER_HOSTNAME));
       props.delete();
     }
   }
@@ -916,9 +934,9 @@ public class ConfigurationTest {
   public void noPropertiesAnywhere() throws Exception {
     try (Closeable p =
              new SystemPropertyRule(PropertyKey.TEST_MODE.toString(), "false").toResource()) {
-      Configuration.unset(PropertyKey.SITE_CONF_DIR);
-      Configuration.reset();
-      assertEquals("0.0.0.0", Configuration.get(PropertyKey.PROXY_WEB_BIND_HOST));
+      mConfiguration.unset(PropertyKey.SITE_CONF_DIR);
+      resetConf();
+      assertEquals("0.0.0.0", mConfiguration.get(PropertyKey.PROXY_WEB_BIND_HOST));
     }
   }
 
@@ -926,9 +944,9 @@ public class ConfigurationTest {
   public void initConfWithExtenstionProperty() throws Exception {
     try (Closeable p = new SystemPropertyRule("alluxio.master.journal.ufs.option.fs.obs.endpoint",
         "foo").toResource()) {
-      Configuration.reset();
+      resetConf();
       assertEquals("foo",
-          Configuration.get(Template.MASTER_JOURNAL_UFS_OPTION_PROPERTY.format("fs.obs.endpoint")));
+          mConfiguration.get(Template.MASTER_JOURNAL_UFS_OPTION_PROPERTY.format("fs.obs.endpoint")));
     }
   }
 }
diff --git a/core/common/src/test/java/alluxio/conf/ConfigurationUtilsTest.java b/core/common/src/test/java/alluxio/conf/ConfigurationUtilsTest.java
new file mode 100644
index 0000000000..94743bb2a8
--- /dev/null
+++ b/core/common/src/test/java/alluxio/conf/ConfigurationUtilsTest.java
@@ -0,0 +1,7 @@
+package alluxio.conf;
+
+public class ConfigurationUtilsTest
+{
+
+
+}
diff --git a/core/common/src/test/java/alluxio/heartbeat/HeartbeatThreadTest.java b/core/common/src/test/java/alluxio/heartbeat/HeartbeatThreadTest.java
index 0f5e1b2d17..ac1fddbc63 100644
--- a/core/common/src/test/java/alluxio/heartbeat/HeartbeatThreadTest.java
+++ b/core/common/src/test/java/alluxio/heartbeat/HeartbeatThreadTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.heartbeat;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -63,6 +65,8 @@ public final class HeartbeatThreadTest {
 
   private ExecutorService mExecutorService;
 
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
   @Before
   public void before() {
     mExecutorService = Executors.newFixedThreadPool(NUMBER_OF_THREADS);
@@ -136,7 +140,7 @@ public final class HeartbeatThreadTest {
       try (ManuallyScheduleHeartbeat.Resource r =
           new ManuallyScheduleHeartbeat.Resource(Arrays.asList(mThreadName))) {
         DummyHeartbeatExecutor executor = new DummyHeartbeatExecutor();
-        HeartbeatThread ht = new HeartbeatThread(mThreadName, executor, 1);
+        HeartbeatThread ht = new HeartbeatThread(mThreadName, executor, 1, mConfiguration);
 
         // Run the HeartbeatThread.
         mExecutorService.submit(ht);
diff --git a/core/common/src/test/java/alluxio/master/MasterInquireClientTest.java b/core/common/src/test/java/alluxio/master/MasterInquireClientTest.java
index a45f785431..add779e88f 100644
--- a/core/common/src/test/java/alluxio/master/MasterInquireClientTest.java
+++ b/core/common/src/test/java/alluxio/master/MasterInquireClientTest.java
@@ -13,15 +13,17 @@ package alluxio.master;
 
 import static org.junit.Assert.assertEquals;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.MasterInquireClient.ConnectDetails;
 import alluxio.master.SingleMasterInquireClient.SingleMasterConnectDetails;
 import alluxio.master.ZkMasterInquireClient.ZkMasterConnectDetails;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import java.io.Closeable;
@@ -32,13 +34,21 @@ import java.util.HashMap;
  * Unit tests for functionality in {@link MasterInquireClient}.
  */
 public final class MasterInquireClientTest {
+
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = new InstancedConfiguration(ConfigurationUtils.defaults());
+  }
+
   @Test
   public void defaultConnectString() {
     ConnectDetails cs = new SingleMasterConnectDetails(
-        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC));
+        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mConfiguration));
     assertCurrentConnectString(cs);
-    assertEquals(NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC) + ":"
-        + NetworkAddressUtils.getPort(ServiceType.MASTER_RPC), cs.toString());
+    assertEquals(NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC, mConfiguration) + ":"
+        + NetworkAddressUtils.getPort(ServiceType.MASTER_RPC, mConfiguration), cs.toString());
   }
 
   @Test
@@ -50,7 +60,7 @@ public final class MasterInquireClientTest {
         put(PropertyKey.MASTER_HOSTNAME, host);
         put(PropertyKey.MASTER_RPC_PORT, Integer.toString(port));
       }
-    }).toResource()) {
+    }, mConfiguration).toResource()) {
       ConnectDetails cs = new SingleMasterConnectDetails(new InetSocketAddress(host, port));
       assertCurrentConnectString(cs);
       assertEquals("testhost:123", cs.toString());
@@ -66,12 +76,12 @@ public final class MasterInquireClientTest {
         put(PropertyKey.ZOOKEEPER_ADDRESS, zkAddr);
         put(PropertyKey.ZOOKEEPER_LEADER_PATH, leaderPath);
       }
-    }).toResource()) {
+    }, mConfiguration).toResource()) {
       ConnectDetails singleConnect = new SingleMasterConnectDetails(
-          NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC));
+          NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mConfiguration));
       assertCurrentConnectString(singleConnect);
       try (Closeable c2 =
-          new ConfigurationRule(PropertyKey.ZOOKEEPER_ENABLED, "true").toResource()) {
+          new ConfigurationRule(PropertyKey.ZOOKEEPER_ENABLED, "true", mConfiguration).toResource()) {
         ConnectDetails zkConnect = new ZkMasterConnectDetails(zkAddr, leaderPath);
         assertCurrentConnectString(zkConnect);
         assertEquals("zk@zkAddr:1234/my/leader/path", zkConnect.toString());
@@ -79,7 +89,7 @@ public final class MasterInquireClientTest {
     }
   }
 
-  private static void assertCurrentConnectString(ConnectDetails cs) {
-    assertEquals(cs, MasterInquireClient.Factory.getConnectDetails(Configuration.global()));
+  private void assertCurrentConnectString(ConnectDetails cs) {
+    assertEquals(cs, MasterInquireClient.Factory.getConnectDetails(mConfiguration));
   }
 }
diff --git a/core/common/src/test/java/alluxio/network/TieredIdentityFactoryTest.java b/core/common/src/test/java/alluxio/network/TieredIdentityFactoryTest.java
index 96b10b06fe..b07dfe950b 100644
--- a/core/common/src/test/java/alluxio/network/TieredIdentityFactoryTest.java
+++ b/core/common/src/test/java/alluxio/network/TieredIdentityFactoryTest.java
@@ -17,14 +17,17 @@ import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
-import alluxio.PropertyKey.Template;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.PropertyKey.Template;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.wire.TieredIdentity;
 import alluxio.wire.TieredIdentity.LocalityTier;
 
 import com.google.common.collect.ImmutableMap;
 import org.apache.commons.io.FileUtils;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -45,11 +48,18 @@ public class TieredIdentityFactoryTest {
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
 
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = ConfigurationTestUtils.defaults();
+  }
+
   @Test
   public void defaultConf() throws Exception {
-    TieredIdentity identity = TieredIdentityFactory.create();
+    TieredIdentity identity = TieredIdentityFactory.create(mConfiguration);
     TieredIdentity expected = new TieredIdentity(Arrays.asList(
-        new LocalityTier("node", NetworkAddressUtils.getLocalNodeName()),
+        new LocalityTier("node", NetworkAddressUtils.getLocalNodeName(mConfiguration)),
         new LocalityTier("rack", null)));
     assertEquals(expected, identity);
   }
@@ -59,8 +69,8 @@ public class TieredIdentityFactoryTest {
     String scriptPath = setupScript("node=myhost,rack=myrack,custom=mycustom", mFolder.newFile());
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         PropertyKey.LOCALITY_ORDER, "node,rack,custom",
-        PropertyKey.LOCALITY_SCRIPT, scriptPath)).toResource()) {
-      TieredIdentity identity = TieredIdentityFactory.create();
+        PropertyKey.LOCALITY_SCRIPT, scriptPath), mConfiguration).toResource()) {
+      TieredIdentity identity = TieredIdentityFactory.create(mConfiguration);
       TieredIdentity expected = new TieredIdentity(Arrays.asList(
           new LocalityTier("node", "myhost"),
           new LocalityTier("rack", "myrack"),
@@ -78,8 +88,8 @@ public class TieredIdentityFactoryTest {
     setupScript("node=myhost,rack=myrack,custom=mycustom", script);
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         PropertyKey.LOCALITY_ORDER, "node,rack,custom",
-        PropertyKey.LOCALITY_SCRIPT, customScriptName)).toResource()) {
-      TieredIdentity identity = TieredIdentityFactory.create();
+        PropertyKey.LOCALITY_SCRIPT, customScriptName), mConfiguration).toResource()) {
+      TieredIdentity identity = TieredIdentityFactory.create(mConfiguration);
       TieredIdentity expected = new TieredIdentity(Arrays.asList(
           new LocalityTier("node", "myhost"),
           new LocalityTier("rack", "myrack"),
@@ -95,8 +105,8 @@ public class TieredIdentityFactoryTest {
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         Template.LOCALITY_TIER.format("node"), "overridden",
         PropertyKey.LOCALITY_ORDER, "node,rack,custom",
-        PropertyKey.LOCALITY_SCRIPT, scriptPath)).toResource()) {
-      TieredIdentity identity = TieredIdentityFactory.create();
+        PropertyKey.LOCALITY_SCRIPT, scriptPath), mConfiguration).toResource()) {
+      TieredIdentity identity = TieredIdentityFactory.create(mConfiguration);
       TieredIdentity expected = new TieredIdentity(Arrays.asList(
           new LocalityTier("node", "overridden"),
           new LocalityTier("rack", "myrack"),
@@ -109,8 +119,8 @@ public class TieredIdentityFactoryTest {
   public void outOfOrderScript() throws Exception {
     String scriptPath = setupScript("rack=myrack,node=myhost", mFolder.newFile());
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
-        PropertyKey.LOCALITY_SCRIPT, scriptPath)).toResource()) {
-      TieredIdentity identity = TieredIdentityFactory.create();
+        PropertyKey.LOCALITY_SCRIPT, scriptPath), mConfiguration).toResource()) {
+      TieredIdentity identity = TieredIdentityFactory.create(mConfiguration);
       TieredIdentity expected = new TieredIdentity(Arrays.asList(
           new LocalityTier("node", "myhost"),
           new LocalityTier("rack", "myrack")));
@@ -152,9 +162,9 @@ public class TieredIdentityFactoryTest {
     File script = mFolder.newFile();
     FileUtils.writeStringToFile(script, "#!/bin/bash");
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
-        PropertyKey.LOCALITY_SCRIPT, script.getAbsolutePath())).toResource()) {
+        PropertyKey.LOCALITY_SCRIPT, script.getAbsolutePath()), mConfiguration).toResource()) {
       try {
-        TieredIdentity identity = TieredIdentityFactory.create();
+        TieredIdentity identity = TieredIdentityFactory.create(mConfiguration);
       } catch (RuntimeException e) {
         assertThat(e.getMessage(), containsString(script.getAbsolutePath()));
         assertThat(e.getMessage(), containsString("Permission denied"));
@@ -167,7 +177,7 @@ public class TieredIdentityFactoryTest {
     assertEquals(new TieredIdentity(Arrays.asList(
         new LocalityTier("node", "b"),
         new LocalityTier("rack", "d")
-    )), TieredIdentityFactory.fromString("node=b,rack=d"));
+    )), TieredIdentityFactory.fromString("node=b,rack=d", mConfiguration));
   }
 
   private String setupScript(String tieredIdentityString, File script) throws Exception {
@@ -181,8 +191,8 @@ public class TieredIdentityFactoryTest {
   private TieredIdentity runScriptWithOutput(String output) throws Exception {
     String scriptPath = setupScript(output, mFolder.newFile());
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
-        PropertyKey.LOCALITY_SCRIPT, scriptPath)).toResource()) {
-      return TieredIdentityFactory.create();
+        PropertyKey.LOCALITY_SCRIPT, scriptPath), mConfiguration).toResource()) {
+      return TieredIdentityFactory.create(mConfiguration);
     }
   }
 }
diff --git a/core/common/src/test/java/alluxio/security/LoginUserTest.java b/core/common/src/test/java/alluxio/security/LoginUserTest.java
index 3d06a95963..61367f8845 100644
--- a/core/common/src/test/java/alluxio/security/LoginUserTest.java
+++ b/core/common/src/test/java/alluxio/security/LoginUserTest.java
@@ -11,11 +11,13 @@
 
 package alluxio.security;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authentication.AuthType;
 
+import alluxio.util.ConfigurationUtils;
+
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
@@ -34,6 +36,8 @@ public final class LoginUserTest {
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
 
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
   @Before
   public void before() throws Exception {
     LoginUserTestUtils.resetLoginUser();
@@ -41,7 +45,7 @@ public final class LoginUserTest {
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    mConfiguration = ConfigurationTestUtils.defaults();
   }
 
   /**
@@ -49,9 +53,9 @@ public final class LoginUserTest {
    */
   @Test
   public void getSimpleLoginUser() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     Assert.assertNotNull(loginUser);
     Assert.assertEquals(System.getProperty("user.name"), loginUser.getName());
@@ -63,10 +67,10 @@ public final class LoginUserTest {
    */
   @Test
   public void getSimpleLoginUserProvidedByApp() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "alluxio-user");
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "alluxio-user");
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     Assert.assertNotNull(loginUser);
     Assert.assertEquals("alluxio-user", loginUser.getName());
@@ -78,10 +82,10 @@ public final class LoginUserTest {
    */
   @Test
   public void getSimpleLoginUserListProvidedByApp() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "alluxio-user, superuser");
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "alluxio-user, superuser");
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     // The user list is considered as a single user name.
     Assert.assertNotNull(loginUser);
@@ -95,10 +99,10 @@ public final class LoginUserTest {
    */
   @Test
   public void getSimpleLoginUserWhenNotProvidedByApp() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.unset(PropertyKey.SECURITY_LOGIN_USERNAME);
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.unset(PropertyKey.SECURITY_LOGIN_USERNAME);
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     Assert.assertNotNull(loginUser);
     Assert.assertEquals(System.getProperty("user.name"), loginUser.getName());
@@ -109,9 +113,9 @@ public final class LoginUserTest {
    */
   @Test
   public void getCustomLoginUser() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     Assert.assertNotNull(loginUser);
     Assert.assertEquals(System.getProperty("user.name"), loginUser.getName());
@@ -123,10 +127,10 @@ public final class LoginUserTest {
    */
   @Test
   public void getCustomLoginUserProvidedByApp() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "alluxio-user");
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "alluxio-user");
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     Assert.assertNotNull(loginUser);
     Assert.assertEquals("alluxio-user", loginUser.getName());
@@ -139,10 +143,10 @@ public final class LoginUserTest {
    */
   @Test
   public void getCustomLoginUserWhenNotProvidedByApp() throws Exception {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
-    Configuration.unset(PropertyKey.SECURITY_LOGIN_USERNAME);
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
+    mConfiguration.unset(PropertyKey.SECURITY_LOGIN_USERNAME);
 
-    User loginUser = LoginUser.get();
+    User loginUser = LoginUser.get(mConfiguration);
 
     Assert.assertNotNull(loginUser);
     Assert.assertEquals(System.getProperty("user.name"), loginUser.getName());
@@ -157,10 +161,10 @@ public final class LoginUserTest {
   public void securityEnabled() throws Exception {
     // TODO(dong): add Kerberos in the white list when it is supported.
     // throw exception when AuthType is not "SIMPLE", or "CUSTOM"
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
 
     mThrown.expect(UnsupportedOperationException.class);
     mThrown.expectMessage("User is not supported in NOSASL mode");
-    LoginUser.get();
+    LoginUser.get(mConfiguration);
   }
 }
diff --git a/core/common/src/test/java/alluxio/security/authentication/GrpcSecurityTest.java b/core/common/src/test/java/alluxio/security/authentication/GrpcSecurityTest.java
index f12fe22961..a78cbb8d5f 100644
--- a/core/common/src/test/java/alluxio/security/authentication/GrpcSecurityTest.java
+++ b/core/common/src/test/java/alluxio/security/authentication/GrpcSecurityTest.java
@@ -11,14 +11,16 @@
 
 package alluxio.security.authentication;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.grpc.GrpcChannelBuilder;
 import alluxio.grpc.GrpcServer;
 import alluxio.grpc.GrpcServerBuilder;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -37,6 +39,13 @@ public class GrpcSecurityTest {
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
 
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = new InstancedConfiguration(ConfigurationUtils.defaults());
+  }
+
   @Test
   public void testServerUnsupportedAuthentication() {
     mThrown.expect(RuntimeException.class);
@@ -49,7 +58,7 @@ public class GrpcSecurityTest {
     GrpcServer server = createServer(AuthType.SIMPLE);
     server.start();
     GrpcChannelBuilder channelBuilder =
-        GrpcChannelBuilder.forAddress(getServerConnectAddress(server));
+        GrpcChannelBuilder.forAddress(getServerConnectAddress(server), mConfiguration);
     channelBuilder.build();
     server.shutdown();
   }
@@ -59,7 +68,7 @@ public class GrpcSecurityTest {
     GrpcServer server = createServer(AuthType.NOSASL);
     server.start();
     GrpcChannelBuilder channelBuilder =
-        GrpcChannelBuilder.forAddress(getServerConnectAddress(server));
+        GrpcChannelBuilder.forAddress(getServerConnectAddress(server), mConfiguration);
     channelBuilder.build();
     server.shutdown();
   }
@@ -67,13 +76,13 @@ public class GrpcSecurityTest {
   @Test
   public void testCustomAuthentication() throws Exception {
 
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS,
         ExactlyMatchAuthenticationProvider.class.getName());
     GrpcServer server = createServer(AuthType.CUSTOM);
     server.start();
     GrpcChannelBuilder channelBuilder =
-        GrpcChannelBuilder.forAddress(getServerConnectAddress(server));
+        GrpcChannelBuilder.forAddress(getServerConnectAddress(server), mConfiguration);
     channelBuilder.setCredentials(ExactlyMatchAuthenticationProvider.USERNAME,
         ExactlyMatchAuthenticationProvider.PASSWORD, null).build();
     server.shutdown();
@@ -82,13 +91,13 @@ public class GrpcSecurityTest {
   @Test
   public void testCustomAuthenticationFails() throws Exception {
 
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.CUSTOM.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS,
         ExactlyMatchAuthenticationProvider.class.getName());
     GrpcServer server = createServer(AuthType.CUSTOM);
     server.start();
     GrpcChannelBuilder channelBuilder =
-        GrpcChannelBuilder.forAddress(getServerConnectAddress(server));
+        GrpcChannelBuilder.forAddress(getServerConnectAddress(server), mConfiguration);
     mThrown.expect(UnauthenticatedException.class);
     channelBuilder.setCredentials("fail", "fail", null).build();
     server.shutdown();
@@ -99,7 +108,7 @@ public class GrpcSecurityTest {
     GrpcServer server = createServer(AuthType.SIMPLE);
     server.start();
     GrpcChannelBuilder channelBuilder =
-        GrpcChannelBuilder.forAddress(getServerConnectAddress(server));
+        GrpcChannelBuilder.forAddress(getServerConnectAddress(server), mConfiguration);
     channelBuilder.disableAuthentication().build();
     server.shutdown();
   }
@@ -108,22 +117,25 @@ public class GrpcSecurityTest {
   public void testAuthMismatch() throws Exception {
     GrpcServer server = createServer(AuthType.NOSASL);
     server.start();
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE);
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE);
     GrpcChannelBuilder channelBuilder =
-        GrpcChannelBuilder.forAddress(getServerConnectAddress(server));
+        GrpcChannelBuilder.forAddress(getServerConnectAddress(server), mConfiguration);
     mThrown.expect(UnauthenticatedException.class);
     channelBuilder.build();
     server.shutdown();
   }
 
   private InetSocketAddress getServerConnectAddress(GrpcServer server) {
-    return new InetSocketAddress(NetworkAddressUtils.getLocalHostName(), server.getBindPort());
+    return new InetSocketAddress(NetworkAddressUtils
+        .getLocalHostName((int)mConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)),
+        server.getBindPort());
   }
 
   private GrpcServer createServer(AuthType authType) {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, authType.name());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, authType.name());
     GrpcServerBuilder serverBuilder = GrpcServerBuilder
-        .forAddress(new InetSocketAddress(NetworkAddressUtils.getLocalHostName(), 0));
+        .forAddress(new InetSocketAddress(NetworkAddressUtils
+            .getLocalHostName((int)mConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)), 0), mConfiguration);
     return serverBuilder.build();
   }
 
diff --git a/core/common/src/test/java/alluxio/security/authentication/PlainSaslServerCallbackHandlerTest.java b/core/common/src/test/java/alluxio/security/authentication/PlainSaslServerCallbackHandlerTest.java
index 69879c066a..758c7f19a2 100644
--- a/core/common/src/test/java/alluxio/security/authentication/PlainSaslServerCallbackHandlerTest.java
+++ b/core/common/src/test/java/alluxio/security/authentication/PlainSaslServerCallbackHandlerTest.java
@@ -13,9 +13,11 @@ package alluxio.security.authentication;
 
 import alluxio.ConfigurationRule;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authentication.plain.PlainSaslServerCallbackHandler;
 
+import alluxio.util.ConfigurationUtils;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Rule;
@@ -41,10 +43,12 @@ public final class PlainSaslServerCallbackHandlerTest {
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
 
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
   @Rule
   public ConfigurationRule mConfigurationRule =
       new ConfigurationRule(PropertyKey.SECURITY_AUTHENTICATION_CUSTOM_PROVIDER_CLASS,
-          NameMatchAuthenticationProvider.class.getName());
+          NameMatchAuthenticationProvider.class.getName(), mConfiguration);
 
   /**
    * Sets up the configuration and callback handler before running a test.
@@ -52,16 +56,15 @@ public final class PlainSaslServerCallbackHandlerTest {
   @Before
   public void before() throws Exception {
     mPlainServerCBHandler = new PlainSaslServerCallbackHandler(
-        AuthenticationProvider.Factory.create(AuthType.CUSTOM), new Runnable() {
+        AuthenticationProvider.Factory.create(AuthType.CUSTOM, mConfiguration), new Runnable() {
           @Override
           public void run() {}
-        });
+        }, mConfiguration);
   }
 
   @After
   public void after() {
     AuthenticatedClientUser.remove();
-    ConfigurationTestUtils.resetConfiguration();
   }
 
   /**
diff --git a/core/common/src/test/java/alluxio/security/authentication/SaslParticipantProviderTest.java b/core/common/src/test/java/alluxio/security/authentication/SaslParticipantProviderTest.java
index ad1f34ed99..e25d5f1256 100644
--- a/core/common/src/test/java/alluxio/security/authentication/SaslParticipantProviderTest.java
+++ b/core/common/src/test/java/alluxio/security/authentication/SaslParticipantProviderTest.java
@@ -11,10 +11,14 @@
 
 package alluxio.security.authentication;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.security.authentication.plain.PlainSaslServerProvider;
 import alluxio.security.authentication.plain.SaslParticipantProviderPlain;
 
+import alluxio.util.ConfigurationUtils;
 import org.junit.Assert;
 import org.junit.Rule;
 import org.junit.Test;
@@ -32,6 +36,9 @@ public class SaslParticipantProviderTest {
   /**
    * The exception expected to be thrown.
    */
+
+  private AlluxioConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
 
@@ -54,7 +61,7 @@ public class SaslParticipantProviderTest {
         SaslParticipantProvider.Factory.create(AuthType.SIMPLE);
     Assert.assertNotNull(simpleProvider);
     // Test allow null subject
-    SaslClient client = simpleProvider.createSaslClient(null);
+    SaslClient client = simpleProvider.createSaslClient(null, mConfiguration);
     Assert.assertNotNull(client);
     Assert.assertEquals(PlainSaslServerProvider.MECHANISM, client.getMechanismName());
   }
@@ -108,7 +115,7 @@ public class SaslParticipantProviderTest {
     SaslParticipantProvider simpleProvider =
         SaslParticipantProvider.Factory.create(AuthType.SIMPLE);
     Assert.assertNotNull(simpleProvider);
-    SaslServer server = simpleProvider.createSaslServer("test");
+    SaslServer server = simpleProvider.createSaslServer("test", mConfiguration);
     Assert.assertNotNull(server);
     Assert.assertEquals(PlainSaslServerProvider.MECHANISM, server.getMechanismName());
   }
diff --git a/core/common/src/test/java/alluxio/security/authorization/ModeTest.java b/core/common/src/test/java/alluxio/security/authorization/ModeTest.java
index d8d03db5e6..cb9bd8d145 100644
--- a/core/common/src/test/java/alluxio/security/authorization/ModeTest.java
+++ b/core/common/src/test/java/alluxio/security/authorization/ModeTest.java
@@ -15,14 +15,14 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.ModeUtils;
 
-import org.junit.After;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -38,9 +38,11 @@ public final class ModeTest {
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
 
-  @After
-  public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = new InstancedConfiguration(ConfigurationUtils.defaults());
   }
 
   @Test
@@ -139,9 +141,7 @@ public final class ModeTest {
   @Test
   public void umask() {
     String umask = "0022";
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, umask);
-    // after umask 0022, 0777 should change to 0755
-    Mode mode = ModeUtils.applyDirectoryUMask(Mode.defaults());
+    Mode mode = ModeUtils.applyDirectoryUMask(Mode.defaults(), umask);
     assertEquals(Mode.Bits.ALL, mode.getOwnerBits());
     assertEquals(Mode.Bits.READ_EXECUTE, mode.getGroupBits());
     assertEquals(Mode.Bits.READ_EXECUTE, mode.getOtherBits());
@@ -154,11 +154,11 @@ public final class ModeTest {
   @Test
   public void umaskExceedLength() {
     String umask = "00022";
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, umask);
+    mConfiguration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, umask);
     mThrown.expect(IllegalArgumentException.class);
     mThrown.expectMessage(ExceptionMessage.INVALID_CONFIGURATION_VALUE.getMessage(umask,
         PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
-    ModeUtils.applyDirectoryUMask(Mode.defaults());
+    ModeUtils.applyDirectoryUMask(Mode.defaults(), mConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
   }
 
   /**
@@ -167,11 +167,10 @@ public final class ModeTest {
   @Test
   public void umaskNotInteger() {
     String umask = "NotInteger";
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, umask);
     mThrown.expect(IllegalArgumentException.class);
     mThrown.expectMessage(ExceptionMessage.INVALID_CONFIGURATION_VALUE.getMessage(umask,
         PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK));
-    ModeUtils.applyDirectoryUMask(Mode.defaults());
+    ModeUtils.applyDirectoryUMask(Mode.defaults(), umask);
   }
 
   @Test
diff --git a/core/common/src/test/java/alluxio/security/group/GroupMappingServiceTest.java b/core/common/src/test/java/alluxio/security/group/GroupMappingServiceTest.java
index 56796de0ff..de7b225467 100644
--- a/core/common/src/test/java/alluxio/security/group/GroupMappingServiceTest.java
+++ b/core/common/src/test/java/alluxio/security/group/GroupMappingServiceTest.java
@@ -15,9 +15,11 @@ import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertEquals;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.group.provider.IdentityUserGroupsMapping;
 
+import alluxio.util.ConfigurationUtils;
 import org.junit.Test;
 
 import java.io.Closeable;
@@ -33,11 +35,12 @@ public final class GroupMappingServiceTest {
   @Test
   public void group() throws Throwable {
     String userName = "alluxio-user1";
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
 
     try (Closeable mConfigurationRule =
         new ConfigurationRule(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
-            IdentityUserGroupsMapping.class.getName()).toResource()) {
-      GroupMappingService groups = GroupMappingService.Factory.get();
+            IdentityUserGroupsMapping.class.getName(), conf).toResource()) {
+      GroupMappingService groups = GroupMappingService.Factory.get(conf);
 
       assertNotNull(groups);
       assertNotNull(groups.getGroups(userName));
diff --git a/core/common/src/test/java/alluxio/test/util/CommonUtils.java b/core/common/src/test/java/alluxio/test/util/CommonUtils.java
index aab3378406..a9564b3b1e 100644
--- a/core/common/src/test/java/alluxio/test/util/CommonUtils.java
+++ b/core/common/src/test/java/alluxio/test/util/CommonUtils.java
@@ -19,6 +19,7 @@ import org.powermock.reflect.Whitebox;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -92,16 +93,23 @@ public final class CommonUtils {
    * @param excludedFields names of fields which should not impact equality
    */
   public static <T> void testEquals(Class<T> clazz, String... excludedFields) {
+    testEquals(clazz,null, null, excludedFields);
+  }
+
+  public static <T> void testEquals(Class<T> clazz, Class<?>[] ctorClassArgs,
+      Object[] ctorArgs, String... excludedFields) {
     Set<String> excludedFieldsSet = new HashSet<>(Arrays.asList(excludedFields));
     EqualsTester equalsTester = new EqualsTester();
-    equalsTester.addEqualityGroup(createBaseObject(clazz), createBaseObject(clazz));
+    equalsTester.addEqualityGroup(
+        createBaseObject(clazz, ctorClassArgs, ctorArgs),
+        createBaseObject(clazz, ctorClassArgs, ctorArgs));
     // For each non-excluded field, create an object of the class with only that field changed.
     for (Field field : getNonStaticFields(clazz)) {
       if (excludedFieldsSet.contains(field.getName())) {
         continue;
       }
       field.setAccessible(true);
-      T instance = createBaseObject(clazz);
+      T instance = createBaseObject(clazz, ctorClassArgs, ctorArgs);
       try {
         field.set(instance, getValuesForFieldType(field.getType()).get(1));
       } catch (Exception e) {
@@ -132,6 +140,50 @@ public final class CommonUtils {
     }
   }
 
+  /**
+   * Creates new instance of a class by calling a constructor that receives ctorClassArgs arguments.
+   *
+   * @param <T> type of the object
+   * @param clazz the class to create
+   * @param ctorClassArgs parameters type list of the constructor to initiate, if null default
+   *        constructor will be called
+   * @param ctorArgs the arguments to pass the constructor
+   * @return new class object
+   * @throws RuntimeException if the class cannot be instantiated
+   */
+  private static <T> T createBaseObject(Class<T> clazz, Class<?>[] ctorClassArgs,
+      Object[] ctorArgs) {
+    try {
+      Constructor<T> ctor;
+      if (ctorClassArgs == null || ctorClassArgs.length == 0) {
+        ctor = clazz.getDeclaredConstructor();
+      } else {
+        ctor = clazz.getConstructor(ctorClassArgs);
+      }
+      ctor.setAccessible(true);
+
+      T instance;
+      if (ctorClassArgs == null || ctorClassArgs.length == 0) {
+        instance = ctor.newInstance();
+      } else {
+        instance = ctor.newInstance(ctorArgs);
+      }
+
+      for (Field field : getNonStaticFields(clazz)) {
+        field.setAccessible(true);
+        field.set(instance, getValuesForFieldType(field.getType()).get(0));
+      }
+      return instance;
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(e.getCause());
+    } catch (ReflectiveOperationException e) {
+      throw new RuntimeException(e);
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+
   /**
    * Returns a list of at least two values of the given type.
    *
diff --git a/core/common/src/test/java/alluxio/underfs/AbstractUnderFileSystemContractTest.java b/core/common/src/test/java/alluxio/underfs/AbstractUnderFileSystemContractTest.java
index 57cb6f0f06..462be2a289 100644
--- a/core/common/src/test/java/alluxio/underfs/AbstractUnderFileSystemContractTest.java
+++ b/core/common/src/test/java/alluxio/underfs/AbstractUnderFileSystemContractTest.java
@@ -17,15 +17,17 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertArrayEquals;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.options.CreateOptions;
 import alluxio.underfs.options.DeleteOptions;
 import alluxio.underfs.options.ListOptions;
 import alluxio.underfs.options.MkdirsOptions;
 import alluxio.underfs.options.OpenOptions;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.UnderFileSystemUtils;
 import alluxio.util.io.PathUtils;
 
@@ -58,16 +60,17 @@ public abstract class AbstractUnderFileSystemContractTest {
 
   private String mUnderfsAddress;
   private UnderFileSystem mUfs;
+  protected InstancedConfiguration mConfiguration;
 
   @Rule
   public final ExpectedException mThrown = ExpectedException.none();
 
   @Rule
-  public final ConfigurationRule mConfiguration =
+  public final ConfigurationRule mConfRule =
       new ConfigurationRule(ImmutableMap.of(PropertyKey.UNDERFS_LISTING_LENGTH, "50",
           PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, "512B",
           // Increase the buffer time of journal writes to speed up tests
-          PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS, "1sec"));
+          PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS, "1sec"), mConfiguration);
 
   /**
    * @param path path of UFS
@@ -84,9 +87,10 @@ public abstract class AbstractUnderFileSystemContractTest {
 
   @Before
   public final void before() throws Exception {
+    mConfiguration = ConfigurationTestUtils.defaults();
     mUnderfsAddress = PathUtils.concatPath(getUfsBaseDir(), UUID.randomUUID());
     mUfs = createUfs(mUnderfsAddress, UnderFileSystemConfiguration.defaults());
-    mUfs.mkdirs(mUnderfsAddress, MkdirsOptions.defaults().setCreateParent(true));
+    mUfs.mkdirs(mUnderfsAddress, MkdirsOptions.defaults(mConfiguration).setCreateParent(true));
   }
 
   @After
@@ -98,7 +102,7 @@ public abstract class AbstractUnderFileSystemContractTest {
   @Test
   public void createAtomic() throws IOException {
     String testFile = PathUtils.concatPath(mUnderfsAddress, "createAtomic");
-    OutputStream stream = mUfs.create(testFile, CreateOptions.defaults().setEnsureAtomic(true));
+    OutputStream stream = mUfs.create(testFile, CreateOptions.defaults(mConfiguration).setEnsureAtomic(true));
     stream.write(TEST_BYTES);
     assertFalse(mUfs.isFile(testFile));
     stream.close();
@@ -119,14 +123,14 @@ public abstract class AbstractUnderFileSystemContractTest {
 
     mThrown.expect(IOException.class);
     String testFile = PathUtils.concatPath(mUnderfsAddress, "createNoParent/testFile");
-    OutputStream o = mUfs.create(testFile, CreateOptions.defaults().setCreateParent(false));
+    OutputStream o = mUfs.create(testFile, CreateOptions.defaults(mConfiguration).setCreateParent(false));
     o.close();
   }
 
   @Test
   public void createParent() throws IOException {
     String testFile = PathUtils.concatPath(mUnderfsAddress, "createParent/testFile");
-    OutputStream o = mUfs.create(testFile, CreateOptions.defaults().setCreateParent(true));
+    OutputStream o = mUfs.create(testFile, CreateOptions.defaults(mConfiguration).setCreateParent(true));
     o.close();
     assertTrue(mUfs.exists(testFile));
   }
@@ -207,9 +211,9 @@ public abstract class AbstractUnderFileSystemContractTest {
     String testDirNonEmptyChildFile = PathUtils.concatPath(testDirNonEmpty, "testDirNonEmptyF");
     String testDirNonEmptyChildDirFile =
         PathUtils.concatPath(testDirNonEmptyChildDir, "testDirNonEmptyChildDirF");
-    mUfs.mkdirs(testDirEmpty, MkdirsOptions.defaults().setCreateParent(false));
-    mUfs.mkdirs(testDirNonEmpty, MkdirsOptions.defaults().setCreateParent(false));
-    mUfs.mkdirs(testDirNonEmptyChildDir, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDirEmpty, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
+    mUfs.mkdirs(testDirNonEmpty, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
+    mUfs.mkdirs(testDirNonEmptyChildDir, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     createEmptyFile(testDirNonEmptyChildFile);
     createEmptyFile(testDirNonEmptyChildDirFile);
     mUfs.deleteDirectory(testDirEmpty, DeleteOptions.defaults().setRecursive(false));
@@ -259,7 +263,7 @@ public abstract class AbstractUnderFileSystemContractTest {
     assertTrue(mUfs.isFile(testFile));
     String testDir = PathUtils.concatPath(mUnderfsAddress, "testDir");
     assertFalse(mUfs.isDirectory(testDir));
-    mUfs.mkdirs(testDir, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDir, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     assertTrue(mUfs.isDirectory(testDir));
   }
 
@@ -309,7 +313,7 @@ public abstract class AbstractUnderFileSystemContractTest {
     String testDir = PathUtils.concatPath(mUnderfsAddress, "testDir");
     assertFalse(mUfs.isFile(testFile));
     createEmptyFile(testFile);
-    mUfs.mkdirs(testDir, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDir, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     assertTrue(mUfs.isFile(testFile));
     assertFalse(mUfs.isFile(testDir));
   }
@@ -321,8 +325,8 @@ public abstract class AbstractUnderFileSystemContractTest {
     String testDirNonEmptyChildFile = PathUtils.concatPath(testDirNonEmpty, "testDirNonEmptyF");
     String testDirNonEmptyChildDirFile =
         PathUtils.concatPath(testDirNonEmptyChildDir, "testDirNonEmptyChildDirF");
-    mUfs.mkdirs(testDirNonEmpty, MkdirsOptions.defaults().setCreateParent(false));
-    mUfs.mkdirs(testDirNonEmptyChildDir, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDirNonEmpty, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
+    mUfs.mkdirs(testDirNonEmptyChildDir, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     createEmptyFile(testDirNonEmptyChildFile);
     createEmptyFile(testDirNonEmptyChildDirFile);
     String[] expectedResTopDir = new String[] {"testDirNonEmpty2", "testDirNonEmptyF"};
@@ -406,9 +410,9 @@ public abstract class AbstractUnderFileSystemContractTest {
     // lsr of nonexistent path should be null
     assertNull(mUfs.listStatus(sub1, ListOptions.defaults().setRecursive(true)));
 
-    mUfs.mkdirs(sub1, MkdirsOptions.defaults().setCreateParent(false));
-    mUfs.mkdirs(sub2, MkdirsOptions.defaults().setCreateParent(false));
-    mUfs.mkdirs(sub11, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(sub1, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
+    mUfs.mkdirs(sub2, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
+    mUfs.mkdirs(sub11, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     createEmptyFile(file11);
     createEmptyFile(file2);
     createEmptyFile(file);
@@ -451,9 +455,9 @@ public abstract class AbstractUnderFileSystemContractTest {
     String testDir2 = PathUtils.concatPath(testDir1, "2");
     String testDir3 = PathUtils.concatPath(testDir2, "3");
     String testDirDeep = PathUtils.concatPath(testDir3, "testDirDeep");
-    mUfs.mkdirs(testDirTop, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDirTop, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     assertTrue(mUfs.isDirectory(testDirTop));
-    mUfs.mkdirs(testDirDeep, MkdirsOptions.defaults().setCreateParent(true));
+    mUfs.mkdirs(testDirDeep, MkdirsOptions.defaults(mConfiguration).setCreateParent(true));
     assertTrue(mUfs.isDirectory(testDir1));
     assertTrue(mUfs.isDirectory(testDir2));
     assertTrue(mUfs.isDirectory(testDir3));
@@ -580,7 +584,7 @@ public abstract class AbstractUnderFileSystemContractTest {
     String testDirSrcChild = PathUtils.concatPath(testDirSrc, "testFile");
     String testDirDst = PathUtils.concatPath(mUnderfsAddress, "renameDirectoryDst");
     String testDirDstChild = PathUtils.concatPath(testDirDst, "testFile");
-    mUfs.mkdirs(testDirSrc, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDirSrc, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     createEmptyFile(testDirSrcChild);
     mUfs.renameDirectory(testDirSrc, testDirDst);
     assertFalse(mUfs.isDirectory(testDirSrc));
@@ -601,9 +605,9 @@ public abstract class AbstractUnderFileSystemContractTest {
     String testDirDstNested = PathUtils.concatPath(testDirDst, "testNested");
     String testDirDstNestedChild = PathUtils.concatPath(testDirDstNested, "testNestedFile");
 
-    mUfs.mkdirs(testDirSrc, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDirSrc, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     createEmptyFile(testDirSrcChild);
-    mUfs.mkdirs(testDirSrcNested, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(testDirSrcNested, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     createEmptyFile(testDirSrcNestedChild);
 
     mUfs.renameDirectory(testDirSrc, testDirDst);
@@ -642,7 +646,7 @@ public abstract class AbstractUnderFileSystemContractTest {
     String[] children = new String[numFiles + numFiles];
 
     // Make top level directory
-    mUfs.mkdirs(topLevelDirectory, MkdirsOptions.defaults().setCreateParent(false));
+    mUfs.mkdirs(topLevelDirectory, MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
 
     // Make the children files
     for (int i = 0; i < numFiles; ++i) {
@@ -653,7 +657,7 @@ public abstract class AbstractUnderFileSystemContractTest {
     for (int i = 0; i < numFiles; ++i) {
       children[numFiles + i] =
           PathUtils.concatPath(topLevelDirectory, folderPrefix + String.format("%04d", i));
-      mUfs.mkdirs(children[numFiles + i], MkdirsOptions.defaults().setCreateParent(false));
+      mUfs.mkdirs(children[numFiles + i], MkdirsOptions.defaults(mConfiguration).setCreateParent(false));
     }
 
     return new LargeDirectoryConfig(topLevelDirectory, children);
@@ -704,7 +708,7 @@ public abstract class AbstractUnderFileSystemContractTest {
     // Write multiple blocks of data
     int numBlocks = 3;
     // Test block size is small enough for 'int'
-    int blockSize = (int) Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+    int blockSize = (int) mConfiguration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
     int numCopies = numBlocks * blockSize / TEST_BYTES.length;
     for (int i = 0; i < numCopies; ++i) {
       outputStream.write(TEST_BYTES);
diff --git a/core/common/src/test/java/alluxio/underfs/UnderFileSystemConfigurationTest.java b/core/common/src/test/java/alluxio/underfs/UnderFileSystemConfigurationTest.java
index 46d6c97bb6..8d270ad53d 100644
--- a/core/common/src/test/java/alluxio/underfs/UnderFileSystemConfigurationTest.java
+++ b/core/common/src/test/java/alluxio/underfs/UnderFileSystemConfigurationTest.java
@@ -17,9 +17,12 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.collect.ImmutableMap;
+import org.junit.Before;
 import org.junit.Test;
 
 import java.io.Closeable;
@@ -27,10 +30,17 @@ import java.util.Random;
 
 public final class UnderFileSystemConfigurationTest {
 
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = ConfigurationTestUtils.defaults();
+  }
+
   @Test
   public void getValueWhenGlobalConfHasProperty() throws Exception {
     // Set property in global configuration
-    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, "bar").toResource()) {
+    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, "bar", mConfiguration).toResource()) {
       Random random = new Random();
       boolean readOnly = random.nextBoolean();
       boolean shared = random.nextBoolean();
@@ -38,9 +48,9 @@ public final class UnderFileSystemConfigurationTest {
           UnderFileSystemConfiguration.defaults().setReadOnly(readOnly).setShared(shared);
       assertEquals(readOnly, conf.isReadOnly());
       assertEquals(shared, conf.isShared());
-      assertEquals("bar", conf.get(PropertyKey.S3A_ACCESS_KEY));
+      assertEquals("bar", mConfiguration.get(PropertyKey.S3A_ACCESS_KEY));
       conf = UnderFileSystemConfiguration.defaults().setReadOnly(readOnly).setShared(shared)
-          .setMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
+          .createMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
       assertEquals(readOnly, conf.isReadOnly());
       assertEquals(shared, conf.isShared());
       assertEquals("foo", conf.get(PropertyKey.S3A_ACCESS_KEY));
@@ -51,8 +61,8 @@ public final class UnderFileSystemConfigurationTest {
   public void getValueWhenGlobalConfOverridesPropertyWithDefaultValue() throws Exception {
     // Set property in global configuration
     try (Closeable c =
-        new ConfigurationRule(PropertyKey.UNDERFS_LISTING_LENGTH, "2000").toResource()) {
-      UnderFileSystemConfiguration conf = UnderFileSystemConfiguration.defaults();
+        new ConfigurationRule(PropertyKey.UNDERFS_LISTING_LENGTH, "2000", mConfiguration).toResource()) {
+      UnderFileSystemConfiguration conf = UnderFileSystemConfiguration.defaults(mConfiguration);
       assertEquals("2000", conf.get(PropertyKey.UNDERFS_LISTING_LENGTH));
     }
   }
@@ -60,36 +70,40 @@ public final class UnderFileSystemConfigurationTest {
   @Test
   public void getValueWhenGlobalConfHasNotProperty() throws Exception {
     // Set property in global configuration
-    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, null).toResource()) {
+    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, null, mConfiguration).toResource()) {
       Random random = new Random();
       boolean readOnly = random.nextBoolean();
       boolean shared = random.nextBoolean();
       UnderFileSystemConfiguration conf =
-          UnderFileSystemConfiguration.defaults().setReadOnly(readOnly).setShared(shared);
+          UnderFileSystemConfiguration.defaults(mConfiguration)
+              .setReadOnly(readOnly)
+              .setShared(shared);
       try {
         conf.get(PropertyKey.S3A_ACCESS_KEY);
         fail("this key should not exist");
       } catch (Exception e) {
         // expect to pass
       }
-      conf.setMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
-      assertEquals(readOnly, conf.isReadOnly());
-      assertEquals(shared, conf.isShared());
-      assertEquals("foo", conf.get(PropertyKey.S3A_ACCESS_KEY));
+      UnderFileSystemConfiguration conf2 =
+          conf.createMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
+      assertEquals(readOnly, conf2.isReadOnly());
+      assertEquals(shared, conf2.isShared());
+      assertEquals("foo", conf2.get(PropertyKey.S3A_ACCESS_KEY));
     }
   }
 
   @Test
   public void containsWhenGlobalConfHasProperty() throws Exception {
     // Unset property in global configuration
-    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, "bar").toResource()) {
+    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, "bar", mConfiguration).toResource()) {
       Random random = new Random();
       boolean readOnly = random.nextBoolean();
       boolean shared = random.nextBoolean();
       UnderFileSystemConfiguration conf =
-          UnderFileSystemConfiguration.defaults().setReadOnly(readOnly).setShared(shared);
+          UnderFileSystemConfiguration.defaults(mConfiguration).setReadOnly(readOnly)
+              .setShared(shared);
       assertTrue(conf.isSet(PropertyKey.S3A_ACCESS_KEY));
-      conf.setMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
+      conf.createMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
       assertEquals(readOnly, conf.isReadOnly());
       assertEquals(shared, conf.isShared());
       assertTrue(conf.isSet(PropertyKey.S3A_ACCESS_KEY));
@@ -99,29 +113,35 @@ public final class UnderFileSystemConfigurationTest {
   @Test
   public void containsWhenGlobalConfHasNotProperty() throws Exception {
     // Unset property in global configuration
-    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, null).toResource()) {
+    try (Closeable c = new ConfigurationRule(PropertyKey.S3A_ACCESS_KEY, null, mConfiguration).toResource()) {
       Random random = new Random();
       boolean readOnly = random.nextBoolean();
       boolean shared = random.nextBoolean();
       UnderFileSystemConfiguration conf =
-          UnderFileSystemConfiguration.defaults().setReadOnly(readOnly).setShared(shared);
+          UnderFileSystemConfiguration.defaults(mConfiguration)
+              .setReadOnly(readOnly).setShared(shared);
       assertFalse(conf.isSet(PropertyKey.S3A_ACCESS_KEY));
-      conf.setMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
-      assertEquals(readOnly, conf.isReadOnly());
-      assertEquals(shared, conf.isShared());
-      assertTrue(conf.isSet(PropertyKey.S3A_ACCESS_KEY));
+      UnderFileSystemConfiguration conf2 =
+          conf.createMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(),
+          "foo"));
+      assertEquals(readOnly, conf2.isReadOnly());
+      assertEquals(shared, conf2.isShared());
+      assertTrue(conf2.isSet(PropertyKey.S3A_ACCESS_KEY));
     }
   }
 
   @Test
   public void setUserSpecifiedConfRepeatedly() throws Exception {
-    UnderFileSystemConfiguration conf = UnderFileSystemConfiguration.defaults()
-        .setMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
-    assertEquals("foo", conf.get(PropertyKey.S3A_ACCESS_KEY));
-    assertEquals(1, conf.getMountSpecificConf().size());
-    conf.setMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_SECRET_KEY.toString(), "bar"));
-    assertEquals("bar", conf.get(PropertyKey.S3A_SECRET_KEY));
-    assertFalse(conf.isSet(PropertyKey.S3A_ACCESS_KEY));
-    assertEquals(1, conf.getMountSpecificConf().size());
+    UnderFileSystemConfiguration conf = UnderFileSystemConfiguration.defaults(mConfiguration);
+        UnderFileSystemConfiguration conf2 =
+            conf.createMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_ACCESS_KEY.toString(), "foo"));
+    assertEquals("foo", conf2.get(PropertyKey.S3A_ACCESS_KEY));
+    assertEquals(1, conf2.getMountSpecificConf().size());
+    conf2 = conf.createMountSpecificConf(ImmutableMap.of(PropertyKey.S3A_SECRET_KEY.toString(),
+        "bar"));
+    assertEquals("bar", conf2.get(PropertyKey.S3A_SECRET_KEY));
+    assertFalse(conf2.isSet(PropertyKey.S3A_ACCESS_KEY));
+    assertEquals(1, conf2.getMountSpecificConf().size());
+    assertEquals(0, conf.getMountSpecificConf().size());
   }
 }
diff --git a/core/common/src/test/java/alluxio/underfs/UnderFileSystemTest.java b/core/common/src/test/java/alluxio/underfs/UnderFileSystemTest.java
index 54c9875122..7eb1a7ac36 100644
--- a/core/common/src/test/java/alluxio/underfs/UnderFileSystemTest.java
+++ b/core/common/src/test/java/alluxio/underfs/UnderFileSystemTest.java
@@ -11,14 +11,25 @@
 
 package alluxio.underfs;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import org.junit.Assert;
 import org.junit.Assume;
+import org.junit.Before;
 import org.junit.Test;
 
 /**
  * Unit tests for {@link UnderFileSystem}.
  */
 public final class UnderFileSystemTest {
+
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = ConfigurationTestUtils.defaults();
+  }
+
   /**
    * Tests the {@link UnderFileSystemFactoryRegistry#find(String)} method when using a core
    * factory.
@@ -26,10 +37,10 @@ public final class UnderFileSystemTest {
   @Test
   public void coreFactory() {
     // Supported in core
-    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("/test/path");
+    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("/test/path", mConfiguration);
     Assert.assertNull("An UnderFileSystemFactory should not exist for local file paths", factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("file:///test/path");
+    factory = UnderFileSystemFactoryRegistry.find("file:///test/path", mConfiguration);
     Assert.assertNull("An UnderFileSystemFactory should not exist for local file paths", factory);
   }
 
@@ -48,27 +59,27 @@ public final class UnderFileSystemTest {
 
     // Requires additional modules
     UnderFileSystemFactory factory =
-        UnderFileSystemFactoryRegistry.find("hdfs://localhost/test/path");
+        UnderFileSystemFactoryRegistry.find("hdfs://localhost/test/path", mConfiguration);
     Assert.assertNull(
         "No UnderFileSystemFactory should exist for HDFS paths as it requires a separate module",
         factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("oss://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("oss://localhost/test/path", mConfiguration);
     Assert.assertNull(
         "No UnderFileSystemFactory should exist for OSS paths as it requires a separate module",
         factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("s3://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("s3://localhost/test/path", mConfiguration);
     Assert.assertNull(
         "No UnderFileSystemFactory should exist for S3 paths as it requires a separate module",
         factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("s3a://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("s3a://localhost/test/path", mConfiguration);
     Assert.assertNull(
         "No UnderFileSystemFactory should exist for S3 paths as it requires a separate module",
         factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("glusterfs://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("glusterfs://localhost/test/path", mConfiguration);
     Assert.assertNull("No UnderFileSystemFactory should exist for Gluster FS paths as it requires"
         + " a separate module", factory);
   }
diff --git a/core/common/src/test/java/alluxio/underfs/options/CreateOptionsTest.java b/core/common/src/test/java/alluxio/underfs/options/CreateOptionsTest.java
index f926a888f1..f72220b794 100644
--- a/core/common/src/test/java/alluxio/underfs/options/CreateOptionsTest.java
+++ b/core/common/src/test/java/alluxio/underfs/options/CreateOptionsTest.java
@@ -15,14 +15,16 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authentication.AuthType;
 import alluxio.security.authorization.Mode;
 import alluxio.security.group.provider.IdentityUserGroupsMapping;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.ModeUtils;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -32,18 +34,27 @@ import java.util.Random;
  * Tests for the {@link CreateOptions} class.
  */
 public final class CreateOptionsTest {
+
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = new InstancedConfiguration(ConfigurationUtils.defaults());
+  }
+
   /**
    * Tests for default {@link CreateOptions}.
    */
   @Test
   public void defaults() throws IOException {
-    CreateOptions options = CreateOptions.defaults();
+    CreateOptions options = CreateOptions.defaults(mConfiguration);
 
     assertFalse(options.getCreateParent());
     assertFalse(options.isEnsureAtomic());
     assertNull(options.getOwner());
     assertNull(options.getGroup());
-    assertEquals(ModeUtils.applyFileUMask(Mode.defaults()), options.getMode());
+    String umask = mConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK);
+    assertEquals(ModeUtils.applyFileUMask(Mode.defaults(), umask), options.getMode());
   }
 
   /**
@@ -52,19 +63,20 @@ public final class CreateOptionsTest {
    */
   @Test
   public void securityEnabled() throws IOException {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "foo");
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "foo");
     // Use IdentityUserGroupMapping to map user "foo" to group "foo".
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         IdentityUserGroupsMapping.class.getName());
 
-    CreateOptions options = CreateOptions.defaults();
+    CreateOptions options = CreateOptions.defaults(mConfiguration);
 
     assertFalse(options.getCreateParent());
     assertFalse(options.isEnsureAtomic());
     assertNull(options.getOwner());
     assertNull(options.getGroup());
-    assertEquals(ModeUtils.applyFileUMask(Mode.defaults()), options.getMode());
+    String umask = mConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK);
+    assertEquals(ModeUtils.applyFileUMask(Mode.defaults(), umask), options.getMode());
   }
 
   /**
@@ -79,7 +91,7 @@ public final class CreateOptionsTest {
     String group = CommonUtils.randomAlphaNumString(10);
     Mode mode = new Mode((short) random.nextInt());
 
-    CreateOptions options = CreateOptions.defaults();
+    CreateOptions options = CreateOptions.defaults(mConfiguration);
     options.setCreateParent(createParent);
     options.setEnsureAtomic(ensureAtomic);
     options.setOwner(owner);
@@ -95,6 +107,9 @@ public final class CreateOptionsTest {
 
   @Test
   public void equalsTest() throws Exception {
-    alluxio.test.util.CommonUtils.testEquals(CreateOptions.class);
+    CreateOptions m2 = CreateOptions.defaults(mConfiguration);
+    CreateOptions m1 = CreateOptions.defaults(mConfiguration);
+    assertEquals(m1, m2);
+    assertEquals(m1.hashCode(), m2.hashCode());
   }
 }
diff --git a/core/common/src/test/java/alluxio/underfs/options/MkdirsOptionsTest.java b/core/common/src/test/java/alluxio/underfs/options/MkdirsOptionsTest.java
index 51ea90b2e6..b83f94c105 100644
--- a/core/common/src/test/java/alluxio/underfs/options/MkdirsOptionsTest.java
+++ b/core/common/src/test/java/alluxio/underfs/options/MkdirsOptionsTest.java
@@ -15,14 +15,17 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.Constants;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authentication.AuthType;
 import alluxio.security.authorization.Mode;
 import alluxio.security.group.provider.IdentityUserGroupsMapping;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.ModeUtils;
 
+import org.junit.Before;
 import org.junit.Test;
 
 import java.io.IOException;
@@ -32,19 +35,28 @@ import java.util.Random;
  * Tests for the {@link MkdirsOptions} class.
  */
 public final class MkdirsOptionsTest {
+
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before() {
+    mConfiguration = new InstancedConfiguration(ConfigurationUtils.defaults());
+  }
+
   /**
    * Tests for default {@link MkdirsOptions}.
    */
   @Test
   public void defaults() throws IOException {
-    MkdirsOptions options = MkdirsOptions.defaults();
+    MkdirsOptions options = MkdirsOptions.defaults(mConfiguration);
 
     // Verify the default createParent is true.
     assertTrue(options.getCreateParent());
     // Verify that the owner and group are not set.
     assertNull(options.getOwner());
     assertNull(options.getGroup());
-    assertEquals(ModeUtils.applyDirectoryUMask(Mode.defaults()), options.getMode());
+    String umask = mConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK);
+    assertEquals(ModeUtils.applyDirectoryUMask(Mode.defaults(), umask), options.getMode());
   }
 
   /**
@@ -53,20 +65,22 @@ public final class MkdirsOptionsTest {
    */
   @Test
   public void securityEnabled() throws IOException {
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "foo");
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    conf.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    conf.set(PropertyKey.SECURITY_LOGIN_USERNAME, "foo");
     // Use IdentityUserGroupMapping to map user "foo" to group "foo".
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    conf.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         IdentityUserGroupsMapping.class.getName());
 
-    MkdirsOptions options = MkdirsOptions.defaults();
+    MkdirsOptions options = MkdirsOptions.defaults(mConfiguration);
 
     // Verify the default createParent is true.
     assertTrue(options.getCreateParent());
     // Verify that the owner and group are not set.
     assertNull(options.getOwner());
     assertNull(options.getGroup());
-    assertEquals(ModeUtils.applyDirectoryUMask(Mode.defaults()), options.getMode());
+    String umask = mConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK);
+    assertEquals(ModeUtils.applyDirectoryUMask(Mode.defaults(), umask), options.getMode());
   }
 
   /**
@@ -80,7 +94,7 @@ public final class MkdirsOptionsTest {
     String group = CommonUtils.randomAlphaNumString(10);
     Mode mode = new Mode((short) random.nextInt());
 
-    MkdirsOptions options = MkdirsOptions.defaults();
+    MkdirsOptions options = MkdirsOptions.defaults(mConfiguration);
     options.setCreateParent(createParent);
     options.setOwner(owner);
     options.setGroup(group);
@@ -94,6 +108,9 @@ public final class MkdirsOptionsTest {
 
   @Test
   public void equalsTest() throws Exception {
-    alluxio.test.util.CommonUtils.testEquals(MkdirsOptions.class);
+    MkdirsOptions m1 = MkdirsOptions.defaults(mConfiguration);
+    MkdirsOptions m2 = MkdirsOptions.defaults(mConfiguration);
+    assertEquals(m1, m2);
+    assertEquals(m1.hashCode(), m2.hashCode());
   }
 }
diff --git a/core/common/src/test/java/alluxio/util/CommonUtilsTest.java b/core/common/src/test/java/alluxio/util/CommonUtilsTest.java
index bce7f0779b..77013eb665 100644
--- a/core/common/src/test/java/alluxio/util/CommonUtilsTest.java
+++ b/core/common/src/test/java/alluxio/util/CommonUtilsTest.java
@@ -18,9 +18,8 @@ import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.security.group.CachedGroupMapping;
 import alluxio.security.group.GroupMappingService;
 
@@ -32,7 +31,6 @@ import org.mockito.Mockito;
 import org.powermock.api.mockito.PowerMockito;
 import org.powermock.core.classloader.annotations.PrepareForTest;
 import org.powermock.modules.junit4.PowerMockRunner;
-import org.powermock.reflect.Whitebox;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -96,20 +94,18 @@ public class CommonUtilsTest {
 
   @Test
   public void getTmpDir() {
+
     // Test single tmp dir
     String singleDir = "/tmp";
-    Whitebox.setInternalState(CommonUtils.class, "TMP_DIRS", Collections.singletonList(singleDir));
-    assertEquals(singleDir, CommonUtils.getTmpDir());
+    List<String> singleDirList = Arrays.asList( "/tmp");
+    assertEquals(singleDir, CommonUtils.getTmpDir(singleDirList));
     // Test multiple tmp dir
     List<String> multiDirs = Arrays.asList("/tmp1", "/tmp2", "/tmp3");
-    Whitebox.setInternalState(CommonUtils.class, "TMP_DIRS", multiDirs);
     Set<String> results = new HashSet<>();
     for (int i = 0; i < 100 || results.size() != multiDirs.size(); i++) {
-      results.add(CommonUtils.getTmpDir());
+      results.add(CommonUtils.getTmpDir(multiDirs));
     }
     assertEquals(new HashSet<>(multiDirs), results);
-    Whitebox.setInternalState(CommonUtils.class, "TMP_DIRS",
-        Configuration.getList(PropertyKey.TMP_DIRS, ","));
   }
 
   /**
@@ -270,6 +266,8 @@ public class CommonUtilsTest {
    */
   @Test
   public void getGroups() throws Throwable {
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+
     String userName = "alluxio-user1";
     String userGroup1 = "alluxio-user1-group1";
     String userGroup2 = "alluxio-user1-group2";
@@ -280,12 +278,12 @@ public class CommonUtilsTest {
     PowerMockito.when(cachedGroupService.getGroups(Mockito.anyString())).thenReturn(
         Lists.newArrayList(userGroup1, userGroup2));
     PowerMockito.mockStatic(GroupMappingService.Factory.class);
-    Mockito.when(GroupMappingService.Factory.get()).thenReturn(cachedGroupService);
+    Mockito.when(GroupMappingService.Factory.get(conf)).thenReturn(cachedGroupService);
 
-    List<String> groups = CommonUtils.getGroups(userName);
+    List<String> groups = CommonUtils.getGroups(userName, conf);
     assertEquals(Arrays.asList(userGroup1, userGroup2), groups);
 
-    String primaryGroup = CommonUtils.getPrimaryGroupName(userName);
+    String primaryGroup = CommonUtils.getPrimaryGroupName(userName, conf);
     assertNotNull(primaryGroup);
     assertEquals(userGroup1, primaryGroup);
   }
diff --git a/core/common/src/test/java/alluxio/util/JvmPauseMonitorTest.java b/core/common/src/test/java/alluxio/util/JvmPauseMonitorTest.java
index 149185376a..fa72ce465f 100644
--- a/core/common/src/test/java/alluxio/util/JvmPauseMonitorTest.java
+++ b/core/common/src/test/java/alluxio/util/JvmPauseMonitorTest.java
@@ -11,6 +11,9 @@
 
 package alluxio.util;
 
+import alluxio.conf.AlluxioProperties;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import com.google.common.collect.Lists;
 import org.junit.Assert;
 import org.junit.Ignore;
@@ -22,7 +25,12 @@ public final class JvmPauseMonitorTest {
   @Test
   @Ignore("https://alluxio.atlassian.net/browse/ALLUXIO-3059")
   public void monitorTest() {
-    JvmPauseMonitor jvmPauseMonitor = new JvmPauseMonitor();
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    long gcSleepInterval = conf.getMs(PropertyKey.JVM_MONITOR_SLEEP_INTERVAL_MS);
+    long warnThreshold = conf.getMs(PropertyKey.JVM_MONITOR_WARN_THRESHOLD_MS);
+    long infoThreshold = conf.getMs(PropertyKey.JVM_MONITOR_INFO_THRESHOLD_MS);
+
+    JvmPauseMonitor jvmPauseMonitor = new JvmPauseMonitor(gcSleepInterval, warnThreshold, infoThreshold);
     jvmPauseMonitor.start();
     List<String> list = Lists.newArrayList();
     int i = 0;
diff --git a/core/common/src/test/java/alluxio/util/SecurityUtilsTest.java b/core/common/src/test/java/alluxio/util/SecurityUtilsTest.java
index e33b7f59d6..ed26cfcb3e 100644
--- a/core/common/src/test/java/alluxio/util/SecurityUtilsTest.java
+++ b/core/common/src/test/java/alluxio/util/SecurityUtilsTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.util;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.LoginUserTestUtils;
 import alluxio.security.authentication.AuthType;
 import alluxio.security.authentication.AuthenticatedClientUser;
@@ -21,14 +21,21 @@ import alluxio.security.group.provider.IdentityUserGroupsMapping;
 
 import org.junit.After;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 public final class SecurityUtilsTest {
 
+  private InstancedConfiguration mConfiguration;
+
+  @Before
+  public void before(){
+    mConfiguration = new InstancedConfiguration(ConfigurationUtils.defaults());
+  }
+
   @After
   public void after() {
     LoginUserTestUtils.resetLoginUser();
-    ConfigurationTestUtils.resetConfiguration();
   }
 
   /**
@@ -37,14 +44,14 @@ public final class SecurityUtilsTest {
   @Test
   public void getOwnerFromGrpcClient() throws Exception {
     // When security is not enabled, user and group are not set
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
-    Assert.assertEquals("", SecurityUtils.getOwnerFromGrpcClient());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
+    Assert.assertEquals("", SecurityUtils.getOwnerFromGrpcClient(mConfiguration));
 
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         IdentityUserGroupsMapping.class.getName());
     AuthenticatedClientUser.set("test_client_user");
-    Assert.assertEquals("test_client_user", SecurityUtils.getOwnerFromGrpcClient());
+    Assert.assertEquals("test_client_user", SecurityUtils.getOwnerFromGrpcClient(mConfiguration));
   }
 
   /**
@@ -53,14 +60,14 @@ public final class SecurityUtilsTest {
   @Test
   public void getGroupFromGrpcClient() throws Exception {
     // When security is not enabled, user and group are not set
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
-    Assert.assertEquals("", SecurityUtils.getGroupFromGrpcClient());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
+    Assert.assertEquals("", SecurityUtils.getGroupFromGrpcClient(mConfiguration));
 
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         IdentityUserGroupsMapping.class.getName());
     AuthenticatedClientUser.set("test_client_user");
-    Assert.assertEquals("test_client_user", SecurityUtils.getGroupFromGrpcClient());
+    Assert.assertEquals("test_client_user", SecurityUtils.getGroupFromGrpcClient(mConfiguration));
   }
 
   /**
@@ -69,15 +76,15 @@ public final class SecurityUtilsTest {
   @Test
   public void getOwnerFromLoginModule() throws Exception {
     // When security is not enabled, user and group are not set
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
-    Assert.assertEquals("", SecurityUtils.getOwnerFromLoginModule());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
+    Assert.assertEquals("", SecurityUtils.getOwnerFromLoginModule(mConfiguration));
 
     // When authentication is enabled, user and group are inferred from login module
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "test_login_user");
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "test_login_user");
+    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         IdentityUserGroupsMapping.class.getName());
-    Assert.assertEquals("test_login_user", SecurityUtils.getOwnerFromLoginModule());
+    Assert.assertEquals("test_login_user", SecurityUtils.getOwnerFromLoginModule(mConfiguration));
   }
 
   /**
@@ -86,15 +93,15 @@ public final class SecurityUtilsTest {
   @Test
   public void getGroupFromLoginModuleError() throws Exception {
     // When security is not enabled, user and group are not set
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
-    Assert.assertEquals("", SecurityUtils.getGroupFromLoginModule());
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.NOSASL.getAuthName());
+    Assert.assertEquals("", SecurityUtils.getGroupFromLoginModule(mConfiguration));
 
     // When authentication is enabled, user and group are inferred from login module
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "test_login_user");
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    mConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    mConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, "test_login_user");
+    mConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         IdentityUserGroupsMapping.class.getName());
     LoginUserTestUtils.resetLoginUser();
-    Assert.assertEquals("test_login_user", SecurityUtils.getGroupFromLoginModule());
+    Assert.assertEquals("test_login_user", SecurityUtils.getGroupFromLoginModule(mConfiguration));
   }
 }
diff --git a/core/common/src/test/java/alluxio/util/io/FileUtilsTest.java b/core/common/src/test/java/alluxio/util/io/FileUtilsTest.java
index 9f47d292c8..fb2ba92ec1 100644
--- a/core/common/src/test/java/alluxio/util/io/FileUtilsTest.java
+++ b/core/common/src/test/java/alluxio/util/io/FileUtilsTest.java
@@ -19,6 +19,10 @@ import static org.junit.Assume.assumeFalse;
 
 import alluxio.AlluxioURI;
 
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
+import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -47,6 +51,8 @@ import javax.annotation.Nullable;
  */
 public class FileUtilsTest {
 
+  private String workerDataFolderPerms = ConfigurationUtils.defaults().get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);
+
   /**
    * The temporary folder.
    */
@@ -228,7 +234,7 @@ public class FileUtilsTest {
   public void createBlockPath() throws IOException {
     String absolutePath = PathUtils.concatPath(mTestFolder.getRoot(), "tmp", "bar");
     File tempFile = new File(absolutePath);
-    FileUtils.createBlockPath(tempFile.getAbsolutePath());
+    FileUtils.createBlockPath(tempFile.getAbsolutePath(), workerDataFolderPerms);
     assertTrue(FileUtils.exists(tempFile.getParent()));
   }
 
@@ -291,14 +297,14 @@ public class FileUtilsTest {
     File blockFile = new File(storageDir, "200");
 
     // When storage dir doesn't exist
-    FileUtils.createBlockPath(blockFile.getAbsolutePath());
+    FileUtils.createBlockPath(blockFile.getAbsolutePath(), workerDataFolderPerms);
     assertTrue(FileUtils.exists(storageDir.getAbsolutePath()));
     assertEquals(
         PosixFilePermissions.fromString("rwxrwxrwx"),
         Files.getPosixFilePermissions(Paths.get(storageDir.getAbsolutePath())));
 
     // When storage dir exists
-    FileUtils.createBlockPath(blockFile.getAbsolutePath());
+    FileUtils.createBlockPath(blockFile.getAbsolutePath(), workerDataFolderPerms);
     assertTrue(FileUtils.exists(storageDir.getAbsolutePath()));
   }
 
@@ -324,7 +330,7 @@ public class FileUtilsTest {
       @Nullable
       public Void call() throws Exception {
         mBarrier.await(); // Await until all threads submitted
-        FileUtils.createBlockPath(mPath);
+        FileUtils.createBlockPath(mPath, workerDataFolderPerms);
         return null;
       }
     }
diff --git a/core/common/src/test/java/alluxio/util/network/GetMasterWorkerAddressTest.java b/core/common/src/test/java/alluxio/util/network/GetMasterWorkerAddressTest.java
index dcf3774d13..4ee98c0ea4 100644
--- a/core/common/src/test/java/alluxio/util/network/GetMasterWorkerAddressTest.java
+++ b/core/common/src/test/java/alluxio/util/network/GetMasterWorkerAddressTest.java
@@ -11,12 +11,11 @@
 
 package alluxio.util.network;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
 
-import org.junit.After;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -28,41 +27,39 @@ import java.net.InetSocketAddress;
  */
 public class GetMasterWorkerAddressTest {
 
-  @After
-  public void after() {
-    ConfigurationTestUtils.resetConfiguration();
-  }
-
   /**
    * Tests the {@link NetworkAddressUtils#getConnectAddress(ServiceType)} method for
    * a master node.
    */
   @Test
   public void getMasterAddress() {
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
     // connect host and port
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "RemoteMaster1");
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, "10000");
-    String defaultHostname = NetworkAddressUtils.getLocalHostName();
+    conf.set(PropertyKey.MASTER_HOSTNAME, "RemoteMaster1");
+    conf.set(PropertyKey.MASTER_RPC_PORT, "10000");
+    int resolveTimeout = (int)conf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
+    String defaultHostname = NetworkAddressUtils.getLocalHostName(resolveTimeout);
     int defaultPort = Integer.parseInt(PropertyKey.MASTER_RPC_PORT.getDefaultValue());
     InetSocketAddress masterAddress =
-        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC);
+        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, conf);
     Assert.assertEquals(new InetSocketAddress("RemoteMaster1", 10000), masterAddress);
-    ConfigurationTestUtils.resetConfiguration();
+    conf = new InstancedConfiguration(ConfigurationUtils.defaults());
 
     // port only
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, "20000");
-    masterAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC);
+    conf.set(PropertyKey.MASTER_RPC_PORT, "20000");
+    masterAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, conf);
     Assert.assertEquals(new InetSocketAddress(defaultHostname, 20000), masterAddress);
-    ConfigurationTestUtils.resetConfiguration();
+    conf = new InstancedConfiguration(ConfigurationUtils.defaults());
 
     // connect host only
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, "RemoteMaster3");
-    masterAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC);
+    conf.set(PropertyKey.MASTER_HOSTNAME, "RemoteMaster3");
+    masterAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, conf);
     Assert.assertEquals(new InetSocketAddress("RemoteMaster3", defaultPort), masterAddress);
-    ConfigurationTestUtils.resetConfiguration();
+    conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+
 
     // all default
-    masterAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC);
+    masterAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, conf);
     Assert.assertEquals(new InetSocketAddress(defaultHostname, defaultPort), masterAddress);
   }
 }
diff --git a/core/common/src/test/java/alluxio/util/network/NetworkAddressUtilsTest.java b/core/common/src/test/java/alluxio/util/network/NetworkAddressUtilsTest.java
index 6863ecc04c..8d8575ee65 100644
--- a/core/common/src/test/java/alluxio/util/network/NetworkAddressUtilsTest.java
+++ b/core/common/src/test/java/alluxio/util/network/NetworkAddressUtilsTest.java
@@ -13,12 +13,13 @@ package alluxio.util.network;
 
 import static org.junit.Assert.assertEquals;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationRule;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.CommonUtils;
 import alluxio.util.CommonUtils.ProcessType;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
 import alluxio.wire.WorkerNetAddress;
 
@@ -35,13 +36,17 @@ import java.net.UnknownHostException;
  */
 public class NetworkAddressUtilsTest {
 
+  private InstancedConfiguration mConfiguration;
+
   @Before
-  public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+  public void before() {
+    mConfiguration = ConfigurationTestUtils.defaults();
   }
 
   /**
-   * Tests the {@link NetworkAddressUtils#getConnectAddress(ServiceType)} method.
+   * Tests the
+   * {@link NetworkAddressUtils#getConnectAddress(ServiceType, alluxio.conf.AlluxioConfiguration)}
+   * method.
    */
   @Test
   public void testGetConnectAddress() throws Exception {
@@ -51,72 +56,77 @@ public class NetworkAddressUtilsTest {
   }
 
   /**
-   * Tests the {@link NetworkAddressUtils#getConnectAddress(ServiceType)} method for specific
+   * Tests the
+   * {@link NetworkAddressUtils#getConnectAddress(ServiceType, alluxio.conf.AlluxioConfiguration)}
+   * method
+   * for specific
    * service under different conditions.
    *
    * @param service the service name used to connect
    */
   private void getConnectAddress(ServiceType service) throws Exception {
-    String localHostName = NetworkAddressUtils.getLocalHostName();
+    int resolveTimeout = (int)mConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
+    String localHostName = NetworkAddressUtils.getLocalHostName(resolveTimeout);
     InetSocketAddress masterAddress;
 
     // all default
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress(localHostName, service.getDefaultPort()),
         masterAddress);
 
     // bind host only
-    Configuration.unset(service.getHostNameKey());
-    Configuration.set(service.getBindHostKey(), "bind.host");
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.unset(service.getHostNameKey());
+    mConfiguration.set(service.getBindHostKey(), "bind.host");
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", service.getDefaultPort()), masterAddress);
 
     // connect host and bind host
-    Configuration.set(service.getHostNameKey(), "connect.host");
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getHostNameKey(), "connect.host");
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("connect.host", service.getDefaultPort()),
         masterAddress);
 
     // wildcard connect host and bind host
-    Configuration.set(service.getHostNameKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getHostNameKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", service.getDefaultPort()), masterAddress);
 
     // wildcard connect host and wildcard bind host
-    Configuration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress(localHostName, service.getDefaultPort()),
         masterAddress);
 
     // connect host and wildcard bind host
-    Configuration.set(service.getHostNameKey(), "connect.host");
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getHostNameKey(), "connect.host");
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("connect.host", service.getDefaultPort()),
         masterAddress);
 
     // connect host and wildcard bind host with port
-    Configuration.set(service.getPortKey(), "10000");
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getPortKey(), "10000");
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("connect.host", 10000), masterAddress);
 
     // connect host and bind host with port
-    Configuration.set(service.getBindHostKey(), "bind.host");
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getBindHostKey(), "bind.host");
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("connect.host", 10000), masterAddress);
 
     // empty connect host and bind host with port
-    Configuration.unset(service.getHostNameKey());
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.unset(service.getHostNameKey());
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", 10000), masterAddress);
 
     // empty connect host and wildcard bind host with port
-    Configuration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
-    masterAddress = NetworkAddressUtils.getConnectAddress(service);
+    mConfiguration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
+    masterAddress = NetworkAddressUtils.getConnectAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress(localHostName, 10000), masterAddress);
   }
 
-  /**
-   * Tests the {@link NetworkAddressUtils#getBindAddress(ServiceType)} method.
+   /**
+   * Tests the
+   * {@link NetworkAddressUtils#getBindAddress(ServiceType, alluxio.conf.AlluxioConfiguration)} method.
    */
   @Test
   public void testGetBindAddress() throws Exception {
@@ -126,47 +136,47 @@ public class NetworkAddressUtilsTest {
   }
 
   /**
-   * Tests the {@link NetworkAddressUtils#getBindAddress(ServiceType)} method for specific
-   * service under different conditions.
+   * Tests the {@link NetworkAddressUtils#getBindAddress(ServiceType,
+   * alluxio.conf.AlluxioConfiguration)} method for specific service under different conditions.
    *
    * @param service the service name used to connect
    */
   private void getBindAddress(ServiceType service) throws Exception {
-    String localHostName = NetworkAddressUtils.getLocalHostName();
+    int resolveTimeout = (int)mConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
+    String localHostName = NetworkAddressUtils.getLocalHostName(resolveTimeout);
     InetSocketAddress workerAddress;
 
     // all default
-    ConfigurationTestUtils.resetConfiguration();
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(
         new InetSocketAddress(NetworkAddressUtils.WILDCARD_ADDRESS, service.getDefaultPort()),
         workerAddress);
 
     // bind host only
-    Configuration.set(service.getBindHostKey(), "bind.host");
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getBindHostKey(), "bind.host");
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", service.getDefaultPort()), workerAddress);
 
     // connect host and bind host
-    Configuration.set(service.getHostNameKey(), "connect.host");
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getHostNameKey(), "connect.host");
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", service.getDefaultPort()), workerAddress);
 
     // wildcard connect host and bind host
-    Configuration.set(service.getHostNameKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getHostNameKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", service.getDefaultPort()), workerAddress);
 
     // wildcard connect host and wildcard bind host
-    Configuration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(
         new InetSocketAddress(NetworkAddressUtils.WILDCARD_ADDRESS, service.getDefaultPort()),
         workerAddress);
 
     // connect host and wildcard bind host
-    Configuration.set(service.getHostNameKey(), "connect.host");
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getHostNameKey(), "connect.host");
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(
         new InetSocketAddress(NetworkAddressUtils.WILDCARD_ADDRESS, service.getDefaultPort()),
         workerAddress);
@@ -180,89 +190,91 @@ public class NetworkAddressUtilsTest {
         Configuration.set(PropertyKey.MASTER_EMBEDDED_JOURNAL_PORT, "20000");
         break;
       case JOB_MASTER_RPC:
-        Configuration.set(PropertyKey.JOB_MASTER_RPC_PORT, "20000");
+        mConfiguration.set(PropertyKey.JOB_MASTER_RPC_PORT, "20000");
         break;
       case JOB_MASTER_WEB:
-        Configuration.set(PropertyKey.JOB_MASTER_WEB_PORT, "20000");
+        mConfiguration.set(PropertyKey.JOB_MASTER_WEB_PORT, "20000");
         break;
       case JOB_WORKER_RPC:
-        Configuration.set(PropertyKey.JOB_WORKER_RPC_PORT, "20000");
+        mConfiguration.set(PropertyKey.JOB_WORKER_RPC_PORT, "20000");
         break;
       case JOB_WORKER_WEB:
-        Configuration.set(PropertyKey.JOB_WORKER_WEB_PORT, "20000");
+        mConfiguration.set(PropertyKey.JOB_WORKER_WEB_PORT, "20000");
         break;
       case MASTER_RPC:
-        Configuration.set(PropertyKey.MASTER_RPC_PORT, "20000");
+        mConfiguration.set(PropertyKey.MASTER_RPC_PORT, "20000");
         break;
       case MASTER_WEB:
-        Configuration.set(PropertyKey.MASTER_WEB_PORT, "20000");
+        mConfiguration.set(PropertyKey.MASTER_WEB_PORT, "20000");
         break;
       case PROXY_WEB:
-        Configuration.set(PropertyKey.PROXY_WEB_PORT, "20000");
+        mConfiguration.set(PropertyKey.PROXY_WEB_PORT, "20000");
         break;
       case WORKER_RPC:
-        Configuration.set(PropertyKey.WORKER_RPC_PORT, "20000");
+        mConfiguration.set(PropertyKey.WORKER_RPC_PORT, "20000");
         break;
       case WORKER_WEB:
-        Configuration.set(PropertyKey.WORKER_WEB_PORT, "20000");
+        mConfiguration.set(PropertyKey.WORKER_WEB_PORT, "20000");
         break;
       default:
         Assert.fail("Unrecognized service type: " + service.toString());
         break;
     }
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress(NetworkAddressUtils.WILDCARD_ADDRESS, 20000),
         workerAddress);
 
     // connect host and bind host with port
-    Configuration.set(service.getBindHostKey(), "bind.host");
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getBindHostKey(), "bind.host");
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", 20000), workerAddress);
 
     // empty connect host and bind host with port
-    Configuration.unset(service.getHostNameKey());
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.unset(service.getHostNameKey());
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress("bind.host", 20000), workerAddress);
 
     // empty connect host and wildcard bind host with port
-    Configuration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.set(service.getBindHostKey(), NetworkAddressUtils.WILDCARD_ADDRESS);
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress(NetworkAddressUtils.WILDCARD_ADDRESS, 20000),
         workerAddress);
 
     // empty connect host and empty bind host with port
-    Configuration.unset(service.getBindHostKey());
-    workerAddress = NetworkAddressUtils.getBindAddress(service);
+    mConfiguration.unset(service.getBindHostKey());
+    workerAddress = NetworkAddressUtils.getBindAddress(service, mConfiguration);
     assertEquals(new InetSocketAddress(localHostName, 20000), workerAddress);
   }
 
   @Test
   public void getLocalNodeNameClient() throws Exception {
     CommonUtils.PROCESS_TYPE.set(ProcessType.CLIENT);
-    try (Closeable c = new ConfigurationRule(PropertyKey.USER_HOSTNAME, "client").toResource()) {
-      assertEquals("client", NetworkAddressUtils.getLocalNodeName());
+    try (Closeable c = new ConfigurationRule(PropertyKey.USER_HOSTNAME, "client", mConfiguration).toResource()) {
+      assertEquals("client", NetworkAddressUtils.getLocalNodeName(mConfiguration));
     }
   }
 
   @Test
   public void getLocalNodeNameWorker() throws Exception {
     CommonUtils.PROCESS_TYPE.set(ProcessType.WORKER);
-    try (Closeable c = new ConfigurationRule(PropertyKey.WORKER_HOSTNAME, "worker").toResource()) {
-      assertEquals("worker", NetworkAddressUtils.getLocalNodeName());
+    try (Closeable c = new ConfigurationRule(PropertyKey.WORKER_HOSTNAME, "worker", mConfiguration).toResource()) {
+      assertEquals("worker", NetworkAddressUtils.getLocalNodeName(mConfiguration));
     }
   }
 
   @Test
   public void getLocalNodeNameMaster() throws Exception {
     CommonUtils.PROCESS_TYPE.set(ProcessType.MASTER);
-    try (Closeable c = new ConfigurationRule(PropertyKey.MASTER_HOSTNAME, "master").toResource()) {
-      assertEquals("master", NetworkAddressUtils.getLocalNodeName());
+    try (Closeable c = new ConfigurationRule(PropertyKey.MASTER_HOSTNAME, "master", mConfiguration).toResource()) {
+      assertEquals("master", NetworkAddressUtils.getLocalNodeName(mConfiguration));
     }
   }
 
   @Test
   public void getLocalNodeNameLookup() throws Exception {
-    assertEquals(NetworkAddressUtils.getLocalHostName(), NetworkAddressUtils.getLocalNodeName());
+    int resolveTimeout = (int)mConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
+    assertEquals(NetworkAddressUtils.getLocalHostName(resolveTimeout),
+        NetworkAddressUtils.getLocalNodeName(mConfiguration));
   }
 
   /**
@@ -314,13 +326,14 @@ public class NetworkAddressUtilsTest {
 
   @Test
   public void getConfiguredClientHostname() {
-    Configuration.set(PropertyKey.USER_HOSTNAME, "clienthost");
-    assertEquals("clienthost", NetworkAddressUtils.getClientHostName());
+    mConfiguration.set(PropertyKey.USER_HOSTNAME, "clienthost");
+    assertEquals("clienthost", NetworkAddressUtils.getClientHostName(mConfiguration));
   }
 
   @Test
   public void getDefaultClientHostname() {
-    assertEquals(NetworkAddressUtils.getLocalHostName(),
-        NetworkAddressUtils.getClientHostName());
+    int resolveTimeout = (int)mConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);
+    assertEquals(NetworkAddressUtils.getLocalHostName(resolveTimeout),
+        NetworkAddressUtils.getClientHostName(mConfiguration));
   }
 }
diff --git a/core/common/src/test/java/alluxio/wire/TieredIdentityTest.java b/core/common/src/test/java/alluxio/wire/TieredIdentityTest.java
index c8b7e1ffe8..9e44ea237d 100644
--- a/core/common/src/test/java/alluxio/wire/TieredIdentityTest.java
+++ b/core/common/src/test/java/alluxio/wire/TieredIdentityTest.java
@@ -17,9 +17,9 @@ import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assume.assumeTrue;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.network.TieredIdentityFactory;
 import alluxio.util.CommonUtils;
 import alluxio.util.TieredIdentityUtils;
@@ -27,7 +27,7 @@ import alluxio.grpc.GrpcUtils;
 import alluxio.wire.TieredIdentity.LocalityTier;
 
 import com.fasterxml.jackson.databind.ObjectMapper;
-import org.junit.After;
+import org.junit.Before;
 import org.junit.Test;
 
 import java.net.InetAddress;
@@ -40,26 +40,29 @@ import java.util.Random;
  */
 public class TieredIdentityTest {
 
-  @After
-  public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+  private InstancedConfiguration mConfiguration = ConfigurationTestUtils.defaults();
+
+  @Before
+  public void before() {
+    mConfiguration = ConfigurationTestUtils.defaults();
   }
 
   @Test
   public void nearest() throws Exception {
-    TieredIdentity id1 = TieredIdentityFactory.fromString("node=A,rack=rack1");
-    TieredIdentity id2 = TieredIdentityFactory.fromString("node=B,rack=rack2");
-    TieredIdentity id3 = TieredIdentityFactory.fromString("node=C,rack=rack2");
+    TieredIdentity id1 = TieredIdentityFactory.fromString("node=A,rack=rack1", mConfiguration);
+    TieredIdentity id2 = TieredIdentityFactory.fromString("node=B,rack=rack2", mConfiguration);
+    TieredIdentity id3 = TieredIdentityFactory.fromString("node=C,rack=rack2", mConfiguration);
     List<TieredIdentity> identities = Arrays.asList(id1, id2, id3);
 
+    boolean resolveIp = mConfiguration.getBoolean(PropertyKey.LOCALITY_COMPARE_NODE_IP);
     assertSame(id1, TieredIdentityUtils
-        .nearest(TieredIdentityFactory.fromString("node=D,rack=rack1"), identities).get());
+        .nearest(TieredIdentityFactory.fromString("node=D,rack=rack1", mConfiguration), identities, resolveIp).get());
     assertSame(id2, TieredIdentityUtils
-        .nearest(TieredIdentityFactory.fromString("node=B,rack=rack2"), identities).get());
+        .nearest(TieredIdentityFactory.fromString("node=B,rack=rack2", mConfiguration), identities, resolveIp).get());
     assertSame(id3, TieredIdentityUtils
-        .nearest(TieredIdentityFactory.fromString("node=C,rack=rack2"), identities).get());
+        .nearest(TieredIdentityFactory.fromString("node=C,rack=rack2", mConfiguration), identities, resolveIp).get());
     assertSame(id1, TieredIdentityUtils
-        .nearest(TieredIdentityFactory.fromString("node=D,rack=rack3"), identities).get());
+        .nearest(TieredIdentityFactory.fromString("node=D,rack=rack3", mConfiguration), identities, resolveIp).get());
   }
 
   @Test
@@ -80,8 +83,6 @@ public class TieredIdentityTest {
 
   @Test
   public void matchByStringEquality() {
-    Configuration.set(PropertyKey.LOCALITY_COMPARE_NODE_IP, "true");
-
     LocalityTier lt1 = new LocalityTier("node", "NonResolvableHostname-A");
     LocalityTier lt2 = new LocalityTier("node", "NonResolvableHostname-A");
     LocalityTier lt3 = new LocalityTier("node", "NonResolvableHostname-B");
@@ -91,13 +92,13 @@ public class TieredIdentityTest {
     LocalityTier lt7 = new LocalityTier("rack", "");
     LocalityTier lt8 = new LocalityTier("node", "NonResolvableHostname-A");
     LocalityTier lt9 = new LocalityTier("node", "");
-    assertTrue(TieredIdentityUtils.matches(lt1, lt1));
-    assertTrue(TieredIdentityUtils.matches(lt1, lt2));
-    assertFalse(TieredIdentityUtils.matches(lt2, lt3));
-    assertTrue(TieredIdentityUtils.matches(lt5, lt6));
-    assertFalse(TieredIdentityUtils.matches(lt4, lt5));
-    assertFalse(TieredIdentityUtils.matches(lt6, lt7));
-    assertFalse(TieredIdentityUtils.matches(lt8, lt9));
+    assertTrue(TieredIdentityUtils.matches(lt1, lt1, true));
+    assertTrue(TieredIdentityUtils.matches(lt1, lt2, true));
+    assertFalse(TieredIdentityUtils.matches(lt2, lt3, true));
+    assertTrue(TieredIdentityUtils.matches(lt5, lt6, true));
+    assertFalse(TieredIdentityUtils.matches(lt4, lt5, true));
+    assertFalse(TieredIdentityUtils.matches(lt6, lt7, true));
+    assertFalse(TieredIdentityUtils.matches(lt8, lt9, true));
   }
 
   @Test
@@ -106,11 +107,8 @@ public class TieredIdentityTest {
     LocalityTier lt1 = new LocalityTier("node", "localhost");
     LocalityTier lt2 = new LocalityTier("node", "127.0.0.1");
 
-    Configuration.set(PropertyKey.LOCALITY_COMPARE_NODE_IP, "true");
-    assertTrue(TieredIdentityUtils.matches(lt1, lt2));
-
-    Configuration.set(PropertyKey.LOCALITY_COMPARE_NODE_IP, "false");
-    assertFalse(TieredIdentityUtils.matches(lt1, lt2));
+    assertTrue(TieredIdentityUtils.matches(lt1, lt2, true));
+    assertFalse(TieredIdentityUtils.matches(lt1, lt2, false));
   }
 
   public void string() {
diff --git a/core/server/common/src/main/java/alluxio/MasterStorageTierAssoc.java b/core/server/common/src/main/java/alluxio/MasterStorageTierAssoc.java
index 2f14703ae7..bcca2f7dce 100644
--- a/core/server/common/src/main/java/alluxio/MasterStorageTierAssoc.java
+++ b/core/server/common/src/main/java/alluxio/MasterStorageTierAssoc.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.PropertyKey;
+
 import java.util.List;
 
 import javax.annotation.concurrent.ThreadSafe;
diff --git a/core/server/common/src/main/java/alluxio/ProcessUtils.java b/core/server/common/src/main/java/alluxio/ProcessUtils.java
index 4bde675afd..7ab2c10c63 100644
--- a/core/server/common/src/main/java/alluxio/ProcessUtils.java
+++ b/core/server/common/src/main/java/alluxio/ProcessUtils.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import org.apache.commons.lang3.exception.ExceptionUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -68,7 +70,7 @@ public final class ProcessUtils {
     if (t != null) {
       message += "\n" + ExceptionUtils.getStackTrace(t);
     }
-    if (Configuration.getBoolean(PropertyKey.TEST_MODE)) {
+    if (ServerConfiguration.getBoolean(PropertyKey.TEST_MODE)) {
       throw new RuntimeException(message);
     }
     logger.error(message);
diff --git a/core/server/common/src/main/java/alluxio/RestUtils.java b/core/server/common/src/main/java/alluxio/RestUtils.java
index 37b7011b42..0b3a1eecad 100644
--- a/core/server/common/src/main/java/alluxio/RestUtils.java
+++ b/core/server/common/src/main/java/alluxio/RestUtils.java
@@ -11,6 +11,7 @@
 
 package alluxio;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.exception.status.Status;
 import alluxio.security.LoginUser;
@@ -39,11 +40,12 @@ public final class RestUtils {
    * @param callable the callable to call
    * @return the response object
    */
-  public static <T> Response call(RestUtils.RestCallable<T> callable) {
+  public static <T> Response call(RestUtils.RestCallable<T> callable,
+      AlluxioConfiguration alluxioConf) {
     try {
       // TODO(cc): reconsider how to enable authentication
-      if (SecurityUtils.isSecurityEnabled() && AuthenticatedClientUser.get() == null) {
-        AuthenticatedClientUser.set(LoginUser.get().getName());
+      if (SecurityUtils.isSecurityEnabled(alluxioConf) && AuthenticatedClientUser.get(alluxioConf) == null) {
+        AuthenticatedClientUser.set(LoginUser.get(alluxioConf).getName());
       }
     } catch (IOException e) {
       LOG.warn("Failed to set AuthenticatedClientUser in REST service handler: {}", e.getMessage());
diff --git a/core/server/common/src/main/java/alluxio/StorageTierAssoc.java b/core/server/common/src/main/java/alluxio/StorageTierAssoc.java
index 1a89a52f4a..c113df35d2 100644
--- a/core/server/common/src/main/java/alluxio/StorageTierAssoc.java
+++ b/core/server/common/src/main/java/alluxio/StorageTierAssoc.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import com.google.common.collect.ImmutableBiMap;
 
 import java.util.ArrayList;
@@ -20,7 +22,7 @@ import javax.annotation.concurrent.ThreadSafe;
 
 /**
  * Creates a two-way mapping between storage tier aliases and ordinal numbers from the given
- * {@link Configuration}.
+ * {@link ServerConfiguration}.
  */
 @ThreadSafe
 public abstract class StorageTierAssoc {
@@ -52,17 +54,17 @@ public abstract class StorageTierAssoc {
   }
 
   /**
-   * Constructs a new instance using the given {@link Configuration} object. The mapping cannot be
+   * Constructs a new instance using the given {@link ServerConfiguration} object. The mapping cannot be
    * modified after creation.
    *
    * @param levelsProperty the property in the conf that specifies how many levels there are
    * @param template the format for the conf that identifies the alias for each level
    */
   protected StorageTierAssoc(PropertyKey levelsProperty, PropertyKey.Template template) {
-    int levels = Configuration.getInt(levelsProperty);
+    int levels = ServerConfiguration.getInt(levelsProperty);
     ImmutableBiMap.Builder<String, Integer> builder = new ImmutableBiMap.Builder<>();
     for (int i = 0; i < levels; i++) {
-      String alias = Configuration.get(template.format(i));
+      String alias = ServerConfiguration.get(template.format(i));
       builder.put(alias, i);
     }
     mAliasToOrdinal = builder.build();
diff --git a/core/server/common/src/main/java/alluxio/WorkerStorageTierAssoc.java b/core/server/common/src/main/java/alluxio/WorkerStorageTierAssoc.java
index fd30ac1419..aff8057c1d 100644
--- a/core/server/common/src/main/java/alluxio/WorkerStorageTierAssoc.java
+++ b/core/server/common/src/main/java/alluxio/WorkerStorageTierAssoc.java
@@ -11,6 +11,9 @@
 
 package alluxio;
 
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
+
 import java.util.List;
 
 import javax.annotation.concurrent.ThreadSafe;
@@ -22,7 +25,7 @@ import javax.annotation.concurrent.ThreadSafe;
 public class WorkerStorageTierAssoc extends StorageTierAssoc {
 
   /**
-   * Creates a new instance of {@link WorkerStorageTierAssoc} using a {@link Configuration}.
+   * Creates a new instance of {@link WorkerStorageTierAssoc} using a {@link ServerConfiguration}.
    */
   public WorkerStorageTierAssoc() {
     super(PropertyKey.WORKER_TIERED_STORE_LEVELS,
diff --git a/core/server/common/src/main/java/alluxio/cli/Format.java b/core/server/common/src/main/java/alluxio/cli/Format.java
index 58080e63f1..31e85eb4b1 100644
--- a/core/server/common/src/main/java/alluxio/cli/Format.java
+++ b/core/server/common/src/main/java/alluxio/cli/Format.java
@@ -11,14 +11,17 @@
 
 package alluxio.cli;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.NoopMaster;
 import alluxio.master.ServiceUtils;
 import alluxio.master.journal.JournalSystem;
 import alluxio.master.journal.JournalUtils;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.FileUtils;
 
 import org.slf4j.Logger;
@@ -65,7 +68,7 @@ public final class Format {
     Files.createDirectory(path);
     // For short-circuit read/write to work, others needs to be able to access this directory.
     // Therefore, default is 777 but if the user specifies the permissions, respect those instead.
-    String permissions = Configuration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);
+    String permissions = ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);
     Set<PosixFilePermission> perms = PosixFilePermissions.fromString(permissions);
     Files.setPosixFilePermissions(path, perms);
     FileUtils.setLocalDirStickyBit(path.toAbsolutePath().toString());
@@ -81,6 +84,7 @@ public final class Format {
       LOG.info(USAGE);
       System.exit(-1);
     }
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
     // Set the process type as "MASTER" since format needs to access the journal like the master.
     CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.MASTER);
     Mode mode = null;
@@ -92,7 +96,7 @@ public final class Format {
       System.exit(-1);
     }
     try {
-      format(mode);
+      format(mode, conf);
     } catch (Exception e) {
       LOG.error("Failed to format", e);
       System.exit(-1);
@@ -106,7 +110,7 @@ public final class Format {
    *
    * @param mode either {@code MASTER} or {@code WORKER}
    */
-  public static void format(Mode mode) throws IOException {
+  public static void format(Mode mode, AlluxioConfiguration alluxioConf) throws IOException {
     switch (mode) {
       case MASTER:
         URI journalLocation = JournalUtils.getJournalLocation();
@@ -119,16 +123,16 @@ public final class Format {
         journalSystem.format();
         break;
       case WORKER:
-        String workerDataFolder = Configuration.get(PropertyKey.WORKER_DATA_FOLDER);
+        String workerDataFolder = ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER);
         LOG.info("Formatting worker data folder: {}", workerDataFolder);
-        int storageLevels = Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
+        int storageLevels = ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
         for (int level = 0; level < storageLevels; level++) {
           PropertyKey tierLevelDirPath =
               PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(level);
-          String[] dirPaths = Configuration.get(tierLevelDirPath).split(",");
+          String[] dirPaths = ServerConfiguration.get(tierLevelDirPath).split(",");
           String name = "Data path for tier " + level;
           for (String dirPath : dirPaths) {
-            String dirWorkerDataFolder = CommonUtils.getWorkerDataDirectory(dirPath);
+            String dirWorkerDataFolder = CommonUtils.getWorkerDataDirectory(dirPath, alluxioConf);
             LOG.info("Formatting {}:{}", name, dirWorkerDataFolder);
             formatWorkerDataFolder(dirWorkerDataFolder);
           }
diff --git a/core/server/common/src/main/java/alluxio/cli/ValidateEnv.java b/core/server/common/src/main/java/alluxio/cli/ValidateEnv.java
index 7dc652d8b5..bc0299fa31 100644
--- a/core/server/common/src/main/java/alluxio/cli/ValidateEnv.java
+++ b/core/server/common/src/main/java/alluxio/cli/ValidateEnv.java
@@ -11,9 +11,9 @@
 
 package alluxio.cli;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.validation.ClusterConfConsistencyValidationTask;
 import alluxio.cli.validation.HdfsValidationTask;
 import alluxio.cli.validation.PortAvailabilityValidationTask;
@@ -213,7 +213,7 @@ public final class ValidateEnv {
 
     // args is not null.
     String argStr = String.join(" ", cmd.getArgs());
-    String homeDir = Configuration.get(PropertyKey.HOME);
+    String homeDir = ServerConfiguration.get(PropertyKey.HOME);
     String remoteCommand = String.format(
         "%s/bin/alluxio validateEnv %s %s %s",
         homeDir, target, name == null ? "" : name, argStr);
diff --git a/core/server/common/src/main/java/alluxio/cli/extensions/ExtensionsShell.java b/core/server/common/src/main/java/alluxio/cli/extensions/ExtensionsShell.java
index a7d67841de..792b0f6c41 100644
--- a/core/server/common/src/main/java/alluxio/cli/extensions/ExtensionsShell.java
+++ b/core/server/common/src/main/java/alluxio/cli/extensions/ExtensionsShell.java
@@ -13,6 +13,9 @@ package alluxio.cli.extensions;
 
 import alluxio.cli.AbstractShell;
 import alluxio.cli.Command;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 
 import java.util.Map;
 
@@ -23,8 +26,8 @@ public final class ExtensionsShell extends AbstractShell {
   /**
    * Construct a new instance of {@link ExtensionsShell}.
    */
-  ExtensionsShell() {
-    super(null);
+  ExtensionsShell(InstancedConfiguration conf) {
+    super(null, conf);
   }
 
   /**
@@ -33,7 +36,8 @@ public final class ExtensionsShell extends AbstractShell {
    * @param args array of arguments given by the user's input from the terminal
    */
   public static void main(String[] args) {
-    ExtensionsShell extensionShell = new ExtensionsShell();
+    ExtensionsShell extensionShell = new ExtensionsShell(new InstancedConfiguration(
+        ConfigurationUtils.defaults()));
     System.exit(extensionShell.run(args));
   }
 
diff --git a/core/server/common/src/main/java/alluxio/cli/extensions/command/InstallCommand.java b/core/server/common/src/main/java/alluxio/cli/extensions/command/InstallCommand.java
index 687987e200..aa45a2b3d1 100644
--- a/core/server/common/src/main/java/alluxio/cli/extensions/command/InstallCommand.java
+++ b/core/server/common/src/main/java/alluxio/cli/extensions/command/InstallCommand.java
@@ -11,9 +11,9 @@
 
 package alluxio.cli.extensions.command;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
 import alluxio.cli.extensions.ExtensionsShellUtils;
@@ -62,7 +62,7 @@ public final class InstallCommand implements Command {
   @Override
   public int run(CommandLine cl) {
     String uri = cl.getArgs()[0];
-    String extensionsDir = Configuration.get(PropertyKey.EXTENSIONS_DIR);
+    String extensionsDir = ServerConfiguration.get(PropertyKey.EXTENSIONS_DIR);
     File dir = new File(extensionsDir);
     if (!dir.exists() && !dir.mkdirs()) {
       System.err.println("Failed to create extensions directory " + extensionsDir);
diff --git a/core/server/common/src/main/java/alluxio/cli/extensions/command/LsCommand.java b/core/server/common/src/main/java/alluxio/cli/extensions/command/LsCommand.java
index d10ed445bf..7edfcb7865 100644
--- a/core/server/common/src/main/java/alluxio/cli/extensions/command/LsCommand.java
+++ b/core/server/common/src/main/java/alluxio/cli/extensions/command/LsCommand.java
@@ -13,6 +13,7 @@ package alluxio.cli.extensions.command;
 
 import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.util.ExtensionUtils;
 
@@ -31,10 +32,14 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class LsCommand implements Command {
   private static final Logger LOG = LoggerFactory.getLogger(LsCommand.class);
 
+  private final String mExtensionsDir;
+
   /**
    * Constructs a new instance of {@link LsCommand}.
    */
-  public LsCommand() {}
+  public LsCommand(String extensionsDir) {
+    mExtensionsDir = extensionsDir;
+  }
 
   @Override
   public String getCommandName() {
@@ -58,7 +63,7 @@ public final class LsCommand implements Command {
 
   @Override
   public int run(CommandLine cl) {
-    for (File extension : ExtensionUtils.listExtensions()) {
+    for (File extension : ExtensionUtils.listExtensions(mExtensionsDir)) {
       System.out.println(extension.getName());
     }
     return 0;
diff --git a/core/server/common/src/main/java/alluxio/cli/extensions/command/UninstallCommand.java b/core/server/common/src/main/java/alluxio/cli/extensions/command/UninstallCommand.java
index 2efe1d340f..1f7f81bfe0 100644
--- a/core/server/common/src/main/java/alluxio/cli/extensions/command/UninstallCommand.java
+++ b/core/server/common/src/main/java/alluxio/cli/extensions/command/UninstallCommand.java
@@ -11,9 +11,9 @@
 
 package alluxio.cli.extensions.command;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
 import alluxio.cli.extensions.ExtensionsShellUtils;
@@ -62,7 +62,7 @@ public final class UninstallCommand implements Command {
   @Override
   public int run(CommandLine cl) {
     String uri = cl.getArgs()[0];
-    String extensionsDir = Configuration.get(PropertyKey.EXTENSIONS_DIR);
+    String extensionsDir = ServerConfiguration.get(PropertyKey.EXTENSIONS_DIR);
     List<String> failedHosts = new ArrayList<>();
     for (String host : ExtensionsShellUtils.getServerHostnames()) {
       try {
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java
index d37aaae6ce..70119255f5 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.validation;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.Scope;
 import alluxio.grpc.GrpcUtils;
 
@@ -125,7 +125,7 @@ public final class ClusterConfConsistencyValidationTask extends AbstractValidati
 
   private Properties getNodeConf(String node) {
     try {
-      String homeDir = Configuration.get(PropertyKey.HOME);
+      String homeDir = ServerConfiguration.get(PropertyKey.HOME);
       String remoteCommand = String.format(
           "%s/bin/alluxio getConf", homeDir);
       String localCommand = String.format(
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/HdfsValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/HdfsValidationTask.java
index e461e68cff..cc108f56dd 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/HdfsValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/HdfsValidationTask.java
@@ -12,8 +12,8 @@
 package alluxio.cli.validation;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.InvalidPathException;
 import alluxio.util.io.PathUtils;
 
@@ -59,7 +59,7 @@ public class HdfsValidationTask extends AbstractValidationTask {
 
   protected boolean shouldSkip() {
     String scheme =
-        new AlluxioURI(Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS)).getScheme();
+        new AlluxioURI(ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS)).getScheme();
     if (scheme == null || !scheme.startsWith("hdfs")) {
       System.out.format("Root underFS is not HDFS. Skipping validation for HDFS properties.%n");
       return true;
@@ -82,10 +82,10 @@ public class HdfsValidationTask extends AbstractValidationTask {
     String serverCoreSiteFilePath = PathUtils.concatPath(serverHadoopConfDirPath, "/core-site.xml");
     String serverHdfsSiteFilePath = PathUtils.concatPath(serverHadoopConfDirPath, "/hdfs-site.xml");
 
-    // If Configuration does not contain the key, then a {@link RuntimeException} will be thrown
+    // If ServerConfiguration does not contain the key, then a {@link RuntimeException} will be thrown
     // before calling the {@link String#split} method.
     String[] clientHadoopConfFilePaths =
-        Configuration.get(PropertyKey.UNDERFS_HDFS_CONFIGURATION).split(":");
+        ServerConfiguration.get(PropertyKey.UNDERFS_HDFS_CONFIGURATION).split(":");
     String clientCoreSiteFilePath = null;
     String clientHdfsSiteFilePath = null;
     for (String path : clientHadoopConfFilePaths) {
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/PortAvailabilityValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/PortAvailabilityValidationTask.java
index 6f9d8d5cf6..c3bd09f12e 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/PortAvailabilityValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/PortAvailabilityValidationTask.java
@@ -11,6 +11,8 @@
 
 package alluxio.cli.validation;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
 
@@ -42,7 +44,7 @@ public final class PortAvailabilityValidationTask extends AbstractValidationTask
       System.out.format("%s is already running. Skip validation.%n", mOwner);
       return TaskResult.SKIPPED;
     }
-    int port = NetworkAddressUtils.getPort(mServiceType);
+    int port = NetworkAddressUtils.getPort(mServiceType, ServerConfiguration.global());
     if (!isLocalPortAvailable(port)) {
       System.err.format("%s port %d is not available.%n", mServiceType.getServiceName(), port);
       return TaskResult.FAILED;
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/RamDiskMountPrivilegeValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/RamDiskMountPrivilegeValidationTask.java
index fe638e6286..b92f925026 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/RamDiskMountPrivilegeValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/RamDiskMountPrivilegeValidationTask.java
@@ -12,8 +12,8 @@
 package alluxio.cli.validation;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.OSUtils;
 
 import java.io.File;
@@ -35,8 +35,8 @@ public final class RamDiskMountPrivilegeValidationTask extends AbstractValidatio
   @Override
   public TaskResult validate(Map<String, String> optionsMap)
       throws InterruptedException {
-    String path = Configuration.get(PropertyKey.WORKER_TIERED_STORE_LEVEL0_DIRS_PATH);
-    String alias = Configuration.get(PropertyKey.WORKER_TIERED_STORE_LEVEL0_ALIAS);
+    String path = ServerConfiguration.get(PropertyKey.WORKER_TIERED_STORE_LEVEL0_DIRS_PATH);
+    String alias = ServerConfiguration.get(PropertyKey.WORKER_TIERED_STORE_LEVEL0_ALIAS);
     if (!alias.equals("MEM")) {
       System.out.println("Top tier storage is not memory, skip validation.");
       return TaskResult.SKIPPED;
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/SecureHdfsValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/SecureHdfsValidationTask.java
index 7d2fda842b..651a6f8238 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/SecureHdfsValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/SecureHdfsValidationTask.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.validation;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.collect.ImmutableMap;
 
@@ -80,8 +80,8 @@ public final class SecureHdfsValidationTask extends HdfsValidationTask {
       return true;
     }
     String principal = null;
-    if (Configuration.isSet(mPrincipalProperty)) {
-      principal = Configuration.get(mPrincipalProperty);
+    if (ServerConfiguration.isSet(mPrincipalProperty)) {
+      principal = ServerConfiguration.get(mPrincipalProperty);
     }
     if (principal == null || principal.isEmpty()) {
       System.out.format("Skip validation for secure HDFS. %s is not specified.%n",
@@ -93,7 +93,7 @@ public final class SecureHdfsValidationTask extends HdfsValidationTask {
 
   private boolean validatePrincipalLogin() {
     // Check whether can login with specified principal and keytab
-    String principal = Configuration.get(mPrincipalProperty);
+    String principal = ServerConfiguration.get(mPrincipalProperty);
     Matcher matchPrincipal = PRINCIPAL_PATTERN.matcher(principal);
     if (!matchPrincipal.matches()) {
       System.err.format("Principal %s is not in the right format.%n", principal);
@@ -104,7 +104,7 @@ public final class SecureHdfsValidationTask extends HdfsValidationTask {
     String realm = matchPrincipal.group("realm");
 
     // Login with principal and keytab
-    String keytab = Configuration.get(mKeytabProperty);
+    String keytab = ServerConfiguration.get(mKeytabProperty);
     int exitVal =
         Utils.getResultFromProcess(new String[] {"kinit", "-kt", keytab, principal}).getExitValue();
     if (exitVal != 0) {
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/StorageSpaceValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/StorageSpaceValidationTask.java
index 9504c4ecd7..8c6248bd02 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/StorageSpaceValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/StorageSpaceValidationTask.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.validation;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.FormatUtils;
 
 import org.apache.commons.io.FileUtils;
@@ -39,21 +39,21 @@ public final class StorageSpaceValidationTask extends AbstractValidationTask {
 
   @Override
   public TaskResult validate(Map<String, String> optionsMap) {
-    int numLevel = Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
+    int numLevel = ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
     boolean success = true;
 
     for (int level = 0; level < numLevel; level++) {
       PropertyKey tierAliasConf =
           PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_ALIAS.format(level);
-      String alias = Configuration.get(tierAliasConf);
+      String alias = ServerConfiguration.get(tierAliasConf);
 
       PropertyKey tierDirPathConf =
           PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(level);
-      String[] dirPaths = Configuration.get(tierDirPathConf).split(",");
+      String[] dirPaths = ServerConfiguration.get(tierDirPathConf).split(",");
 
       PropertyKey tierDirCapacityConf =
           PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_QUOTA.format(level);
-      String rawDirQuota = Configuration.get(tierDirCapacityConf);
+      String rawDirQuota = ServerConfiguration.get(tierDirCapacityConf);
       if (rawDirQuota.isEmpty()) {
         System.err.format("Tier %d: Quota cannot be empty.%n", level);
         return TaskResult.FAILED;
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java
index 28b78ac9d8..3ff431b6ac 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.validation;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UfsStatus;
 import alluxio.underfs.UnderFileSystem;
 
@@ -31,8 +31,8 @@ public final class UfsDirectoryValidationTask extends AbstractValidationTask {
    * for validating root under file system.
    */
   public UfsDirectoryValidationTask() {
-    mUfs = UnderFileSystem.Factory.createForRoot();
-    mPath = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    mUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
+    mPath = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
   }
 
   @Override
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/UfsSuperUserValidationTask.java b/core/server/common/src/main/java/alluxio/cli/validation/UfsSuperUserValidationTask.java
index 5d82945891..caa24c5f72 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/UfsSuperUserValidationTask.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/UfsSuperUserValidationTask.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.validation;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UfsStatus;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.util.UnderFileSystemUtils;
@@ -34,8 +34,8 @@ public final class UfsSuperUserValidationTask extends AbstractValidationTask {
    * for validating root under file system.
    */
   public UfsSuperUserValidationTask() {
-    mUfs = UnderFileSystem.Factory.createForRoot();
-    mPath = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    mUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
+    mPath = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
   }
 
   @Override
diff --git a/core/server/common/src/main/java/alluxio/cli/validation/Utils.java b/core/server/common/src/main/java/alluxio/cli/validation/Utils.java
index 7615222949..8f6a890827 100644
--- a/core/server/common/src/main/java/alluxio/cli/validation/Utils.java
+++ b/core/server/common/src/main/java/alluxio/cli/validation/Utils.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.validation;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.ShellUtils;
 import alluxio.util.UnixMountInfo;
 
@@ -79,7 +79,7 @@ public final class Utils {
    * @return list of the node names, null when file fails to read
    */
   public static List<String> readNodeList(String fileName) {
-    String confDir = Configuration.get(PropertyKey.CONF_DIR);
+    String confDir = ServerConfiguration.get(PropertyKey.CONF_DIR);
     List<String> lines;
     try {
       lines = Files.readAllLines(Paths.get(confDir, fileName), StandardCharsets.UTF_8);
diff --git a/core/common/src/main/java/alluxio/Configuration.java b/core/server/common/src/main/java/alluxio/conf/ServerConfiguration.java
similarity index 59%
rename from core/common/src/main/java/alluxio/Configuration.java
rename to core/server/common/src/main/java/alluxio/conf/ServerConfiguration.java
index 1b08bea0dd..1d71efe9d8 100644
--- a/core/common/src/main/java/alluxio/Configuration.java
+++ b/core/server/common/src/main/java/alluxio/conf/ServerConfiguration.java
@@ -9,13 +9,8 @@
  * See the NOTICE file distributed with this work for information regarding copyright ownership.
  */
 
-package alluxio;
+package alluxio.conf;
 
-import alluxio.conf.AlluxioProperties;
-import alluxio.conf.InstancedConfiguration;
-import alluxio.conf.Source;
-import alluxio.exception.status.AlluxioStatusException;
-import alluxio.exception.status.UnauthenticatedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.ConfigProperty;
 import alluxio.grpc.GetConfigurationPOptions;
@@ -23,23 +18,18 @@ import alluxio.grpc.GrpcExceptionUtils;
 import alluxio.grpc.MetaMasterConfigurationServiceGrpc;
 import alluxio.grpc.Scope;
 import alluxio.util.ConfigurationUtils;
-import alluxio.grpc.GrpcChannel;
-import alluxio.grpc.GrpcChannelBuilder;
-import alluxio.grpc.GrpcUtils;
-
 import com.google.common.base.Preconditions;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import java.net.InetSocketAddress;
-import java.net.URL;
 import java.time.Duration;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicBoolean;
 
+import javax.annotation.Nonnull;
 import javax.annotation.concurrent.NotThreadSafe;
 
 /**
@@ -64,63 +54,34 @@ import javax.annotation.concurrent.NotThreadSafe;
  * <p>
  * This class defines many convenient static methods which delegate to an internal
  * {@link InstancedConfiguration}. To use this global configuration in a method that takes
- * {@link AlluxioConfiguration} as an argument, pass {@link Configuration#global()}.
+ * {@link AlluxioConfiguration} as an argument, pass {@link ServerConfiguration#global()}.
  */
 @NotThreadSafe
-public final class Configuration {
-  private static final Logger LOG = LoggerFactory.getLogger(Configuration.class);
+public final class ServerConfiguration {
+  private static final Logger LOG = LoggerFactory.getLogger(ServerConfiguration.class);
 
-  private static final AlluxioProperties PROPERTIES = new AlluxioProperties();
-  private static final InstancedConfiguration CONF = new InstancedConfiguration(PROPERTIES);
+  private static InstancedConfiguration CONF;
 
   static {
     reset();
   }
 
+
   /**
-   * Create and return a copy of all properties.
-   *
-   * @return a copy of properties
+   * Resets the {@link AlluxioConfiguration} back the defaults and values from
+   * alluxio-site properties.
    */
-  public static AlluxioProperties copyProperties() {
-    return new AlluxioProperties(PROPERTIES);
+  public static void reset(){
+    CONF = new InstancedConfiguration(ConfigurationUtils.defaults());
   }
 
   /**
-   * Resets {@link Configuration} back to the default one.
+   * Create and return a copy of all properties.
+   *
+   * @return a copy of properties
    */
-  public static void reset() {
-    // Step1: bootstrap the configuration. This is necessary because we need to resolve alluxio.home
-    // (likely to be in system properties) to locate the conf dir to search for the site property
-    // file.
-    PROPERTIES.clear();
-    PROPERTIES.merge(System.getProperties(), Source.SYSTEM_PROPERTY);
-    if (Configuration.getBoolean(PropertyKey.TEST_MODE)) {
-      validate();
-      return;
-    }
-
-    // Step2: Load site specific properties file if not in test mode. Note that we decide whether in
-    // test mode by default properties and system properties (via getBoolean).
-    Properties siteProps = null;
-    // we are not in test mode, load site properties
-    String confPaths = Configuration.get(PropertyKey.SITE_CONF_DIR);
-    String[] confPathList = confPaths.split(",");
-    String sitePropertyFile =
-        ConfigurationUtils.searchPropertiesFile(Constants.SITE_PROPERTIES, confPathList);
-    if (sitePropertyFile != null) {
-      siteProps = ConfigurationUtils.loadPropertiesFromFile(sitePropertyFile);
-    } else {
-      URL resource = Configuration.class.getClassLoader().getResource(Constants.SITE_PROPERTIES);
-      if (resource != null) {
-        siteProps = ConfigurationUtils.loadPropertiesFromResource(resource);
-        if (siteProps != null) {
-          sitePropertyFile = resource.getPath();
-        }
-      }
-    }
-    PROPERTIES.merge(siteProps, Source.siteProperty(sitePropertyFile));
-    validate();
+  public static AlluxioProperties copyProperties() {
+    return new AlluxioProperties(CONF.getProperties());
   }
 
   /**
@@ -132,7 +93,7 @@ public final class Configuration {
    * @param source the source of the the properties (e.g., system property, default and etc)
    */
   public static void merge(Map<?, ?> properties, Source source) {
-    PROPERTIES.merge(properties, source);
+    CONF.merge(properties, source);
   }
 
   // Public accessor methods
@@ -154,12 +115,7 @@ public final class Configuration {
    * @param source the source of the the properties (e.g., system property, default and etc)
    */
   public static void set(PropertyKey key, Object value, Source source) {
-    Preconditions.checkArgument(key != null && value != null && !value.equals(""),
-        String.format("The key value pair (%s, %s) cannot be null", key, value));
-    Preconditions.checkArgument(!value.equals(""),
-        String.format("The key \"%s\" cannot be have an empty string as a value. Use "
-            + "Configuration.unset to remove a key from the configuration.", key));
-    PROPERTIES.put(key, String.valueOf(value), source);
+    CONF.set(key, value, source);
   }
 
   /**
@@ -167,9 +123,9 @@ public final class Configuration {
    *
    * @param key the key to unset
    */
-  public static void unset(PropertyKey key) {
+  public static void unset(@Nonnull PropertyKey key) {
     Preconditions.checkNotNull(key, "key");
-    PROPERTIES.remove(key);
+    CONF.unset(key);
   }
 
   /**
@@ -215,18 +171,6 @@ public final class Configuration {
     return CONF.getOrDefault(key, defaultValue, options);
   }
 
-  /**
-   * Checks if the configuration contains a value for the given key.
-   *
-   * @param key the key to check
-   * @return true if there is value for the key, false otherwise
-   * @deprecated due to misleading method name, use {{@link #isSet(PropertyKey)}} instead
-   */
-  @Deprecated
-  public static boolean containsKey(PropertyKey key) {
-    return isSet(key);
-  }
-
   /**
    * Checks if the configuration contains a value for the given key.
    *
@@ -395,15 +339,6 @@ public final class Configuration {
     return CONF.toMap(opts);
   }
 
-  /**
-   * Validates the configuration.
-   *
-   * @throws IllegalStateException if invalid configuration is encountered
-   */
-  public static void validate() {
-    CONF.validate();
-  }
-
   /**
    * @return the {@link InstancedConfiguration} object backing the global configuration
    */
@@ -411,82 +346,16 @@ public final class Configuration {
     return CONF;
   }
 
-  /** Whether the cluster-default is loaded. */
-  private static final AtomicBoolean CLUSTER_DEFAULT_LOADED = new AtomicBoolean(false);
-
   /**
    * Loads cluster default values from the meta master.
    *
    * @param address the master address
    */
-  public static void loadClusterDefault(InetSocketAddress address) throws AlluxioStatusException {
-    if (!Configuration.getBoolean(PropertyKey.USER_CONF_CLUSTER_DEFAULT_ENABLED)
-        || CLUSTER_DEFAULT_LOADED.get()) {
-      return;
-    }
-    synchronized (Configuration.class) {
-      if (CLUSTER_DEFAULT_LOADED.get()) {
-        return;
-      }
-      LOG.info("Alluxio client (version {}) is trying to bootstrap-connect with {}",
-          RuntimeConstants.VERSION, address);
-
-      GrpcChannel channel = null;
-      List<alluxio.grpc.ConfigProperty> clusterConfig = null;
-
-      try {
-        channel = GrpcChannelBuilder.forAddress(address).disableAuthentication().build();
-        MetaMasterConfigurationServiceGrpc.MetaMasterConfigurationServiceBlockingStub client =
-            MetaMasterConfigurationServiceGrpc.newBlockingStub(channel);
-        clusterConfig =
-            client.getConfiguration(GetConfigurationPOptions.newBuilder().setRawValue(true).build())
-                .getConfigsList();
-      } catch (io.grpc.StatusRuntimeException e) {
-        AlluxioStatusException ase = GrpcExceptionUtils.fromGrpcStatusException(e);
-        LOG.warn("Failed to handshake with master {} : {}", address, ase.getMessage());
-        throw new UnavailableException(String.format(
-            "Failed to handshake with master %s to load cluster default configuration values",
-            address), e);
-      } catch (UnauthenticatedException e) {
-        throw new RuntimeException(String.format(
-            "Received authentication exception with authentication disabled. Host:%s", address), e);
-      } finally {
-        if (channel != null) {
-          channel.shutdown();
-        }
-      }
-
-      // merge conf returned by master as the cluster default into Configuration
-      Properties clusterProps = new Properties();
-      for (ConfigProperty property : clusterConfig) {
-        String name = property.getName();
-        // TODO(binfan): support propagating unsetting properties from master
-        if (PropertyKey.isValid(name) && property.hasValue()) {
-          PropertyKey key = PropertyKey.fromString(name);
-          if (!GrpcUtils.contains(key.getScope(), Scope.CLIENT)) {
-            // Only propagate client properties.
-            continue;
-          }
-          String value = property.getValue();
-          clusterProps.put(key, value);
-          LOG.debug("Loading cluster default: {} ({}) -> {}", key, key.getScope(), value);
-        }
-      }
-
-      String clientVersion = Configuration.get(PropertyKey.VERSION);
-      String clusterVersion = clusterProps.get(PropertyKey.VERSION).toString();
-      if (!clientVersion.equals(clusterVersion)) {
-        LOG.warn("Alluxio client version ({}) does not match Alluxio cluster version ({})",
-            clientVersion, clusterVersion);
-        clusterProps.remove(PropertyKey.VERSION);
-      }
-      Configuration.merge(clusterProps, Source.CLUSTER_DEFAULT);
-      Configuration.validate();
-      // This needs to be the last
-      CLUSTER_DEFAULT_LOADED.set(true);
-      LOG.info("Alluxio client has bootstrap-connected with {}", address);
-    }
+  public static void loadClusterDefaults(InetSocketAddress address) throws
+      UnavailableException {
+    AlluxioConfiguration conf = ConfigurationUtils.loadClusterDefaults(address, global());
+    CONF = new InstancedConfiguration(conf.getProperties());
   }
 
-  private Configuration() {} // prevent instantiation
+  private ServerConfiguration() {} // prevent instantiation
 }
diff --git a/core/server/common/src/main/java/alluxio/master/PrimarySelector.java b/core/server/common/src/main/java/alluxio/master/PrimarySelector.java
index a4af8933c8..b35e95d360 100644
--- a/core/server/common/src/main/java/alluxio/master/PrimarySelector.java
+++ b/core/server/common/src/main/java/alluxio/master/PrimarySelector.java
@@ -11,8 +11,8 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.interfaces.Scoped;
 
 import java.io.IOException;
@@ -42,9 +42,9 @@ public interface PrimarySelector {
      * @return a primary selector based on zookeeper configuration
      */
     public static PrimarySelector createZkPrimarySelector() {
-      String zkAddress = Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS);
-      String zkElectionPath = Configuration.get(PropertyKey.ZOOKEEPER_ELECTION_PATH);
-      String zkLeaderPath = Configuration.get(PropertyKey.ZOOKEEPER_LEADER_PATH);
+      String zkAddress = ServerConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS);
+      String zkElectionPath = ServerConfiguration.get(PropertyKey.ZOOKEEPER_ELECTION_PATH);
+      String zkLeaderPath = ServerConfiguration.get(PropertyKey.ZOOKEEPER_LEADER_PATH);
       return new PrimarySelectorClient(zkAddress, zkElectionPath, zkLeaderPath);
     }
 
@@ -52,9 +52,9 @@ public interface PrimarySelector {
      * @return a job master primary selector based on zookeeper configuration
      */
     public static PrimarySelector createZkJobPrimarySelector() {
-      String zkAddress = Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS);
-      String zkElectionPath = Configuration.get(PropertyKey.ZOOKEEPER_JOB_ELECTION_PATH);
-      String zkLeaderPath = Configuration.get(PropertyKey.ZOOKEEPER_JOB_LEADER_PATH);
+      String zkAddress = ServerConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS);
+      String zkElectionPath = ServerConfiguration.get(PropertyKey.ZOOKEEPER_JOB_ELECTION_PATH);
+      String zkLeaderPath = ServerConfiguration.get(PropertyKey.ZOOKEEPER_JOB_LEADER_PATH);
       return new PrimarySelectorClient(zkAddress, zkElectionPath, zkLeaderPath);
     }
 
diff --git a/core/server/common/src/main/java/alluxio/master/PrimarySelectorClient.java b/core/server/common/src/main/java/alluxio/master/PrimarySelectorClient.java
index 55ebbbdbc0..ebf3b3e00d 100644
--- a/core/server/common/src/main/java/alluxio/master/PrimarySelectorClient.java
+++ b/core/server/common/src/main/java/alluxio/master/PrimarySelectorClient.java
@@ -12,9 +12,9 @@
 package alluxio.master;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.apache.curator.framework.CuratorFramework;
 import org.apache.curator.framework.CuratorFrameworkFactory;
@@ -175,8 +175,8 @@ public final class PrimarySelectorClient extends AbstractPrimarySelector
    */
   private CuratorFramework getNewCuratorClient() {
     CuratorFramework client = CuratorFrameworkFactory.newClient(mZookeeperAddress,
-        (int) Configuration.getMs(PropertyKey.ZOOKEEPER_SESSION_TIMEOUT),
-        (int) Configuration.getMs(PropertyKey.ZOOKEEPER_CONNECTION_TIMEOUT),
+        (int) ServerConfiguration.getMs(PropertyKey.ZOOKEEPER_SESSION_TIMEOUT),
+        (int) ServerConfiguration.getMs(PropertyKey.ZOOKEEPER_CONNECTION_TIMEOUT),
         new ExponentialBackoffRetry(Constants.SECOND_MS, 3));
     client.start();
 
@@ -185,8 +185,8 @@ public final class PrimarySelectorClient extends AbstractPrimarySelector
     // state, explicitly close the "old" client and recreate a new one.
     client.close();
     client = CuratorFrameworkFactory.newClient(mZookeeperAddress,
-        (int) Configuration.getMs(PropertyKey.ZOOKEEPER_SESSION_TIMEOUT),
-        (int) Configuration.getMs(PropertyKey.ZOOKEEPER_CONNECTION_TIMEOUT),
+        (int) ServerConfiguration.getMs(PropertyKey.ZOOKEEPER_SESSION_TIMEOUT),
+        (int) ServerConfiguration.getMs(PropertyKey.ZOOKEEPER_CONNECTION_TIMEOUT),
         new ExponentialBackoffRetry(Constants.SECOND_MS, 3));
     client.start();
     return client;
diff --git a/core/server/common/src/main/java/alluxio/master/audit/AsyncUserAccessAuditLogWriter.java b/core/server/common/src/main/java/alluxio/master/audit/AsyncUserAccessAuditLogWriter.java
index b4d06b6118..a99c6332b3 100644
--- a/core/server/common/src/main/java/alluxio/master/audit/AsyncUserAccessAuditLogWriter.java
+++ b/core/server/common/src/main/java/alluxio/master/audit/AsyncUserAccessAuditLogWriter.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.audit;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -49,7 +49,7 @@ public final class AsyncUserAccessAuditLogWriter {
    * Constructs an {@link AsyncUserAccessAuditLogWriter} instance.
    */
   public AsyncUserAccessAuditLogWriter() {
-    int queueCapacity = Configuration.getInt(PropertyKey.MASTER_AUDIT_LOGGING_QUEUE_CAPACITY);
+    int queueCapacity = ServerConfiguration.getInt(PropertyKey.MASTER_AUDIT_LOGGING_QUEUE_CAPACITY);
     mAuditLogEntries = new LinkedBlockingQueue<>(queueCapacity);
     LOG.info("Audit logging queue capacity is {}.", queueCapacity);
     mStopped = true;
diff --git a/core/server/common/src/main/java/alluxio/master/journal/AsyncJournalWriter.java b/core/server/common/src/main/java/alluxio/master/journal/AsyncJournalWriter.java
index 987fa304a0..330782bbf8 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/AsyncJournalWriter.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/AsyncJournalWriter.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.journal;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.JournalClosedException;
 import alluxio.proto.journal.Journal.JournalEntry;
 import alluxio.resource.LockResource;
@@ -64,7 +64,7 @@ public final class AsyncJournalWriter {
     mWriteCounter = new AtomicLong(0);
     // convert milliseconds to nanoseconds.
     mFlushBatchTimeNs =
-        1000000L * Configuration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS);
+        1000000L * ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS);
   }
 
   /**
diff --git a/core/server/common/src/main/java/alluxio/master/journal/JournalSystem.java b/core/server/common/src/main/java/alluxio/master/journal/JournalSystem.java
index e3584622d1..e821948934 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/JournalSystem.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/JournalSystem.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.journal;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.journal.noop.NoopJournalSystem;
 import alluxio.master.journal.raft.RaftJournalConfiguration;
 import alluxio.master.journal.raft.RaftJournalSystem;
@@ -159,7 +159,7 @@ public interface JournalSystem {
   class Builder {
     private URI mLocation;
     private long mQuietTimeMs =
-        Configuration.getMs(PropertyKey.MASTER_JOURNAL_TAILER_SHUTDOWN_QUIET_WAIT_TIME_MS);
+        ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_TAILER_SHUTDOWN_QUIET_WAIT_TIME_MS);
 
     /**
      * Creates a new journal system builder.
@@ -190,7 +190,7 @@ public interface JournalSystem {
      */
     public JournalSystem build() {
       JournalType journalType =
-          Configuration.getEnum(PropertyKey.MASTER_JOURNAL_TYPE, JournalType.class);
+          ServerConfiguration.getEnum(PropertyKey.MASTER_JOURNAL_TYPE, JournalType.class);
       switch (journalType) {
         case NOOP:
           return new NoopJournalSystem();
diff --git a/core/server/common/src/main/java/alluxio/master/journal/JournalTool.java b/core/server/common/src/main/java/alluxio/master/journal/JournalTool.java
index 53ba4e7135..f3934e4527 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/JournalTool.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/JournalTool.java
@@ -12,8 +12,8 @@
 package alluxio.master.journal;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.NoopMaster;
 import alluxio.master.journal.ufs.UfsJournal;
@@ -148,7 +148,7 @@ public final class JournalTool {
    * @return the journal location
    */
   private static URI getJournalLocation() {
-    String journalDirectory = Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
+    String journalDirectory = ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
     if (!journalDirectory.endsWith(AlluxioURI.SEPARATOR)) {
       journalDirectory += AlluxioURI.SEPARATOR;
     }
diff --git a/core/server/common/src/main/java/alluxio/master/journal/JournalUpgrader.java b/core/server/common/src/main/java/alluxio/master/journal/JournalUpgrader.java
index 7fc821ba36..3e05ac7535 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/JournalUpgrader.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/JournalUpgrader.java
@@ -12,8 +12,10 @@
 package alluxio.master.journal;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.MasterFactory;
 import alluxio.master.NoopMaster;
@@ -21,6 +23,7 @@ import alluxio.master.ServiceUtils;
 import alluxio.master.journal.ufs.UfsJournal;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.options.MkdirsOptions;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.URIUtils;
 
 import org.apache.commons.cli.CommandLine;
@@ -83,15 +86,19 @@ public final class JournalUpgrader {
     private final URI mCheckpointsV1;
     private final URI mLogsV1;
 
-    private Upgrader(String master) {
+    private final AlluxioConfiguration mAlluxioConf;
+
+
+    private Upgrader(String master, AlluxioConfiguration alluxioConf) {
       mMaster = master;
+      mAlluxioConf = alluxioConf;
       mJournalV0 = (new alluxio.master.journalv0.MutableJournal.Factory(
           getJournalLocation(sJournalDirectoryV0))).create(master);
       mJournalV1 =
-          new UfsJournal(getJournalLocation(Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER)),
+          new UfsJournal(getJournalLocation(ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER)),
               new NoopMaster(master), 0);
 
-      mUfs = UnderFileSystem.Factory.create(sJournalDirectoryV0);
+      mUfs = UnderFileSystem.Factory.create(sJournalDirectoryV0, alluxioConf);
 
       mCheckpointV0 = URIUtils.appendPathOrDie(mJournalV0.getLocation(), "checkpoint.data");
       mCompletedLogsV0 = URIUtils.appendPathOrDie(mJournalV0.getLocation(), "completed");
@@ -164,10 +171,10 @@ public final class JournalUpgrader {
       }
 
       if (!mUfs.exists(mCheckpointsV1.toString())) {
-        mUfs.mkdirs(mCheckpointsV1.toString(), MkdirsOptions.defaults().setCreateParent(true));
+        mUfs.mkdirs(mCheckpointsV1.toString(), MkdirsOptions.defaults(mAlluxioConf).setCreateParent(true));
       }
       if (!mUfs.exists(mLogsV1.toString())) {
-        mUfs.mkdirs(mLogsV1.toString(), MkdirsOptions.defaults().setCreateParent(true));
+        mUfs.mkdirs(mLogsV1.toString(), MkdirsOptions.defaults(mAlluxioConf).setCreateParent(true));
       }
     }
 
@@ -235,7 +242,8 @@ public final class JournalUpgrader {
     }
 
     for (String master : masters) {
-      Upgrader upgrader = new Upgrader(master);
+      Upgrader upgrader = new Upgrader(master,
+          new InstancedConfiguration(ConfigurationUtils.defaults()));
       try {
         upgrader.upgrade();
       } catch (IOException e) {
@@ -263,7 +271,7 @@ public final class JournalUpgrader {
     }
     sHelp = cmd.hasOption("help");
     sJournalDirectoryV0 = cmd.getOptionValue("journalDirectoryV0",
-        Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER));
+        ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER));
     return true;
   }
 
diff --git a/core/server/common/src/main/java/alluxio/master/journal/JournalUtils.java b/core/server/common/src/main/java/alluxio/master/journal/JournalUtils.java
index d69cf344f0..c6bea9b309 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/JournalUtils.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/JournalUtils.java
@@ -12,8 +12,8 @@
 package alluxio.master.journal;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import java.net.URI;
 import java.net.URISyntaxException;
@@ -29,7 +29,7 @@ public final class JournalUtils {
    * @return the journal location
    */
   public static URI getJournalLocation() {
-    String journalDirectory = Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
+    String journalDirectory = ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
     if (!journalDirectory.endsWith(AlluxioURI.SEPARATOR)) {
       journalDirectory += AlluxioURI.SEPARATOR;
     }
diff --git a/core/server/common/src/main/java/alluxio/master/journal/MasterJournalContext.java b/core/server/common/src/main/java/alluxio/master/journal/MasterJournalContext.java
index 9933260777..3656548a41 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/MasterJournalContext.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/MasterJournalContext.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.journal;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.JournalClosedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.proto.journal.Journal.JournalEntry;
@@ -36,9 +36,9 @@ public final class MasterJournalContext implements JournalContext {
   private static final Logger LOG = LoggerFactory.getLogger(MasterJournalContext.class);
   private static final long INVALID_FLUSH_COUNTER = -1;
   private static final long FLUSH_RETRY_TIMEOUT_MS =
-      Configuration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_TIMEOUT_MS);
+      ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_TIMEOUT_MS);
   private static final int FLUSH_RETRY_INTERVAL_MS =
-      (int) Configuration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_RETRY_INTERVAL);
+      (int) ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_RETRY_INTERVAL);
 
   private final AsyncJournalWriter mAsyncJournalWriter;
   private long mFlushCounter;
diff --git a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournal.java b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournal.java
index 7a79db0dac..89b32c8ed1 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournal.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournal.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.journal.ufs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.InvalidJournalEntryException;
 import alluxio.exception.JournalClosedException;
 import alluxio.exception.status.UnavailableException;
@@ -111,8 +111,9 @@ public class UfsJournal implements Journal {
    */
   protected static UnderFileSystemConfiguration getJournalUfsConf() {
     Map<String, String> ufsConf =
-        Configuration.getNestedProperties(PropertyKey.MASTER_JOURNAL_UFS_OPTION);
-    return UnderFileSystemConfiguration.defaults().setMountSpecificConf(ufsConf);
+        ServerConfiguration.getNestedProperties(PropertyKey.MASTER_JOURNAL_UFS_OPTION);
+    return UnderFileSystemConfiguration.defaults(ServerConfiguration.global())
+               .createMountSpecificConf(ufsConf);
   }
 
   /**
@@ -276,7 +277,7 @@ public class UfsJournal implements Journal {
       return false;
     }
     // Search for the format file.
-    String formatFilePrefix = Configuration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX);
+    String formatFilePrefix = ServerConfiguration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX);
     for (UfsStatus file : files) {
       if (file.getName().startsWith(formatFilePrefix)) {
         return true;
@@ -306,7 +307,7 @@ public class UfsJournal implements Journal {
 
     // Create a breadcrumb that indicates that the journal folder has been formatted.
     UnderFileSystemUtils.touch(mUfs, URIUtils.appendPathOrDie(location,
-        Configuration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX) + System.currentTimeMillis())
+        ServerConfiguration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX) + System.currentTimeMillis())
         .toString());
   }
 
diff --git a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalCheckpointThread.java b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalCheckpointThread.java
index 92049d73d8..a2a9410e46 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalCheckpointThread.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalCheckpointThread.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.journal.ufs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.InvalidJournalEntryException;
 import alluxio.master.journal.JournalEntryStateMachine;
 import alluxio.master.journal.JournalReader;
@@ -76,9 +76,9 @@ public final class UfsJournalCheckpointThread extends Thread {
     mJournal = Preconditions.checkNotNull(journal, "journal");
     mShutdownQuietWaitTimeMs = journal.getQuietPeriodMs();
     mJournalCheckpointSleepTimeMs =
-        (int) Configuration.getMs(PropertyKey.MASTER_JOURNAL_TAILER_SLEEP_TIME_MS);
+        (int) ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_TAILER_SLEEP_TIME_MS);
     mJournalReader = new UfsJournalReader(mJournal, 0, false);
-    mCheckpointPeriodEntries = Configuration.getLong(
+    mCheckpointPeriodEntries = ServerConfiguration.getLong(
         PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES);
   }
 
diff --git a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalFileParser.java b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalFileParser.java
index 0989088c0e..28f9698d4b 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalFileParser.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalFileParser.java
@@ -11,6 +11,8 @@
 
 package alluxio.master.journal.ufs;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.journal.JournalFileParser;
 import alluxio.proto.journal.Journal;
 import alluxio.underfs.UnderFileSystem;
@@ -50,7 +52,7 @@ public final class UfsJournalFileParser implements JournalFileParser {
    */
   public UfsJournalFileParser(URI location) {
     mLocation = Preconditions.checkNotNull(location, "location");
-    mUfs = UnderFileSystem.Factory.create(mLocation);
+    mUfs = UnderFileSystem.Factory.create(mLocation, ServerConfiguration.global());
   }
 
   @Override
diff --git a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalGarbageCollector.java b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalGarbageCollector.java
index e7c1de7fee..fbfbae6001 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalGarbageCollector.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalGarbageCollector.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.journal.ufs;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.util.ThreadFactoryUtils;
 
@@ -60,7 +60,7 @@ final class UfsJournalGarbageCollector implements Closeable {
           public void run() {
             gc();
           }
-        }, Constants.SECOND_MS, Configuration.getMs(PropertyKey.MASTER_JOURNAL_GC_PERIOD_MS),
+        }, Constants.SECOND_MS, ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_GC_PERIOD_MS),
         TimeUnit.MILLISECONDS);
   }
 
@@ -129,8 +129,8 @@ final class UfsJournalGarbageCollector implements Closeable {
     }
 
     long thresholdMs = file.isTmpCheckpoint()
-        ? Configuration.getMs(PropertyKey.MASTER_JOURNAL_TEMPORARY_FILE_GC_THRESHOLD_MS)
-        : Configuration.getMs(PropertyKey.MASTER_JOURNAL_GC_THRESHOLD_MS);
+        ? ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_TEMPORARY_FILE_GC_THRESHOLD_MS)
+        : ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_GC_THRESHOLD_MS);
 
     if (System.currentTimeMillis() - lastModifiedTimeMs > thresholdMs) {
       deleteNoException(file.getLocation());
diff --git a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalLogWriter.java b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalLogWriter.java
index 3767156309..4677aafb7e 100644
--- a/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalLogWriter.java
+++ b/core/server/common/src/main/java/alluxio/master/journal/ufs/UfsJournalLogWriter.java
@@ -11,8 +11,10 @@
 
 package alluxio.master.journal.ufs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.Server;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.InvalidJournalEntryException;
@@ -98,7 +100,7 @@ final class UfsJournalLogWriter implements JournalWriter {
     mJournal = Preconditions.checkNotNull(journal, "journal");
     mUfs = mJournal.getUfs();
     mNextSequenceNumber = nextSequenceNumber;
-    mMaxLogSize = Configuration.getBytes(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX);
+    mMaxLogSize = ServerConfiguration.getBytes(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX);
 
     mRotateLogForNextWrite = true;
     UfsJournalFile currentLog = UfsJournalSnapshot.getCurrentLog(mJournal);
@@ -268,7 +270,7 @@ final class UfsJournalLogWriter implements JournalWriter {
     UfsJournalFile currentLog = UfsJournalFile.createLogFile(newLog, mNextSequenceNumber,
         UfsJournal.UNKNOWN_SEQUENCE_NUMBER);
     OutputStream outputStream = mUfs.create(currentLog.getLocation().toString(),
-        CreateOptions.defaults().setEnsureAtomic(false).setCreateParent(true));
+        CreateOptions.defaults(ServerConfiguration.global()).setEnsureAtomic(false).setCreateParent(true));
     mJournalOutputStream = new JournalOutputStream(currentLog, outputStream);
     LOG.info("Created current log file: {}", currentLog);
   }
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/AsyncJournalWriter.java b/core/server/common/src/main/java/alluxio/master/journalv0/AsyncJournalWriter.java
index 3516820c6e..92016600ef 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/AsyncJournalWriter.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/AsyncJournalWriter.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.journalv0;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.proto.journal.Journal.JournalEntry;
 
 import com.google.common.base.Preconditions;
@@ -62,7 +62,7 @@ public final class AsyncJournalWriter {
     mWriteCounter = new AtomicLong(0);
     // convert milliseconds to nanoseconds.
     mFlushBatchTimeNs =
-        1000000L * Configuration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS);
+        1000000L * ServerConfiguration.getMs(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS);
   }
 
   /**
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/JournalFactory.java b/core/server/common/src/main/java/alluxio/master/journalv0/JournalFactory.java
index a4d47e9b5d..24381e6022 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/JournalFactory.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/JournalFactory.java
@@ -11,6 +11,8 @@
 
 package alluxio.master.journalv0;
 
+import alluxio.conf.AlluxioConfiguration;
+
 /**
  * Factory for creating named journals.
  */
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/JournalFormatter.java b/core/server/common/src/main/java/alluxio/master/journalv0/JournalFormatter.java
index 8f6135da0d..6fc55138cf 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/JournalFormatter.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/JournalFormatter.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.journalv0;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.proto.journal.Journal.JournalEntry;
 import alluxio.util.CommonUtils;
 
@@ -39,7 +39,7 @@ public interface JournalFormatter {
      */
     public static JournalFormatter create() {
       return CommonUtils.createNewClassInstance(
-          Configuration.<JournalFormatter>getClass(PropertyKey.MASTER_JOURNAL_FORMATTER_CLASS),
+          ServerConfiguration.<JournalFormatter>getClass(PropertyKey.MASTER_JOURNAL_FORMATTER_CLASS),
           null, null);
     }
   }
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/MutableJournal.java b/core/server/common/src/main/java/alluxio/master/journalv0/MutableJournal.java
index 44ebc56690..1f3ff1e101 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/MutableJournal.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/MutableJournal.java
@@ -11,6 +11,7 @@
 
 package alluxio.master.journalv0;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.master.journalv0.ufs.UfsMutableJournal;
 import alluxio.util.URIUtils;
 
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournal.java b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournal.java
index c5a11af7dc..064682fd4a 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournal.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournal.java
@@ -11,8 +11,9 @@
 
 package alluxio.master.journalv0.ufs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.journalv0.Journal;
 import alluxio.master.journalv0.JournalFormatter;
 import alluxio.master.journalv0.JournalReader;
@@ -129,13 +130,13 @@ public class UfsJournal implements Journal {
 
   @Override
   public boolean isFormatted() throws IOException {
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(mLocation);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(mLocation, ServerConfiguration.global());
     UfsStatus[] files = ufs.listStatus(mLocation.toString());
     if (files == null) {
       return false;
     }
     // Search for the format file.
-    String formatFilePrefix = Configuration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX);
+    String formatFilePrefix = ServerConfiguration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX);
     for (UfsStatus file : files) {
       if (file.getName().startsWith(formatFilePrefix)) {
         return true;
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalReader.java b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalReader.java
index f83dc3778c..1e1acf5c29 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalReader.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalReader.java
@@ -11,6 +11,7 @@
 
 package alluxio.master.journalv0.ufs;
 
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.journalv0.JournalInputStream;
 import alluxio.master.journalv0.JournalReader;
 import alluxio.underfs.UnderFileSystem;
@@ -53,7 +54,7 @@ public class UfsJournalReader implements JournalReader {
    */
   UfsJournalReader(UfsJournal journal) {
     mJournal = Preconditions.checkNotNull(journal, "journal");
-    mUfs = UnderFileSystem.Factory.create(mJournal.getLocation());
+    mUfs = UnderFileSystem.Factory.create(mJournal.getLocation(), ServerConfiguration.global());
     mCheckpoint = mJournal.getCheckpoint();
   }
 
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalWriter.java b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalWriter.java
index e90eabdf17..08c0748785 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalWriter.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsJournalWriter.java
@@ -11,8 +11,9 @@
 
 package alluxio.master.journalv0.ufs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.exception.ExceptionMessage;
 import alluxio.master.journalv0.JournalFormatter;
@@ -80,7 +81,7 @@ public final class UfsJournalWriter implements JournalWriter {
     } catch (URISyntaxException e) {
       throw new RuntimeException(e);
     }
-    mUfs = UnderFileSystem.Factory.create(mJournal.getLocation());
+    mUfs = UnderFileSystem.Factory.create(mJournal.getLocation(), ServerConfiguration.global());
     mCheckpointManager = new UfsCheckpointManager(mUfs, mJournal.getCheckpoint(), this);
   }
 
@@ -125,7 +126,7 @@ public final class UfsJournalWriter implements JournalWriter {
     }
     if (mEntryOutputStream == null) {
       mEntryOutputStream = new EntryOutputStream(mUfs, mJournal.getCurrentLog(),
-          mJournal.getJournalFormatter(), this);
+          mJournal.getJournalFormatter(), this, ServerConfiguration.global());
     }
     mEntryOutputStream.write(entry);
   }
@@ -304,6 +305,7 @@ public final class UfsJournalWriter implements JournalWriter {
      * the previous write failed and may have left a corrupted entry at the end of the current log.
      */
     private boolean mRotateLogForNextWrite = false;
+    private final AlluxioConfiguration mAlluxioConf;
 
     /**
      * @param ufs the under storage holding the journal
@@ -313,14 +315,15 @@ public final class UfsJournalWriter implements JournalWriter {
      *        complete the log when it needs to be rotated
      */
     public EntryOutputStream(UnderFileSystem ufs, URI log, JournalFormatter journalFormatter,
-        UfsJournalWriter journalWriter) throws IOException {
+        UfsJournalWriter journalWriter, AlluxioConfiguration alluxioConf) throws IOException {
       mUfs = ufs;
+      mAlluxioConf = alluxioConf;
       mCurrentLog = log;
       mJournalFormatter = journalFormatter;
       mJournalWriter = journalWriter;
-      mMaxLogSize = Configuration.getBytes(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX);
+      mMaxLogSize = ServerConfiguration.getBytes(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX);
       mRawOutputStream = mUfs.create(mCurrentLog.toString(),
-          CreateOptions.defaults().setEnsureAtomic(false).setCreateParent(true));
+          CreateOptions.defaults(alluxioConf).setEnsureAtomic(false).setCreateParent(true));
       LOG.info("Opened current log file: {}", mCurrentLog);
       mDataOutputStream = new DataOutputStream(mRawOutputStream);
     }
@@ -398,7 +401,7 @@ public final class UfsJournalWriter implements JournalWriter {
       mDataOutputStream.close();
       mJournalWriter.completeCurrentLog();
       mRawOutputStream = mUfs.create(mCurrentLog.toString(),
-          CreateOptions.defaults().setEnsureAtomic(false).setCreateParent(true));
+          CreateOptions.defaults(mAlluxioConf).setEnsureAtomic(false).setCreateParent(true));
       LOG.info("Opened current log file: {}", mCurrentLog);
       mDataOutputStream = new DataOutputStream(mRawOutputStream);
     }
diff --git a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsMutableJournal.java b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsMutableJournal.java
index 5cb4f190ad..fea31b4e8b 100644
--- a/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsMutableJournal.java
+++ b/core/server/common/src/main/java/alluxio/master/journalv0/ufs/UfsMutableJournal.java
@@ -11,8 +11,9 @@
 
 package alluxio.master.journalv0.ufs;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.journalv0.JournalWriter;
 import alluxio.master.journalv0.MutableJournal;
 import alluxio.underfs.UfsStatus;
@@ -47,7 +48,7 @@ public class UfsMutableJournal extends UfsJournal implements MutableJournal {
   @Override
   public void format() throws IOException {
     LOG.info("Formatting {}", mLocation);
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(mLocation);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(mLocation, ServerConfiguration.global());
     if (ufs.isDirectory(mLocation.toString())) {
       for (UfsStatus p : ufs.listStatus(mLocation.toString())) {
         URI childPath;
@@ -74,7 +75,7 @@ public class UfsMutableJournal extends UfsJournal implements MutableJournal {
     // Create a breadcrumb that indicates that the journal folder has been formatted.
     try {
       UnderFileSystemUtils.touch(ufs, URIUtils.appendPath(mLocation,
-          Configuration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX) + System.currentTimeMillis())
+          ServerConfiguration.get(PropertyKey.MASTER_FORMAT_FILE_PREFIX) + System.currentTimeMillis())
           .toString());
     } catch (URISyntaxException e) {
       throw new RuntimeException(e.getMessage());
diff --git a/core/server/common/src/main/java/alluxio/underfs/AbstractUfsManager.java b/core/server/common/src/main/java/alluxio/underfs/AbstractUfsManager.java
index 09e1b61506..8164c75fa4 100644
--- a/core/server/common/src/main/java/alluxio/underfs/AbstractUfsManager.java
+++ b/core/server/common/src/main/java/alluxio/underfs/AbstractUfsManager.java
@@ -12,8 +12,8 @@
 package alluxio.underfs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.NotFoundException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.util.IdUtils;
@@ -162,15 +162,15 @@ public abstract class AbstractUfsManager implements UfsManager {
   public UfsClient getRoot() {
     synchronized (this) {
       if (mRootUfsClient == null) {
-        String rootUri = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+        String rootUri = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
         boolean rootReadOnly =
-            Configuration.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_READONLY);
-        boolean rootShared = Configuration.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_SHARED);
+            ServerConfiguration.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_READONLY);
+        boolean rootShared = ServerConfiguration.getBoolean(PropertyKey.MASTER_MOUNT_TABLE_ROOT_SHARED);
         Map<String, String> rootConf =
-            Configuration.getNestedProperties(PropertyKey.MASTER_MOUNT_TABLE_ROOT_OPTION);
+            ServerConfiguration.getNestedProperties(PropertyKey.MASTER_MOUNT_TABLE_ROOT_OPTION);
         addMount(IdUtils.ROOT_MOUNT_ID, new AlluxioURI(rootUri),
             UnderFileSystemConfiguration.defaults().setReadOnly(rootReadOnly).setShared(rootShared)
-                .setMountSpecificConf(rootConf));
+                .createMountSpecificConf(rootConf));
         try {
           mRootUfsClient = get(IdUtils.ROOT_MOUNT_ID);
         } catch (NotFoundException | UnavailableException e) {
diff --git a/core/server/common/src/main/java/alluxio/web/UIFileInfo.java b/core/server/common/src/main/java/alluxio/web/UIFileInfo.java
index cb5c6b0e21..62bdca4ece 100644
--- a/core/server/common/src/main/java/alluxio/web/UIFileInfo.java
+++ b/core/server/common/src/main/java/alluxio/web/UIFileInfo.java
@@ -13,6 +13,8 @@ package alluxio.web;
 
 import alluxio.AlluxioURI;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.file.meta.PersistenceState;
 import alluxio.security.authorization.Mode;
 import alluxio.util.CommonUtils;
@@ -210,14 +212,14 @@ public final class UIFileInfo {
     if (mCreationTimeMs == LocalFileInfo.EMPTY_CREATION_TIME) {
       return "";
     }
-    return CommonUtils.convertMsToDate(mCreationTimeMs);
+    return CommonUtils.convertMsToDate(mCreationTimeMs, ServerConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN));
   }
 
   /**
    * @return the modification time (in milliseconds)
    */
   public String getModificationTime() {
-    return CommonUtils.convertMsToDate(mLastModificationTimeMs);
+    return CommonUtils.convertMsToDate(mLastModificationTimeMs, ServerConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN));
   }
 
   /**
diff --git a/core/server/common/src/main/java/alluxio/web/WebInterfaceBrowseLogsServlet.java b/core/server/common/src/main/java/alluxio/web/WebInterfaceBrowseLogsServlet.java
index 24c26c8e47..43457fffc7 100644
--- a/core/server/common/src/main/java/alluxio/web/WebInterfaceBrowseLogsServlet.java
+++ b/core/server/common/src/main/java/alluxio/web/WebInterfaceBrowseLogsServlet.java
@@ -11,9 +11,9 @@
 
 package alluxio.web;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -100,10 +100,10 @@ public final class WebInterfaceBrowseLogsServlet extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest request, HttpServletResponse response)
       throws ServletException, IOException {
-    if (!Configuration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
+    if (!ServerConfiguration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
       return;
     }
-    request.setAttribute("debug", Configuration.getBoolean(PropertyKey.DEBUG));
+    request.setAttribute("debug", ServerConfiguration.getBoolean(PropertyKey.DEBUG));
     request.setAttribute("invalidPathError", "");
     request.setAttribute("viewingOffset", 0);
     request.setAttribute("downloadLogFile", 1);
@@ -111,7 +111,7 @@ public final class WebInterfaceBrowseLogsServlet extends HttpServlet {
     request.setAttribute("currentPath", "");
     request.setAttribute("showPermissions", false);
 
-    String logsPath = Configuration.get(PropertyKey.LOGS_DIR);
+    String logsPath = ServerConfiguration.get(PropertyKey.LOGS_DIR);
     File logsDir = new File(logsPath);
     String requestFile = request.getParameter("path");
 
diff --git a/core/server/common/src/main/java/alluxio/web/WebInterfaceDownloadLocalServlet.java b/core/server/common/src/main/java/alluxio/web/WebInterfaceDownloadLocalServlet.java
index a05d2294ac..b198831e6a 100644
--- a/core/server/common/src/main/java/alluxio/web/WebInterfaceDownloadLocalServlet.java
+++ b/core/server/common/src/main/java/alluxio/web/WebInterfaceDownloadLocalServlet.java
@@ -12,8 +12,8 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.io.ByteStreams;
 
@@ -58,7 +58,7 @@ public final class WebInterfaceDownloadLocalServlet extends HttpServlet {
     }
 
     // Download a file from the local filesystem.
-    File logsDir = new File(Configuration.get(PropertyKey.LOGS_DIR));
+    File logsDir = new File(ServerConfiguration.get(PropertyKey.LOGS_DIR));
 
     // Only allow filenames as the path, to avoid downloading arbitrary local files.
     requestPath = new File(requestPath).getName();
diff --git a/core/server/common/src/main/java/alluxio/web/WebInterfaceHeaderServlet.java b/core/server/common/src/main/java/alluxio/web/WebInterfaceHeaderServlet.java
index be2d917fc7..d573516e9e 100644
--- a/core/server/common/src/main/java/alluxio/web/WebInterfaceHeaderServlet.java
+++ b/core/server/common/src/main/java/alluxio/web/WebInterfaceHeaderServlet.java
@@ -11,8 +11,9 @@
 
 package alluxio.web;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
 
@@ -47,9 +48,10 @@ public final class WebInterfaceHeaderServlet extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest request, HttpServletResponse response)
       throws ServletException, IOException {
-    boolean fileInfoEnabled = Configuration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED);
-    String masterHostName = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC);
-    int masterWebPort = Configuration.getInt(PropertyKey.MASTER_WEB_PORT);
+    boolean fileInfoEnabled = ServerConfiguration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED);
+    String masterHostName = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC,
+        ServerConfiguration.global());
+    int masterWebPort = ServerConfiguration.getInt(PropertyKey.MASTER_WEB_PORT);
     request.setAttribute("fileInfoEnabled", fileInfoEnabled);
     request.setAttribute("masterHost", masterHostName);
     request.setAttribute("masterPort", masterWebPort);
diff --git a/core/server/common/src/main/java/alluxio/web/WebServer.java b/core/server/common/src/main/java/alluxio/web/WebServer.java
index 5d1460fe33..f9afa7e926 100644
--- a/core/server/common/src/main/java/alluxio/web/WebServer.java
+++ b/core/server/common/src/main/java/alluxio/web/WebServer.java
@@ -12,8 +12,8 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.base.Preconditions;
 import org.eclipse.jetty.server.Connector;
@@ -64,7 +64,7 @@ public abstract class WebServer {
     mServiceName = serviceName;
 
     QueuedThreadPool threadPool = new QueuedThreadPool();
-    int webThreadCount = Configuration.getInt(PropertyKey.WEB_THREADS);
+    int webThreadCount = ServerConfiguration.getInt(PropertyKey.WEB_THREADS);
 
     // Jetty needs at least (1 + selectors + acceptors) threads.
     threadPool.setMinThreads(webThreadCount * 2 + 1);
@@ -89,9 +89,9 @@ public abstract class WebServer {
 
     mWebAppContext = new WebAppContext();
     mWebAppContext.setContextPath(AlluxioURI.SEPARATOR);
-    File warPath = new File(Configuration.get(PropertyKey.WEB_RESOURCES));
+    File warPath = new File(ServerConfiguration.get(PropertyKey.WEB_RESOURCES));
     mWebAppContext.setWar(warPath.getAbsolutePath());
-    String webTempPath = Configuration.get(PropertyKey.WEB_TEMP_PATH);
+    String webTempPath = ServerConfiguration.get(PropertyKey.WEB_TEMP_PATH);
     LOG.info("Using temporary directory {} for web server resources", webTempPath);
     if (!Files.exists(Paths.get(webTempPath))) {
       try {
diff --git a/core/server/common/src/test/java/alluxio/RestUtilsTest.java b/core/server/common/src/test/java/alluxio/RestUtilsTest.java
index 333f7fafb9..f5290a2ce8 100644
--- a/core/server/common/src/test/java/alluxio/RestUtilsTest.java
+++ b/core/server/common/src/test/java/alluxio/RestUtilsTest.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.exception.status.Status;
 
@@ -24,6 +26,7 @@ import javax.ws.rs.core.Response;
  * Unit tests for {@link RestUtils}.
  */
 public class RestUtilsTest {
+
   @Test
   public void voidOkResponse() {
     Response response = RestUtils.call(new RestUtils.RestCallable<Void>() {
@@ -31,7 +34,7 @@ public class RestUtilsTest {
       public Void call() throws Exception {
         return null;
       }
-    });
+    }, ServerConfiguration.global());
     Assert.assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
     Assert.assertNull(response.getEntity());
   }
@@ -44,7 +47,7 @@ public class RestUtilsTest {
       public String call() throws Exception {
         return message;
       }
-    });
+    }, ServerConfiguration.global());
     Assert.assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
     ObjectMapper mapper = new ObjectMapper();
     String jsonMessage = mapper.writeValueAsString(message);
@@ -79,7 +82,7 @@ public class RestUtilsTest {
       public Obj call() throws Exception {
         return object;
       }
-    });
+    }, ServerConfiguration.global());
     Assert.assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
     Obj obj = (Obj) response.getEntity();
     Assert.assertEquals(status, obj.getStatus());
@@ -95,7 +98,7 @@ public class RestUtilsTest {
       public Void call() throws Exception {
         throw new AlluxioStatusException(status, message);
       }
-    });
+    }, ServerConfiguration.global());
     Assert.assertEquals(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode(),
         response.getStatus());
     RestUtils.ErrorResponse errorResponse = (RestUtils.ErrorResponse) response.getEntity();
diff --git a/core/server/common/src/test/java/alluxio/StorageTierAssocTest.java b/core/server/common/src/test/java/alluxio/StorageTierAssocTest.java
index 3aa4c229d3..b84f01d4b1 100644
--- a/core/server/common/src/test/java/alluxio/StorageTierAssocTest.java
+++ b/core/server/common/src/test/java/alluxio/StorageTierAssocTest.java
@@ -11,6 +11,10 @@
 
 package alluxio;
 
+import alluxio.conf.ConfigurationTest;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import com.google.common.collect.ImmutableMap;
 import org.junit.Assert;
 import org.junit.Test;
@@ -24,15 +28,16 @@ import java.util.List;
  * Unit tests for {@link StorageTierAssoc}.
  */
 public final class StorageTierAssocTest {
+
   private void checkStorageTierAssoc(StorageTierAssoc assoc, PropertyKey levelsProperty,
       PropertyKey.Template template) {
-    int size = Configuration.getInt(levelsProperty);
+    int size = ServerConfiguration.getInt(levelsProperty);
     Assert.assertEquals(size, assoc.size());
 
     List<String> expectedOrderedAliases = new ArrayList<>();
 
     for (int i = 0; i < size; i++) {
-      String alias = Configuration.get(template.format(i));
+      String alias = ServerConfiguration.get(template.format(i));
       Assert.assertEquals(i, assoc.getOrdinal(alias));
       Assert.assertEquals(alias, assoc.getAlias(i));
       expectedOrderedAliases.add(alias);
@@ -43,7 +48,7 @@ public final class StorageTierAssocTest {
 
   /**
    * Tests the constructors of the {@link MasterStorageTierAssoc} and {@link WorkerStorageTierAssoc}
-   * classes with a {@link Configuration}.
+   * classes with a {@link ServerConfiguration}.
    */
   @Test
   public void masterWorkerConfConstructor() throws Exception {
@@ -51,7 +56,8 @@ public final class StorageTierAssocTest {
         PropertyKey.MASTER_TIERED_STORE_GLOBAL_LEVELS, "3",
         PropertyKey.Template.MASTER_TIERED_STORE_GLOBAL_LEVEL_ALIAS.format(2), "BOTTOM",
         PropertyKey.WORKER_TIERED_STORE_LEVELS, "2",
-        PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_ALIAS.format(1), "BOTTOM"))
+        PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_ALIAS.format(1), "BOTTOM"),
+        ServerConfiguration.global())
         .toResource()) {
       checkStorageTierAssoc(new MasterStorageTierAssoc(),
           PropertyKey.MASTER_TIERED_STORE_GLOBAL_LEVELS,
diff --git a/core/server/common/src/test/java/alluxio/cli/FormatTest.java b/core/server/common/src/test/java/alluxio/cli/FormatTest.java
index 2c479e6031..84a2df5ddb 100644
--- a/core/server/common/src/test/java/alluxio/cli/FormatTest.java
+++ b/core/server/common/src/test/java/alluxio/cli/FormatTest.java
@@ -15,9 +15,11 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
-import alluxio.Configuration;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.util.CommonUtils;
 import alluxio.util.io.FileUtils;
 import alluxio.util.io.PathUtils;
@@ -54,7 +56,7 @@ public final class FormatTest {
         mTemporaryFolder.newFolder("level2")
     };
     for (File dir : dirs) {
-      workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath());
+      workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath(), ServerConfiguration.global());
       FileUtils.createDir(PathUtils.concatPath(workerDataFolder, "subdir"));
       FileUtils.createFile(PathUtils.concatPath(workerDataFolder, "file"));
     }
@@ -66,10 +68,10 @@ public final class FormatTest {
         put(PropertyKey.WORKER_TIERED_STORE_LEVELS, String.valueOf(storageLevels));
         put(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS, perms);
       }
-    }).toResource()) {
-      Format.format(Format.Mode.WORKER);
+    }, ServerConfiguration.global()).toResource()) {
+      Format.format(Format.Mode.WORKER, ServerConfiguration.global());
       for (File dir : dirs) {
-        workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath());
+        workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath(), ServerConfiguration.global());
         assertTrue(FileUtils.exists(dir.getPath()));
         assertTrue(FileUtils.exists(workerDataFolder));
         assertEquals(PosixFilePermissions.fromString(perms), Files.getPosixFilePermissions(Paths
@@ -95,7 +97,7 @@ public final class FormatTest {
     };
     // Have files of same name as the target worker data dir in each tier
     for (File dir : dirs) {
-      workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath());
+      workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath(), ServerConfiguration.global());
       FileUtils.createFile(workerDataFolder);
     }
     try (Closeable r = new ConfigurationRule(new HashMap<PropertyKey, String>() {
@@ -105,11 +107,12 @@ public final class FormatTest {
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_DIRS_PATH, dirs[2].getPath());
         put(PropertyKey.WORKER_TIERED_STORE_LEVELS, String.valueOf(storageLevels));
       }
-    }).toResource()) {
-      final String perms = Configuration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);
-      Format.format(Format.Mode.WORKER);
+    }, ServerConfiguration.global()).toResource()) {
+      final String perms = ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS);
+      Format.format(Format.Mode.WORKER, ServerConfiguration.global());
       for (File dir : dirs) {
-        workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath());
+        workerDataFolder = CommonUtils.getWorkerDataDirectory(dir.getPath(),
+            ServerConfiguration.global());
         assertTrue(Files.isDirectory(Paths.get(workerDataFolder)));
         assertEquals(PosixFilePermissions.fromString(perms), Files.getPosixFilePermissions(Paths
             .get(workerDataFolder)));
diff --git a/core/server/common/src/test/java/alluxio/master/journal/AsyncJournalWriterTest.java b/core/server/common/src/test/java/alluxio/master/journal/AsyncJournalWriterTest.java
index fbaa9ee09a..ea59c8c5f0 100644
--- a/core/server/common/src/test/java/alluxio/master/journal/AsyncJournalWriterTest.java
+++ b/core/server/common/src/test/java/alluxio/master/journal/AsyncJournalWriterTest.java
@@ -21,9 +21,9 @@ import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.proto.journal.Journal.JournalEntry;
 
 import org.junit.After;
@@ -42,14 +42,14 @@ public class AsyncJournalWriterTest {
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   private void setupAsyncJournalWriter(boolean batchingEnabled) throws Exception {
     if (batchingEnabled) {
-      Configuration.set(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS, "500ms");
+      ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS, "500ms");
     } else {
-      Configuration.set(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS, "0ms");
+      ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_FLUSH_BATCH_TIME_MS, "0ms");
     }
 
     mMockJournalWriter = PowerMockito.mock(JournalWriter.class);
diff --git a/core/server/master/src/main/java/alluxio/master/AlluxioMasterProcess.java b/core/server/master/src/main/java/alluxio/master/AlluxioMasterProcess.java
index 4aaad49272..541d3743b6 100644
--- a/core/server/master/src/main/java/alluxio/master/AlluxioMasterProcess.java
+++ b/core/server/master/src/main/java/alluxio/master/AlluxioMasterProcess.java
@@ -12,8 +12,9 @@
 package alluxio.master;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.grpc.GrpcService;
 import alluxio.master.journal.JournalSystem;
@@ -113,9 +114,9 @@ public class AlluxioMasterProcess implements MasterProcess {
    */
   AlluxioMasterProcess(JournalSystem journalSystem) {
     mJournalSystem = Preconditions.checkNotNull(journalSystem, "journalSystem");
-    mMinWorkerThreads = Configuration.getInt(PropertyKey.MASTER_WORKER_THREADS_MIN);
-    mMaxWorkerThreads = Configuration.getInt(PropertyKey.MASTER_WORKER_THREADS_MAX);
-    int connectionTimeout = (int) Configuration.getMs(PropertyKey.MASTER_CONNECTION_TIMEOUT_MS);
+    mMinWorkerThreads = ServerConfiguration.getInt(PropertyKey.MASTER_WORKER_THREADS_MIN);
+    mMaxWorkerThreads = ServerConfiguration.getInt(PropertyKey.MASTER_WORKER_THREADS_MAX);
+    int connectionTimeout = (int) ServerConfiguration.getMs(PropertyKey.MASTER_CONNECTION_TIMEOUT_MS);
 
     Preconditions.checkArgument(mMaxWorkerThreads >= mMinWorkerThreads,
         PropertyKey.MASTER_WORKER_THREADS_MAX + " can not be less than "
@@ -131,26 +132,26 @@ public class AlluxioMasterProcess implements MasterProcess {
       // use (any random free port).
       // In a production or any real deployment setup, port '0' should not be used as it will make
       // deployment more complicated.
-      if (!Configuration.getBoolean(PropertyKey.TEST_MODE)) {
-        Preconditions.checkState(Configuration.getInt(PropertyKey.MASTER_RPC_PORT) > 0,
+      if (!ServerConfiguration.getBoolean(PropertyKey.TEST_MODE)) {
+        Preconditions.checkState(ServerConfiguration.getInt(PropertyKey.MASTER_RPC_PORT) > 0,
             this + " rpc port is only allowed to be zero in test mode.");
-        Preconditions.checkState(Configuration.getInt(PropertyKey.MASTER_WEB_PORT) > 0,
+        Preconditions.checkState(ServerConfiguration.getInt(PropertyKey.MASTER_WEB_PORT) > 0,
             this + " web port is only allowed to be zero in test mode.");
       }
 
       // Random port binding.
       InetSocketAddress configuredBindAddress =
-          NetworkAddressUtils.getBindAddress(ServiceType.MASTER_RPC);
+          NetworkAddressUtils.getBindAddress(ServiceType.MASTER_RPC, ServerConfiguration.global());
       if (configuredBindAddress.getPort() == 0) {
-        mBindSocket = new ServerSocket(0);
-        mPort = mBindSocket.getLocalPort();
-        Configuration.set(PropertyKey.MASTER_RPC_PORT, Integer.toString(mPort));
+        mGrpcServer = GrpcServerBuilder.forAddress(configuredBindAddress, ServerConfiguration.global()).build().start();
+        mPort = mGrpcServer.getBindPort();
+        ServerConfiguration.set(PropertyKey.MASTER_RPC_PORT, Integer.toString(mPort));
       } else {
         mPort = configuredBindAddress.getPort();
       }
 
-      mRpcBindAddress = NetworkAddressUtils.getBindAddress(ServiceType.MASTER_RPC);
-      mRpcConnectAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC);
+      mRpcBindAddress = NetworkAddressUtils.getBindAddress(ServiceType.MASTER_RPC, ServerConfiguration.global());
+      mRpcConnectAddress = NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, ServerConfiguration.global());
 
       if (!mJournalSystem.isFormatted()) {
         throw new RuntimeException(
@@ -254,9 +255,9 @@ public class AlluxioMasterProcess implements MasterProcess {
   protected void startMasters(boolean isLeader) {
     try {
       if (isLeader) {
-        if (Configuration.isSet(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP)) {
+        if (ServerConfiguration.isSet(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP)) {
           AlluxioURI backup =
-              new AlluxioURI(Configuration.get(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP));
+              new AlluxioURI(ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP));
           if (mJournalSystem.isEmpty()) {
             initFromBackup(backup);
           } else {
@@ -278,7 +279,7 @@ public class AlluxioMasterProcess implements MasterProcess {
     if (URIUtils.isLocalFilesystem(backup.toString())) {
       ufs = UnderFileSystem.Factory.create("/", UnderFileSystemConfiguration.defaults());
     } else {
-      ufs = UnderFileSystem.Factory.createForRoot();
+      ufs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
     }
     try (UnderFileSystem closeUfs = ufs;
          InputStream ufsIn = ufs.open(backup.getPath())) {
@@ -310,17 +311,17 @@ public class AlluxioMasterProcess implements MasterProcess {
    * @param stopMessage empty string or the message that the master loses the leadership
    */
   protected void startServing(String startMessage, String stopMessage) {
-    MetricsSystem.startSinks();
+    MetricsSystem.startSinks(ServerConfiguration.get(PropertyKey.METRICS_CONF_FILE));
     startServingWebServer();
     startJvmMonitorProcess();
     LOG.info("Alluxio master version {} started{}. "
             + "bindHost={}, connectHost={}, rpcPort={}, webPort={}",
         RuntimeConstants.VERSION,
         startMessage,
-        NetworkAddressUtils.getBindAddress(ServiceType.MASTER_RPC),
-        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.MASTER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.MASTER_WEB));
+        NetworkAddressUtils.getBindAddress(ServiceType.MASTER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.MASTER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.MASTER_WEB, ServerConfiguration.global()));
     startServingRPCServer();
     LOG.info("Alluxio master ended{}", stopMessage);
   }
@@ -331,9 +332,9 @@ public class AlluxioMasterProcess implements MasterProcess {
    */
   protected void startServingWebServer() {
     mWebServer = new MasterWebServer(ServiceType.MASTER_WEB.getServiceName(),
-        NetworkAddressUtils.getBindAddress(ServiceType.MASTER_WEB), this);
+        NetworkAddressUtils.getBindAddress(ServiceType.MASTER_WEB, ServerConfiguration.global()), this);
     // reset master web port
-    Configuration.set(PropertyKey.MASTER_WEB_PORT, Integer.toString(mWebServer.getLocalPort()));
+    ServerConfiguration.set(PropertyKey.MASTER_WEB_PORT, Integer.toString(mWebServer.getLocalPort()));
     // Add the metrics servlet to the web server.
     mWebServer.addHandler(mMetricsServlet.getHandler());
     // Add the prometheus metrics servlet to the web server.
@@ -346,8 +347,11 @@ public class AlluxioMasterProcess implements MasterProcess {
    * Starts jvm monitor process, to monitor jvm.
    */
   protected void startJvmMonitorProcess() {
-    if (Configuration.getBoolean(PropertyKey.MASTER_JVM_MONITOR_ENABLED)) {
-      mJvmPauseMonitor = new JvmPauseMonitor();
+    if (ServerConfiguration.getBoolean(PropertyKey.MASTER_JVM_MONITOR_ENABLED)) {
+      mJvmPauseMonitor = new JvmPauseMonitor(
+          ServerConfiguration.getMs(PropertyKey.JVM_MONITOR_SLEEP_INTERVAL_MS),
+          ServerConfiguration.getMs(PropertyKey.JVM_MONITOR_INFO_THRESHOLD_MS),
+          ServerConfiguration.getMs(PropertyKey.JVM_MONITOR_WARN_THRESHOLD_MS));
       mJvmPauseMonitor.start();
     }
   }
@@ -375,7 +379,8 @@ public class AlluxioMasterProcess implements MasterProcess {
       }
 
       LOG.info("Starting gRPC server on address {}", mRpcBindAddress);
-      GrpcServerBuilder serverBuilder = GrpcServerBuilder.forAddress(mRpcBindAddress);
+      GrpcServerBuilder serverBuilder = GrpcServerBuilder.forAddress(mRpcBindAddress,
+          ServerConfiguration.global());
       for (Master master : mRegistry.getServers()) {
         registerServices(serverBuilder, master.getServices());
       }
diff --git a/core/server/master/src/main/java/alluxio/master/AlluxioSecondaryMaster.java b/core/server/master/src/main/java/alluxio/master/AlluxioSecondaryMaster.java
index be76e6ed25..0d9ea1bf4a 100644
--- a/core/server/master/src/main/java/alluxio/master/AlluxioSecondaryMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/AlluxioSecondaryMaster.java
@@ -11,10 +11,10 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Process;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.journal.JournalSystem;
 import alluxio.master.journal.JournalUtils;
@@ -53,7 +53,7 @@ public final class AlluxioSecondaryMaster implements Process {
       mSafeModeManager = new DefaultSafeModeManager();
       mBackupManager = new BackupManager(mRegistry);
       mStartTimeMs = System.currentTimeMillis();
-      mPort = Configuration.getInt(PropertyKey.MASTER_RPC_PORT);
+      mPort = ServerConfiguration.getInt(PropertyKey.MASTER_RPC_PORT);
       // Create masters.
       MasterUtils.createMasters(mRegistry, CoreMasterContext.newBuilder()
           .setJournalSystem(mJournalSystem)
diff --git a/core/server/master/src/main/java/alluxio/master/DefaultSafeModeManager.java b/core/server/master/src/main/java/alluxio/master/DefaultSafeModeManager.java
index 91e14f67c1..e5a5e48a8c 100644
--- a/core/server/master/src/main/java/alluxio/master/DefaultSafeModeManager.java
+++ b/core/server/master/src/main/java/alluxio/master/DefaultSafeModeManager.java
@@ -11,8 +11,8 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.clock.ElapsedTimeClock;
 
 import org.slf4j.Logger;
@@ -60,7 +60,7 @@ public class DefaultSafeModeManager implements SafeModeManager {
   @Override
   public void notifyRpcServerStarted() {
     // updates start time when Alluxio master waits for workers to register
-    long waitTime = Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME);
+    long waitTime = ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME);
     LOG.info(String.format("Rpc server started, waiting %dms for workers to register", waitTime));
     mWorkerConnectWaitStartTimeMs.set(mClock.millis(), true);
   }
@@ -79,7 +79,7 @@ public class DefaultSafeModeManager implements SafeModeManager {
     }
 
     // lazily updates safe mode state upon inquiry
-    long waitTime = Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME);
+    long waitTime = ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME);
     if (mClock.millis() - startTime < waitTime) {
       return true;
     }
diff --git a/core/server/master/src/main/java/alluxio/master/FaultTolerantAlluxioMasterProcess.java b/core/server/master/src/main/java/alluxio/master/FaultTolerantAlluxioMasterProcess.java
index 41b84f148d..3c1cefba62 100644
--- a/core/server/master/src/main/java/alluxio/master/FaultTolerantAlluxioMasterProcess.java
+++ b/core/server/master/src/main/java/alluxio/master/FaultTolerantAlluxioMasterProcess.java
@@ -11,10 +11,10 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.master.PrimarySelector.State;
 import alluxio.master.journal.JournalSystem;
 import alluxio.util.CommonUtils;
@@ -42,7 +42,7 @@ final class FaultTolerantAlluxioMasterProcess extends AlluxioMasterProcess {
       LoggerFactory.getLogger(FaultTolerantAlluxioMasterProcess.class);
 
   private final long mServingThreadTimeoutMs =
-      Configuration.getMs(PropertyKey.MASTER_SERVING_THREAD_TIMEOUT);
+      ServerConfiguration.getMs(PropertyKey.MASTER_SERVING_THREAD_TIMEOUT);
 
   private PrimarySelector mLeaderSelector;
   private Thread mServingThread;
diff --git a/core/server/master/src/main/java/alluxio/master/MasterProcess.java b/core/server/master/src/main/java/alluxio/master/MasterProcess.java
index baa0a26f14..6cb4e6b4a8 100644
--- a/core/server/master/src/main/java/alluxio/master/MasterProcess.java
+++ b/core/server/master/src/main/java/alluxio/master/MasterProcess.java
@@ -11,9 +11,9 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Process;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.master.journal.JournalSystem;
 import alluxio.master.journal.JournalUtils;
 import alluxio.master.journal.raft.RaftJournalSystem;
@@ -41,7 +41,7 @@ public interface MasterProcess extends Process {
       URI journalLocation = JournalUtils.getJournalLocation();
       JournalSystem journalSystem =
           new JournalSystem.Builder().setLocation(journalLocation).build();
-      if (Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
+      if (ServerConfigurationConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
         Preconditions.checkState(!(journalSystem instanceof RaftJournalSystem),
             "Raft journal cannot be used with Zookeeper enabled");
         PrimarySelector primarySelector = PrimarySelector.Factory.createZkPrimarySelector();
@@ -57,8 +57,8 @@ public interface MasterProcess extends Process {
   }
 
   /**
-   * @param clazz the class of the master to get
-   * @param <T> the type of the master to get
+   * @param clazz the class of the master to create
+   * @param <T> the type of the master to create
    * @return the given master
    */
   <T extends Master> T getMaster(Class<T> clazz);
diff --git a/core/server/master/src/main/java/alluxio/master/block/BlockMaster.java b/core/server/master/src/main/java/alluxio/master/block/BlockMaster.java
index 7716a5b7a8..aba35f1991 100644
--- a/core/server/master/src/main/java/alluxio/master/block/BlockMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/block/BlockMaster.java
@@ -125,7 +125,7 @@ public interface BlockMaster extends Master, ContainerIdGenerable {
   void commitBlockInUFS(long blockId, long length) throws UnavailableException;
 
   /**
-   * @param blockId the block id to get information for
+   * @param blockId the block id to create information for
    * @return the {@link BlockInfo} for the given block id
    * @throws BlockInfoException if the block info is not found
    */
diff --git a/core/server/master/src/main/java/alluxio/master/block/BlockMasterClientRestServiceHandler.java b/core/server/master/src/main/java/alluxio/master/block/BlockMasterClientRestServiceHandler.java
index f92768f35f..01629f27e7 100644
--- a/core/server/master/src/main/java/alluxio/master/block/BlockMasterClientRestServiceHandler.java
+++ b/core/server/master/src/main/java/alluxio/master/block/BlockMasterClientRestServiceHandler.java
@@ -13,6 +13,7 @@ package alluxio.master.block;
 
 import alluxio.Constants;
 import alluxio.RestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.MasterProcess;
 import alluxio.web.MasterWebServer;
 
@@ -59,29 +60,30 @@ public final class BlockMasterClientRestServiceHandler {
   }
 
   /**
-   * @summary get the service name
+   * @summary create the service name
    * @return the response object
    */
   @GET
   @Path(SERVICE_NAME)
   @ReturnType("java.lang.String")
   public Response getServiceName() {
-    return RestUtils.call(() -> Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME);
+    return RestUtils.call(() -> Constants.BLOCK_MASTER_CLIENT_SERVICE_NAME, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the service version
+   * @summary create the service version
    * @return the response object
    */
   @GET
   @Path(SERVICE_VERSION)
   @ReturnType("java.lang.Long")
   public Response getServiceVersion() {
-    return RestUtils.call(() -> Constants.BLOCK_MASTER_CLIENT_SERVICE_VERSION);
+    return RestUtils.call(() -> Constants.BLOCK_MASTER_CLIENT_SERVICE_VERSION,
+        ServerConfiguration.global());
   }
 
   /**
-   * @summary get the block descriptor for a block
+   * @summary create the block descriptor for a block
    * @param blockId the block id
    * @return the response object
    */
@@ -92,6 +94,6 @@ public final class BlockMasterClientRestServiceHandler {
     return RestUtils.call(() -> {
       Preconditions.checkNotNull(blockId, "required 'blockId' parameter is missing");
       return mBlockMaster.getBlockInfo(blockId);
-    });
+    }, ServerConfiguration.global());
   }
 }
diff --git a/core/server/master/src/main/java/alluxio/master/block/DefaultBlockMaster.java b/core/server/master/src/main/java/alluxio/master/block/DefaultBlockMaster.java
index 7d630c1238..29e7eba4e3 100644
--- a/core/server/master/src/main/java/alluxio/master/block/DefaultBlockMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/block/DefaultBlockMaster.java
@@ -11,10 +11,10 @@
 
 package alluxio.master.block;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
 import alluxio.MasterStorageTierAssoc;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Server;
 import alluxio.StorageTierAssoc;
 import alluxio.client.block.options.GetWorkerReportOptions;
@@ -313,7 +313,8 @@ public final class DefaultBlockMaster extends CoreMaster implements BlockMaster
     if (isLeader) {
       mLostWorkerDetectionService = getExecutorService().submit(new HeartbeatThread(
           HeartbeatContext.MASTER_LOST_WORKER_DETECTION, new LostWorkerDetectionHeartbeatExecutor(),
-          (int) Configuration.getMs(PropertyKey.MASTER_WORKER_HEARTBEAT_INTERVAL)));
+          (int) ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_HEARTBEAT_INTERVAL),
+          ServerConfiguration.global()));
     }
   }
 
@@ -955,7 +956,7 @@ public final class DefaultBlockMaster extends CoreMaster implements BlockMaster
     if (mSafeModeManager.isInSafeMode()) {
       throw new UnavailableException(ExceptionMessage.MASTER_IN_SAFEMODE.getMessage());
     }
-    // "Join" to get all the addresses of the workers.
+    // "Join" to create all the addresses of the workers.
     List<BlockLocation> locations = new ArrayList<>();
     List<MasterBlockLocation> blockLocations = masterBlockInfo.getBlockLocations();
     // Sort the block locations by their alias ordinal in the master storage tier mapping
@@ -1001,7 +1002,7 @@ public final class DefaultBlockMaster extends CoreMaster implements BlockMaster
 
     @Override
     public void heartbeat() {
-      long masterWorkerTimeoutMs = Configuration.getMs(PropertyKey.MASTER_WORKER_TIMEOUT_MS);
+      long masterWorkerTimeoutMs = ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_TIMEOUT_MS);
       for (MasterWorkerInfo worker : mWorkers) {
         synchronized (worker) {
           final long lastUpdate = mClock.millis() - worker.getLastUpdatedTimeMs();
diff --git a/core/server/master/src/main/java/alluxio/master/file/BlockIntegrityChecker.java b/core/server/master/src/main/java/alluxio/master/file/BlockIntegrityChecker.java
index eca6d68bdc..f248aba3e9 100644
--- a/core/server/master/src/main/java/alluxio/master/file/BlockIntegrityChecker.java
+++ b/core/server/master/src/main/java/alluxio/master/file/BlockIntegrityChecker.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.heartbeat.HeartbeatExecutor;
 
 import org.slf4j.Logger;
@@ -34,7 +34,7 @@ public final class BlockIntegrityChecker implements HeartbeatExecutor {
    */
   public BlockIntegrityChecker(FileSystemMaster fsm) {
     mFileSystemMaster = fsm;
-    mRepair = Configuration.getBoolean(PropertyKey.MASTER_PERIODIC_BLOCK_INTEGRITY_CHECK_REPAIR);
+    mRepair = ServerConfiguration.getBoolean(PropertyKey.MASTER_PERIODIC_BLOCK_INTEGRITY_CHECK_REPAIR);
   }
 
   @Override
diff --git a/core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java b/core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java
index c3a6078df4..cf72e75145 100644
--- a/core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java
@@ -12,9 +12,9 @@
 package alluxio.master.file;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Server;
 import alluxio.clock.SystemClock;
 import alluxio.collections.Pair;
@@ -236,10 +236,10 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
    *
    * JournalContext, BlockDeletionContext, and RpcContext
    *
-   * RpcContext is an aggregator for various contexts which get passed around through file system
+   * RpcContext is an aggregator for various contexts which create passed around through file system
    * master methods.
    *
-   * Currently there are two types of contexts that get passed around: {@link JournalContext} and
+   * Currently there are two types of contexts that create passed around: {@link JournalContext} and
    * {@link BlockDeletionContext}. These contexts are used to register work that should be done when
    * the context closes. The journal context tracks journal entries which need to be flushed, while
    * the block deletion context tracks which blocks need to be deleted in the {@link BlockMaster}.
@@ -392,10 +392,10 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
     mInodeLockManager = mInodeTree.getInodeLockManager();
 
     // TODO(gene): Handle default config value for whitelist.
-    mWhitelist = new PrefixList(Configuration.getList(PropertyKey.MASTER_WHITELIST, ","));
+    mWhitelist = new PrefixList(ServerConfiguration.getList(PropertyKey.MASTER_WHITELIST, ","));
 
     mPermissionChecker = new DefaultPermissionChecker(mInodeTree);
-    mJobMasterClientPool = new alluxio.client.job.JobMasterClientPool();
+    mJobMasterClientPool = new alluxio.client.job.JobMasterClientPool(ServerConfiguration.global());
     mPersistRequests = new java.util.concurrent.ConcurrentHashMap<>();
     mPersistJobs = new java.util.concurrent.ConcurrentHashMap<>();
     mUfsAbsentPathCache = UfsAbsentPathCache.Factory.create(mMountTable);
@@ -409,11 +409,11 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
 
   private static MountInfo getRootMountInfo(MasterUfsManager ufsManager) {
     try (CloseableResource<UnderFileSystem> resource = ufsManager.getRoot().acquireUfsResource()) {
-      String rootUfsUri = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+      String rootUfsUri = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
       boolean shared = resource.get().isObjectStorage()
-          && Configuration.getBoolean(PropertyKey.UNDERFS_OBJECT_STORE_MOUNT_SHARED_PUBLICLY);
+          && ServerConfiguration.getBoolean(PropertyKey.UNDERFS_OBJECT_STORE_MOUNT_SHARED_PUBLICLY);
       Map<String, String> rootUfsConf =
-          Configuration.getNestedProperties(PropertyKey.MASTER_MOUNT_TABLE_ROOT_OPTION);
+          ServerConfiguration.getNestedProperties(PropertyKey.MASTER_MOUNT_TABLE_ROOT_OPTION);
       MountPOptions mountOptions = MountContext
           .defaults(MountPOptions.newBuilder().setShared(shared).putAllProperties(rootUfsConf))
           .getOptions().build();
@@ -492,16 +492,18 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
       InodeDirectoryView root = mInodeTree.getRoot();
       if (root == null) {
         try (JournalContext context = createJournalContext()) {
-          mInodeTree.initializeRoot(SecurityUtils.getOwnerFromLoginModule(),
-              SecurityUtils.getGroupFromLoginModule(),
-              ModeUtils.applyDirectoryUMask(Mode.createFullAccess()), context);
+          mInodeTree.initializeRoot(SecurityUtils.getOwnerFromLoginModule(ServerConfiguration.global()),
+              SecurityUtils.getGroupFromLoginModule(ServerConfiguration.global()),
+              ModeUtils.applyDirectoryUMask(Mode.createFullAccess(),
+                  ServerConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)),
+              context);
         }
       } else {
         // For backwards-compatibility:
         // Empty root owner indicates that previously the master had no security. In this case, the
         // master is allowed to be started with security turned on.
-        String serverOwner = SecurityUtils.getOwnerFromLoginModule();
-        if (SecurityUtils.isSecurityEnabled() && !root.getOwner().isEmpty()
+        String serverOwner = SecurityUtils.getOwnerFromLoginModule(ServerConfiguration.global());
+        if (SecurityUtils.isSecurityEnabled(ServerConfiguration.global()) && !root.getOwner().isEmpty()
             && !root.getOwner().equals(serverOwner)) {
           // user is not the previous owner
           throw new PermissionDeniedException(ExceptionMessage.PERMISSION_DENIED.getMessage(String
@@ -516,9 +518,10 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
           continue;
         }
         MountInfo mountInfo = mMountTable.getMountTable().get(key);
-        UnderFileSystemConfiguration ufsConf = UnderFileSystemConfiguration.defaults()
-            .setMountSpecificConf(mountInfo.getOptions().getPropertiesMap());
-        mUfsManager.addMount(mountInfo.getMountId(), mountInfo.getUfsUri(), ufsConf);
+        UnderFileSystemConfiguration ufsConf =
+            UnderFileSystemConfiguration.defaults(ServerConfiguration.global())
+            .createMountSpecificConf(mountInfo.getOptions().getPropertiesMap());
+        mUfsManager.addMount(mountInfo.getMountId(), new AlluxioURI(key), ufsConf);
       }
       // Startup Checks and Periodic Threads.
       // Rebuild the list of persist jobs (mPersistJobs) and map of pending persist requests
@@ -545,10 +548,10 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
                     mInodeTree.getPath(inodeFile), inodeFile.getTempUfsPath());
               } else {
                 mPersistRequests.put(inodeFile.getId(), new alluxio.time.ExponentialTimer(
-                    Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS),
-                    Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS),
-                    Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS),
-                    Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS)));
+                    ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS),
+                    ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS),
+                    ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS),
+                    ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS)));
               }
             }
           }
@@ -556,34 +559,40 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
       } catch (InvalidPathException | FileDoesNotExistException e) {
         throw new IllegalStateException(e);
       }
-      if (Configuration.getBoolean(PropertyKey.MASTER_STARTUP_BLOCK_INTEGRITY_CHECK_ENABLED)) {
+      if (ServerConfiguration.getBoolean(PropertyKey.MASTER_STARTUP_BLOCK_INTEGRITY_CHECK_ENABLED)) {
         validateInodeBlocks(true);
       }
 
       int blockIntegrityCheckInterval =
-          (int) Configuration.getMs(PropertyKey.MASTER_PERIODIC_BLOCK_INTEGRITY_CHECK_INTERVAL);
+          (int) ServerConfiguration.getMs(PropertyKey.MASTER_PERIODIC_BLOCK_INTEGRITY_CHECK_INTERVAL);
+
       if (blockIntegrityCheckInterval > 0) { // negative or zero interval implies disabled
         getExecutorService().submit(
             new HeartbeatThread(HeartbeatContext.MASTER_BLOCK_INTEGRITY_CHECK,
-                new BlockIntegrityChecker(this), blockIntegrityCheckInterval));
+                new BlockIntegrityChecker(this), blockIntegrityCheckInterval,
+                ServerConfiguration.global()));
       }
       getExecutorService().submit(
           new HeartbeatThread(HeartbeatContext.MASTER_TTL_CHECK,
               new InodeTtlChecker(this, mInodeTree),
-              (int) Configuration.getMs(PropertyKey.MASTER_TTL_CHECKER_INTERVAL_MS)));
+              (int) ServerConfiguration.getMs(PropertyKey.MASTER_TTL_CHECKER_INTERVAL_MS),
+              ServerConfiguration.global()));
       getExecutorService().submit(
           new HeartbeatThread(HeartbeatContext.MASTER_LOST_FILES_DETECTION,
               new LostFileDetector(this, mInodeTree),
-              (int) Configuration.getMs(PropertyKey.MASTER_WORKER_HEARTBEAT_INTERVAL)));
+              (int) ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_HEARTBEAT_INTERVAL),
+              ServerConfiguration.global()));
       getExecutorService().submit(new HeartbeatThread(
           HeartbeatContext.MASTER_REPLICATION_CHECK,
           new alluxio.master.file.replication.ReplicationChecker(mInodeTree, mBlockMaster,
               mSafeModeManager, mJobMasterClientPool),
-          (int) Configuration.getMs(PropertyKey.MASTER_REPLICATION_CHECK_INTERVAL_MS)));
+          (int) ServerConfiguration.getMs(PropertyKey.MASTER_REPLICATION_CHECK_INTERVAL_MS),
+          ServerConfiguration.global()));
       getExecutorService().submit(
           new HeartbeatThread(HeartbeatContext.MASTER_PERSISTENCE_SCHEDULER,
               new PersistenceScheduler(),
-              (int) Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_SCHEDULER_INTERVAL_MS)));
+              (int) ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_SCHEDULER_INTERVAL_MS),
+              ServerConfiguration.global()));
       mPersistCheckerPool =
           new java.util.concurrent.ThreadPoolExecutor(PERSIST_CHECKER_POOL_THREADS,
               PERSIST_CHECKER_POOL_THREADS, 1, java.util.concurrent.TimeUnit.MINUTES,
@@ -593,20 +602,22 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
       getExecutorService().submit(
           new HeartbeatThread(HeartbeatContext.MASTER_PERSISTENCE_CHECKER,
               new PersistenceChecker(),
-              (int) Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_CHECKER_INTERVAL_MS)));
-      if (Configuration.getBoolean(PropertyKey.MASTER_STARTUP_CONSISTENCY_CHECK_ENABLED)) {
+              (int) ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_CHECKER_INTERVAL_MS)
+              , ServerConfiguration.global()));
+      if (ServerConfiguration.getBoolean(PropertyKey.MASTER_STARTUP_CONSISTENCY_CHECK_ENABLED)) {
         mStartupConsistencyCheck = getExecutorService().submit(() -> startupCheckConsistency(
             ExecutorServiceFactories
                .fixedThreadPool("startup-consistency-check", 32).create()));
       }
-      if (Configuration.getBoolean(PropertyKey.MASTER_AUDIT_LOGGING_ENABLED)) {
+      if (ServerConfiguration.getBoolean(PropertyKey.MASTER_AUDIT_LOGGING_ENABLED)) {
         mAsyncAuditLogWriter = new AsyncUserAccessAuditLogWriter();
         mAsyncAuditLogWriter.start();
       }
-      if (Configuration.getBoolean(PropertyKey.UNDERFS_CLEANUP_ENABLED)) {
+      if (ServerConfiguration.getBoolean(PropertyKey.UNDERFS_CLEANUP_ENABLED)) {
         getExecutorService().submit(
             new HeartbeatThread(HeartbeatContext.MASTER_UFS_CLEANUP, new UfsCleaner(this),
-                (int) Configuration.getMs(PropertyKey.UNDERFS_CLEANUP_INTERVAL)));
+                (int) ServerConfiguration.getMs(PropertyKey.UNDERFS_CLEANUP_INTERVAL),
+                ServerConfiguration.global()));
       }
       mSyncManager.start();
     }
@@ -755,7 +766,7 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
 
   @Override
   public StartupConsistencyCheck getStartupConsistencyCheck() {
-    if (!Configuration.getBoolean(PropertyKey.MASTER_STARTUP_CONSISTENCY_CHECK_ENABLED)) {
+    if (!ServerConfiguration.getBoolean(PropertyKey.MASTER_STARTUP_CONSISTENCY_CHECK_ENABLED)) {
       return StartupConsistencyCheck.disabled();
     }
     if (mStartupConsistencyCheck == null) {
@@ -837,7 +848,7 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
   }
 
   /**
-   * @param inodePath the {@link LockedInodePath} to get the {@link FileInfo} for
+   * @param inodePath the {@link LockedInodePath} to create the {@link FileInfo} for
    * @return the {@link FileInfo} for the given inode
    */
   private FileInfo getFileInfoInternal(LockedInodePath inodePath)
@@ -1644,7 +1655,7 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
   }
 
   /**
-   * @param inodePath the {@link LockedInodePath} to get the info for
+   * @param inodePath the {@link LockedInodePath} to create the info for
    * @return a list of {@link FileBlockInfo} for all the blocks of the given inode
    */
   private List<FileBlockInfo> getFileBlockInfoListInternal(LockedInodePath inodePath)
@@ -2297,7 +2308,7 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
 
   @Override
   public String getUfsAddress() {
-    return Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    return ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
   }
 
   @Override
@@ -2726,15 +2737,17 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
     AlluxioURI alluxioPath = inodePath.getUri();
     // Adding the mount point will not create the UFS instance and thus not connect to UFS
     mUfsManager.addMount(mountId, new AlluxioURI(ufsPath.toString()),
-        UnderFileSystemConfiguration.defaults().setReadOnly(context.getOptions().getReadOnly())
+        UnderFileSystemConfiguration.defaults(ServerConfiguration.global())
+            .setReadOnly(context.getOptions().getReadOnly())
             .setShared(context.getOptions().getShared())
-            .setMountSpecificConf(context.getOptions().getPropertiesMap()));
+            .createMountSpecificConf(context.getOptions().getPropertiesMap()));
     try {
       try (CloseableResource<UnderFileSystem> ufsResource =
           mUfsManager.get(mountId).acquireUfsResource()) {
         UnderFileSystem ufs = ufsResource.get();
         ufs.connectFromMaster(
-            NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC));
+            NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC,
+                ServerConfiguration.global()));
         // Check that the ufsPath exists and is a directory
         if (!ufs.isDirectory(ufsPath.toString())) {
           throw new IOException(
@@ -3037,7 +3050,7 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
    */
   private void checkUserBelongsToGroup(String owner, String group)
       throws IOException {
-    List<String> groups = CommonUtils.getGroups(owner);
+    List<String> groups = CommonUtils.getGroups(owner, ServerConfiguration.global());
     if (groups == null || !groups.contains(group)) {
       throw new FailedPreconditionException("Owner " + owner
           + " does not belong to the group " + group);
@@ -3075,10 +3088,10 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
           .setPersistenceState(PersistenceState.TO_BE_PERSISTED.name())
           .build());
       mPersistRequests.put(inodePath.getInode().getId(), new alluxio.time.ExponentialTimer(
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS),
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS),
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS),
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS)));
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS),
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS),
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS),
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS)));
     }
   }
 
@@ -3759,10 +3772,10 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
     alluxio.time.ExponentialTimer timer = mPersistRequests.remove(fileId);
     if (timer == null) {
       timer = new alluxio.time.ExponentialTimer(
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS),
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS),
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS),
-          Configuration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS));
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS),
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS),
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS),
+          ServerConfiguration.getMs(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS));
     }
     mPersistJobs.put(fileId, new PersistJob(jobId, fileId, uri, tempUfsPath, timer));
   }
@@ -4306,7 +4319,7 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
               .getMetricName(MasterMetrics.PATHS_TOTAL),
           () -> master.getNumberOfPaths());
 
-      final String ufsDataFolder = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+      final String ufsDataFolder = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
 
       MetricsSystem.registerGaugeIfAbsent(MetricsSystem
               .getMetricName(MasterMetrics.UFS_CAPACITY_TOTAL),
@@ -4369,17 +4382,17 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
     FileSystemMasterAuditContext auditContext =
         new FileSystemMasterAuditContext(mAsyncAuditLogWriter);
     if (mAsyncAuditLogWriter != null) {
-      String user = AuthenticatedClientUser.getClientUser();
+      String user = AuthenticatedClientUser.getClientUser(ServerConfiguration.global());
       String ugi;
       try {
-        String primaryGroup = CommonUtils.getPrimaryGroupName(user);
+        String primaryGroup = CommonUtils.getPrimaryGroupName(user, ServerConfiguration.global());
         ugi = user + "," + primaryGroup;
       } catch (IOException e) {
-        LOG.warn("Failed to get primary group for user {}.", user);
+        LOG.warn("Failed to create primary group for user {}.", user);
         ugi = user;
       }
       AuthType authType =
-          Configuration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
+          ServerConfiguration.getEnum(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.class);
       auditContext.setUgi(ugi)
           .setAuthType(authType)
           .setIp(ClientIpAddressInjector.getIpAddress())
@@ -4427,6 +4440,6 @@ public final class DefaultFileSystemMaster extends CoreMaster implements FileSys
   }
 
   private boolean isAclEnabled() {
-    return Configuration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED);
+    return ServerConfiguration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED);
   }
 }
diff --git a/core/server/master/src/main/java/alluxio/master/file/DefaultPermissionChecker.java b/core/server/master/src/main/java/alluxio/master/file/DefaultPermissionChecker.java
index 6565d7e929..2daa25591c 100644
--- a/core/server/master/src/main/java/alluxio/master/file/DefaultPermissionChecker.java
+++ b/core/server/master/src/main/java/alluxio/master/file/DefaultPermissionChecker.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.InvalidPathException;
@@ -55,9 +55,9 @@ public class DefaultPermissionChecker implements PermissionChecker {
   public DefaultPermissionChecker(InodeTree inodeTree) {
     mInodeTree = Preconditions.checkNotNull(inodeTree, "inodeTree");
     mPermissionCheckEnabled =
-        Configuration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED);
+        ServerConfiguration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED);
     mFileSystemSuperGroup =
-        Configuration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP);
+        ServerConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP);
   }
 
   @Override
@@ -77,7 +77,7 @@ public class DefaultPermissionChecker implements PermissionChecker {
     List<InodeView> inodeList = inodePath.getInodeList();
 
     // collects user and groups
-    String user = AuthenticatedClientUser.getClientUser();
+    String user = AuthenticatedClientUser.getClientUser(ServerConfiguration.global());
     List<String> groups = getGroups(user);
 
     // remove the last element if all components of the path exist, since we only check the parent.
@@ -98,7 +98,7 @@ public class DefaultPermissionChecker implements PermissionChecker {
     List<InodeView> inodeList = inodePath.getInodeList();
 
     // collects user and groups
-    String user = AuthenticatedClientUser.getClientUser();
+    String user = AuthenticatedClientUser.getClientUser(ServerConfiguration.global());
     List<String> groups = getGroups(user);
 
     checkInodeList(user, groups, bits, inodePath.getUri().getPath(), inodeList, false);
@@ -114,7 +114,7 @@ public class DefaultPermissionChecker implements PermissionChecker {
 
     // collects user and groups
     try {
-      String user = AuthenticatedClientUser.getClientUser();
+      String user = AuthenticatedClientUser.getClientUser(ServerConfiguration.global());
       List<String> groups = getGroups(user);
       return getPermissionInternal(user, groups, inodePath.getUri().getPath(), inodeList);
     } catch (AccessControlException e) {
@@ -141,13 +141,13 @@ public class DefaultPermissionChecker implements PermissionChecker {
   }
 
   /**
-   * @param user the user to get groups for
+   * @param user the user to create groups for
    * @return the groups for the given user
    * @throws AccessControlException if the group service information cannot be accessed
    */
   private List<String> getGroups(String user) throws AccessControlException {
     try {
-      return CommonUtils.getGroups(user);
+      return CommonUtils.getGroups(user, ServerConfiguration.global());
     } catch (IOException e) {
       throw new AccessControlException(
           ExceptionMessage.PERMISSION_DENIED.getMessage(e.getMessage()));
@@ -167,7 +167,7 @@ public class DefaultPermissionChecker implements PermissionChecker {
     List<InodeView> inodeList = inodePath.getInodeList();
 
     // collects user and groups
-    String user = AuthenticatedClientUser.getClientUser();
+    String user = AuthenticatedClientUser.getClientUser(ServerConfiguration.global());
     List<String> groups = getGroups(user);
 
     if (isPrivilegedUser(user, groups)) {
@@ -184,7 +184,7 @@ public class DefaultPermissionChecker implements PermissionChecker {
    */
   private void checkSuperUser() throws AccessControlException {
     // collects user and groups
-    String user = AuthenticatedClientUser.getClientUser();
+    String user = AuthenticatedClientUser.getClientUser(ServerConfiguration.global());
     List<String> groups = getGroups(user);
     if (!isPrivilegedUser(user, groups)) {
       throw new AccessControlException(ExceptionMessage.PERMISSION_DENIED
diff --git a/core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java b/core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java
index 6cb8e1f916..04cab90f3a 100644
--- a/core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java
@@ -80,7 +80,7 @@ public interface FileSystemMaster extends Master {
    * <p>
    * This operation requires users to have READ permission of the path.
    *
-   * @param path the path to get the file id for
+   * @param path the path to create the file id for
    * @return the file id for a given path, or -1 if there is no file at that path
    * @throws AccessControlException if permission checking fails
    */
@@ -90,7 +90,7 @@ public interface FileSystemMaster extends Master {
    * Returns the {@link FileInfo} for a given file id. This method is not user-facing but supposed
    * to be called by other internal servers (e.g., block workers, web UI).
    *
-   * @param fileId the file id to get the {@link FileInfo} for
+   * @param fileId the file id to create the {@link FileInfo} for
    * @return the {@link FileInfo} for the given file
    * @throws FileDoesNotExistException if the file does not exist
    * @throws AccessControlException if permission denied
@@ -104,7 +104,7 @@ public interface FileSystemMaster extends Master {
    * <p>
    * This operation requires users to have READ permission on the path.
    *
-   * @param path the path to get the {@link FileInfo} for
+   * @param path the path to create the {@link FileInfo} for
    * @param context the method context
    * @return the {@link FileInfo} for the given file id
    * @throws FileDoesNotExistException if the file does not exist
@@ -133,7 +133,7 @@ public interface FileSystemMaster extends Master {
    * This operation requires users to have READ permission on the path, and also
    * EXECUTE permission on the path if it is a directory.
    *
-   * @param path the path to get the {@link FileInfo} list for
+   * @param path the path to create the {@link FileInfo} list for
    * @param context the method context
    * @return the list of {@link FileInfo}s
    * @throws AccessControlException if permission checking fails
@@ -206,7 +206,7 @@ public interface FileSystemMaster extends Master {
    * This operation requires users to have WRITE permission on the path as this API is called when
    * creating a new block for a file.
    *
-   * @param path the path of the file to get the next block id for
+   * @param path the path of the file to create the next block id for
    * @return the next block id for the given file
    * @throws FileDoesNotExistException if the file does not exist
    * @throws InvalidPathException if the given path is not valid
@@ -260,7 +260,7 @@ public interface FileSystemMaster extends Master {
    * <p>
    * This operation requires the client user to have READ permission on the the path.
    *
-   * @param path the path to get the info for
+   * @param path the path to create the info for
    * @return a list of {@link FileBlockInfo} for all the blocks of the given path
    * @throws FileDoesNotExistException if the file does not exist or path is a directory
    * @throws InvalidPathException if the path of the given file is invalid
diff --git a/core/server/master/src/main/java/alluxio/master/file/FileSystemMasterOptions.java b/core/server/master/src/main/java/alluxio/master/file/FileSystemMasterOptions.java
index 7b741e4d24..8765306931 100644
--- a/core/server/master/src/main/java/alluxio/master/file/FileSystemMasterOptions.java
+++ b/core/server/master/src/main/java/alluxio/master/file/FileSystemMasterOptions.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.grpc.CheckConsistencyPOptions;
 import alluxio.grpc.CompleteFilePOptions;
@@ -48,10 +48,10 @@ public final class FileSystemMasterOptions{
    */
   private static FileSystemMasterCommonPOptions commonDefaults() {
     return FileSystemMasterCommonPOptions.newBuilder()
-        .setTtl(Configuration.getLong(PropertyKey.USER_FILE_CREATE_TTL))
+        .setTtl(ServerConfiguration.getLong(PropertyKey.USER_FILE_CREATE_TTL))
         .setTtlAction(
-            Configuration.getEnum(PropertyKey.USER_FILE_CREATE_TTL_ACTION, TtlAction.class))
-        .setSyncIntervalMs(Configuration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL))
+            ServerConfiguration.getEnum(PropertyKey.USER_FILE_CREATE_TTL_ACTION, TtlAction.class))
+        .setSyncIntervalMs(ServerConfiguration.getMs(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL))
         .build();
   }
 
@@ -71,9 +71,10 @@ public final class FileSystemMasterOptions{
   public static CreateDirectoryPOptions createDirectoryDefaults() {
     return CreateDirectoryPOptions.newBuilder()
         .setCommonOptions(commonDefaults())
-        .setMode(ModeUtils.applyDirectoryUMask(Mode.defaults()).toProto())
+        .setMode(ModeUtils.applyDirectoryUMask(Mode.defaults(),
+            ServerConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)).toProto())
         .setRecursive(false)
-        .setWriteType(Configuration
+        .setWriteType(ServerConfiguration
             .getEnum(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class).toProto())
         .setAllowExists(false).build();
   }
@@ -85,15 +86,18 @@ public final class FileSystemMasterOptions{
     return CreateFilePOptions.newBuilder()
         .setCommonOptions(commonDefaults())
         .setRecursive(false)
-        .setBlockSizeBytes(Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT))
-        .setFileWriteLocationPolicy(Configuration.get(PropertyKey.USER_FILE_WRITE_LOCATION_POLICY))
-        .setWriteTier(Configuration.getInt(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT))
-        .setWriteType(Configuration
+        .setBlockSizeBytes(ServerConfiguration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT))
+        .setFileWriteLocationPolicy(
+            ServerConfiguration.get(PropertyKey.USER_FILE_WRITE_LOCATION_POLICY))
+        .setWriteTier(ServerConfiguration.getInt(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT))
+        .setWriteType(ServerConfiguration
             .getEnum(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class).toProto())
-        .setMode(ModeUtils.applyFileUMask(Mode.defaults()).toProto())
-        .setReplicationDurable(Configuration.getInt(PropertyKey.USER_FILE_REPLICATION_DURABLE))
-        .setReplicationMin(Configuration.getInt(PropertyKey.USER_FILE_REPLICATION_MIN))
-        .setReplicationMax(Configuration.getInt(PropertyKey.USER_FILE_REPLICATION_MAX)).build();
+        .setMode(ModeUtils.applyFileUMask(Mode.defaults(),
+            ServerConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)).toProto())
+        .setReplicationDurable(ServerConfiguration.getInt(PropertyKey.USER_FILE_REPLICATION_DURABLE))
+        .setReplicationMin(ServerConfiguration.getInt(PropertyKey.USER_FILE_REPLICATION_MIN))
+        .setReplicationMax(ServerConfiguration.getInt(PropertyKey.USER_FILE_REPLICATION_MAX))
+               .build();
   }
 
   /**
@@ -104,7 +108,7 @@ public final class FileSystemMasterOptions{
         .setCommonOptions(commonDefaults())
         .setRecursive(false)
         .setAlluxioOnly(false)
-        .setUnchecked(Configuration.getBoolean(PropertyKey.USER_FILE_DELETE_UNCHECKED)).build();
+        .setUnchecked(ServerConfiguration.getBoolean(PropertyKey.USER_FILE_DELETE_UNCHECKED)).build();
   }
 
   /**
@@ -124,7 +128,7 @@ public final class FileSystemMasterOptions{
   public static GetStatusPOptions getStatusDefaults() {
     return GetStatusPOptions.newBuilder()
         .setCommonOptions(commonDefaults())
-        .setLoadMetadataType(GrpcUtils.toProto(Configuration
+        .setLoadMetadataType(GrpcUtils.toProto(ServerConfiguration
             .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class)))
         .build();
   }
@@ -135,7 +139,7 @@ public final class FileSystemMasterOptions{
   public static ListStatusPOptions listStatusDefaults() {
     return ListStatusPOptions.newBuilder()
         .setCommonOptions(commonDefaults())
-        .setLoadMetadataType(GrpcUtils.toProto(Configuration
+        .setLoadMetadataType(GrpcUtils.toProto(ServerConfiguration
             .getEnum(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.class)))
         .build();
   }
diff --git a/core/server/master/src/main/java/alluxio/master/file/LostFileDetector.java b/core/server/master/src/main/java/alluxio/master/file/LostFileDetector.java
index f1a6299166..ce150a47be 100644
--- a/core/server/master/src/main/java/alluxio/master/file/LostFileDetector.java
+++ b/core/server/master/src/main/java/alluxio/master/file/LostFileDetector.java
@@ -59,7 +59,7 @@ final class LostFileDetector implements HeartbeatExecutor {
               .build());
         }
       } catch (FileDoesNotExistException e) {
-        LOG.debug("Exception trying to get inode from inode tree", e);
+        LOG.debug("Exception trying to create inode from inode tree", e);
       } catch (UnavailableException e) {
         LOG.warn("Failed to run lost file detector: {}", e.toString());
       }
diff --git a/core/server/master/src/main/java/alluxio/master/file/RpcContext.java b/core/server/master/src/main/java/alluxio/master/file/RpcContext.java
index ea631e57c3..2ca6c0098f 100644
--- a/core/server/master/src/main/java/alluxio/master/file/RpcContext.java
+++ b/core/server/master/src/main/java/alluxio/master/file/RpcContext.java
@@ -81,7 +81,7 @@ public final class RpcContext implements Closeable, Supplier<JournalContext> {
   @Override
   public void close() throws UnavailableException {
     // JournalContext is closed before block deletion context so that file system master changes
-    // get written before block master changes. If a failure occurs between deleting an inode and
+    // create written before block master changes. If a failure occurs between deleting an inode and
     // remove its blocks, it's better to have an orphaned block than an inode with a missing block.
     closeQuietly(mJournalContext);
     closeQuietly(mBlockDeletionContext);
diff --git a/core/server/master/src/main/java/alluxio/master/file/async/AsyncPersistHandler.java b/core/server/master/src/main/java/alluxio/master/file/async/AsyncPersistHandler.java
index cf672c9a37..cc2e44e40b 100644
--- a/core/server/master/src/main/java/alluxio/master/file/async/AsyncPersistHandler.java
+++ b/core/server/master/src/main/java/alluxio/master/file/async/AsyncPersistHandler.java
@@ -12,8 +12,8 @@
 package alluxio.master.file.async;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.FileDoesNotExistException;
@@ -54,7 +54,7 @@ public interface AsyncPersistHandler {
      */
     public static AsyncPersistHandler create(FileSystemMasterView view) {
       return CommonUtils.createNewClassInstance(
-          Configuration
+          ServerConfiguration
               .<AsyncPersistHandler>getClass(PropertyKey.MASTER_FILE_ASYNC_PERSIST_HANDLER),
           new Class[] {FileSystemMasterView.class}, new Object[] {view});
     }
diff --git a/core/server/master/src/main/java/alluxio/master/file/contexts/CreatePathContext.java b/core/server/master/src/main/java/alluxio/master/file/contexts/CreatePathContext.java
index b4af87e11d..42dd009fbc 100644
--- a/core/server/master/src/main/java/alluxio/master/file/contexts/CreatePathContext.java
+++ b/core/server/master/src/main/java/alluxio/master/file/contexts/CreatePathContext.java
@@ -12,6 +12,8 @@
 package alluxio.master.file.contexts;
 
 import alluxio.client.WriteType;
+import alluxio.conf.ServerConfiguration;
+import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.TtlAction;
@@ -71,9 +73,9 @@ public abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>,
     mMetadataLoad = false;
     mGroup = "";
     mOwner = "";
-    if (SecurityUtils.isAuthenticationEnabled()) {
-      mOwner = SecurityUtils.getOwnerFromGrpcClient();
-      mGroup = SecurityUtils.getGroupFromGrpcClient();
+    if (SecurityUtils.isAuthenticationEnabled(ServerConfiguration.global())) {
+      mOwner = SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global());
+      mGroup = SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global());
     }
     // Initialize mPersisted based on proto write type.
     WritePType writeType = WritePType.NONE;
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/AsyncUfsAbsentPathCache.java b/core/server/master/src/main/java/alluxio/master/file/meta/AsyncUfsAbsentPathCache.java
index 9c3836b9e9..004c58a09e 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/AsyncUfsAbsentPathCache.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/AsyncUfsAbsentPathCache.java
@@ -12,8 +12,8 @@
 package alluxio.master.file.meta;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.InvalidPathException;
 import alluxio.master.file.meta.options.MountInfo;
 import alluxio.resource.CloseableResource;
@@ -52,7 +52,7 @@ public final class AsyncUfsAbsentPathCache implements UfsAbsentPathCache {
   private static final int THREAD_KEEP_ALIVE_SECONDS = 60;
   /** Number of paths to cache. */
   private static final int MAX_PATHS =
-      Configuration.getInt(PropertyKey.MASTER_UFS_PATH_CACHE_CAPACITY);
+      ServerConfiguration.getInt(PropertyKey.MASTER_UFS_PATH_CACHE_CAPACITY);
 
   /** The mount table. */
   private final MountTable mMountTable;
@@ -205,7 +205,7 @@ public final class AsyncUfsAbsentPathCache implements UfsAbsentPathCache {
   }
 
   /**
-   * @param alluxioUri the Alluxio path to get the mount info for
+   * @param alluxioUri the Alluxio path to create the mount info for
    * @return the {@link MountInfo} of the given Alluxio path, or null if it doesn't exist
    */
   private MountInfo getMountInfo(AlluxioURI alluxioUri) {
@@ -214,7 +214,7 @@ public final class AsyncUfsAbsentPathCache implements UfsAbsentPathCache {
       return mMountTable.getMountInfo(resolution.getMountId());
     } catch (Exception e) {
       // Catch Exception in case the mount point doesn't exist currently.
-      LOG.warn("Failed to get mount info for path {}. message: {}", alluxioUri, e.getMessage());
+      LOG.warn("Failed to create mount info for path {}. message: {}", alluxioUri, e.getMessage());
       return null;
     }
   }
@@ -223,7 +223,7 @@ public final class AsyncUfsAbsentPathCache implements UfsAbsentPathCache {
    * Returns a sequence of Alluxio paths for a specified path, starting from the path component at
    * a specific index, to the specified path.
    *
-   * @param alluxioUri the Alluxio path to get the nested paths for
+   * @param alluxioUri the Alluxio path to create the nested paths for
    * @param startComponentIndex the index to the starting path component,
    *        root directory has index 0
    * @return a list of nested paths from the starting component to the given path
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/FileSystemMasterView.java b/core/server/master/src/main/java/alluxio/master/file/meta/FileSystemMasterView.java
index ad007530e1..5ed64525e9 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/FileSystemMasterView.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/FileSystemMasterView.java
@@ -58,7 +58,7 @@ public final class FileSystemMasterView {
   /**
    * Returns the {@link FileInfo} for a given path. Called via RPC, as well as internal masters.
    *
-   * @param fileId the file id to get the {@link FileInfo} for
+   * @param fileId the file id to create the {@link FileInfo} for
    * @return the {@link FileInfo} for the given file id
    * @throws FileDoesNotExistException if the file does not exist
    * @throws AccessControlException if permission denied
@@ -79,7 +79,7 @@ public final class FileSystemMasterView {
    * Returns the file id for a given path. If the given path does not exist in Alluxio, the method
    * attempts to load it from UFS.
    *
-   * @param path the path to get the file id for
+   * @param path the path to create the file id for
    * @return the file id for a given path, or -1 if there is no file at that path
    * @throws AccessControlException if permission checking fails
    * @throws FileDoesNotExistException if file does not exist
@@ -90,7 +90,7 @@ public final class FileSystemMasterView {
   }
 
   /**
-   * @param path the path to get the info for
+   * @param path the path to create the info for
    * @return a list of {@link FileBlockInfo} for all the blocks of the given file
    * @throws FileDoesNotExistException if the file does not exist
    * @throws InvalidPathException if the path of the given file is invalid
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/InodeFileView.java b/core/server/master/src/main/java/alluxio/master/file/meta/InodeFileView.java
index 5e91cd8911..a04571c0fd 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/InodeFileView.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/InodeFileView.java
@@ -68,7 +68,7 @@ public interface InodeFileView extends InodeView {
   /**
    * Gets the block id for a given index.
    *
-   * @param blockIndex the index to get the block id for
+   * @param blockIndex the index to create the block id for
    * @return the block id for the index
    * @throws BlockInfoException if the index of the block is out of range
    */
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/InodeTree.java b/core/server/master/src/main/java/alluxio/master/file/meta/InodeTree.java
index f91db6eff3..312320e241 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/InodeTree.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/InodeTree.java
@@ -13,6 +13,7 @@ package alluxio.master.file.meta;
 
 import alluxio.AlluxioURI;
 import alluxio.collections.Pair;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.BlockInfoException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileAlreadyExistsException;
@@ -205,8 +206,8 @@ public class InodeTree implements JournalEntryIterable, JournalEntryReplayable {
   private final InodeDirectoryIdGenerator mDirectoryIdGenerator;
 
   /**
-   * @param containerIdGenerator the container id generator to use to get new container ids
-   * @param directoryIdGenerator the directory id generator to use to get new directory ids
+   * @param containerIdGenerator the container id generator to use to create new container ids
+   * @param directoryIdGenerator the directory id generator to use to create new directory ids
    * @param mountTable the mount table to manage the file system mount points
    */
   public InodeTree(ContainerIdGenerable containerIdGenerator,
@@ -340,7 +341,7 @@ public class InodeTree implements JournalEntryIterable, JournalEntryReplayable {
   }
 
   /**
-   * @param id the id to get the inode for
+   * @param id the id to create the inode for
    * @return whether the inode exists
    */
   public boolean inodeIdExists(long id) {
@@ -562,7 +563,7 @@ public class InodeTree implements JournalEntryIterable, JournalEntryReplayable {
    * Returns the path for a particular inode. The inode and the path to the inode must already be
    * locked.
    *
-   * @param inode the {@link Inode} to get the path for
+   * @param inode the {@link Inode} to create the path for
    * @return the {@link AlluxioURI} for the path of the inode
    * @throws FileDoesNotExistException if the path does not exist
    */
@@ -1129,7 +1130,8 @@ public class InodeTree implements JournalEntryIterable, JournalEntryReplayable {
     String ufsUri = resolution.getUri().toString();
     try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {
       UnderFileSystem ufs = ufsResource.get();
-      MkdirsOptions mkdirsOptions = MkdirsOptions.defaults().setCreateParent(false)
+      MkdirsOptions mkdirsOptions =
+          MkdirsOptions.defaults(ServerConfiguration.global()).setCreateParent(false)
           .setOwner(dir.getOwner()).setGroup(dir.getGroup()).setMode(new Mode(dir.getMode()));
       if (!ufs.mkdirs(ufsUri, mkdirsOptions)) {
         // Directory might already exist. Try loading the status from ufs.
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/LazyUfsBlockLocationCache.java b/core/server/master/src/main/java/alluxio/master/file/meta/LazyUfsBlockLocationCache.java
index fad9e535b1..e75f76a33c 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/LazyUfsBlockLocationCache.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/LazyUfsBlockLocationCache.java
@@ -12,8 +12,8 @@
 package alluxio.master.file.meta;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.InvalidPathException;
 import alluxio.resource.CloseableResource;
 import alluxio.underfs.UnderFileSystem;
@@ -38,7 +38,7 @@ public class LazyUfsBlockLocationCache implements UfsBlockLocationCache {
 
   /** Number of blocks to cache. */
   private static final int MAX_BLOCKS =
-      Configuration.getInt(PropertyKey.MASTER_UFS_BLOCK_LOCATION_CACHE_CAPACITY);
+      ServerConfiguration.getInt(PropertyKey.MASTER_UFS_BLOCK_LOCATION_CACHE_CAPACITY);
 
   /** Cache of ufs block locations, key is block ID, value is block locations. */
   private Cache<Long, List<String>> mCache;
@@ -82,7 +82,7 @@ public class LazyUfsBlockLocationCache implements UfsBlockLocationCache {
         return locations;
       }
     } catch (InvalidPathException | IOException e) {
-      LOG.warn("Failed to get locations for block {} in file {} with offset {}: {}",
+      LOG.warn("Failed to create locations for block {} in file {} with offset {}: {}",
           blockId, fileUri, offset, e);
     }
     return null;
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/LockedInodePathList.java b/core/server/master/src/main/java/alluxio/master/file/meta/LockedInodePathList.java
index 3fda7dc3d4..ca7c3f9e8d 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/LockedInodePathList.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/LockedInodePathList.java
@@ -32,7 +32,7 @@ public class LockedInodePathList implements AutoCloseable {
   }
 
   /**
-   * get the associated inodePathList.
+   * create the associated inodePathList.
    * @return the list of inodePaths
    */
   public List<LockedInodePath> getInodePathList() {
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/TtlBucket.java b/core/server/master/src/main/java/alluxio/master/file/meta/TtlBucket.java
index cc7d77a283..ab45704a95 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/TtlBucket.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/TtlBucket.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.file.meta;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.collections.ConcurrentHashSet;
 
 import com.google.common.base.Objects;
@@ -34,7 +34,7 @@ public final class TtlBucket implements Comparable<TtlBucket> {
    * This field is intentionally not final so that tests can change the value.
    */
   private static long sTtlIntervalMs =
-      Configuration.getMs(PropertyKey.MASTER_TTL_CHECKER_INTERVAL_MS);
+      ServerConfiguration.getMs(PropertyKey.MASTER_TTL_CHECKER_INTERVAL_MS);
   /**
    * Each bucket has a time to live interval, this value is the start of the interval, interval
    * value is the same as the configuration of {@link PropertyKey#MASTER_TTL_CHECKER_INTERVAL_MS}.
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/UfsAbsentPathCache.java b/core/server/master/src/main/java/alluxio/master/file/meta/UfsAbsentPathCache.java
index 98d3bf0053..531ec6c40b 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/UfsAbsentPathCache.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/UfsAbsentPathCache.java
@@ -12,8 +12,8 @@
 package alluxio.master.file.meta;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -59,7 +59,7 @@ public interface UfsAbsentPathCache {
     private Factory() {} // prevent instantiation
 
     public static UfsAbsentPathCache create(MountTable mountTable) {
-      int numThreads = Configuration.getInt(PropertyKey.MASTER_UFS_PATH_CACHE_THREADS);
+      int numThreads = ServerConfiguration.getInt(PropertyKey.MASTER_UFS_PATH_CACHE_THREADS);
       if (numThreads <= 0) {
         LOG.info("UfsAbsentPathCache is disabled. {}: {}",
             PropertyKey.MASTER_UFS_PATH_CACHE_THREADS, numThreads);
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/UfsBlockLocationCache.java b/core/server/master/src/main/java/alluxio/master/file/meta/UfsBlockLocationCache.java
index fc04badb46..db21daa131 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/UfsBlockLocationCache.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/UfsBlockLocationCache.java
@@ -28,12 +28,12 @@ public interface UfsBlockLocationCache {
   /**
    * If the locations exist in the cache, return them, otherwise, retrieves the block locations
    * from UFS, and caches the result.
-   * If failed to get the locations from UFS, {@code null} is returned and nothing is cached.
+   * If failed to create the locations from UFS, {@code null} is returned and nothing is cached.
    *
    * @param blockId the block ID
    * @param fileUri the URI of the file which contains the block
    * @param offset the block's offset in the file
-   * @return the block locations or null if it fails to get the locations from UFS
+   * @return the block locations or null if it fails to create the locations from UFS
    */
   List<String> get(long blockId, AlluxioURI fileUri, long offset);
 
diff --git a/core/server/master/src/main/java/alluxio/master/file/meta/UfsSyncPathCache.java b/core/server/master/src/main/java/alluxio/master/file/meta/UfsSyncPathCache.java
index 3d05f432e8..29f9561946 100644
--- a/core/server/master/src/main/java/alluxio/master/file/meta/UfsSyncPathCache.java
+++ b/core/server/master/src/main/java/alluxio/master/file/meta/UfsSyncPathCache.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.file.meta;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
@@ -30,7 +30,7 @@ public final class UfsSyncPathCache {
 
   /** Number of paths to cache. */
   private static final int MAX_PATHS =
-      Configuration.getInt(PropertyKey.MASTER_UFS_PATH_CACHE_CAPACITY);
+      ServerConfiguration.getInt(PropertyKey.MASTER_UFS_PATH_CACHE_CAPACITY);
 
   /** Cache of paths which have been synced. */
   private final Cache<String, Long> mCache;
diff --git a/core/server/master/src/main/java/alluxio/master/meta/AlluxioMasterRestServiceHandler.java b/core/server/master/src/main/java/alluxio/master/meta/AlluxioMasterRestServiceHandler.java
index a3fd842b20..c55647e766 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/AlluxioMasterRestServiceHandler.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/AlluxioMasterRestServiceHandler.java
@@ -12,8 +12,9 @@
 package alluxio.master.meta;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.ConfigurationValueOptions;
 import alluxio.MasterStorageTierAssoc;
 import alluxio.RestUtils;
 import alluxio.RuntimeConstants;
@@ -110,7 +111,7 @@ public final class AlluxioMasterRestServiceHandler {
   }
 
   /**
-   * @summary get the Alluxio master information
+   * @summary create the Alluxio master information
    * @param rawConfiguration if it's true, raw configuration values are returned,
    *    otherwise, they are looked up; if it's not provided in URL queries, then
    *    it is null, which means false.
@@ -140,11 +141,11 @@ public final class AlluxioMasterRestServiceHandler {
           .setUptimeMs(mMasterProcess.getUptimeMs())
           .setVersion(RuntimeConstants.VERSION)
           .setWorkers(mBlockMaster.getWorkerInfoList());
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the configuration map, the keys are ordered alphabetically.
+   * @summary create the configuration map, the keys are ordered alphabetically.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -154,11 +155,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.util.SortedMap<java.lang.String, java.lang.String>")
   @Deprecated
   public Response getConfiguration() {
-    return RestUtils.call(() -> getConfigurationInternal(true));
+    return RestUtils.call(() -> getConfigurationInternal(true), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the master metrics, the keys are ordered alphabetically.
+   * @summary create the master metrics, the keys are ordered alphabetically.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -168,11 +169,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.util.SortedMap<java.lang.String, java.lang.Long>")
   @Deprecated
   public Response getMetrics() {
-    return RestUtils.call(this::getMetricsInternal);
+    return RestUtils.call(this::getMetricsInternal, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the master rpc address
+   * @summary create the master rpc address
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -182,11 +183,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.String")
   @Deprecated
   public Response getRpcAddress() {
-    return RestUtils.call(() -> mMasterProcess.getRpcAddress().toString());
+    return RestUtils.call(() -> mMasterProcess.getRpcAddress().toString(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the start time of the master
+   * @summary create the start time of the master
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -196,11 +197,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getStartTimeMs() {
-    return RestUtils.call(() -> mMasterProcess.getStartTimeMs());
+    return RestUtils.call(() -> mMasterProcess.getStartTimeMs(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the uptime of the master
+   * @summary create the uptime of the master
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -210,11 +211,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getUptimeMs() {
-    return RestUtils.call(() -> mMasterProcess.getUptimeMs());
+    return RestUtils.call(() -> mMasterProcess.getUptimeMs(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the version of the master
+   * @summary create the version of the master
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -224,11 +225,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.String")
   @Deprecated
   public Response getVersion() {
-    return RestUtils.call(() -> RuntimeConstants.VERSION);
+    return RestUtils.call(() -> RuntimeConstants.VERSION, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the total capacity of all workers in bytes
+   * @summary create the total capacity of all workers in bytes
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -238,11 +239,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getCapacityBytes() {
-    return RestUtils.call(() -> mBlockMaster.getCapacityBytes());
+    return RestUtils.call(() -> mBlockMaster.getCapacityBytes(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the used capacity
+   * @summary create the used capacity
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -252,11 +253,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getUsedBytes() {
-    return RestUtils.call(() -> mBlockMaster.getUsedBytes());
+    return RestUtils.call(() -> mBlockMaster.getUsedBytes(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the free capacity
+   * @summary create the free capacity
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -266,11 +267,12 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getFreeBytes() {
-    return RestUtils.call(() -> mBlockMaster.getCapacityBytes() - mBlockMaster.getUsedBytes());
+    return RestUtils.call(() -> mBlockMaster.getCapacityBytes() - mBlockMaster.getUsedBytes(),
+        ServerConfiguration.global());
   }
 
   /**
-   * @summary get the total ufs capacity in bytes, a negative value means the capacity is unknown.
+   * @summary create the total ufs capacity in bytes, a negative value means the capacity is unknown.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -280,11 +282,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getUfsCapacityBytes() {
-    return RestUtils.call(() -> getUfsCapacityInternal().getTotal());
+    return RestUtils.call(() -> getUfsCapacityInternal().getTotal(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the used disk capacity, a negative value means the capacity is unknown.
+   * @summary create the used disk capacity, a negative value means the capacity is unknown.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -294,11 +296,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getUfsUsedBytes() {
-    return RestUtils.call(() -> getUfsCapacityInternal().getUsed());
+    return RestUtils.call(() -> getUfsCapacityInternal().getUsed(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the free ufs capacity in bytes, a negative value means the capacity is unknown.
+   * @summary create the free ufs capacity in bytes, a negative value means the capacity is unknown.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -315,7 +317,7 @@ public final class AlluxioMasterRestServiceHandler {
         return capacity.getTotal() - capacity.getUsed();
       }
       return -1;
-    });
+    }, ServerConfiguration.global());
   }
 
   private Comparator<String> getTierAliasComparator() {
@@ -332,7 +334,7 @@ public final class AlluxioMasterRestServiceHandler {
   }
 
   /**
-   * @summary get the mapping from tier alias to total capacity of the tier in bytes, keys are in
+   * @summary create the mapping from tier alias to total capacity of the tier in bytes, keys are in
    *    the order from tier alias with smaller ordinal to those with larger ones.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
@@ -349,11 +351,11 @@ public final class AlluxioMasterRestServiceHandler {
         capacityBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());
       }
       return capacityBytesOnTiers;
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the mapping from tier alias to the used bytes of the tier, keys are in the order
+   * @summary create the mapping from tier alias to the used bytes of the tier, keys are in the order
    *    from tier alias with smaller ordinal to those with larger ones.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
@@ -370,11 +372,11 @@ public final class AlluxioMasterRestServiceHandler {
         usedBytesOnTiers.put(tierBytes.getKey(), tierBytes.getValue());
       }
       return usedBytesOnTiers;
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the count of workers
+   * @summary create the count of workers
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -384,11 +386,11 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.lang.Integer")
   @Deprecated
   public Response getWorkerCount() {
-    return RestUtils.call(()->mBlockMaster.getWorkerCount());
+    return RestUtils.call(()->mBlockMaster.getWorkerCount(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the list of worker descriptors
+   * @summary create the list of worker descriptors
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -398,7 +400,7 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("java.util.List<alluxio.wire.WorkerInfo>")
   @Deprecated
   public Response getWorkerInfoList() {
-    return RestUtils.call(()-> mBlockMaster.getWorkerInfoList());
+    return RestUtils.call(()-> mBlockMaster.getWorkerInfoList(), ServerConfiguration.global());
   }
 
   private Capacity getCapacityInternal() {
@@ -407,7 +409,7 @@ public final class AlluxioMasterRestServiceHandler {
   }
 
   private Map<String, String> getConfigurationInternal(boolean raw) {
-    return new TreeMap<>(Configuration
+    return new TreeMap<>(ServerConfiguration
         .toMap(ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(raw)));
   }
 
@@ -483,6 +485,6 @@ public final class AlluxioMasterRestServiceHandler {
   @ReturnType("alluxio.wire.LogInfo")
   public Response logLevel(@QueryParam(LOG_ARGUMENT_NAME) final String logName, @QueryParam
       (LOG_ARGUMENT_LEVEL) final String level) {
-    return RestUtils.call(() -> LogUtils.setLogLevel(logName, level));
+    return RestUtils.call(() -> LogUtils.setLogLevel(logName, level), ServerConfiguration.global());
   }
 }
diff --git a/core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java b/core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java
index fb238ec76f..ec1a248a72 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java
@@ -12,10 +12,10 @@
 package alluxio.master.meta;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.ConfigurationValueOptions;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Server;
 import alluxio.clock.SystemClock;
 import alluxio.collections.IndexDefinition;
@@ -129,7 +129,8 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
 
   /** The connect address for the rpc server. */
   private final InetSocketAddress mRpcConnectAddress
-      = NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.MASTER_RPC);
+      = NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.MASTER_RPC,
+      ServerConfiguration.global());
 
   /** The address of this master. */
   private Address mMasterAddress;
@@ -163,7 +164,7 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
       ExecutorServiceFactory executorServiceFactory) {
     super(masterContext, new SystemClock(), executorServiceFactory);
     mMasterAddress =
-        new Address().setHost(Configuration.getOrDefault(PropertyKey.MASTER_HOSTNAME, "localhost"))
+        new Address().setHost(ServerConfiguration.getOrDefault(PropertyKey.MASTER_HOSTNAME, "localhost"))
             .setRpcPort(mPort);
     mBlockMaster = blockMaster;
     mBlockMaster.registerLostWorkerFoundListener(mWorkerConfigStore::lostNodeFound);
@@ -221,32 +222,33 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
     if (isPrimary) {
       // Add the configuration of the current leader master
       mMasterConfigStore.registerNewConf(mMasterAddress,
-          ConfigurationUtils.getConfiguration(Scope.MASTER));
+          ConfigurationUtils.getConfiguration(ServerConfiguration.global(), Scope.MASTER));
 
       // The service that detects lost standby master nodes
       getExecutorService().submit(new HeartbeatThread(
           HeartbeatContext.MASTER_LOST_MASTER_DETECTION,
           new LostMasterDetectionHeartbeatExecutor(),
-          (int) Configuration.getMs(PropertyKey.MASTER_MASTER_HEARTBEAT_INTERVAL)));
+          (int) ServerConfiguration.getMs(PropertyKey.MASTER_MASTER_HEARTBEAT_INTERVAL),
+          ServerConfiguration.global()));
       getExecutorService().submit(
           new HeartbeatThread(HeartbeatContext.MASTER_LOG_CONFIG_REPORT_SCHEDULING,
           new LogConfigReportHeartbeatExecutor(),
-          (int) Configuration.getMs(PropertyKey.MASTER_LOG_CONFIG_REPORT_HEARTBEAT_INTERVAL)));
+          (int) ServerConfiguration.getMs(PropertyKey.MASTER_LOG_CONFIG_REPORT_HEARTBEAT_INTERVAL)));
 
-      if (Configuration.getBoolean(PropertyKey.MASTER_DAILY_BACKUP_ENABLED)) {
+      if (ServerConfiguration.getBoolean(PropertyKey.MASTER_DAILY_BACKUP_ENABLED)) {
         mDailyBackup = new DailyMetadataBackup(this, Executors.newSingleThreadScheduledExecutor(
             ThreadFactoryUtils.build("DailyMetadataBackup-%d", true)), mUfs);
         mDailyBackup.start();
       }
     } else {
-      boolean haEnabled = Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED);
+      boolean haEnabled = ServerConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED);
       if (haEnabled) {
         // Standby master should setup MetaMasterSync to communicate with the leader master
         RetryHandlingMetaMasterMasterClient metaMasterClient =
-            new RetryHandlingMetaMasterMasterClient(MasterClientConfig.defaults());
+            new RetryHandlingMetaMasterMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()));
         getExecutorService().submit(new HeartbeatThread(HeartbeatContext.META_MASTER_SYNC,
             new MetaMasterSync(mMasterAddress, metaMasterClient),
-            (int) Configuration.getMs(PropertyKey.MASTER_MASTER_HEARTBEAT_INTERVAL)));
+            (int) ServerConfiguration.getMs(PropertyKey.MASTER_MASTER_HEARTBEAT_INTERVAL), ServerConfiguration.global()));
         LOG.info("Standby master with address {} starts sending heartbeat to leader master.",
             mMasterAddress);
       }
@@ -266,7 +268,7 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
   public BackupResponse backup(BackupOptions options) throws IOException {
     String dir = options.getTargetDirectory();
     if (dir == null) {
-      dir = Configuration.get(PropertyKey.MASTER_BACKUP_DIRECTORY);
+      dir = ServerConfiguration.get(PropertyKey.MASTER_BACKUP_DIRECTORY);
     }
     UnderFileSystem ufs = mUfs;
     if (options.isLocalFileSystem() && !ufs.getUnderFSType().equals("local")) {
@@ -276,7 +278,7 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
       LOG.info("Backing up to root UFS in directory {}", dir);
     }
     if (!ufs.isDirectory(dir)) {
-      if (!ufs.mkdirs(dir, MkdirsOptions.defaults().setCreateParent(true))) {
+      if (!ufs.mkdirs(dir, MkdirsOptions.defaults(ServerConfiguration.global()).setCreateParent(true))) {
         throw new IOException(String.format("Failed to create directory %s", dir));
       }
     }
@@ -301,13 +303,13 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
         throw t;
       }
     }
-    String rootUfs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String rootUfs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     if (options.isLocalFileSystem()) {
       rootUfs = "file:///";
     }
     AlluxioURI backupUri = new AlluxioURI(new AlluxioURI(rootUfs), new AlluxioURI(backupFilePath));
     return new BackupResponse(backupUri,
-        NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC));
+        NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC, ServerConfiguration.global()));
   }
 
   @Override
@@ -318,10 +320,10 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
   @Override
   public List<ConfigProperty> getConfiguration(GetConfigurationPOptions options) {
     List<ConfigProperty> configInfoList = new ArrayList<>();
-    for (PropertyKey key : Configuration.keySet()) {
+    for (PropertyKey key : ServerConfiguration.keySet()) {
       if (key.isBuiltIn()) {
-        String source = Configuration.getSource(key).toString();
-        String value = Configuration.getOrDefault(key, null, ConfigurationValueOptions.defaults()
+        String source = ServerConfiguration.getSource(key).toString();
+        String value = ServerConfiguration.getOrDefault(key, null, ConfigurationValueOptions.defaults()
             .useDisplayValue(true).useRawValue(options.getRawValue()));
         ConfigProperty.Builder config =
             ConfigProperty.newBuilder().setName(key.getName()).setSource(source);
@@ -397,7 +399,7 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
 
   @Override
   public int getWebPort() {
-    return Configuration.getInt(PropertyKey.MASTER_WEB_PORT);
+    return ServerConfiguration.getInt(PropertyKey.MASTER_WEB_PORT);
   }
 
   @Override
@@ -445,7 +447,7 @@ public final class DefaultMetaMaster extends CoreMaster implements MetaMaster {
 
     @Override
     public void heartbeat() {
-      long masterTimeoutMs = Configuration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT);
+      long masterTimeoutMs = ServerConfiguration.getMs(PropertyKey.MASTER_HEARTBEAT_TIMEOUT);
       for (MasterInfo master : mMasters) {
         synchronized (master) {
           final long lastUpdate = mClock.millis() - master.getLastUpdatedTimeMs();
diff --git a/core/server/master/src/main/java/alluxio/master/meta/MetaMasterClientServiceHandler.java b/core/server/master/src/main/java/alluxio/master/meta/MetaMasterClientServiceHandler.java
index 01a91fde43..ce764bf2b3 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/MetaMasterClientServiceHandler.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/MetaMasterClientServiceHandler.java
@@ -12,8 +12,8 @@
 package alluxio.master.meta;
 
 import alluxio.RpcUtils;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.grpc.BackupPOptions;
 import alluxio.grpc.BackupPResponse;
@@ -115,9 +115,9 @@ public final class MetaMasterClientServiceHandler
                 .map(Address::toProto).collect(Collectors.toList()));
             break;
           case ZOOKEEPER_ADDRESSES:
-            if (Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS)) {
+            if (ServerConfiguration.isSet(PropertyKey.ZOOKEEPER_ADDRESS)) {
               masterInfo.addAllZookeeperAddresses(
-                  Arrays.asList(Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS).split(",")));
+                  Arrays.asList(ServerConfiguration.get(PropertyKey.ZOOKEEPER_ADDRESS).split(",")));
             }
             break;
           default:
diff --git a/core/server/master/src/main/java/alluxio/master/meta/MetaMasterSync.java b/core/server/master/src/main/java/alluxio/master/meta/MetaMasterSync.java
index c503a4fbfa..a8fded7f2c 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/MetaMasterSync.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/MetaMasterSync.java
@@ -11,6 +11,7 @@
 
 package alluxio.master.meta;
 
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.MetaCommand;
 import alluxio.grpc.Scope;
 import alluxio.heartbeat.HeartbeatExecutor;
@@ -112,7 +113,8 @@ public final class MetaMasterSync implements HeartbeatExecutor {
    */
   private void setIdAndRegister() throws IOException {
     mMasterId.set(mMasterClient.getId(mMasterAddress));
-    mMasterClient.register(mMasterId.get(), ConfigurationUtils.getConfiguration(Scope.MASTER));
+    mMasterClient.register(mMasterId.get(),
+        ConfigurationUtils.getConfiguration(ServerConfiguration.global(), Scope.MASTER));
   }
 
   @Override
diff --git a/core/server/master/src/main/java/alluxio/master/meta/RetryHandlingMetaMasterMasterClient.java b/core/server/master/src/main/java/alluxio/master/meta/RetryHandlingMetaMasterMasterClient.java
index d850e4677e..a3348f12cd 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/RetryHandlingMetaMasterMasterClient.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/RetryHandlingMetaMasterMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.master.meta;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.ConfigProperty;
 import alluxio.grpc.GetMasterIdPRequest;
 import alluxio.grpc.MasterHeartbeatPRequest;
@@ -43,7 +44,7 @@ public final class RetryHandlingMetaMasterMasterClient extends AbstractMasterCli
    * @param conf master client configuration
    */
   public RetryHandlingMetaMasterMasterClient(MasterClientConfig conf) {
-    super(conf);
+    super(conf, ServerConfiguration.global());
   }
 
   @Override
@@ -69,7 +70,7 @@ public final class RetryHandlingMetaMasterMasterClient extends AbstractMasterCli
   /**
    * Returns a master id for a master address.
    *
-   * @param address the address to get a master id for
+   * @param address the address to create a master id for
    * @return a master id
    */
   public long getId(final Address address) throws IOException {
diff --git a/core/server/master/src/main/java/alluxio/master/meta/checkconf/ConfigRecord.java b/core/server/master/src/main/java/alluxio/master/meta/checkconf/ConfigRecord.java
index 293d4a5686..4fb3cd51b4 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/checkconf/ConfigRecord.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/checkconf/ConfigRecord.java
@@ -11,7 +11,7 @@
 
 package alluxio.master.meta.checkconf;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import javax.annotation.Nullable;
 import java.util.Optional;
diff --git a/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationChecker.java b/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationChecker.java
index 5b61a894a8..652dbc779b 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationChecker.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationChecker.java
@@ -11,8 +11,8 @@
 
 package alluxio.master.meta.checkconf;
 
-import alluxio.PropertyKey;
-import alluxio.PropertyKey.ConsistencyCheckLevel;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.PropertyKey.ConsistencyCheckLevel;
 import alluxio.grpc.ConfigStatus;
 import alluxio.grpc.Scope;
 import alluxio.wire.Address;
@@ -159,7 +159,7 @@ public class ServerConfigurationChecker {
    * Fills the configuration map.
    *
    * @param targetMap the map to fill
-   * @param recordMap the map to get data from
+   * @param recordMap the map to create data from
    */
   private void fillConfMap(Map<PropertyKey, Map<Optional<String>, List<String>>> targetMap,
       Map<Address, List<ConfigRecord>> recordMap) {
diff --git a/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationStore.java b/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationStore.java
index 26104d06a9..e73ecc16ac 100644
--- a/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationStore.java
+++ b/core/server/master/src/main/java/alluxio/master/meta/checkconf/ServerConfigurationStore.java
@@ -11,7 +11,7 @@
 
 package alluxio.master.meta.checkconf;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.ConfigProperty;
 import alluxio.wire.Address;
 
diff --git a/core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java b/core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java
index 90d1d79d77..ad0af25a69 100644
--- a/core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java
+++ b/core/server/master/src/main/java/alluxio/master/metrics/DefaultMetricsMaster.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.metrics;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.clock.SystemClock;
 import alluxio.grpc.GrpcService;
 import alluxio.grpc.ServiceType;
@@ -86,7 +86,8 @@ public class DefaultMetricsMaster extends CoreMaster implements MetricsMaster {
     mClusterMetricsUpdater =
         new HeartbeatThread(HeartbeatContext.MASTER_CLUSTER_METRICS_UPDATER,
             new ClusterMetricsUpdater(),
-            Configuration.getMs(PropertyKey.MASTER_CLUSTER_METRICS_UPDATE_INTERVAL));
+            ServerConfiguration.getMs(PropertyKey.MASTER_CLUSTER_METRICS_UPDATE_INTERVAL),
+            ServerConfiguration.global());
   }
 
   @VisibleForTesting
diff --git a/core/server/master/src/main/java/alluxio/web/WebInterfaceBrowseServlet.java b/core/server/master/src/main/java/alluxio/web/WebInterfaceBrowseServlet.java
index 92940e15bd..ae1fc44ee9 100644
--- a/core/server/master/src/main/java/alluxio/web/WebInterfaceBrowseServlet.java
+++ b/core/server/master/src/main/java/alluxio/web/WebInterfaceBrowseServlet.java
@@ -12,9 +12,9 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -134,15 +134,16 @@ public final class WebInterfaceBrowseServlet extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest request, HttpServletResponse response)
       throws ServletException, IOException {
-    if (!Configuration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
+    if (!ServerConfiguration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
       return;
     }
-    if (SecurityUtils.isSecurityEnabled() && AuthenticatedClientUser.get() == null) {
-      AuthenticatedClientUser.set(LoginUser.get().getName());
+    if (SecurityUtils.isSecurityEnabled(ServerConfiguration.global())
+            && AuthenticatedClientUser.get(ServerConfiguration.global()) == null) {
+      AuthenticatedClientUser.set(LoginUser.get(ServerConfiguration.global()).getName());
     }
-    request.setAttribute("debug", Configuration.getBoolean(PropertyKey.DEBUG));
+    request.setAttribute("debug", ServerConfiguration.getBoolean(PropertyKey.DEBUG));
     request.setAttribute("showPermissions",
-        Configuration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED));
+        ServerConfiguration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED));
 
     request.setAttribute("masterNodeAddress", mMasterProcess.getRpcAddress().toString());
     request.setAttribute("invalidPathError", "");
diff --git a/core/server/master/src/main/java/alluxio/web/WebInterfaceConfigurationServlet.java b/core/server/master/src/main/java/alluxio/web/WebInterfaceConfigurationServlet.java
index 63cba7b0a7..6309edbf34 100644
--- a/core/server/master/src/main/java/alluxio/web/WebInterfaceConfigurationServlet.java
+++ b/core/server/master/src/main/java/alluxio/web/WebInterfaceConfigurationServlet.java
@@ -11,7 +11,7 @@
 
 package alluxio.web;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.ConfigProperty;
 import alluxio.grpc.GetConfigurationPOptions;
 import alluxio.master.file.FileSystemMaster;
@@ -46,8 +46,8 @@ public final class WebInterfaceConfigurationServlet extends HttpServlet {
   /**
    * Creates a new instance of {@link WebInterfaceConfigurationServlet}.
    *
-   * @param fsMaster file system master to get white list
-   * @param metaMaster the meta master to get configuration
+   * @param fsMaster file system master to create white list
+   * @param metaMaster the meta master to create configuration
    */
   public WebInterfaceConfigurationServlet(FileSystemMaster fsMaster, MetaMaster metaMaster) {
     mFsMaster = fsMaster;
diff --git a/core/server/master/src/main/java/alluxio/web/WebInterfaceDownloadServlet.java b/core/server/master/src/main/java/alluxio/web/WebInterfaceDownloadServlet.java
index fa38652691..7fffdea91c 100644
--- a/core/server/master/src/main/java/alluxio/web/WebInterfaceDownloadServlet.java
+++ b/core/server/master/src/main/java/alluxio/web/WebInterfaceDownloadServlet.java
@@ -12,8 +12,8 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -68,11 +68,11 @@ public final class WebInterfaceDownloadServlet extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest request, HttpServletResponse response)
       throws ServletException, IOException {
-    if (!Configuration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
+    if (!ServerConfiguration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
       return;
     }
-    if (SecurityUtils.isSecurityEnabled() && AuthenticatedClientUser.get() == null) {
-      AuthenticatedClientUser.set(LoginUser.get().getName());
+    if (SecurityUtils.isSecurityEnabled(ServerConfiguration.global()) && AuthenticatedClientUser.get(ServerConfiguration.global()) == null) {
+      AuthenticatedClientUser.set(LoginUser.get(ServerConfiguration.global()).getName());
     }
     String requestPath = request.getParameter("path");
     if (requestPath == null || requestPath.isEmpty()) {
diff --git a/core/server/master/src/main/java/alluxio/web/WebInterfaceGeneralServlet.java b/core/server/master/src/main/java/alluxio/web/WebInterfaceGeneralServlet.java
index daa6883a1e..3fd07be196 100644
--- a/core/server/master/src/main/java/alluxio/web/WebInterfaceGeneralServlet.java
+++ b/core/server/master/src/main/java/alluxio/web/WebInterfaceGeneralServlet.java
@@ -12,8 +12,8 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.StorageTierAssoc;
 import alluxio.master.MasterProcess;
@@ -181,14 +181,15 @@ public final class WebInterfaceGeneralServlet extends HttpServlet {
     BlockMaster blockMaster = mMasterProcess.getMaster(BlockMaster.class);
     FileSystemMaster fileSystemMaster = mMasterProcess.getMaster(FileSystemMaster.class);
 
-    request.setAttribute("debug", Configuration.getBoolean(PropertyKey.DEBUG));
+    request.setAttribute("debug", ServerConfiguration.getBoolean(PropertyKey.DEBUG));
 
     request.setAttribute("masterNodeAddress", mMasterProcess.getRpcAddress().toString());
 
     request.setAttribute("uptime", CommonUtils
         .convertMsToClockTime(System.currentTimeMillis() - mMetaMaster.getStartTimeMs()));
 
-    request.setAttribute("startTime", CommonUtils.convertMsToDate(mMetaMaster.getStartTimeMs()));
+    request.setAttribute("startTime", CommonUtils.convertMsToDate(mMetaMaster.getStartTimeMs(),
+        ServerConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN)));
 
     request.setAttribute("version", RuntimeConstants.VERSION);
 
diff --git a/core/server/master/src/main/java/alluxio/web/WebInterfaceMemoryServlet.java b/core/server/master/src/main/java/alluxio/web/WebInterfaceMemoryServlet.java
index 031db982b2..c50fefa7e2 100644
--- a/core/server/master/src/main/java/alluxio/web/WebInterfaceMemoryServlet.java
+++ b/core/server/master/src/main/java/alluxio/web/WebInterfaceMemoryServlet.java
@@ -12,8 +12,8 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.FileDoesNotExistException;
 import alluxio.master.MasterProcess;
@@ -63,16 +63,17 @@ public final class WebInterfaceMemoryServlet extends HttpServlet {
   @Override
   public void doGet(HttpServletRequest request, HttpServletResponse response)
       throws ServletException, IOException {
-    if (!Configuration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
+    if (!ServerConfiguration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
       return;
     }
-    if (SecurityUtils.isSecurityEnabled() && AuthenticatedClientUser.get() == null) {
-      AuthenticatedClientUser.set(LoginUser.get().getName());
+    if (SecurityUtils.isSecurityEnabled(ServerConfiguration.global())
+            && AuthenticatedClientUser.get(ServerConfiguration.global()) == null) {
+      AuthenticatedClientUser.set(LoginUser.get(ServerConfiguration.global()).getName());
     }
     request.setAttribute("masterNodeAddress", mMasterProcess.getRpcAddress().toString());
     request.setAttribute("fatalError", "");
     request.setAttribute("showPermissions",
-        Configuration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED));
+        ServerConfiguration.getBoolean(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED));
 
     FileSystemMaster fileSystemMaster = mMasterProcess.getMaster(FileSystemMaster.class);
 
diff --git a/core/server/master/src/main/java/alluxio/web/WebInterfaceWorkersServlet.java b/core/server/master/src/main/java/alluxio/web/WebInterfaceWorkersServlet.java
index edab50fafd..92412f0704 100644
--- a/core/server/master/src/main/java/alluxio/web/WebInterfaceWorkersServlet.java
+++ b/core/server/master/src/main/java/alluxio/web/WebInterfaceWorkersServlet.java
@@ -11,8 +11,8 @@
 
 package alluxio.web;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.block.BlockMaster;
 import alluxio.util.FormatUtils;
 import alluxio.wire.WorkerInfo;
@@ -223,7 +223,7 @@ public final class WebInterfaceWorkersServlet extends HttpServlet {
    * @param request the {@link HttpServletRequest} object
    */
   private void populateValues(HttpServletRequest request) throws IOException {
-    request.setAttribute("debug", Configuration.getBoolean(PropertyKey.DEBUG));
+    request.setAttribute("debug", ServerConfiguration.getBoolean(PropertyKey.DEBUG));
 
     List<WorkerInfo> workerInfos = mBlockMaster.getWorkerInfoList();
     NodeInfo[] normalNodeInfos = generateOrderedNodeInfos(workerInfos);
diff --git a/core/server/master/src/test/java/alluxio/master/SafeModeManagerTest.java b/core/server/master/src/test/java/alluxio/master/SafeModeManagerTest.java
index 19ff295a97..998364bcf9 100644
--- a/core/server/master/src/test/java/alluxio/master/SafeModeManagerTest.java
+++ b/core/server/master/src/test/java/alluxio/master/SafeModeManagerTest.java
@@ -14,9 +14,10 @@ package alluxio.master;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.clock.ManualClock;
 
 import com.google.common.collect.ImmutableMap;
@@ -36,7 +37,8 @@ public class SafeModeManagerTest {
 
   @Rule
   public ConfigurationRule mConfiguration = new ConfigurationRule(ImmutableMap
-      .of(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME, SAFEMODE_WAIT_TEST));
+      .of(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME, SAFEMODE_WAIT_TEST),
+      ServerConfiguration.global());
 
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
@@ -72,7 +74,7 @@ public class SafeModeManagerTest {
   @Test
   public void leaveSafeModeAfterRpcServerStart() throws Exception {
     mSafeModeManager.notifyRpcServerStarted();
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
 
     assertFalse(mSafeModeManager.isInSafeMode());
   }
@@ -80,7 +82,7 @@ public class SafeModeManagerTest {
   @Test
   public void stayInSafeModeAfterPrimaryMasterStart() throws Exception {
     mSafeModeManager.notifyPrimaryMasterStarted();
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
 
     assertTrue(mSafeModeManager.isInSafeMode());
   }
@@ -88,7 +90,7 @@ public class SafeModeManagerTest {
   @Test
   public void reenterSafeModeOnPrimaryMasterStart() throws Exception {
     mSafeModeManager.notifyRpcServerStarted();
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
     mSafeModeManager.notifyPrimaryMasterStarted();
 
     assertTrue(mSafeModeManager.isInSafeMode());
@@ -97,7 +99,7 @@ public class SafeModeManagerTest {
   @Test
   public void reenterSafeModeOnRpcServerStart() throws Exception {
     mSafeModeManager.notifyRpcServerStarted();
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) + 10);
     mSafeModeManager.notifyRpcServerStarted();
 
     assertTrue(mSafeModeManager.isInSafeMode());
@@ -108,9 +110,9 @@ public class SafeModeManagerTest {
     mSafeModeManager.notifyRpcServerStarted();
 
     // Enters safe mode again while in safe mode.
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
     mSafeModeManager.notifyRpcServerStarted();
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
 
     // Verifies safe mode timer is reset.
     assertTrue(mSafeModeManager.isInSafeMode());
@@ -123,9 +125,9 @@ public class SafeModeManagerTest {
     mSafeModeManager.notifyRpcServerStarted();
 
     // Enters safe mode again while in safe mode.
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
     mSafeModeManager.notifyPrimaryMasterStarted();
-    mClock.addTimeMs(Configuration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
+    mClock.addTimeMs(ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_CONNECT_WAIT_TIME) - 10);
 
     // Verifies safe mode timer is cleared.
     assertTrue(mSafeModeManager.isInSafeMode());
diff --git a/core/server/master/src/test/java/alluxio/master/block/BlockMasterTest.java b/core/server/master/src/test/java/alluxio/master/block/BlockMasterTest.java
index 6bb6ef5741..56507e5470 100644
--- a/core/server/master/src/test/java/alluxio/master/block/BlockMasterTest.java
+++ b/core/server/master/src/test/java/alluxio/master/block/BlockMasterTest.java
@@ -14,9 +14,9 @@ package alluxio.master.block;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.clock.ManualClock;
 import alluxio.grpc.Command;
 import alluxio.grpc.CommandType;
@@ -101,7 +101,7 @@ public class BlockMasterTest {
     mRegistry = new MasterRegistry();
     mSafeModeManager = new TestSafeModeManager();
     mStartTimeMs = System.currentTimeMillis();
-    mPort = Configuration.getInt(PropertyKey.MASTER_RPC_PORT);
+    mPort = ServerConfiguration.getInt(PropertyKey.MASTER_RPC_PORT);
     mMetrics = Lists.newArrayList();
     JournalSystem journalSystem = new NoopJournalSystem();
     CoreMasterContext masterContext = MasterTestUtils.testMasterContext();
diff --git a/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterMetricsTest.java b/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterMetricsTest.java
index 37f454f7ae..6b47e60fb7 100644
--- a/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterMetricsTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterMetricsTest.java
@@ -14,8 +14,8 @@ package alluxio.master.file;
 import static org.junit.Assert.assertEquals;
 import static org.mockito.Mockito.when;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.file.DefaultFileSystemMaster.Metrics;
 import alluxio.metrics.MasterMetrics;
 import alluxio.metrics.MetricsSystem;
@@ -58,7 +58,7 @@ public class FileSystemMasterMetricsTest {
   public void testMetricsUfsCapacity() throws Exception {
     UfsManager.UfsClient client = Mockito.mock(UfsManager.UfsClient.class);
     UnderFileSystem ufs = Mockito.mock(UnderFileSystem.class);
-    String ufsDataFolder = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsDataFolder = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     when(ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_TOTAL)).thenReturn(1000L);
     when(ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_USED)).thenReturn(200L);
     when(ufs.getSpace(ufsDataFolder, UnderFileSystem.SpaceType.SPACE_FREE)).thenReturn(800L);
diff --git a/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java b/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java
index 032dadcfbe..0bde295531 100644
--- a/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java
@@ -26,11 +26,11 @@ import alluxio.AlluxioTestDirectory;
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedClientUserResource;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
 import alluxio.Constants;
 import alluxio.LoginUserRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.BlockInfoException;
 import alluxio.exception.DirectoryNotEmptyException;
@@ -174,10 +174,10 @@ public final class FileSystemMasterTest {
   public ExpectedException mThrown = ExpectedException.none();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER, ServerConfiguration.global());
 
   @Rule
-  public LoginUserRule mLoginUser = new LoginUserRule(TEST_USER);
+  public LoginUserRule mLoginUser = new LoginUserRule(TEST_USER, ServerConfiguration.global());
 
   @Rule
   public ConfigurationRule mConfigurationRule = new ConfigurationRule(new HashMap() {
@@ -188,7 +188,7 @@ public final class FileSystemMasterTest {
       put(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, AlluxioTestDirectory
           .createTemporaryDirectory("FileSystemMasterTest").getAbsolutePath());
     }
-  });
+  }, ServerConfiguration.global());
 
   @ClassRule
   public static ManuallyScheduleHeartbeat sManuallySchedule = new ManuallyScheduleHeartbeat(
@@ -206,7 +206,7 @@ public final class FileSystemMasterTest {
     GroupMappingServiceTestUtils.resetCache();
     // This makes sure that the mount point of the UFS corresponding to the Alluxio root ("/")
     // doesn't exist by default (helps loadRootTest).
-    mUnderFS = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    mUnderFS = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     mNestedFileContext = CreateFileContext.defaults(
         CreateFilePOptions.newBuilder().setBlockSizeBytes(Constants.KB).setRecursive(true));
     mJournalFolder = mTestFolder.newFolder().getAbsolutePath();
@@ -387,7 +387,7 @@ public final class FileSystemMasterTest {
         .defaults(SetAttributePOptions.newBuilder().setMode(new Mode((short) 0777).toProto())));
     mFileSystemMaster.setAttribute(NESTED_FILE_URI, SetAttributeContext
         .defaults(SetAttributePOptions.newBuilder().setMode(new Mode((short) 0777).toProto())));
-    try (AuthenticatedClientUserResource userA = new AuthenticatedClientUserResource("userA")) {
+    try (AuthenticatedClientUserResource userA = new AuthenticatedClientUserResource("userA", ServerConfiguration.global())) {
       mFileSystemMaster.delete(NESTED_URI,
           DeleteContext.defaults(DeletePOptions.newBuilder().setRecursive(true)));
     }
@@ -406,7 +406,7 @@ public final class FileSystemMasterTest {
         .defaults(SetAttributePOptions.newBuilder().setMode(new Mode((short) 0700).toProto())));
     mFileSystemMaster.setAttribute(NESTED_FILE2_URI, SetAttributeContext
         .defaults(SetAttributePOptions.newBuilder().setMode(new Mode((short) 0777).toProto())));
-    try (AuthenticatedClientUserResource userA = new AuthenticatedClientUserResource("userA")) {
+    try (AuthenticatedClientUserResource userA = new AuthenticatedClientUserResource("userA", ServerConfiguration.global())) {
       mFileSystemMaster.delete(NESTED_URI,
           DeleteContext.defaults(DeletePOptions.newBuilder().setRecursive(true)));
       fail("Deleting a directory w/ insufficient permission on child should fail");
@@ -652,7 +652,7 @@ public final class FileSystemMasterTest {
     long rootId = mFileSystemMaster.getFileId(rootUri);
     assertEquals(rootUri, mFileSystemMaster.getPath(rootId));
 
-    // get non-existent id
+    // create non-existent id
     try {
       mFileSystemMaster.getPath(rootId + 1234);
       fail("getPath() for a non-existent id should fail.");
@@ -670,7 +670,7 @@ public final class FileSystemMasterTest {
     long rootId = mFileSystemMaster.getFileId(rootUri);
     assertEquals(PersistenceState.PERSISTED, mFileSystemMaster.getPersistenceState(rootId));
 
-    // get non-existent id
+    // create non-existent id
     try {
       mFileSystemMaster.getPersistenceState(rootId + 1234);
       fail("getPath() for a non-existent id should fail.");
@@ -1073,7 +1073,7 @@ public final class FileSystemMasterTest {
     // Test with permissions
     mFileSystemMaster.setAttribute(NESTED_URI, SetAttributeContext.defaults(SetAttributePOptions
         .newBuilder().setMode(new Mode((short) 0400).toProto()).setRecursive(true)));
-    try (Closeable r = new AuthenticatedUserRule("test_user1").toResource()) {
+    try (Closeable r = new AuthenticatedUserRule("test_user1", ServerConfiguration.global()).toResource()) {
       // Test recursive listStatus
       infos = mFileSystemMaster.listStatus(ROOT_URI, ListStatusContext.defaults(ListStatusPOptions
           .newBuilder().setLoadMetadataType(LoadMetadataPType.ALWAYS).setRecursive(true)));
@@ -1723,7 +1723,7 @@ public final class FileSystemMasterTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get information about a file after it has been
+   * Tests that an exception is thrown when trying to create information about a file after it has been
    * deleted because of a TTL of 0.
    */
   @Test
@@ -1745,7 +1745,7 @@ public final class FileSystemMasterTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get information about a Directory after
+   * Tests that an exception is thrown when trying to create information about a Directory after
    * it has been deleted because of a TTL of 0.
    */
   @Test
@@ -1773,7 +1773,7 @@ public final class FileSystemMasterTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get information about a file after it has been
+   * Tests that an exception is thrown when trying to create information about a file after it has been
    * deleted after the TTL has been set to 0.
    */
   @Test
@@ -1796,7 +1796,7 @@ public final class FileSystemMasterTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get information about a Directory after
+   * Tests that an exception is thrown when trying to create information about a Directory after
    * it has been deleted after the TTL has been set to 0.
    */
   @Test
diff --git a/core/server/master/src/test/java/alluxio/master/file/PermissionCheckTest.java b/core/server/master/src/test/java/alluxio/master/file/PermissionCheckTest.java
index 1919f83d15..8c5691eefe 100644
--- a/core/server/master/src/test/java/alluxio/master/file/PermissionCheckTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/PermissionCheckTest.java
@@ -18,12 +18,13 @@ import static org.junit.Assert.assertTrue;
 import alluxio.AlluxioTestDirectory;
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.LoginUserRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileDoesNotExistException;
@@ -118,14 +119,15 @@ public final class PermissionCheckTest {
           .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, TEST_SUPER_GROUP)
           .put(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, AlluxioTestDirectory
               .createTemporaryDirectory("PermissionCheckTest").getAbsolutePath())
-          .build());
+          .build(), ServerConfiguration.global());
 
   @Rule
   public AuthenticatedUserRule mAuthenticatedUser =
-      new AuthenticatedUserRule(TEST_USER_ADMIN.getUser());
+      new AuthenticatedUserRule(TEST_USER_ADMIN.getUser(), ServerConfiguration.global());
 
   @Rule
-  public LoginUserRule mLoginUserRule = new LoginUserRule(TEST_USER_ADMIN.getUser());
+  public LoginUserRule mLoginUserRule = new LoginUserRule(TEST_USER_ADMIN.getUser(),
+      ServerConfiguration.global());
 
   @Rule
   public TemporaryFolder mTestFolder = new TemporaryFolder();
@@ -179,7 +181,7 @@ public final class PermissionCheckTest {
 
   @Before
   public void before() throws Exception {
-    Configuration.set(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, mTestFolder.newFolder());
+    ServerConfiguration.set(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, mTestFolder.newFolder());
     GroupMappingServiceTestUtils.resetCache();
     mRegistry = new MasterRegistry();
     mRegistry.add(MetricsMaster.class, mMetricsMaster);
@@ -196,7 +198,8 @@ public final class PermissionCheckTest {
   public void after() throws Exception {
     mRegistry.stop();
     GroupMappingServiceTestUtils.resetCache();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
+
   }
 
   /**
@@ -208,14 +211,14 @@ public final class PermissionCheckTest {
    */
   private void createDirAndFileForTest() throws Exception {
     // create "/testDir" for user1
-    try (Closeable r = new AuthenticatedUserRule(TEST_USER_ADMIN.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(TEST_USER_ADMIN.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.createDirectory(new AlluxioURI("/testDir"), CreateDirectoryContext
           .defaults(CreateDirectoryPOptions.newBuilder().setMode(TEST_DIR_MODE.toProto()))
           .setOwner(TEST_USER_1.getUser()).setGroup(TEST_USER_1.getGroup()));
     }
 
     // create "/testDir/file" for user1
-    try (Closeable r = new AuthenticatedUserRule(TEST_USER_1.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(TEST_USER_1.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.createFile(new AlluxioURI("/testDir/file"),
           CreateFileContext
               .defaults(CreateFilePOptions.newBuilder().setBlockSizeBytes(Constants.KB)
@@ -224,7 +227,7 @@ public final class PermissionCheckTest {
     }
 
     // create "/testFile" for user2
-    try (Closeable r = new AuthenticatedUserRule(TEST_USER_ADMIN.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(TEST_USER_ADMIN.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.createFile(new AlluxioURI("/testFile"),
           CreateFileContext
               .defaults(CreateFilePOptions.newBuilder().setBlockSizeBytes(Constants.KB)
@@ -282,12 +285,12 @@ public final class PermissionCheckTest {
   }
 
   private void verifyCreateFile(TestUser user, String path, boolean recursive) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       CreateFileContext context = CreateFileContext
           .defaults(
               CreateFilePOptions.newBuilder().setRecursive(recursive))
-          .setOwner(SecurityUtils.getOwnerFromGrpcClient())
-          .setGroup(SecurityUtils.getGroupFromGrpcClient())
+          .setOwner(SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global()))
+          .setGroup(SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global()))
           .setPersisted(true);
 
       long fileId = mFileSystemMaster.createFile(new AlluxioURI(path), context);
@@ -340,11 +343,11 @@ public final class PermissionCheckTest {
 
   private void verifyCreateDirectory(TestUser user, String path, boolean recursive)
       throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       CreateDirectoryContext context = CreateDirectoryContext
           .defaults(CreateDirectoryPOptions.newBuilder().setRecursive(recursive))
-          .setOwner(SecurityUtils.getOwnerFromGrpcClient())
-          .setGroup(SecurityUtils.getGroupFromGrpcClient());
+          .setOwner(SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global()))
+          .setGroup(SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global()));
       mFileSystemMaster.createDirectory(new AlluxioURI(path), context);
 
       FileInfo fileInfo =
@@ -416,7 +419,7 @@ public final class PermissionCheckTest {
   }
 
   private void verifyRename(TestUser user, String srcPath, String dstPath) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       String fileOwner =
           mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(new AlluxioURI(srcPath)))
               .getOwner();
@@ -496,7 +499,7 @@ public final class PermissionCheckTest {
   }
 
   private void verifyDelete(TestUser user, String path, boolean recursive) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.delete(new AlluxioURI(path),
           DeleteContext.defaults(DeletePOptions.newBuilder().setRecursive(recursive)));
       assertEquals(-1, mFileSystemMaster.getFileId(new AlluxioURI(path)));
@@ -549,7 +552,7 @@ public final class PermissionCheckTest {
     mThrown.expect(AccessControlException.class);
     mThrown.expectMessage(ExceptionMessage.PERMISSION_DENIED.getMessage(
         toExceptionMessage(TEST_USER_2.getUser(), Mode.Bits.READ, dir, "onlyReadByUser1")));
-    try (Closeable r = new AuthenticatedUserRule(TEST_USER_2.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(TEST_USER_2.getUser(), ServerConfiguration.global()).toResource()) {
       verifyGetFileInfoOrList(TEST_USER_2, dir, false);
     }
   }
@@ -558,7 +561,7 @@ public final class PermissionCheckTest {
   public void readNotExecuteDir() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "033").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "033", ServerConfiguration.global()).toResource()) {
       String dir = PathUtils.concatPath(TEST_DIR_URI, "/notExecuteDir");
       // create dir "/testDir/notExecuteDir" [user1, group1, drwxr--r--]
       verifyCreateDirectory(TEST_USER_1, dir, false);
@@ -574,7 +577,7 @@ public final class PermissionCheckTest {
   private String createUnreadableFileOrDir(boolean isFile) throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066", ServerConfiguration.global()).toResource()) {
       String fileOrDir = PathUtils.concatPath(TEST_DIR_URI, "/onlyReadByUser1");
       if (isFile) {
         // create file "/testDir/onlyReadByUser1" [user1, group1, -rw-------]
@@ -597,20 +600,20 @@ public final class PermissionCheckTest {
    * @throws Exception if it fails to verify
    */
   private void verifyRead(TestUser user, String path, boolean isFile) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       verifyGetFileId(user, path);
       verifyGetFileInfoOrList(user, path, isFile);
     }
   }
 
   /**
-   * This method verifies the get fileId.
+   * This method verifies the create fileId.
    * @param user the user
    * @param path the path of the file to verify
    * @throws Exception if it fails to verify
    */
   private void verifyGetFileId(TestUser user, String path) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       long fileId = mFileSystemMaster.getFileId(new AlluxioURI(path));
       assertNotEquals(-1, fileId);
     }
@@ -618,7 +621,7 @@ public final class PermissionCheckTest {
 
   private void verifyGetFileInfoOrList(TestUser user, String path, boolean isFile)
       throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       if (isFile) {
         assertEquals(path, mFileSystemMaster
             .getFileInfo(new AlluxioURI(path), GetStatusContext.defaults()).getPath());
@@ -640,7 +643,7 @@ public final class PermissionCheckTest {
   public void setStateSuccess() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "000").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "000", ServerConfiguration.global()).toResource()) {
       String file = PathUtils.concatPath(TEST_DIR_URI, "testState1");
       verifyCreateFile(TEST_USER_1, file, false);
       SetAttributePOptions expect = getNonDefaultSetState();
@@ -656,7 +659,7 @@ public final class PermissionCheckTest {
   public void setStateFail() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066", ServerConfiguration.global()).toResource()) {
       String file = PathUtils.concatPath(TEST_DIR_URI, "testState1");
       verifyCreateFile(TEST_USER_1, file, false);
       SetAttributePOptions expect = getNonDefaultSetState();
@@ -675,7 +678,7 @@ public final class PermissionCheckTest {
 
   private SetAttributePOptions verifySetState(TestUser user, String path,
       SetAttributePOptions options) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.setAttribute(new AlluxioURI(path),
           SetAttributeContext.defaults(options.toBuilder()));
 
@@ -691,7 +694,7 @@ public final class PermissionCheckTest {
   public void completeFileSuccess() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "044").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "044", ServerConfiguration.global()).toResource()) {
       String file = PathUtils.concatPath(TEST_DIR_URI, "/testState1");
       verifyCreateFile(TEST_USER_1, file, false);
       CompleteFileContext expect = getNonDefaultCompleteFileContext();
@@ -703,7 +706,7 @@ public final class PermissionCheckTest {
   public void completeFileFail() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066", ServerConfiguration.global()).toResource()) {
       String file = PathUtils.concatPath(TEST_DIR_URI, "/testComplete1");
       verifyCreateFile(TEST_USER_1, file, false);
       CompleteFileContext expect = getNonDefaultCompleteFileContext();
@@ -725,7 +728,7 @@ public final class PermissionCheckTest {
 
   private void verifyCompleteFile(TestUser user, String path, CompleteFileContext context)
       throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.completeFile(new AlluxioURI(path), context);
     }
   }
@@ -750,7 +753,7 @@ public final class PermissionCheckTest {
   public void freeFileFail() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066", ServerConfiguration.global()).toResource()) {
       String file = PathUtils.concatPath(TEST_DIR_URI, "testComplete1");
       verifyCreateFile(TEST_USER_1, file, false);
 
@@ -765,7 +768,7 @@ public final class PermissionCheckTest {
   public void freeNonNullDirectoryFail() throws Exception {
     // set unmask
     try (Closeable c = new ConfigurationRule(
-        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066").toResource()) {
+        PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK, "066", ServerConfiguration.global()).toResource()) {
       String file = PathUtils.concatPath(TEST_DIR_URI + "/testComplete1");
       verifyCreateFile(TEST_USER_1, file, false);
 
@@ -777,7 +780,7 @@ public final class PermissionCheckTest {
   }
 
   private void verifyFree(TestUser user, String path, boolean recursive) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(user.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(user.getUser(), ServerConfiguration.global()).toResource()) {
       mFileSystemMaster.free(new AlluxioURI(path),
           FreeContext.defaults(FreePOptions.newBuilder().setRecursive(recursive)));
     }
@@ -882,7 +885,7 @@ public final class PermissionCheckTest {
 
   private void verifySetAcl(TestUser runUser, String path, String owner, String group,
       short mode, boolean recursive) throws Exception {
-    try (Closeable r = new AuthenticatedUserRule(runUser.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(runUser.getUser(), ServerConfiguration.global()).toResource()) {
       SetAttributeContext context = SetAttributeContext.defaults(SetAttributePOptions.newBuilder()
           .setMode(new Mode(mode).toProto()).setRecursive(recursive));
       if (owner != null) {
@@ -893,7 +896,7 @@ public final class PermissionCheckTest {
       }
       mFileSystemMaster.setAttribute(new AlluxioURI(path), context);
     }
-    try (Closeable r = new AuthenticatedUserRule(TEST_USER_ADMIN.getUser()).toResource()) {
+    try (Closeable r = new AuthenticatedUserRule(TEST_USER_ADMIN.getUser(), ServerConfiguration.global()).toResource()) {
       FileInfo fileInfo =
           mFileSystemMaster.getFileInfo(mFileSystemMaster.getFileId(new AlluxioURI(path)));
       if (owner != null) {
diff --git a/core/server/master/src/test/java/alluxio/master/file/PermissionCheckerTest.java b/core/server/master/src/test/java/alluxio/master/file/PermissionCheckerTest.java
index ed9db181fb..c546530e58 100644
--- a/core/server/master/src/test/java/alluxio/master/file/PermissionCheckerTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/PermissionCheckerTest.java
@@ -14,10 +14,10 @@ package alluxio.master.file;
 import static org.mockito.Mockito.mock;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.InvalidPathException;
@@ -193,11 +193,12 @@ public final class PermissionCheckerTest {
     sRegistry.start(true);
 
     GroupMappingServiceTestUtils.resetCache();
-    Configuration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
+    ServerConfiguration.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS,
         FakeUserGroupsMapping.class.getName());
-    Configuration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, "true");
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, TEST_SUPER_GROUP);
+    ServerConfiguration.set(PropertyKey.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName());
+    ServerConfiguration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, "true");
+    ServerConfiguration
+        .set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, TEST_SUPER_GROUP);
     sTree.initializeRoot(TEST_USER_ADMIN.getUser(), TEST_USER_ADMIN.getGroup(), TEST_NORMAL_MODE,
         NoopJournalContext.INSTANCE);
 
@@ -211,7 +212,7 @@ public final class PermissionCheckerTest {
   public static void afterClass() throws Exception {
     sRegistry.stop();
     AuthenticatedClientUser.remove();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Before
diff --git a/core/server/master/src/test/java/alluxio/master/file/PersistenceTest.java b/core/server/master/src/test/java/alluxio/master/file/PersistenceTest.java
index 0f79957e4e..370ea701d1 100644
--- a/core/server/master/src/test/java/alluxio/master/file/PersistenceTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/PersistenceTest.java
@@ -12,10 +12,10 @@
 package alluxio.master.file;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.job.JobMasterClient;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.FileDoesNotExistException;
@@ -93,26 +93,26 @@ public final class PersistenceTest {
 
   @Before
   public void before() throws Exception {
-    AuthenticatedClientUser.set(LoginUser.get().getName());
+    AuthenticatedClientUser.set(LoginUser.get(ServerConfiguration.global()).getName());
     TemporaryFolder tmpFolder = new TemporaryFolder();
     tmpFolder.create();
     File ufsRoot = tmpFolder.newFolder();
-    Configuration.set(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, ufsRoot.getAbsolutePath());
-    Configuration.set(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS, 0);
-    Configuration.set(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS, 1000);
-    Configuration.set(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS, 0);
-    Configuration.set(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS, 1000);
+    ServerConfiguration.set(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, ufsRoot.getAbsolutePath());
+    ServerConfiguration.set(PropertyKey.MASTER_PERSISTENCE_INITIAL_INTERVAL_MS, 0);
+    ServerConfiguration.set(PropertyKey.MASTER_PERSISTENCE_MAX_INTERVAL_MS, 1000);
+    ServerConfiguration.set(PropertyKey.MASTER_PERSISTENCE_INITIAL_WAIT_TIME_MS, 0);
+    ServerConfiguration.set(PropertyKey.MASTER_PERSISTENCE_MAX_TOTAL_WAIT_TIME_MS, 1000);
     mJournalFolder = tmpFolder.newFolder();
     mSafeModeManager = new DefaultSafeModeManager();
     mStartTimeMs = System.currentTimeMillis();
-    mPort = Configuration.getInt(PropertyKey.MASTER_RPC_PORT);
+    mPort = ServerConfiguration.getInt(PropertyKey.MASTER_RPC_PORT);
     startServices();
   }
 
   @After
   public void after() throws Exception {
     stopServices();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
     AuthenticatedClientUser.remove();
   }
 
@@ -198,7 +198,7 @@ public final class PersistenceTest {
       fileInfo = mFileSystemMaster.getFileInfo(testFile, GET_STATUS_CONTEXT);
       Map<Long, PersistJob> persistJobs = getPersistJobs();
       PersistJob job = persistJobs.get(fileInfo.getFileId());
-      UnderFileSystem ufs = UnderFileSystem.Factory.create(job.getTempUfsPath());
+      UnderFileSystem ufs = UnderFileSystem.Factory.create(job.getTempUfsPath(), ServerConfiguration.global());
       UnderFileSystemUtils.touch(ufs, job.getTempUfsPath());
     }
 
@@ -315,7 +315,7 @@ public final class PersistenceTest {
    */
   @Test(timeout = 20000)
   public void retryPersistJobRenameDelete() throws Exception {
-    AuthenticatedClientUser.set(LoginUser.get().getName());
+    AuthenticatedClientUser.set(LoginUser.get(ServerConfiguration.global()).getName());
     // Create src file and directory, checking the internal state.
     AlluxioURI alluxioDirSrc = new AlluxioURI("/src");
     mFileSystemMaster.createDirectory(alluxioDirSrc,
@@ -358,7 +358,7 @@ public final class PersistenceTest {
     {
       Map<Long, PersistJob> persistJobs = getPersistJobs();
       PersistJob job = persistJobs.get(fileId);
-      UnderFileSystem ufs = UnderFileSystem.Factory.create(job.getTempUfsPath());
+      UnderFileSystem ufs = UnderFileSystem.Factory.create(job.getTempUfsPath(), ServerConfiguration.global());
       UnderFileSystemUtils.touch(ufs, job.getTempUfsPath());
     }
 
@@ -453,8 +453,8 @@ public final class PersistenceTest {
 
   private AlluxioURI createTestFile() throws Exception {
     AlluxioURI path = new AlluxioURI("/" + CommonUtils.randomAlphaNumString(10));
-    String owner = SecurityUtils.getOwnerFromGrpcClient();
-    String group = SecurityUtils.getGroupFromGrpcClient();
+    String owner = SecurityUtils.getOwnerFromGrpcClient(ServerConfiguration.global());
+    String group = SecurityUtils.getGroupFromGrpcClient(ServerConfiguration.global());
     mFileSystemMaster.createFile(path,
         CreateFileContext
             .defaults(
@@ -535,7 +535,7 @@ public final class PersistenceTest {
     mRegistry.start(true);
     mMockJobMasterClient = Mockito.mock(JobMasterClient.class);
     PowerMockito.mockStatic(JobMasterClient.Factory.class);
-    Mockito.when(JobMasterClient.Factory.create(Mockito.any(JobMasterClientConfig.class)))
+    Mockito.when(JobMasterClient.Factory.create(Mockito.any(JobMasterClientConfig.class), ServerConfiguration.global()))
         .thenReturn(mMockJobMasterClient);
   }
 
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/AsyncUfsAbsentPathCacheTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/AsyncUfsAbsentPathCacheTest.java
index a1a85b4d75..9be2eeeaac 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/AsyncUfsAbsentPathCacheTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/AsyncUfsAbsentPathCacheTest.java
@@ -61,7 +61,7 @@ public class AsyncUfsAbsentPathCacheTest {
     mUfsManager.addMount(mMountId, new AlluxioURI(mLocalUfsPath),
         UnderFileSystemConfiguration.defaults().setReadOnly(options.getReadOnly())
             .setShared(options.getShared())
-            .setMountSpecificConf(Collections.<String, String>emptyMap()));
+            .createMountSpecificConf(Collections.<String, String>emptyMap()));
     mMountTable.add(NoopJournalContext.INSTANCE, new AlluxioURI("/mnt"),
         new AlluxioURI(mLocalUfsPath), mMountId, options);
   }
@@ -167,7 +167,7 @@ public class AsyncUfsAbsentPathCacheTest {
     mUfsManager.addMount(newMountId, new AlluxioURI(mLocalUfsPath),
         UnderFileSystemConfiguration.defaults().setReadOnly(options.getReadOnly())
             .setShared(options.getShared())
-            .setMountSpecificConf(Collections.<String, String>emptyMap()));
+            .createMountSpecificConf(Collections.<String, String>emptyMap()));
     mMountTable.add(NoopJournalContext.INSTANCE, new AlluxioURI("/mnt"),
         new AlluxioURI(mLocalUfsPath), newMountId, options);
 
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/InodeDirectoryTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/InodeDirectoryTest.java
index 427d1faffe..0bf73fb4d4 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/InodeDirectoryTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/InodeDirectoryTest.java
@@ -12,6 +12,8 @@
 package alluxio.master.file.meta;
 
 import alluxio.Constants;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.file.contexts.CreateDirectoryContext;
 import alluxio.security.authorization.Mode;
 import alluxio.util.ModeUtils;
@@ -247,7 +249,9 @@ public final class InodeDirectoryTest extends AbstractInodeTest {
     InodeDirectory inode2 = createInodeDirectory();
     Assert.assertEquals(TEST_OWNER, inode2.getOwner());
     Assert.assertEquals(TEST_GROUP, inode2.getGroup());
-    Assert.assertEquals(ModeUtils.applyDirectoryUMask(Mode.defaults()).toShort(), inode2.getMode());
+    Assert.assertEquals(ModeUtils.applyDirectoryUMask(Mode.defaults(),
+        ServerConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)).toShort(),
+        inode2.getMode());
   }
 
   /**
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/InodeFileTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/InodeFileTest.java
index fbfb188bf2..674305e597 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/InodeFileTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/InodeFileTest.java
@@ -16,6 +16,8 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import alluxio.Constants;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.BlockInfoException;
 import alluxio.security.authorization.Mode;
 import alluxio.util.ModeUtils;
@@ -130,6 +132,8 @@ public final class InodeFileTest extends AbstractInodeTest {
     InodeFile inode1 = createInodeFile(1);
     assertEquals(TEST_OWNER, inode1.getOwner());
     assertEquals(TEST_GROUP, inode1.getGroup());
-    assertEquals(ModeUtils.applyFileUMask(Mode.defaults()).toShort(), inode1.getMode());
+    assertEquals(ModeUtils.applyFileUMask(Mode.defaults(),
+        ServerConfiguration.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)).toShort(),
+        inode1.getMode());
   }
 }
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/InodeTreeTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/InodeTreeTest.java
index 497d24ac42..91fd86ce5d 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/InodeTreeTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/InodeTreeTest.java
@@ -20,7 +20,8 @@ import static org.mockito.Mockito.mock;
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.BlockInfoException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileAlreadyExistsException;
@@ -104,7 +105,7 @@ public final class InodeTreeTest {
       new ConfigurationRule(new ImmutableMap.Builder<PropertyKey, String>()
           .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, "true")
           .put(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, "test-supergroup")
-          .build());
+          .build(), ServerConfiguration.global());
 
   /**
    * Sets up all dependencies before a test runs.
@@ -531,7 +532,7 @@ public final class InodeTreeTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get an Inode by a non-existing path.
+   * Tests that an exception is thrown when trying to create an Inode by a non-existing path.
    */
   @Test
   public void getInodeByNonexistingPath() throws Exception {
@@ -543,7 +544,7 @@ public final class InodeTreeTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get an Inode by a non-existing, nested path.
+   * Tests that an exception is thrown when trying to create an Inode by a non-existing, nested path.
    */
   @Test
   public void getInodeByNonexistingNestedPath() throws Exception {
@@ -556,7 +557,7 @@ public final class InodeTreeTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get an Inode with an invalid id.
+   * Tests that an exception is thrown when trying to create an Inode with an invalid id.
    */
   @Test
   public void getInodeByInvalidId() throws Exception {
@@ -802,7 +803,7 @@ public final class InodeTreeTest {
     }
   }
 
-  // Helper to get an inode by path. The inode is unlocked before returning.
+  // Helper to create an inode by path. The inode is unlocked before returning.
   private static InodeView getInodeByPath(InodeTree root, AlluxioURI path) throws Exception {
     try (LockedInodePath inodePath = root.lockFullInodePath(path, LockPattern.READ)) {
       return inodePath.getInode();
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/LazyUfsBlockLocationCacheTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/LazyUfsBlockLocationCacheTest.java
index e03eeef1a8..86ceb6a1a4 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/LazyUfsBlockLocationCacheTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/LazyUfsBlockLocationCacheTest.java
@@ -12,6 +12,7 @@
 package alluxio.master.file.meta;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.MountPOptions;
 import alluxio.master.file.contexts.MountContext;
 import alluxio.master.file.meta.options.MountInfo;
@@ -47,7 +48,7 @@ public class LazyUfsBlockLocationCacheTest {
   @Before
   public void before() throws Exception {
     mLocalUfsPath = Files.createTempDir().getAbsolutePath();
-    mLocalUfs = UnderFileSystem.Factory.create(mLocalUfsPath);
+    mLocalUfs = UnderFileSystem.Factory.create(mLocalUfsPath, ServerConfiguration.global());
 
     mMountId = IdUtils.getRandomNonNegativeLong();
     mUfsManager = new MasterUfsManager();
@@ -55,7 +56,7 @@ public class LazyUfsBlockLocationCacheTest {
     mUfsManager.addMount(mMountId, new AlluxioURI(mLocalUfsPath),
         UnderFileSystemConfiguration.defaults().setReadOnly(options.getReadOnly())
             .setShared(options.getShared())
-            .setMountSpecificConf(Collections.<String, String>emptyMap()));
+            .createMountSpecificConf(Collections.<String, String>emptyMap()));
 
     mMountTable = new MountTable(mUfsManager, new MountInfo(new AlluxioURI("/"),
         new AlluxioURI("/ufs"), 1, MountContext.defaults().getOptions().build()));
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/MountTableTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/MountTableTest.java
index 0a6b2e0a53..a5ad0ad63b 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/MountTableTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/MountTableTest.java
@@ -16,6 +16,7 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AccessControlException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileAlreadyExistsException;
@@ -44,7 +45,8 @@ import java.util.Map;
 public final class MountTableTest {
   private MountTable mMountTable;
   private final UnderFileSystem mTestUfs =
-      new LocalUnderFileSystemFactory().create("/", UnderFileSystemConfiguration.defaults());
+      new LocalUnderFileSystemFactory().create("/", UnderFileSystemConfiguration.defaults(),
+          ServerConfiguration.global());
   private static final String ROOT_UFS = "s3a://bucket/";
 
   @Before
diff --git a/core/server/master/src/test/java/alluxio/master/file/meta/UfsAbsentPathCacheTest.java b/core/server/master/src/test/java/alluxio/master/file/meta/UfsAbsentPathCacheTest.java
index ed7709770d..ea97355b6b 100644
--- a/core/server/master/src/test/java/alluxio/master/file/meta/UfsAbsentPathCacheTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/meta/UfsAbsentPathCacheTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.file.meta;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.junit.After;
 import org.junit.Assert;
@@ -28,7 +28,7 @@ public class UfsAbsentPathCacheTest {
    */
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
@@ -39,14 +39,14 @@ public class UfsAbsentPathCacheTest {
 
   @Test
   public void noAsyncPathThreads() throws Exception {
-    Configuration.set(PropertyKey.MASTER_UFS_PATH_CACHE_THREADS, 0);
+    ServerConfiguration.set(PropertyKey.MASTER_UFS_PATH_CACHE_THREADS, 0);
     UfsAbsentPathCache cache = UfsAbsentPathCache.Factory.create(null);
     Assert.assertTrue(cache instanceof NoopUfsAbsentPathCache);
   }
 
   @Test
   public void negativeAsyncPathThreads() throws Exception {
-    Configuration.set(PropertyKey.MASTER_UFS_PATH_CACHE_THREADS, -1);
+    ServerConfiguration.set(PropertyKey.MASTER_UFS_PATH_CACHE_THREADS, -1);
     UfsAbsentPathCache cache = UfsAbsentPathCache.Factory.create(null);
     Assert.assertTrue(cache instanceof NoopUfsAbsentPathCache);
   }
diff --git a/core/server/master/src/test/java/alluxio/master/file/replication/ReplicationCheckerTest.java b/core/server/master/src/test/java/alluxio/master/file/replication/ReplicationCheckerTest.java
index b8a160fac3..f5bd438acc 100644
--- a/core/server/master/src/test/java/alluxio/master/file/replication/ReplicationCheckerTest.java
+++ b/core/server/master/src/test/java/alluxio/master/file/replication/ReplicationCheckerTest.java
@@ -14,10 +14,10 @@ package alluxio.master.file.replication;
 import static org.mockito.Mockito.mock;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.RegisterWorkerPOptions;
 import alluxio.job.replicate.ReplicationHandler;
@@ -135,8 +135,9 @@ public final class ReplicationCheckerTest {
     journalSystem.gainPrimacy();
     mBlockMaster.start(true);
 
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, "true");
-    Configuration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, "test-supergroup");
+    ServerConfiguration.set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, "true");
+    ServerConfiguration
+        .set(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, "test-supergroup");
     mInodeTree.initializeRoot(TEST_OWNER, TEST_GROUP, TEST_MODE, NoopJournalContext.INSTANCE);
 
     mMockReplicationHandler = new MockHandler();
@@ -146,7 +147,7 @@ public final class ReplicationCheckerTest {
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
diff --git a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointThreadTest.java b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointThreadTest.java
index e343b8db97..010b1465fd 100644
--- a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointThreadTest.java
+++ b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointThreadTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.journal.ufs;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.master.MockMaster;
 import alluxio.master.NoopMaster;
 import alluxio.proto.journal.Journal;
@@ -49,13 +49,13 @@ public final class UfsJournalCheckpointThreadTest {
   public void before() throws Exception {
     URI location = URIUtils
         .appendPathOrDie(new URI(mFolder.newFolder().getAbsolutePath()), "FileSystemMaster");
-    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location));
+    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location, ServerConfiguration.global()));
     mJournal = new UfsJournal(location, new NoopMaster(), mUfs, 0);
   }
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -63,7 +63,7 @@ public final class UfsJournalCheckpointThreadTest {
    */
   @Test
   public void checkpointBeforeShutdown() throws Exception {
-    Configuration.set(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, "2");
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, "2");
     buildCompletedLog(0, 10);
     buildIncompleteLog(10, 15);
     MockMaster mockMaster = new MockMaster();
@@ -94,7 +94,7 @@ public final class UfsJournalCheckpointThreadTest {
    */
   @Test
   public void checkpointAfterShutdown() throws Exception {
-    Configuration.set(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, "2");
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, "2");
     buildCompletedLog(0, 10);
     buildIncompleteLog(10, 15);
     MockMaster mockMaster = new MockMaster();
diff --git a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointWriterTest.java b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointWriterTest.java
index 8345a682f1..489241b629 100644
--- a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointWriterTest.java
+++ b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalCheckpointWriterTest.java
@@ -12,6 +12,7 @@
 package alluxio.master.journal.ufs;
 
 import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.NoopMaster;
 import alluxio.proto.journal.Journal;
 import alluxio.underfs.UnderFileSystem;
@@ -41,13 +42,13 @@ public final class UfsJournalCheckpointWriterTest {
   public void before() throws Exception {
     URI location = URIUtils
         .appendPathOrDie(new URI(mFolder.newFolder().getAbsolutePath()), "FileSystemMaster");
-    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location));
+    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location, ServerConfiguration.global()));
     mJournal = new UfsJournal(location, new NoopMaster(), mUfs, 0);
   }
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
diff --git a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalConfTest.java b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalConfTest.java
index 75105ca784..5dc2361311 100644
--- a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalConfTest.java
+++ b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalConfTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.journal.ufs;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystemConfiguration;
 
 import org.junit.After;
@@ -26,7 +26,7 @@ import org.junit.Test;
 public class UfsJournalConfTest {
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
@@ -41,7 +41,7 @@ public class UfsJournalConfTest {
         PropertyKey.Template.MASTER_JOURNAL_UFS_OPTION_PROPERTY
             .format(PropertyKey.UNDERFS_LISTING_LENGTH.toString());
     String value = "10000";
-    Configuration.set(key, value);
+    ServerConfiguration.set(key, value);
     UnderFileSystemConfiguration conf = UfsJournal.getJournalUfsConf();
     Assert.assertEquals(value, conf.get(PropertyKey.UNDERFS_LISTING_LENGTH));
     Assert.assertEquals(1, conf.getMountSpecificConf().size());
diff --git a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalLogWriterTest.java b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalLogWriterTest.java
index 8bd8d13395..dc3cae18cc 100644
--- a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalLogWriterTest.java
+++ b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalLogWriterTest.java
@@ -13,9 +13,9 @@ package alluxio.master.journal.ufs;
 
 import static org.hamcrest.CoreMatchers.containsString;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.InvalidJournalEntryException;
@@ -61,13 +61,13 @@ public final class UfsJournalLogWriterTest {
   public void before() throws Exception {
     URI location = URIUtils
         .appendPathOrDie(new URI(mFolder.newFolder().getAbsolutePath()), "FileSystemMaster");
-    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location));
+    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location, ServerConfiguration.global()));
     mJournal = new UfsJournal(location, new NoopMaster(), mUfs, 0);
   }
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -175,7 +175,7 @@ public final class UfsJournalLogWriterTest {
   @Test
   public void writeJournalEntryRotate() throws Exception {
     Mockito.when(mUfs.supportsFlush()).thenReturn(true);
-    Configuration.set(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX, "1");
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX, "1");
 
     long nextSN = 0x20;
     UfsJournalLogWriter writer = new UfsJournalLogWriter(mJournal, nextSN);
diff --git a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalReaderTest.java b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalReaderTest.java
index d211882066..ab4ee428fd 100644
--- a/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalReaderTest.java
+++ b/core/server/master/src/test/java/alluxio/master/journal/ufs/UfsJournalReaderTest.java
@@ -12,6 +12,7 @@
 package alluxio.master.journal.ufs;
 
 import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.NoopMaster;
 import alluxio.master.journal.JournalReader;
 import alluxio.proto.journal.Journal;
@@ -43,13 +44,13 @@ public final class UfsJournalReaderTest {
   public void before() throws Exception {
     URI location = URIUtils
         .appendPathOrDie(new URI(mFolder.newFolder().getAbsolutePath()), "FileSystemMaster");
-    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location));
+    mUfs = Mockito.spy(UnderFileSystem.Factory.create(location, ServerConfiguration.global()));
     mJournal = new UfsJournal(location, new NoopMaster(), mUfs, 0);
   }
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
diff --git a/core/server/master/src/test/java/alluxio/master/meta/AlluxioMasterRestServiceHandlerTest.java b/core/server/master/src/test/java/alluxio/master/meta/AlluxioMasterRestServiceHandlerTest.java
index 28282391ba..8b0d163ae3 100644
--- a/core/server/master/src/test/java/alluxio/master/meta/AlluxioMasterRestServiceHandlerTest.java
+++ b/core/server/master/src/test/java/alluxio/master/meta/AlluxioMasterRestServiceHandlerTest.java
@@ -22,8 +22,10 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.Server;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.RegisterWorkerPOptions;
 import alluxio.master.CoreMasterContext;
 import alluxio.master.MasterProcess;
@@ -107,7 +109,7 @@ public final class AlluxioMasterRestServiceHandlerTest {
     {
       put(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS, TEST_PATH);
     }
-  });
+  }, ServerConfiguration.global());
 
   @Before
   public void before() throws Exception {
@@ -157,7 +159,8 @@ public final class AlluxioMasterRestServiceHandlerTest {
     when(underFileSystemMock.getSpace(TEST_PATH, UnderFileSystem.SpaceType.SPACE_USED)).thenReturn(
         UFS_SPACE_USED);
     when(underFileSystemFactoryMock.create(eq(TEST_PATH),
-        Matchers.<UnderFileSystemConfiguration>any())).thenReturn(underFileSystemMock);
+        Matchers.<UnderFileSystemConfiguration>any(), ServerConfiguration.global()))
+        .thenReturn(underFileSystemMock);
     UnderFileSystemFactoryRegistry.register(underFileSystemFactoryMock);
   }
 
diff --git a/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationCheckerTest.java b/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationCheckerTest.java
index 579b89ba55..f58b421e7d 100644
--- a/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationCheckerTest.java
+++ b/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationCheckerTest.java
@@ -13,7 +13,7 @@ package alluxio.master.meta.checkconf;
 
 import static org.junit.Assert.assertEquals;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.ConfigProperty;
 import alluxio.grpc.ConfigStatus;
 import alluxio.grpc.Scope;
diff --git a/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationStoreTest.java b/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationStoreTest.java
index 54d70502d4..3f30300414 100644
--- a/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationStoreTest.java
+++ b/core/server/master/src/test/java/alluxio/master/meta/checkconf/ServerConfigurationStoreTest.java
@@ -15,7 +15,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.ConfigProperty;
 import alluxio.wire.Address;
 
diff --git a/core/server/proxy/src/main/java/alluxio/StreamCache.java b/core/server/proxy/src/main/java/alluxio/StreamCache.java
index 2c2285a00f..817358c5af 100644
--- a/core/server/proxy/src/main/java/alluxio/StreamCache.java
+++ b/core/server/proxy/src/main/java/alluxio/StreamCache.java
@@ -65,7 +65,7 @@ public final class StreamCache {
   }
 
   /**
-   * @param key the key to get the stream for
+   * @param key the key to create the stream for
    * @return the stream or null if the cache contains no stream for the given key
    */
   public FileInStream getInStream(Integer key) {
@@ -73,7 +73,7 @@ public final class StreamCache {
   }
 
   /**
-   * @param key the key to get the stream for
+   * @param key the key to create the stream for
    * @return the stream or null if the cache contains no stream for the given key
    */
   public FileOutStream getOutStream(Integer key) {
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxy.java b/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxy.java
index 8dc226f298..37121d0f3d 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxy.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxy.java
@@ -13,8 +13,11 @@ package alluxio.proxy;
 
 import alluxio.Constants;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
+import alluxio.conf.ServerConfiguration;
 import alluxio.util.CommonUtils;
 import alluxio.util.ConfigurationUtils;
 
@@ -42,7 +45,7 @@ public final class AlluxioProxy {
       System.exit(-1);
     }
 
-    if (!ConfigurationUtils.masterHostConfigured()) {
+    if (!ConfigurationUtils.masterHostConfigured(ServerConfiguration.global())) {
       ProcessUtils.fatalError(LOG,
           "Cannot run alluxio proxy; master hostname is not "
               + "configured. Please modify %s to either set %s or configure zookeeper with "
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyProcess.java b/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyProcess.java
index 694dbf5753..71b7c2b4bc 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyProcess.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyProcess.java
@@ -11,9 +11,10 @@
 
 package alluxio.proxy;
 
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.util.CommonUtils;
 import alluxio.util.WaitForOptions;
 import alluxio.util.network.NetworkAddressUtils;
@@ -77,9 +78,9 @@ public final class AlluxioProxyProcess implements ProxyProcess {
   @Override
   public void start() throws Exception {
     mWebServer = new ProxyWebServer(ServiceType.PROXY_WEB.getServiceName(),
-        NetworkAddressUtils.getBindAddress(ServiceType.PROXY_WEB), this);
+        NetworkAddressUtils.getBindAddress(ServiceType.PROXY_WEB, ServerConfiguration.global()), this);
     // reset proxy web port
-    Configuration.set(PropertyKey.PROXY_WEB_PORT, Integer.toString(mWebServer.getLocalPort()));
+    ServerConfiguration.set(PropertyKey.PROXY_WEB_PORT, Integer.toString(mWebServer.getLocalPort()));
     mWebServer.start();
     mLatch.await();
   }
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyRestServiceHandler.java b/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyRestServiceHandler.java
index b0ef0a0b6a..8dacbb5135 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyRestServiceHandler.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/AlluxioProxyRestServiceHandler.java
@@ -11,8 +11,8 @@
 
 package alluxio.proxy;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.ConfigurationValueOptions;
 import alluxio.RestUtils;
 import alluxio.RuntimeConstants;
 import alluxio.web.ProxyWebServer;
@@ -62,7 +62,7 @@ public final class AlluxioProxyRestServiceHandler {
   }
 
   /**
-   * @summary get the Alluxio proxy information
+   * @summary create the Alluxio proxy information
    * @param rawConfiguration if it's true, raw configuration values are returned,
    *    otherwise, they are looked up; if it's not provided in URL queries, then
    *    it is null, which means false.
@@ -88,11 +88,11 @@ public final class AlluxioProxyRestServiceHandler {
                 .setVersion(RuntimeConstants.VERSION);
         return result;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   private Map<String, String> getConfigurationInternal(boolean raw) {
-    return new TreeMap<>(Configuration
+    return new TreeMap<>(ServerConfiguration
         .toMap(ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(raw)));
   }
 }
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/PathsRestServiceHandler.java b/core/server/proxy/src/main/java/alluxio/proxy/PathsRestServiceHandler.java
index 8e2c8c1324..cdc6d25bb1 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/PathsRestServiceHandler.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/PathsRestServiceHandler.java
@@ -13,11 +13,13 @@ package alluxio.proxy;
 
 import alluxio.AlluxioURI;
 import alluxio.RestUtils;
+import alluxio.Server;
 import alluxio.StreamCache;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.DeletePOptions;
@@ -66,7 +68,7 @@ public final class PathsRestServiceHandler {
   public static final String DELETE = "delete";
   public static final String EXISTS = "exists";
   public static final String FREE = "free";
-  public static final String GET_STATUS = "get-status";
+  public static final String GET_STATUS = "create-status";
   public static final String LIST_STATUS = "list-status";
   public static final String MOUNT = "mount";
   public static final String OPEN_FILE = "open-file";
@@ -112,7 +114,7 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -138,7 +140,7 @@ public final class PathsRestServiceHandler {
         }
         return mStreamCache.put(os);
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -161,7 +163,7 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -183,7 +185,7 @@ public final class PathsRestServiceHandler {
           return mFileSystem.exists(new AlluxioURI(path), options);
         }
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -206,7 +208,7 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -228,7 +230,7 @@ public final class PathsRestServiceHandler {
           return mFileSystem.getStatus(new AlluxioURI(path), options);
         }
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -252,7 +254,7 @@ public final class PathsRestServiceHandler {
           return mFileSystem.listStatus(new AlluxioURI(path), options);
         }
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -279,7 +281,7 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -304,7 +306,7 @@ public final class PathsRestServiceHandler {
         }
         return mStreamCache.put(is);
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -331,7 +333,7 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -355,7 +357,7 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -378,6 +380,6 @@ public final class PathsRestServiceHandler {
         }
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 }
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/StreamsRestServiceHandler.java b/core/server/proxy/src/main/java/alluxio/proxy/StreamsRestServiceHandler.java
index 8f25296fe4..23e0015231 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/StreamsRestServiceHandler.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/StreamsRestServiceHandler.java
@@ -15,6 +15,7 @@ import alluxio.RestUtils;
 import alluxio.StreamCache;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
+import alluxio.conf.ServerConfiguration;
 import alluxio.web.ProxyWebServer;
 
 import com.google.common.io.ByteStreams;
@@ -77,7 +78,7 @@ public final class StreamsRestServiceHandler {
         throw new IllegalArgumentException("stream does not exist");
       }
       return null;
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -100,7 +101,7 @@ public final class StreamsRestServiceHandler {
         }
         throw new IllegalArgumentException("stream does not exist");
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -123,6 +124,6 @@ public final class StreamsRestServiceHandler {
         }
         throw new IllegalArgumentException("stream does not exist");
       }
-    });
+    }, ServerConfiguration.global());
   }
 }
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/s3/ListBucketResult.java b/core/server/proxy/src/main/java/alluxio/proxy/s3/ListBucketResult.java
index 728b7b6eeb..6534333b0e 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/s3/ListBucketResult.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/s3/ListBucketResult.java
@@ -113,7 +113,7 @@ public class ListBucketResult {
       if (mPrefix != null && !objectKey.startsWith(mPrefix)) {
         continue;
       }
-      // TODO(chaomin): set ETag once there's a way to get MD5 hash of an Alluxio file.
+      // TODO(chaomin): set ETag once there's a way to create MD5 hash of an Alluxio file.
       // TODO(chaomin): construct the response with CommonPrefixes when delimiter support is added.
       mContents.add(new Content(
           status.getPath().substring(mName.length() + 1),
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestServiceHandler.java b/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestServiceHandler.java
index 77ba19c87d..664618f5d1 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestServiceHandler.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestServiceHandler.java
@@ -12,9 +12,9 @@
 package alluxio.proxy.s3;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
@@ -146,7 +146,7 @@ public final class S3RestServiceHandler {
         checkBucketIsAlluxioDirectory(bucketPath);
 
         // Delete the bucket.
-        DeletePOptions options = DeletePOptions.newBuilder().setAlluxioOnly(Configuration
+        DeletePOptions options = DeletePOptions.newBuilder().setAlluxioOnly(ServerConfiguration
             .get(PropertyKey.PROXY_S3_DELETE_TYPE).equals(Constants.S3_DELETE_IN_ALLUXIO_ONLY))
             .build();
         try {
@@ -540,7 +540,7 @@ public final class S3RestServiceHandler {
     String bucketPath = parseBucketPath(AlluxioURI.SEPARATOR + bucket);
     // Delete the object.
     String objectPath = bucketPath + AlluxioURI.SEPARATOR + object;
-    DeletePOptions options = DeletePOptions.newBuilder().setAlluxioOnly(Configuration
+    DeletePOptions options = DeletePOptions.newBuilder().setAlluxioOnly(ServerConfiguration
         .get(PropertyKey.PROXY_S3_DELETE_TYPE).equals(Constants.S3_DELETE_IN_ALLUXIO_ONLY)).build();
     try {
       mFileSystem.delete(new AlluxioURI(objectPath), options);
@@ -662,7 +662,7 @@ public final class S3RestServiceHandler {
   }
 
   private WritePType getS3WriteType() {
-    return Configuration.getEnum(PropertyKey.PROXY_S3_WRITE_TYPE, WriteType.class).toProto();
+    return ServerConfiguration.getEnum(PropertyKey.PROXY_S3_WRITE_TYPE, WriteType.class).toProto();
   }
 
   private class URIStatusNameComparator implements Comparator<URIStatus> {
diff --git a/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestUtils.java b/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestUtils.java
index 268dcfb837..23583fd14d 100644
--- a/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestUtils.java
+++ b/core/server/proxy/src/main/java/alluxio/proxy/s3/S3RestUtils.java
@@ -12,8 +12,8 @@
 package alluxio.proxy.s3;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.security.LoginUser;
 import alluxio.security.authentication.AuthenticatedClientUser;
 import alluxio.util.SecurityUtils;
@@ -47,8 +47,9 @@ public final class S3RestUtils {
   public static <T> Response call(String resource, S3RestUtils.RestCallable<T> callable) {
     try {
       // TODO(cc): reconsider how to enable authentication
-      if (SecurityUtils.isSecurityEnabled() && AuthenticatedClientUser.get() == null) {
-        AuthenticatedClientUser.set(LoginUser.get().getName());
+      if (SecurityUtils.isSecurityEnabled(ServerConfiguration.global())
+              && AuthenticatedClientUser.get(ServerConfiguration.global()) == null) {
+        AuthenticatedClientUser.set(LoginUser.get(ServerConfiguration.global()).getName());
       }
     } catch (IOException e) {
       LOG.warn("Failed to set AuthenticatedClientUser in REST service handler: {}", e.getMessage());
@@ -143,7 +144,7 @@ public final class S3RestUtils {
    */
   public static String getMultipartTemporaryDirForObject(String bucketPath, String objectKey) {
     String multipartTemporaryDirSuffix =
-        Configuration.get(PropertyKey.PROXY_S3_MULTIPART_TEMPORARY_DIR_SUFFIX);
+        ServerConfiguration.get(PropertyKey.PROXY_S3_MULTIPART_TEMPORARY_DIR_SUFFIX);
     return bucketPath + AlluxioURI.SEPARATOR + objectKey + multipartTemporaryDirSuffix;
   }
 
diff --git a/core/server/proxy/src/main/java/alluxio/web/ProxyWebServer.java b/core/server/proxy/src/main/java/alluxio/web/ProxyWebServer.java
index 20187064fb..4ffeb5e319 100644
--- a/core/server/proxy/src/main/java/alluxio/web/ProxyWebServer.java
+++ b/core/server/proxy/src/main/java/alluxio/web/ProxyWebServer.java
@@ -11,9 +11,9 @@
 
 package alluxio.web;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.StreamCache;
 import alluxio.proxy.ProxyProcess;
@@ -62,7 +62,7 @@ public final class ProxyWebServer extends WebServer {
         getServletContext()
             .setAttribute(FILE_SYSTEM_SERVLET_RESOURCE_KEY, FileSystem.Factory.get());
         getServletContext().setAttribute(STREAM_CACHE_SERVLET_RESOURCE_KEY,
-            new StreamCache(Configuration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS)));
+            new StreamCache(ServerConfiguration.getMs(PropertyKey.PROXY_STREAM_CACHE_TIMEOUT_MS)));
       }
     };
     ServletHolder servletHolder = new ServletHolder("Alluxio Proxy Web Service", servlet);
diff --git a/core/server/worker/src/main/java/alluxio/Sessions.java b/core/server/worker/src/main/java/alluxio/Sessions.java
index 13fd3c524d..977c058eda 100644
--- a/core/server/worker/src/main/java/alluxio/Sessions.java
+++ b/core/server/worker/src/main/java/alluxio/Sessions.java
@@ -11,6 +11,8 @@
 
 package alluxio;
 
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.IdUtils;
 
 import org.slf4j.Logger;
@@ -91,7 +93,7 @@ public final class Sessions {
       if (mSessions.containsKey(sessionId)) {
         mSessions.get(sessionId).heartbeat();
       } else {
-        int sessionTimeoutMs = (int) Configuration.getMs(PropertyKey.WORKER_SESSION_TIMEOUT_MS);
+        int sessionTimeoutMs = (int) ServerConfiguration.getMs(PropertyKey.WORKER_SESSION_TIMEOUT_MS);
         mSessions.put(sessionId, new SessionInfo(sessionId, sessionTimeoutMs));
       }
     }
diff --git a/core/server/worker/src/main/java/alluxio/underfs/WorkerUfsManager.java b/core/server/worker/src/main/java/alluxio/underfs/WorkerUfsManager.java
index 05db03a6ff..b6a65fcbb9 100644
--- a/core/server/worker/src/main/java/alluxio/underfs/WorkerUfsManager.java
+++ b/core/server/worker/src/main/java/alluxio/underfs/WorkerUfsManager.java
@@ -12,6 +12,7 @@
 package alluxio.underfs;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.status.NotFoundException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.UfsInfo;
@@ -41,13 +42,14 @@ public final class WorkerUfsManager extends AbstractUfsManager {
    * Constructs an instance of {@link WorkerUfsManager}.
    */
   public WorkerUfsManager() {
-    mMasterClient = mCloser.register(new FileSystemMasterClient(MasterClientConfig.defaults()));
+    mMasterClient =
+        mCloser.register(new FileSystemMasterClient(MasterClientConfig.defaults(ServerConfiguration.global())));
   }
 
   /**
    * {@inheritDoc}.
    *
-   * If this mount id is new to this worker, this method will query master to get the corresponding
+   * If this mount id is new to this worker, this method will query master to create the corresponding
    * ufs info.
    */
   @Override
@@ -63,18 +65,20 @@ public final class WorkerUfsManager extends AbstractUfsManager {
       info = mMasterClient.getUfsInfo(mountId);
     } catch (IOException e) {
       throw new UnavailableException(
-          String.format("Failed to get UFS info for mount point with id %d", mountId), e);
+          String.format("Failed to create UFS info for mount point with id %d", mountId), e);
     }
     Preconditions.checkState((info.hasUri() && info.hasProperties()), "unknown mountId");
     super.addMount(mountId, new AlluxioURI(info.getUri()),
-        UnderFileSystemConfiguration.defaults().setReadOnly(info.getProperties().getReadOnly())
+        UnderFileSystemConfiguration.defaults(ServerConfiguration.global())
+            .setReadOnly(info.getProperties().getReadOnly())
             .setShared(info.getProperties().getShared())
-            .setMountSpecificConf(info.getProperties().getProperties()));
+            .createMountSpecificConf(info.getProperties().getPropertiesMap()));
     UfsClient ufsClient = super.get(mountId);
     try (CloseableResource<UnderFileSystem> ufsResource = ufsClient.acquireUfsResource()) {
       UnderFileSystem ufs = ufsResource.get();
       ufs.connectFromWorker(
-          NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.WORKER_RPC));
+          NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.WORKER_RPC,
+              ServerConfiguration.global()));
     } catch (IOException e) {
       removeMount(mountId);
       throw new UnavailableException(
diff --git a/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerBlockInfoServlet.java b/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerBlockInfoServlet.java
index 2eb797cfe9..bf7a5416de 100644
--- a/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerBlockInfoServlet.java
+++ b/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerBlockInfoServlet.java
@@ -12,8 +12,8 @@
 package alluxio.web;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.WorkerStorageTierAssoc;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -74,7 +74,7 @@ public final class WebInterfaceWorkerBlockInfoServlet extends HttpServlet {
   @Override
   protected void doGet(HttpServletRequest request, HttpServletResponse response)
       throws ServletException, IOException {
-    if (!Configuration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
+    if (!ServerConfiguration.getBoolean(PropertyKey.WEB_FILE_INFO_ENABLED)) {
       return;
     }
     request.setAttribute("fatalError", "");
@@ -140,7 +140,7 @@ public final class WebInterfaceWorkerBlockInfoServlet extends HttpServlet {
           uiFileInfos.add(getUiFileInfo(fileId));
         } catch (Exception e) {
           // The file might have been deleted, log a warning and ignore this file.
-          LOG.warn("Unable to get file info for fileId {}. {}", fileId, e.getMessage());
+          LOG.warn("Unable to create file info for fileId {}. {}", fileId, e.getMessage());
         }
       }
       request.setAttribute("fileInfos", uiFileInfos);
diff --git a/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerGeneralServlet.java b/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerGeneralServlet.java
index ddda62e756..adcba44746 100644
--- a/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerGeneralServlet.java
+++ b/core/server/worker/src/main/java/alluxio/web/WebInterfaceWorkerGeneralServlet.java
@@ -13,6 +13,8 @@ package alluxio.web;
 
 import alluxio.RuntimeConstants;
 import alluxio.collections.Pair;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.util.CommonUtils;
 import alluxio.util.FormatUtils;
 import alluxio.worker.block.BlockStoreMeta;
@@ -112,7 +114,8 @@ public final class WebInterfaceWorkerGeneralServlet extends HttpServlet {
      * @return the start time
      */
     public String getStartTime() {
-      return CommonUtils.convertMsToDate(mStartTimeMs);
+      return CommonUtils.convertMsToDate(mStartTimeMs,
+          ServerConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN));
     }
 
     /**
diff --git a/core/server/worker/src/main/java/alluxio/worker/AlluxioWorker.java b/core/server/worker/src/main/java/alluxio/worker/AlluxioWorker.java
index 5d60920b24..752646f6f5 100644
--- a/core/server/worker/src/main/java/alluxio/worker/AlluxioWorker.java
+++ b/core/server/worker/src/main/java/alluxio/worker/AlluxioWorker.java
@@ -11,10 +11,10 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.MasterInquireClient;
 import alluxio.retry.RetryUtils;
@@ -48,7 +48,7 @@ public final class AlluxioWorker {
       System.exit(-1);
     }
 
-    if (!ConfigurationUtils.masterHostConfigured()) {
+    if (!ConfigurationUtils.masterHostConfigured(ServerConfiguration.global())) {
       ProcessUtils.fatalError(LOG,
           "Cannot run alluxio worker; master hostname is not "
               + "configured. Please modify %s to either set %s or configure zookeeper with "
@@ -58,12 +58,13 @@ public final class AlluxioWorker {
     }
 
     CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.WORKER);
-    MasterInquireClient masterInquireClient = MasterInquireClient.Factory.create();
+    MasterInquireClient masterInquireClient =
+        MasterInquireClient.Factory.create(ServerConfiguration.global());
     try {
       RetryUtils.retry("load cluster default configuration with master", () -> {
         InetSocketAddress masterAddress = masterInquireClient.getPrimaryRpcAddress();
-        Configuration.loadClusterDefault(masterAddress);
-      }, RetryUtils.defaultWorkerMasterClientRetry());
+        ServerConfiguration.loadClusterDefaults(masterAddress);
+      }, RetryUtils.defaultWorkerMasterClientRetry(ServerConfiguration.getDuration(PropertyKey.WORKER_MASTER_CONNECT_RETRY_TIMEOUT)));
     } catch (IOException e) {
       ProcessUtils.fatalError(LOG,
           "Failed to load cluster default configuration for worker: %s", e.getMessage());
diff --git a/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerProcess.java b/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerProcess.java
index f0aefe8006..781e6a19d3 100644
--- a/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerProcess.java
+++ b/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerProcess.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.metrics.MetricsSystem;
 import alluxio.metrics.sink.MetricsServlet;
@@ -117,17 +117,20 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
 
       // Setup web server
       mWebServer =
-          new WorkerWebServer(NetworkAddressUtils.getBindAddress(ServiceType.WORKER_WEB), this,
+          new WorkerWebServer(NetworkAddressUtils.getBindAddress(ServiceType.WORKER_WEB,
+              ServerConfiguration.global()), this,
               mRegistry.get(BlockWorker.class),
-              NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC), mStartTimeMs);
+              NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC, ServerConfiguration.global()),
+              mStartTimeMs);
 
       // Random port binding.
       int bindPort;
       InetSocketAddress configuredBindAddress =
-              NetworkAddressUtils.getBindAddress(ServiceType.WORKER_RPC);
+              NetworkAddressUtils.getBindAddress(ServiceType.WORKER_RPC, ServerConfiguration.global());
       if (configuredBindAddress.getPort() == 0) {
         mBindSocket = new ServerSocket(0);
         bindPort = mBindSocket.getLocalPort();
+        ServerConfiguration.set(PropertyKey.WORKER_RPC_PORT, Integer.toString(bindPort));
       } else {
         bindPort = configuredBindAddress.getPort();
       }
@@ -143,8 +146,8 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
       // Setup domain socket data server
       if (isDomainSocketEnabled()) {
         String domainSocketPath =
-            Configuration.get(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_ADDRESS);
-        if (Configuration.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
+            ServerConfiguration.get(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_ADDRESS);
+        if (ServerConfiguration.getBoolean(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_AS_UUID)) {
           domainSocketPath =
               PathUtils.concatPath(domainSocketPath, UUID.randomUUID().toString());
         }
@@ -217,7 +220,7 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
     // NOTE: the order to start different services is sensitive. If you change it, do it cautiously.
 
     // Start serving metrics system, this will not block
-    MetricsSystem.startSinks();
+    MetricsSystem.startSinks(ServerConfiguration.get(PropertyKey.METRICS_CONF_FILE));
 
     // Start each worker. This must be done before starting the web or RPC servers.
     // Requirement: NetAddress set in WorkerContext, so block worker can initialize BlockMasterSync
@@ -231,8 +234,12 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
     mWebServer.start();
 
     // Start monitor jvm
-    if (Configuration.getBoolean(PropertyKey.WORKER_JVM_MONITOR_ENABLED)) {
-      mJvmPauseMonitor = new JvmPauseMonitor();
+    if (ServerConfiguration.getBoolean(PropertyKey.WORKER_JVM_MONITOR_ENABLED)) {
+      mJvmPauseMonitor =
+          new JvmPauseMonitor(
+              ServerConfiguration.getMs(PropertyKey.JVM_MONITOR_SLEEP_INTERVAL_MS),
+              ServerConfiguration.getMs(PropertyKey.JVM_MONITOR_WARN_THRESHOLD_MS),
+              ServerConfiguration.getMs(PropertyKey.JVM_MONITOR_INFO_THRESHOLD_MS));
       mJvmPauseMonitor.start();
     }
 
@@ -240,10 +247,10 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
     LOG.info("Alluxio worker version {} started. "
             + "bindHost={}, connectHost={}, rpcPort={}, webPort={}",
         RuntimeConstants.VERSION,
-        NetworkAddressUtils.getBindHost(ServiceType.WORKER_RPC),
-        NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.WORKER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.WORKER_WEB));
+        NetworkAddressUtils.getBindHost(ServiceType.WORKER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.WORKER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.WORKER_WEB, ServerConfiguration.global()));
 
     mDataServer.awaitTermination();
 
@@ -292,8 +299,8 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
    * @return true if domain socket is enabled
    */
   private boolean isDomainSocketEnabled() {
-    return NettyUtils.WORKER_CHANNEL_TYPE == ChannelType.EPOLL
-        && Configuration.containsKey(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_ADDRESS);
+    return NettyUtils.getWorkerChannel(ServerConfiguration.global()) == ChannelType.EPOLL
+        && ServerConfiguration.isSet(PropertyKey.WORKER_DATA_SERVER_DOMAIN_SOCKET_ADDRESS);
   }
 
   @Override
@@ -315,7 +322,7 @@ public final class AlluxioWorkerProcess implements WorkerProcess {
   @Override
   public WorkerNetAddress getAddress() {
     return new WorkerNetAddress()
-        .setHost(NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC))
+        .setHost(NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC, ServerConfiguration.global()))
         .setRpcPort(mRpcAddress.getPort())
         .setDataPort(getDataLocalPort())
         .setDomainSocketPath(getDataDomainSocketPath())
diff --git a/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerRestServiceHandler.java b/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerRestServiceHandler.java
index 275a8f4d34..7bcb715781 100644
--- a/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerRestServiceHandler.java
+++ b/core/server/worker/src/main/java/alluxio/worker/AlluxioWorkerRestServiceHandler.java
@@ -11,8 +11,9 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.ConfigurationValueOptions;
 import alluxio.RestUtils;
 import alluxio.RuntimeConstants;
 import alluxio.WorkerStorageTierAssoc;
@@ -94,7 +95,7 @@ public final class AlluxioWorkerRestServiceHandler {
   }
 
   /**
-   * @summary get the Alluxio master information
+   * @summary create the Alluxio master information
    * @param rawConfiguration if it's true, raw configuration values are returned,
    *    otherwise, they are looked up; if it's not provided in URL queries, then
    *    it is null, which means false.
@@ -125,11 +126,11 @@ public final class AlluxioWorkerRestServiceHandler {
                 .setVersion(RuntimeConstants.VERSION);
         return result;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the configuration map, the keys are ordered alphabetically.
+   * @summary create the configuration map, the keys are ordered alphabetically.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -139,11 +140,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.util.SortedMap<java.lang.String, java.lang.String>")
   @Deprecated
   public Response getConfiguration() {
-    return RestUtils.call(() -> getConfigurationInternal(true));
+    return RestUtils.call(() -> getConfigurationInternal(true), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the address of the worker
+   * @summary create the address of the worker
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -153,11 +154,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.lang.String")
   @Deprecated
   public Response getRpcAddress() {
-    return RestUtils.call(() -> mWorkerProcess.getRpcAddress().toString());
+    return RestUtils.call(() -> mWorkerProcess.getRpcAddress().toString(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the total capacity of the worker in bytes
+   * @summary create the total capacity of the worker in bytes
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -167,11 +168,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getCapacityBytes() {
-    return RestUtils.call(() -> mStoreMeta.getCapacityBytes());
+    return RestUtils.call(() -> mStoreMeta.getCapacityBytes(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the used bytes of the worker
+   * @summary create the used bytes of the worker
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -181,11 +182,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getUsedBytes() {
-    return RestUtils.call(mStoreMeta::getUsedBytes);
+    return RestUtils.call(mStoreMeta::getUsedBytes, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the mapping from tier alias to the total capacity of the tier in bytes, the keys
+   * @summary create the mapping from tier alias to the total capacity of the tier in bytes, the keys
    *    are in the order from tier aliases with smaller ordinals to those with larger ones.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
@@ -205,11 +206,11 @@ public final class AlluxioWorkerRestServiceHandler {
         }
         return capacityBytesOnTiers;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the mapping from tier alias to the used bytes of the tier, the keys are in the
+   * @summary create the mapping from tier alias to the used bytes of the tier, the keys are in the
    *    order from tier aliases with smaller ordinals to those with larger ones.
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
@@ -229,11 +230,11 @@ public final class AlluxioWorkerRestServiceHandler {
         }
         return usedBytesOnTiers;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the mapping from tier alias to the paths of the directories in the tier
+   * @summary create the mapping from tier alias to the paths of the directories in the tier
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -243,11 +244,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.util.SortedMap<java.lang.String, java.util.List<java.lang.String>>")
   @Deprecated
   public Response getDirectoryPathsOnTiers() {
-    return RestUtils.call(() -> getTierPathsInternal());
+    return RestUtils.call(() -> getTierPathsInternal(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the version of the worker
+   * @summary create the version of the worker
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -257,11 +258,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.lang.String")
   @Deprecated
   public Response getVersion() {
-    return RestUtils.call(() -> RuntimeConstants.VERSION);
+    return RestUtils.call(() -> RuntimeConstants.VERSION, ServerConfiguration.global());
   }
 
   /**
-   * @summary get the start time of the worker in milliseconds
+   * @summary create the start time of the worker in milliseconds
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -271,11 +272,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getStartTimeMs() {
-    return RestUtils.call(() -> mWorkerProcess.getStartTimeMs());
+    return RestUtils.call(() -> mWorkerProcess.getStartTimeMs(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the uptime of the worker in milliseconds
+   * @summary create the uptime of the worker in milliseconds
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -285,11 +286,11 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.lang.Long")
   @Deprecated
   public Response getUptimeMs() {
-    return RestUtils.call(() -> mWorkerProcess.getUptimeMs());
+    return RestUtils.call(() -> mWorkerProcess.getUptimeMs(), ServerConfiguration.global());
   }
 
   /**
-   * @summary get the worker metrics
+   * @summary create the worker metrics
    * @return the response object
    * @deprecated since version 1.4 and will be removed in version 2.0
    * @see #getInfo(Boolean)
@@ -299,7 +300,7 @@ public final class AlluxioWorkerRestServiceHandler {
   @ReturnType("java.util.SortedMap<java.lang.String, java.lang.Long>")
   @Deprecated
   public Response getMetrics() {
-    return RestUtils.call(() -> getMetricsInternal());
+    return RestUtils.call(() -> getMetricsInternal(), ServerConfiguration.global());
   }
 
   private Capacity getCapacityInternal() {
@@ -308,7 +309,7 @@ public final class AlluxioWorkerRestServiceHandler {
   }
 
   private Map<String, String> getConfigurationInternal(boolean raw) {
-    return new TreeMap<>(Configuration.toMap(
+    return new TreeMap<>(ServerConfiguration.toMap(
         ConfigurationValueOptions.defaults().useDisplayValue(true).useRawValue(raw)));
   }
 
@@ -382,6 +383,6 @@ public final class AlluxioWorkerRestServiceHandler {
       public LogInfo call() throws Exception {
         return LogUtils.setLogLevel(logName, level);
       }
-    });
+    }, ServerConfiguration.global());
   }
 }
diff --git a/core/server/worker/src/main/java/alluxio/worker/DataServer.java b/core/server/worker/src/main/java/alluxio/worker/DataServer.java
index 3fe107f396..dd95e48c14 100644
--- a/core/server/worker/src/main/java/alluxio/worker/DataServer.java
+++ b/core/server/worker/src/main/java/alluxio/worker/DataServer.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.CommonUtils;
 
 import java.io.Closeable;
@@ -43,7 +43,7 @@ public interface DataServer extends Closeable {
      */
     public static DataServer create(final SocketAddress dataAddress, final WorkerProcess worker) {
       return CommonUtils.createNewClassInstance(
-          Configuration.<DataServer>getClass(PropertyKey.WORKER_DATA_SERVER_CLASS),
+          ServerConfiguration.<DataServer>getClass(PropertyKey.WORKER_DATA_SERVER_CLASS),
           new Class[] {SocketAddress.class, WorkerProcess.class},
           new Object[] {dataAddress, worker});
     }
diff --git a/core/server/worker/src/main/java/alluxio/worker/SessionCleaner.java b/core/server/worker/src/main/java/alluxio/worker/SessionCleaner.java
index d777415c65..1b464b0697 100644
--- a/core/server/worker/src/main/java/alluxio/worker/SessionCleaner.java
+++ b/core/server/worker/src/main/java/alluxio/worker/SessionCleaner.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
 import alluxio.util.CommonUtils;
 
@@ -52,7 +52,7 @@ public final class SessionCleaner implements Runnable {
     for (SessionCleanable sc : sessionCleanable) {
       mSessionCleanables.add(sc);
     }
-    mCheckIntervalMs = (int) Configuration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS);
+    mCheckIntervalMs = (int) ServerConfiguration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS);
 
     mRunning = true;
   }
diff --git a/core/server/worker/src/main/java/alluxio/worker/WorkerProcess.java b/core/server/worker/src/main/java/alluxio/worker/WorkerProcess.java
index cecf684bc6..4b1464a847 100644
--- a/core/server/worker/src/main/java/alluxio/worker/WorkerProcess.java
+++ b/core/server/worker/src/main/java/alluxio/worker/WorkerProcess.java
@@ -12,6 +12,7 @@
 package alluxio.worker;
 
 import alluxio.Process;
+import alluxio.conf.ServerConfiguration;
 import alluxio.network.TieredIdentityFactory;
 import alluxio.underfs.UfsManager;
 import alluxio.wire.TieredIdentity;
@@ -34,7 +35,7 @@ public interface WorkerProcess extends Process {
      * @return a new instance of {@link WorkerProcess}
      */
     public static WorkerProcess create() {
-      return create(TieredIdentityFactory.localIdentity());
+      return create(TieredIdentityFactory.localIdentity(ServerConfiguration.global()));
     }
 
     /**
@@ -99,8 +100,8 @@ public interface WorkerProcess extends Process {
   int getWebLocalPort();
 
   /**
-   * @param clazz the class of the worker to get
-   * @param <T> the type of the worker to get
+   * @param clazz the class of the worker to create
+   * @param <T> the type of the worker to create
 
    * @return the given worker
    */
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/AsyncCacheRequestManager.java b/core/server/worker/src/main/java/alluxio/worker/block/AsyncCacheRequestManager.java
index e430dceb56..83404ae487 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/AsyncCacheRequestManager.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/AsyncCacheRequestManager.java
@@ -15,6 +15,8 @@ import alluxio.Constants;
 import alluxio.Sessions;
 import alluxio.StorageTierAssoc;
 import alluxio.WorkerStorageTierAssoc;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.BlockAlreadyExistsException;
 import alluxio.exception.BlockDoesNotExistException;
@@ -61,7 +63,9 @@ public class AsyncCacheRequestManager {
     mAsyncCacheExecutor = service;
     mBlockWorker = blockWorker;
     mPendingRequests = new ConcurrentHashMap<>();
-    mLocalWorkerHostname = NetworkAddressUtils.getLocalHostName();
+    mLocalWorkerHostname =
+        NetworkAddressUtils.getLocalHostName(
+            (int)ServerConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
   }
 
   /**
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java
index 83a9875c20..a4ea86878b 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.BlockDoesNotExistException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.InvalidWorkerStateException;
@@ -53,7 +53,7 @@ public final class BlockLockManager {
 
  /** A pool of read write locks. */
   private final ResourcePool<ClientRWLock> mLockPool = new ResourcePool<ClientRWLock>(
-      Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCKS)) {
+      ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCKS)) {
     @Override
     public void close() {}
 
@@ -157,7 +157,7 @@ public final class BlockLockManager {
    *
    * If all locks have been allocated, this method will block until one can be acquired.
    *
-   * @param blockId the block id to get the lock for
+   * @param blockId the block id to create the lock for
    * @return the block lock
    */
   private ClientRWLock getBlockLock(long blockId) {
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClient.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClient.java
index 1c75a21b12..2f13138540 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClient.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.worker.block;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.BlockHeartbeatPOptions;
 import alluxio.grpc.BlockHeartbeatPRequest;
 import alluxio.grpc.BlockMasterWorkerServiceGrpc;
@@ -51,7 +52,7 @@ public final class BlockMasterClient extends AbstractMasterClient {
    * @param conf master client configuration
    */
   public BlockMasterClient(MasterClientConfig conf) {
-    super(conf);
+    super(conf, ServerConfiguration.global());
   }
 
   @Override
@@ -113,7 +114,7 @@ public final class BlockMasterClient extends AbstractMasterClient {
   /**
    * Returns a worker id for a workers net address.
    *
-   * @param address the net address to get a worker id for
+   * @param address the net address to create a worker id for
    * @return a worker id
    */
   public long getId(final WorkerNetAddress address) throws IOException {
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClientPool.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClientPool.java
index e68908ea41..a9bedeb4e3 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClientPool.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterClientPool.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.MasterClientConfig;
 import alluxio.resource.ResourcePool;
 
@@ -37,7 +37,7 @@ public final class BlockMasterClientPool extends ResourcePool<BlockMasterClient>
    * Creates a new block master client pool.
    */
   public BlockMasterClientPool() {
-    super(Configuration.getInt(PropertyKey.WORKER_BLOCK_MASTER_CLIENT_POOL_SIZE));
+    super(ServerConfiguration.getInt(PropertyKey.WORKER_BLOCK_MASTER_CLIENT_POOL_SIZE));
     mClientList = new ConcurrentLinkedQueue<>();
   }
 
@@ -53,7 +53,8 @@ public final class BlockMasterClientPool extends ResourcePool<BlockMasterClient>
 
   @Override
   protected BlockMasterClient createNewResource() {
-    BlockMasterClient client = new BlockMasterClient(MasterClientConfig.defaults());
+    BlockMasterClient client =
+        new BlockMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()));
     mClientList.add(client);
     return client;
   }
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterSync.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterSync.java
index 175189d929..01c3caa1bb 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterSync.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockMasterSync.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.StorageTierAssoc;
 import alluxio.WorkerStorageTierAssoc;
 import alluxio.exception.ConnectionFailedException;
@@ -88,7 +88,7 @@ public final class BlockMasterSync implements HeartbeatExecutor {
     mWorkerId = workerId;
     mWorkerAddress = workerAddress;
     mMasterClient = masterClient;
-    mHeartbeatTimeoutMs = (int) Configuration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_TIMEOUT_MS);
+    mHeartbeatTimeoutMs = (int) ServerConfiguration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_TIMEOUT_MS);
     mAsyncBlockRemover = new AsyncBlockRemover(mBlockWorker);
 
     registerWithMaster();
@@ -102,7 +102,8 @@ public final class BlockMasterSync implements HeartbeatExecutor {
   private void registerWithMaster() throws IOException {
     BlockStoreMeta storeMeta = mBlockWorker.getStoreMetaFull();
     StorageTierAssoc storageTierAssoc = new WorkerStorageTierAssoc();
-    List<ConfigProperty> configList = ConfigurationUtils.getConfiguration(Scope.WORKER);
+    List<ConfigProperty> configList =
+        ConfigurationUtils.getConfiguration(ServerConfiguration.global(), Scope.WORKER);
     mMasterClient.register(mWorkerId.get(),
         storageTierAssoc.getOrderedStorageAliases(), storeMeta.getCapacityBytesOnTiers(),
         storeMeta.getUsedBytesOnTiers(), storeMeta.getBlockList(), configList);
@@ -140,7 +141,7 @@ public final class BlockMasterSync implements HeartbeatExecutor {
       mMasterClient.disconnect();
       if (mHeartbeatTimeoutMs > 0) {
         if (System.currentTimeMillis() - mLastSuccessfulHeartbeatMs >= mHeartbeatTimeoutMs) {
-          if (Configuration.getBoolean(PropertyKey.TEST_MODE)) {
+          if (ServerConfiguration.getBoolean(PropertyKey.TEST_MODE)) {
             throw new RuntimeException("Master heartbeat timeout exceeded: " + mHeartbeatTimeoutMs);
           }
           // TODO(andrew): Propagate the exception to the main thread and exit there.
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockStore.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockStore.java
index 3753e4a6f0..f52e81fda6 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockStore.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockStore.java
@@ -112,7 +112,7 @@ public interface BlockStore extends SessionCleanable {
    * This method requires the lock id returned by a previously acquired
    * {@link #lockBlock(long, long)}.
    *
-   * @param sessionId the id of the session to get this file
+   * @param sessionId the id of the session to create this file
    * @param blockId the id of the block
    * @param lockId the id of the lock
    * @return metadata of the block
@@ -127,7 +127,7 @@ public interface BlockStore extends SessionCleanable {
   /**
    * Gets the temp metadata of a specific block from local storage.
    *
-   * @param sessionId the id of the session to get this file
+   * @param sessionId the id of the session to create this file
    * @param blockId the id of the block
    * @return metadata of the block or null if the temp block does not exist
    */
@@ -182,7 +182,7 @@ public interface BlockStore extends SessionCleanable {
    * Creates a writer to write data to a temp block. Since the temp block is "private" to the
    * writer, this operation requires no previously acquired lock.
    *
-   * @param sessionId the id of the session to get the writer
+   * @param sessionId the id of the session to create the writer
    * @param blockId the id of the temp block
    * @return a {@link BlockWriter} instance on this block
    * @throws BlockDoesNotExistException if the block can not be found
@@ -199,7 +199,7 @@ public interface BlockStore extends SessionCleanable {
    * This operation requires the lock id returned by a previously acquired
    * {@link #lockBlock(long, long)}.
    *
-   * @param sessionId the id of the session to get the reader
+   * @param sessionId the id of the session to create the reader
    * @param blockId the id of an existing block
    * @param lockId the id of the lock returned by {@link #lockBlock(long, long)}
    * @return a {@link BlockReader} instance on this block
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockWorker.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockWorker.java
index 4f648ff780..6ff2c6b6fa 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockWorker.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockWorker.java
@@ -108,7 +108,7 @@ public interface BlockWorker extends Worker, SessionCleanable {
 
   /**
    * Creates a block. This method is only called from a data server.
-   * Calls {@link #getTempBlockWriterRemote(long, long)} to get a writer for writing to the block.
+   * Calls {@link #getTempBlockWriterRemote(long, long)} to create a writer for writing to the block.
    * Throws an {@link IllegalArgumentException} if the location does not belong to tiered storage.
    *
    * @param sessionId the id of the client
@@ -197,7 +197,7 @@ public interface BlockWorker extends Worker, SessionCleanable {
    * Unlike {@link #getVolatileBlockMeta(long)}, this method requires the lock id returned by a
    * previously acquired {@link #lockBlock(long, long)}.
    *
-   * @param sessionId the id of the session to get this file
+   * @param sessionId the id of the session to create this file
    * @param blockId the id of the block
    * @param lockId the id of the lock
    * @return metadata of the block
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/ClientRWLock.java b/core/server/worker/src/main/java/alluxio/worker/block/ClientRWLock.java
index 9f0701aa40..da38b3feb6 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/ClientRWLock.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/ClientRWLock.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
@@ -32,7 +32,7 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class ClientRWLock implements ReadWriteLock {
   /** Total number of permits. This value decides the max number of concurrent readers. */
   private static final int MAX_AVAILABLE =
-          Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCK_READERS);
+          ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCK_READERS);
   /**
    * Uses the unfair lock to prevent a read lock that fails to release from locking the block
    * forever and thus blocking all the subsequent write access.
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/DefaultBlockWorker.java b/core/server/worker/src/main/java/alluxio/worker/block/DefaultBlockWorker.java
index 0d0a6585c0..34c5795038 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/DefaultBlockWorker.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/DefaultBlockWorker.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.Server;
 import alluxio.Sessions;
@@ -90,7 +90,7 @@ public final class DefaultBlockWorker extends AbstractWorker implements BlockWor
   private final BlockMasterClient mBlockMasterClient;
   /**
    * Block master clients. commitBlock is the only reason to keep a pool of block master clients
-   * on each worker. We should either improve our RPC model in the master or get rid of the
+   * on each worker. We should either improve our RPC model in the master or create rid of the
    * necessity to call commitBlock in the workers.
    */
   private final BlockMasterClientPool mBlockMasterClientPool;
@@ -128,7 +128,8 @@ public final class DefaultBlockWorker extends AbstractWorker implements BlockWor
    * @param ufsManager ufs manager
    */
   DefaultBlockWorker(UfsManager ufsManager) {
-    this(new BlockMasterClientPool(), new FileSystemMasterClient(MasterClientConfig.defaults()),
+    this(new BlockMasterClientPool(),
+        new FileSystemMasterClient(MasterClientConfig.defaults(ServerConfiguration.global())),
         new Sessions(), new TieredBlockStore(), ufsManager);
   }
 
@@ -196,10 +197,11 @@ public final class DefaultBlockWorker extends AbstractWorker implements BlockWor
   public void start(WorkerNetAddress address) throws IOException {
     mAddress = address;
     try {
-      RetryUtils.retry("get worker id", () -> mWorkerId.set(mBlockMasterClient.getId(address)),
-          RetryUtils.defaultWorkerMasterClientRetry());
+      RetryUtils.retry("create worker id", () -> mWorkerId.set(mBlockMasterClient.getId(address)),
+          RetryUtils.defaultWorkerMasterClientRetry(ServerConfiguration
+                                                        .getDuration(PropertyKey.WORKER_MASTER_CONNECT_RETRY_TIMEOUT)));
     } catch (Exception e) {
-      throw new RuntimeException("Failed to get a worker id from block master: " + e.getMessage());
+      throw new RuntimeException("Failed to create a worker id from block master: " + e.getMessage());
     }
 
     Preconditions.checkNotNull(mWorkerId, "mWorkerId");
@@ -215,21 +217,23 @@ public final class DefaultBlockWorker extends AbstractWorker implements BlockWor
     mSessionCleaner = new SessionCleaner(mSessions, mBlockStore, mUnderFileSystemBlockStore);
 
     // Setup space reserver
-    if (Configuration.getBoolean(PropertyKey.WORKER_TIERED_STORE_RESERVER_ENABLED)) {
+    if (ServerConfiguration.getBoolean(PropertyKey.WORKER_TIERED_STORE_RESERVER_ENABLED)) {
       mSpaceReserver = new SpaceReserver(this);
       getExecutorService().submit(
           new HeartbeatThread(HeartbeatContext.WORKER_SPACE_RESERVER, mSpaceReserver,
-              (int) Configuration.getMs(PropertyKey.WORKER_TIERED_STORE_RESERVER_INTERVAL_MS)));
+              (int) ServerConfiguration.getMs(PropertyKey.WORKER_TIERED_STORE_RESERVER_INTERVAL_MS), ServerConfiguration.global()));
     }
 
     getExecutorService()
         .submit(new HeartbeatThread(HeartbeatContext.WORKER_BLOCK_SYNC, mBlockMasterSync,
-            (int) Configuration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS)));
+            (int) ServerConfiguration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS),
+            ServerConfiguration.global()));
 
     // Start the pinlist syncer to perform the periodical fetching
     getExecutorService()
         .submit(new HeartbeatThread(HeartbeatContext.WORKER_PIN_LIST_SYNC, mPinListSync,
-            (int) Configuration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS)));
+            (int) ServerConfiguration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS),
+            ServerConfiguration.global()));
 
     // Setup storage checker
     if (Configuration.getBoolean(PropertyKey.WORKER_STORAGE_CHECKER_ENABLED)) {
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/RemoteBlockReader.java b/core/server/worker/src/main/java/alluxio/worker/block/RemoteBlockReader.java
index c8b169e7c5..17a59511c5 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/RemoteBlockReader.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/RemoteBlockReader.java
@@ -13,6 +13,8 @@ package alluxio.worker.block;
 
 import alluxio.client.block.stream.BlockInStream;
 import alluxio.client.file.FileSystemContext;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.proto.dataserver.Protocol;
 import alluxio.wire.WorkerNetAddress;
 import alluxio.worker.block.io.BlockReader;
@@ -107,8 +109,11 @@ public class RemoteBlockReader implements BlockReader {
     }
     WorkerNetAddress address = new WorkerNetAddress().setHost(mDataSource.getHostName())
         .setDataPort(mDataSource.getPort());
-    mInputStream = BlockInStream.createRemoteBlockInStream(FileSystemContext.get(), mBlockId,
-        address, BlockInStream.BlockInStreamSource.REMOTE, mBlockSize, mUfsOptions);
+    mInputStream = BlockInStream.createRemoteBlockInStream(FileSystemContext.create(), mBlockId,
+        address, BlockInStream.BlockInStreamSource.REMOTE, mBlockSize, mUfsOptions,
+        ServerConfiguration.getBytes(PropertyKey.USER_NETWORK_NETTY_READER_PACKET_SIZE_BYTES),
+        ServerConfiguration.getInt(PropertyKey.USER_NETWORK_NETTY_READER_BUFFER_SIZE_PACKETS),
+        ServerConfiguration.getMs(PropertyKey.USER_NETWORK_NETTY_TIMEOUT_MS));
     mChannel = Channels.newChannel(mInputStream);
   }
 }
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/SpaceReserver.java b/core/server/worker/src/main/java/alluxio/worker/block/SpaceReserver.java
index e72badd4d7..f9762e7b4c 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/SpaceReserver.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/SpaceReserver.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
 import alluxio.StorageTierAssoc;
 import alluxio.WorkerStorageTierAssoc;
@@ -77,27 +77,27 @@ public class SpaceReserver implements HeartbeatExecutor {
       long reservedSpace;
       PropertyKey tierReservedSpaceProp =
           PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_RESERVED_RATIO.format(ordinal);
-      if (Configuration.isSet(tierReservedSpaceProp)) {
+      if (ServerConfiguration.isSet(tierReservedSpaceProp)) {
         LOG.warn("The property reserved.ratio is deprecated, use high/low watermark instead.");
-        reservedSpace = (long) (tierCapacity * Configuration.getDouble(tierReservedSpaceProp));
+        reservedSpace = (long) (tierCapacity * ServerConfiguration.getDouble(tierReservedSpaceProp));
       } else {
         // High watermark defines when to start the space reserving process
         PropertyKey tierHighWatermarkProp =
             PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_HIGH_WATERMARK_RATIO.format(ordinal);
-        double tierHighWatermarkConf = Configuration.getDouble(tierHighWatermarkProp);
+        double tierHighWatermarkConf = ServerConfiguration.getDouble(tierHighWatermarkProp);
         Preconditions.checkArgument(tierHighWatermarkConf > 0,
             "The high watermark of tier %s should be positive, but is %s",
             Integer.toString(ordinal), tierHighWatermarkConf);
         Preconditions.checkArgument(tierHighWatermarkConf < 1,
             "The high watermark of tier %s should be less than 1.0, but is %s",
             Integer.toString(ordinal), tierHighWatermarkConf);
-        long highWatermark = (long) (tierCapacity * Configuration.getDouble(tierHighWatermarkProp));
+        long highWatermark = (long) (tierCapacity * ServerConfiguration.getDouble(tierHighWatermarkProp));
         mHighWatermarks.put(tierAlias, highWatermark);
 
         // Low watermark defines when to stop the space reserving process if started
         PropertyKey tierLowWatermarkProp =
             PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_LOW_WATERMARK_RATIO.format(ordinal);
-        double tierLowWatermarkConf = Configuration.getDouble(tierLowWatermarkProp);
+        double tierLowWatermarkConf = ServerConfiguration.getDouble(tierLowWatermarkProp);
         Preconditions.checkArgument(tierLowWatermarkConf >= 0,
             "The low watermark of tier %s should not be negative, but is %s",
             Integer.toString(ordinal), tierLowWatermarkConf);
@@ -105,7 +105,7 @@ public class SpaceReserver implements HeartbeatExecutor {
             "The low watermark (%s) of tier %d should not be smaller than the high watermark (%s)",
             tierLowWatermarkConf, ordinal, tierHighWatermarkConf);
         reservedSpace =
-            (long) (tierCapacity - tierCapacity * Configuration.getDouble(tierLowWatermarkProp));
+            (long) (tierCapacity - tierCapacity * ServerConfiguration.getDouble(tierLowWatermarkProp));
       }
       lastTierReservedBytes += reservedSpace;
       // On each tier, we reserve no more than its capacity
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java b/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java
index 84cfc6ff1b..35c80e7f7e 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
 import alluxio.StorageTierAssoc;
 import alluxio.WorkerStorageTierAssoc;
@@ -93,13 +93,13 @@ public class TieredBlockStore implements BlockStore {
   private static final Logger LOG = LoggerFactory.getLogger(TieredBlockStore.class);
 
   private static final boolean RESERVER_ENABLED =
-      Configuration.getBoolean(PropertyKey.WORKER_TIERED_STORE_RESERVER_ENABLED);
+      ServerConfiguration.getBoolean(PropertyKey.WORKER_TIERED_STORE_RESERVER_ENABLED);
   private static final long FREE_SPACE_TIMEOUT_MS =
-      Configuration.getMs(PropertyKey.WORKER_FREE_SPACE_TIMEOUT);
+      ServerConfiguration.getMs(PropertyKey.WORKER_FREE_SPACE_TIMEOUT);
   private static final int EVICTION_INTERVAL_MS =
-      (int) Configuration.getMs(PropertyKey.WORKER_TIERED_STORE_RESERVER_INTERVAL_MS);
+      (int) ServerConfiguration.getMs(PropertyKey.WORKER_TIERED_STORE_RESERVER_INTERVAL_MS);
   private static final int MAX_RETRIES =
-      Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_RETRY);
+      ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_RETRY);
 
   private final BlockMetadataManager mMetaManager;
   private final BlockLockManager mLockManager;
@@ -695,7 +695,7 @@ public class TieredBlockStore implements BlockStore {
   }
 
   /**
-   * Tries to get an eviction plan to free a certain amount of space in the given location, and
+   * Tries to create an eviction plan to free a certain amount of space in the given location, and
    * carries out this plan with the best effort.
    *
    * @param sessionId the session id
@@ -926,7 +926,7 @@ public class TieredBlockStore implements BlockStore {
    */
   // TODO(peis): Consider using domain socket to avoid setting the permission to 777.
   private static void createBlockFile(String blockPath) throws IOException {
-    FileUtils.createBlockPath(blockPath);
+    FileUtils.createBlockPath(blockPath, ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS));
     FileUtils.createFile(blockPath);
     FileUtils.changeLocalFileToFullPermission(blockPath);
     LOG.debug("Created new file block, block path: {}", blockPath);
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/UfsInputStreamManager.java b/core/server/worker/src/main/java/alluxio/worker/block/UfsInputStreamManager.java
index d2db0e6290..7d67a4b58d 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/UfsInputStreamManager.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/UfsInputStreamManager.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.SeekableUnderFileInputStream;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.options.OpenOptions;
@@ -59,7 +59,7 @@ public class UfsInputStreamManager {
   private static final Logger LOG = LoggerFactory.getLogger(UfsInputStreamManager.class);
   private static final long UNAVAILABLE_RESOURCE_ID = -1;
   private static final boolean CACHE_ENABLED =
-      Configuration.getBoolean(PropertyKey.WORKER_UFS_INSTREAM_CACHE_ENABLED);
+      ServerConfiguration.getBoolean(PropertyKey.WORKER_UFS_INSTREAM_CACHE_ENABLED);
 
   /**
    * A map from the ufs file id to the metadata of the input streams. Synchronization on this map
@@ -118,9 +118,9 @@ public class UfsInputStreamManager {
           }
         };
     mUnderFileInputStreamCache = CacheBuilder.newBuilder()
-        .maximumSize(Configuration.getInt(PropertyKey.WORKER_UFS_INSTREAM_CACHE_MAX_SIZE))
+        .maximumSize(ServerConfiguration.getInt(PropertyKey.WORKER_UFS_INSTREAM_CACHE_MAX_SIZE))
         .expireAfterAccess(
-            Configuration.getMs(PropertyKey.WORKER_UFS_INSTREAM_CACHE_EXPIRARTION_TIME),
+            ServerConfiguration.getMs(PropertyKey.WORKER_UFS_INSTREAM_CACHE_EXPIRARTION_TIME),
             TimeUnit.MILLISECONDS)
         .removalListener(RemovalListeners.asynchronous(listener, mRemovalThreadPool)).build();
   }
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockReader.java b/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockReader.java
index cc280243e9..6abbf7beea 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockReader.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockReader.java
@@ -12,8 +12,8 @@
 package alluxio.worker.block;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.StorageTierAssoc;
 import alluxio.WorkerStorageTierAssoc;
 import alluxio.exception.AlluxioException;
@@ -115,7 +115,7 @@ public final class UnderFileSystemBlockReader implements BlockReader {
    */
   private UnderFileSystemBlockReader(UnderFileSystemBlockMeta blockMeta, BlockStore localBlockStore,
       UfsManager ufsManager, UfsInputStreamManager ufsInstreamManager) throws IOException {
-    mInitialBlockSize = Configuration.getBytes(PropertyKey.WORKER_FILE_BUFFER_SIZE);
+    mInitialBlockSize = ServerConfiguration.getBytes(PropertyKey.WORKER_FILE_BUFFER_SIZE);
     mBlockMeta = blockMeta;
     mLocalBlockStore = localBlockStore;
     mInStreamPos = -1;
@@ -134,7 +134,8 @@ public final class UnderFileSystemBlockReader implements BlockReader {
   private void init(long offset) throws IOException {
     UnderFileSystem ufs = mUfsResource.get();
     ufs.connectFromWorker(
-        NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.WORKER_RPC));
+        NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.WORKER_RPC,
+            ServerConfiguration.global()));
     updateUnderFileSystemInputStream(offset);
     updateBlockWriter(offset);
   }
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockStore.java b/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockStore.java
index 0c1724b80d..8f8730ff07 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockStore.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/UnderFileSystemBlockStore.java
@@ -52,7 +52,7 @@ public final class UnderFileSystemBlockStore implements SessionCleanable {
 
   /**
    * This lock protects mBlocks, mSessionIdToBlockIds and mBlockIdToSessionIds. For any read/write
-   * operations to these maps, the lock needs to be acquired. But once you get the block
+   * operations to these maps, the lock needs to be acquired. But once you create the block
    * information from the map (e.g. mBlocks), the lock does not need to be acquired. For example,
    * the block reader/writer within the BlockInfo can be updated without acquiring this lock.
    * This is based on the assumption that one session won't open multiple readers/writers on the
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/allocator/Allocator.java b/core/server/worker/src/main/java/alluxio/worker/block/allocator/Allocator.java
index dea2e424b8..849087a6b6 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/allocator/Allocator.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/allocator/Allocator.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.allocator;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 import alluxio.util.CommonUtils;
 import alluxio.worker.block.BlockMetadataManagerView;
@@ -43,7 +43,7 @@ public interface Allocator {
     public static Allocator create(BlockMetadataManagerView view) {
       BlockMetadataManagerView managerView = Preconditions.checkNotNull(view, "view");
       return CommonUtils.createNewClassInstance(
-          Configuration.<Allocator>getClass(PropertyKey.WORKER_ALLOCATOR_CLASS),
+          ServerConfiguration.<Allocator>getClass(PropertyKey.WORKER_ALLOCATOR_CLASS),
           new Class[] {BlockMetadataManagerView.class}, new Object[] {managerView});
     }
   }
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/evictor/Evictor.java b/core/server/worker/src/main/java/alluxio/worker/block/evictor/Evictor.java
index 80f3fccd9f..0e691ee09e 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/evictor/Evictor.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/evictor/Evictor.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.evictor;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.annotation.PublicApi;
 import alluxio.util.CommonUtils;
 import alluxio.worker.block.BlockMetadataManagerView;
@@ -51,7 +51,7 @@ public interface Evictor {
      */
     public static Evictor create(BlockMetadataManagerView view, Allocator allocator) {
       return CommonUtils.createNewClassInstance(
-          Configuration.<Evictor>getClass(PropertyKey.WORKER_EVICTOR_CLASS),
+          ServerConfiguration.<Evictor>getClass(PropertyKey.WORKER_EVICTOR_CLASS),
           new Class[] {BlockMetadataManagerView.class, Allocator.class},
           new Object[] {view, allocator});
     }
@@ -63,7 +63,7 @@ public interface Evictor {
    * @param availableBytes the amount of free space in bytes to be ensured after eviction
    * @param location the location in block store
    * @param view generated and passed by block store
-   * @return an {@link EvictionPlan} (possibly with empty fields) to get the free space, or null if
+   * @return an {@link EvictionPlan} (possibly with empty fields) to create the free space, or null if
    *         no plan is feasible
    */
   EvictionPlan freeSpaceWithView(long availableBytes, BlockStoreLocation location,
@@ -93,7 +93,7 @@ public interface Evictor {
    * @param location the location in block store
    * @param view generated and passed by block store
    * @param mode the eviction mode
-   * @return an {@link EvictionPlan} (possibly with empty fields) to get the free space, or null if
+   * @return an {@link EvictionPlan} (possibly with empty fields) to create the free space, or null if
    *         no plan is feasible
    */
   EvictionPlan freeSpaceWithView(long availableBytes, BlockStoreLocation location,
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/evictor/LRFUEvictor.java b/core/server/worker/src/main/java/alluxio/worker/block/evictor/LRFUEvictor.java
index 5ae0b754b1..870be49547 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/evictor/LRFUEvictor.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/evictor/LRFUEvictor.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.evictor;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.collections.Pair;
 import alluxio.worker.block.BlockMetadataManagerView;
 import alluxio.worker.block.BlockStoreLocation;
@@ -71,9 +71,9 @@ public final class LRFUEvictor extends AbstractEvictor {
    */
   public LRFUEvictor(BlockMetadataManagerView view, Allocator allocator) {
     super(view, allocator);
-    mStepFactor = Configuration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_STEP_FACTOR);
+    mStepFactor = ServerConfiguration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_STEP_FACTOR);
     mAttenuationFactor =
-        Configuration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR);
+        ServerConfiguration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR);
     Preconditions.checkArgument(mStepFactor >= 0.0 && mStepFactor <= 1.0,
         "Step factor should be in the range of [0.0, 1.0]");
     Preconditions.checkArgument(mAttenuationFactor >= 2.0,
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/meta/AbstractBlockMeta.java b/core/server/worker/src/main/java/alluxio/worker/block/meta/AbstractBlockMeta.java
index 896ffd7f2a..e9ed009304 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/meta/AbstractBlockMeta.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/meta/AbstractBlockMeta.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.meta;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.io.PathUtils;
 import alluxio.worker.block.BlockStoreLocation;
 
@@ -41,8 +41,8 @@ public abstract class AbstractBlockMeta {
    * @return temp file path
    */
   public static String tempPath(StorageDir dir, long sessionId, long blockId) {
-    final String tmpDir = Configuration.get(PropertyKey.WORKER_DATA_TMP_FOLDER);
-    final int subDirMax = Configuration.getInt(PropertyKey.WORKER_DATA_TMP_SUBDIR_MAX);
+    final String tmpDir = ServerConfiguration.get(PropertyKey.WORKER_DATA_TMP_FOLDER);
+    final int subDirMax = ServerConfiguration.getInt(PropertyKey.WORKER_DATA_TMP_SUBDIR_MAX);
 
     return PathUtils.concatPath(dir.getDirPath(), tmpDir, sessionId % subDirMax,
         String.format("%x-%x", sessionId, blockId));
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageDir.java b/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageDir.java
index fa58f9c06c..1a5cdf5464 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageDir.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageDir.java
@@ -11,6 +11,8 @@
 
 package alluxio.worker.block.meta;
 
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.BlockAlreadyExistsException;
 import alluxio.exception.BlockDoesNotExistException;
 import alluxio.exception.ExceptionMessage;
@@ -104,7 +106,8 @@ public final class StorageDir {
   private void initializeMeta() throws BlockAlreadyExistsException, IOException,
       WorkerOutOfSpaceException {
     // Create the storage directory path
-    boolean isDirectoryNewlyCreated = FileUtils.createStorageDirPath(mDirPath);
+    boolean isDirectoryNewlyCreated = FileUtils.createStorageDirPath(mDirPath,
+        ServerConfiguration.get(PropertyKey.WORKER_DATA_FOLDER_PERMISSIONS));
 
     if (isDirectoryNewlyCreated) {
       LOG.info("Folder {} was created!", mDirPath);
diff --git a/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageTier.java b/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageTier.java
index e905897180..44c1c2b4ca 100644
--- a/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageTier.java
+++ b/core/server/worker/src/main/java/alluxio/worker/block/meta/StorageTier.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.meta;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.WorkerStorageTierAssoc;
 import alluxio.exception.BlockAlreadyExistsException;
 import alluxio.exception.InvalidPathException;
@@ -62,18 +62,18 @@ public final class StorageTier {
 
   private void initStorageTier()
       throws BlockAlreadyExistsException, IOException, WorkerOutOfSpaceException {
-    String tmpDir = Configuration.get(PropertyKey.WORKER_DATA_TMP_FOLDER);
+    String tmpDir = ServerConfiguration.get(PropertyKey.WORKER_DATA_TMP_FOLDER);
     PropertyKey tierDirPathConf =
         PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(mTierOrdinal);
-    String[] dirPaths = Configuration.get(tierDirPathConf).split(",");
+    String[] dirPaths = ServerConfiguration.get(tierDirPathConf).split(",");
 
     for (int i = 0; i < dirPaths.length; i++) {
-      dirPaths[i] = CommonUtils.getWorkerDataDirectory(dirPaths[i]);
+      dirPaths[i] = CommonUtils.getWorkerDataDirectory(dirPaths[i], ServerConfiguration.global());
     }
 
     PropertyKey tierDirCapacityConf =
         PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_QUOTA.format(mTierOrdinal);
-    String rawDirQuota = Configuration.get(tierDirCapacityConf);
+    String rawDirQuota = ServerConfiguration.get(tierDirCapacityConf);
     Preconditions.checkState(rawDirQuota.length() > 0, PreconditionMessage.ERR_TIER_QUOTA_BLANK);
     String[] dirQuotas = rawDirQuota.split(",");
 
@@ -124,7 +124,7 @@ public final class StorageTier {
     try {
       info = ShellUtils.getUnixMountInfo();
     } catch (IOException e) {
-      LOG.warn("Failed to get mount information for verifying memory capacity: {}", e.getMessage());
+      LOG.warn("Failed to create mount information for verifying memory capacity: {}", e.getMessage());
       return;
     }
     boolean foundMountInfo = false;
diff --git a/core/server/worker/src/main/java/alluxio/worker/file/DefaultFileSystemWorker.java b/core/server/worker/src/main/java/alluxio/worker/file/DefaultFileSystemWorker.java
index 0490c348cf..d7d79e8f2d 100644
--- a/core/server/worker/src/main/java/alluxio/worker/file/DefaultFileSystemWorker.java
+++ b/core/server/worker/src/main/java/alluxio/worker/file/DefaultFileSystemWorker.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.file;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Server;
 import alluxio.grpc.GrpcService;
 import alluxio.grpc.ServiceType;
@@ -74,11 +74,12 @@ public final class DefaultFileSystemWorker extends AbstractWorker implements Fil
     mWorkerId = blockWorker.getWorkerId();
     mUfsManager = ufsManager;
     mFileDataManager = new FileDataManager(Preconditions.checkNotNull(blockWorker, "blockWorker"),
-        RateLimiter.create(Configuration.getBytes(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT)),
+        RateLimiter.create(ServerConfiguration.getBytes(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT)),
         mUfsManager);
 
     // Setup AbstractMasterClient
-    mFileSystemMasterWorkerClient = new FileSystemMasterClient(MasterClientConfig.defaults());
+    mFileSystemMasterWorkerClient =
+        new FileSystemMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()));
   }
 
   @Override
@@ -102,7 +103,8 @@ public final class DefaultFileSystemWorker extends AbstractWorker implements Fil
         new HeartbeatThread(HeartbeatContext.WORKER_FILESYSTEM_MASTER_SYNC,
             new FileWorkerMasterSyncExecutor(mFileDataManager, mFileSystemMasterWorkerClient,
                 mWorkerId),
-            (int) Configuration.getMs(PropertyKey.WORKER_FILESYSTEM_HEARTBEAT_INTERVAL_MS)));
+            (int) ServerConfiguration.getMs(PropertyKey.WORKER_FILESYSTEM_HEARTBEAT_INTERVAL_MS),
+            ServerConfiguration.global()));
   }
 
   @Override
diff --git a/core/server/worker/src/main/java/alluxio/worker/file/FileDataManager.java b/core/server/worker/src/main/java/alluxio/worker/file/FileDataManager.java
index 169089f3d0..2d127e8825 100644
--- a/core/server/worker/src/main/java/alluxio/worker/file/FileDataManager.java
+++ b/core/server/worker/src/main/java/alluxio/worker/file/FileDataManager.java
@@ -12,8 +12,9 @@
 package alluxio.worker.file;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -266,7 +267,7 @@ public final class FileDataManager {
         mUfsManager.get(fileInfo.getMountId()).acquireUfsResource()) {
       UnderFileSystem ufs = ufsResource.get();
       String dstPath = prepareUfsFilePath(fileInfo, ufs);
-      OutputStream outputStream = ufs.create(dstPath, CreateOptions.defaults()
+      OutputStream outputStream = ufs.create(dstPath, CreateOptions.defaults(ServerConfiguration.global())
           .setOwner(fileInfo.getOwner()).setGroup(fileInfo.getGroup())
           .setMode(new Mode((short) fileInfo.getMode())));
       final WritableByteChannel outputChannel = Channels.newChannel(outputStream);
@@ -275,7 +276,7 @@ public final class FileDataManager {
         for (long blockId : blockIds) {
           long lockId = blockIdToLockId.get(blockId);
 
-          if (Configuration.getBoolean(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT_ENABLED)) {
+          if (ServerConfiguration.getBoolean(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT_ENABLED)) {
             BlockMeta blockMeta =
                 mBlockWorker.getBlockMeta(Sessions.CHECKPOINT_SESSION_ID, blockId, lockId);
             mPersistenceRateLimiter.acquire((int) blockMeta.getBlockSize());
diff --git a/core/server/worker/src/main/java/alluxio/worker/file/FileSystemMasterClient.java b/core/server/worker/src/main/java/alluxio/worker/file/FileSystemMasterClient.java
index 938d7ff6d7..8405b43747 100644
--- a/core/server/worker/src/main/java/alluxio/worker/file/FileSystemMasterClient.java
+++ b/core/server/worker/src/main/java/alluxio/worker/file/FileSystemMasterClient.java
@@ -13,6 +13,8 @@ package alluxio.worker.file;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.FileSystemCommand;
 import alluxio.grpc.FileSystemHeartbeatPOptions;
 import alluxio.grpc.FileSystemHeartbeatPRequest;
@@ -47,7 +49,7 @@ public final class FileSystemMasterClient extends AbstractMasterClient {
    * @param conf master client configuration
    */
   public FileSystemMasterClient(MasterClientConfig conf) {
-    super(conf);
+    super(conf, ServerConfiguration.global());
   }
 
   @Override
@@ -71,7 +73,7 @@ public final class FileSystemMasterClient extends AbstractMasterClient {
   }
 
   /**
-   * @param fileId the id of the file for which to get the {@link FileInfo}
+   * @param fileId the id of the file for which to create the {@link FileInfo}
    * @return the file info for the given file id
    */
   public FileInfo getFileInfo(final long fileId) throws IOException {
diff --git a/core/server/worker/src/main/java/alluxio/worker/file/FileWorkerMasterSyncExecutor.java b/core/server/worker/src/main/java/alluxio/worker/file/FileWorkerMasterSyncExecutor.java
index 56c81d94ba..27bc9785aa 100644
--- a/core/server/worker/src/main/java/alluxio/worker/file/FileWorkerMasterSyncExecutor.java
+++ b/core/server/worker/src/main/java/alluxio/worker/file/FileWorkerMasterSyncExecutor.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.file;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.CommandType;
 import alluxio.grpc.FileSystemCommand;
 import alluxio.grpc.FileSystemHeartbeatPOptions;
@@ -71,7 +71,7 @@ final class FileWorkerMasterSyncExecutor implements HeartbeatExecutor {
     mMasterClient = Preconditions.checkNotNull(masterClient, "masterClient");
     mWorkerId = Preconditions.checkNotNull(workerId, "workerId");
     mPersistFileService = Executors.newFixedThreadPool(
-        Configuration.getInt(PropertyKey.WORKER_FILE_PERSIST_POOL_SIZE),
+        ServerConfiguration.getInt(PropertyKey.WORKER_FILE_PERSIST_POOL_SIZE),
         ThreadFactoryUtils.build("persist-file-service-%d", true));
   }
 
diff --git a/core/server/worker/src/main/java/alluxio/worker/file/UnderFileSystemUtils.java b/core/server/worker/src/main/java/alluxio/worker/file/UnderFileSystemUtils.java
index 5c747a0324..d7705955bc 100644
--- a/core/server/worker/src/main/java/alluxio/worker/file/UnderFileSystemUtils.java
+++ b/core/server/worker/src/main/java/alluxio/worker/file/UnderFileSystemUtils.java
@@ -12,9 +12,11 @@
 package alluxio.worker.file;
 
 import alluxio.AlluxioURI;
+import alluxio.Server;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.collections.Pair;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.security.authorization.Mode;
@@ -59,7 +61,7 @@ public final class UnderFileSystemUtils {
           throw new IOException(ExceptionMessage.UFS_PATH_DOES_NOT_EXIST.getMessage(curUfsPath));
         }
         ufsDirsToMakeWithOptions.push(new Pair<>(curUfsPath.toString(),
-            MkdirsOptions.defaults().setCreateParent(false).setOwner(curDirStatus.getOwner())
+            MkdirsOptions.defaults(ServerConfiguration.global()).setCreateParent(false).setOwner(curDirStatus.getOwner())
                 .setGroup(curDirStatus.getGroup())
                 .setMode(new Mode((short) curDirStatus.getMode()))));
         curAlluxioPath = curAlluxioPath.getParent();
diff --git a/core/server/worker/src/main/java/alluxio/worker/grpc/BlockReadHandler.java b/core/server/worker/src/main/java/alluxio/worker/grpc/BlockReadHandler.java
index d4a9ba97b3..c5bf93600a 100644
--- a/core/server/worker/src/main/java/alluxio/worker/grpc/BlockReadHandler.java
+++ b/core/server/worker/src/main/java/alluxio/worker/grpc/BlockReadHandler.java
@@ -12,9 +12,9 @@
 package alluxio.worker.grpc;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.StorageTierAssoc;
 import alluxio.WorkerStorageTierAssoc;
 import alluxio.exception.BlockDoesNotExistException;
@@ -55,7 +55,7 @@ import javax.annotation.concurrent.NotThreadSafe;
 public final class BlockReadHandler extends AbstractReadHandler<BlockReadRequestContext> {
   private static final Logger LOG = LoggerFactory.getLogger(BlockReadHandler.class);
   private static final long UFS_BLOCK_OPEN_TIMEOUT_MS =
-      Configuration.getMs(PropertyKey.WORKER_UFS_BLOCK_OPEN_TIMEOUT_MS);
+      ServerConfiguration.getMs(PropertyKey.WORKER_UFS_BLOCK_OPEN_TIMEOUT_MS);
 
   /** The Block Worker. */
   private final BlockWorker mWorker;
diff --git a/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcDataServer.java b/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcDataServer.java
index 38e4ba24bf..0aefb54c74 100644
--- a/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcDataServer.java
+++ b/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcDataServer.java
@@ -11,8 +11,9 @@
 
 package alluxio.worker.grpc;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.Constants;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.GrpcServer;
 import alluxio.grpc.GrpcServerBuilder;
 import alluxio.grpc.GrpcService;
@@ -47,15 +48,16 @@ public final class GrpcDataServer implements DataServer {
 
   private final SocketAddress mSocketAddress;
   private final long mTimeoutMs =
-      Configuration.getMs(PropertyKey.WORKER_NETWORK_SHUTDOWN_TIMEOUT);
+      ServerConfiguration.getMs(PropertyKey.WORKER_NETWORK_SHUTDOWN_TIMEOUT);
   private final long mKeepAliveTimeMs =
-      Configuration.getMs(PropertyKey.WORKER_NETWORK_KEEPALIVE_TIME_MS);
+      ServerConfiguration.getMs(PropertyKey.WORKER_NETWORK_KEEPALIVE_TIME_MS);
   private final long mKeepAliveTimeoutMs =
-      Configuration.getMs(PropertyKey.WORKER_NETWORK_KEEPALIVE_TIMEOUT_MS);
+      ServerConfiguration.getMs(PropertyKey.WORKER_NETWORK_KEEPALIVE_TIMEOUT_MS);
+
   private final long mFlowControlWindow =
-      Configuration.getBytes(PropertyKey.WORKER_NETWORK_FLOWCONTROL_WINDOW);
+      ServerConfiguration.getBytes(PropertyKey.WORKER_NETWORK_FLOWCONTROL_WINDOW);
   private final long mQuietPeriodMs =
-      Configuration.getMs(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD);
+      ServerConfiguration.getMs(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD);
 
   private EventLoopGroup mBossGroup;
   private EventLoopGroup mWorkerGroup;
@@ -72,7 +74,7 @@ public final class GrpcDataServer implements DataServer {
   public GrpcDataServer(final SocketAddress address, final WorkerProcess workerProcess) {
     mSocketAddress = address;
     try {
-      mServer = createServerBuilder(address, NettyUtils.WORKER_CHANNEL_TYPE)
+      mServer = createServerBuilder(address, NettyUtils.getWorkerChannel(ServerConfiguration.global()))
           .addService(new GrpcService(new BlockWorkerImpl(workerProcess)))
           .flowControlWindow((int) mFlowControlWindow)
           .keepAliveTime(mKeepAliveTimeMs, TimeUnit.MILLISECONDS)
@@ -92,11 +94,11 @@ public final class GrpcDataServer implements DataServer {
   }
 
   private GrpcServerBuilder createServerBuilder(SocketAddress address, ChannelType type) {
-    GrpcServerBuilder builder = GrpcServerBuilder.forAddress(address);
-    int bossThreadCount = Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_BOSS_THREADS);
+    GrpcServerBuilder builder = GrpcServerBuilder.forAddress(address, ServerConfiguration.global());
+    int bossThreadCount = ServerConfiguration.getInt(PropertyKey.WORKER_NETWORK_NETTY_BOSS_THREADS);
     // If number of worker threads is 0, Netty creates (#processors * 2) threads by default.
     int workerThreadCount =
-        Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_WORKER_THREADS);
+        ServerConfiguration.getInt(PropertyKey.WORKER_NETWORK_NETTY_WORKER_THREADS);
     String dataServerEventLoopNamePrefix =
         "data-server-" + ((mSocketAddress instanceof DomainSocketAddress) ? "domain-socket" :
             "tcp-socket");
diff --git a/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java b/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java
index 974a43ebdb..025db7e906 100644
--- a/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java
+++ b/core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.grpc;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.util.ThreadFactoryUtils;
 
 import java.util.concurrent.ExecutorService;
@@ -34,7 +34,7 @@ final class GrpcExecutors {
 
   public static final ExecutorService ASYNC_CACHE_MANAGER_EXECUTOR =
       new ThreadPoolExecutor(THREADS_MIN,
-          Configuration.getInt(PropertyKey.WORKER_NETWORK_ASYNC_CACHE_MANAGER_THREADS_MAX),
+          ServerConfiguration.getInt(PropertyKey.WORKER_NETWORK_ASYNC_CACHE_MANAGER_THREADS_MAX),
           THREAD_STOP_MS, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>(512),
           ThreadFactoryUtils.build("AsyncCacheManagerExecutor-%d", true));
 
diff --git a/core/server/worker/src/main/java/alluxio/worker/package-info.java b/core/server/worker/src/main/java/alluxio/worker/package-info.java
index 3d5398368a..2b2da19674 100644
--- a/core/server/worker/src/main/java/alluxio/worker/package-info.java
+++ b/core/server/worker/src/main/java/alluxio/worker/package-info.java
@@ -22,7 +22,7 @@
  * <h2>DataServer</h2>
  *
  * This service is the main interaction between users and worker for reading and writing blocks.
- * The {@link alluxio.worker.DataServer} interface defines how to start/stop, and get port details;
+ * The {@link alluxio.worker.DataServer} interface defines how to start/stop, and create port details;
  * to start, object init is used. The implementation of this interface is in
  * {@link alluxio.worker.grpc.GrpcDataServer}. It creates an {@link alluxio.worker.DataServer}
  * instance based on gRPC which is a high performance universal remote procedure call framework.
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/BlockLockManagerTest.java b/core/server/worker/src/test/java/alluxio/worker/block/BlockLockManagerTest.java
index e197e0bc67..ffc88a0868 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/BlockLockManagerTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/BlockLockManagerTest.java
@@ -15,9 +15,9 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.collections.ConcurrentHashSet;
 import alluxio.exception.BlockDoesNotExistException;
 import alluxio.exception.ExceptionMessage;
@@ -72,7 +72,7 @@ public final class BlockLockManagerTest {
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -80,7 +80,7 @@ public final class BlockLockManagerTest {
    */
   @Test
   public void lockBlock() {
-    // Read-lock on can both get through
+    // Read-lock on can both create through
     long lockId1 = mLockManager.lockBlock(TEST_SESSION_ID, TEST_BLOCK_ID, BlockLockType.READ);
     long lockId2 = mLockManager.lockBlock(TEST_SESSION_ID, TEST_BLOCK_ID, BlockLockType.READ);
     assertNotEquals(lockId1, lockId2);
@@ -153,7 +153,7 @@ public final class BlockLockManagerTest {
     mThrown.expect(BlockDoesNotExistException.class);
     mThrown.expectMessage(ExceptionMessage.LOCK_RECORD_NOT_FOUND_FOR_LOCK_ID.getMessage(lockId2));
     mLockManager.cleanupSession(sessionId2);
-    // Expect validating sessionId1 to get through
+    // Expect validating sessionId1 to create through
     mLockManager.validateLock(sessionId1, TEST_BLOCK_ID, lockId1);
     // Because sessionId2 has been cleaned up, expect validating sessionId2 to throw IOException
     mLockManager.validateLock(sessionId2, TEST_BLOCK_ID, lockId2);
@@ -329,6 +329,6 @@ public final class BlockLockManagerTest {
   }
 
   private void setMaxLocks(int maxLocks) {
-    Configuration.set(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCKS, Integer.toString(maxLocks));
+    ServerConfiguration.set(PropertyKey.WORKER_TIERED_STORE_BLOCK_LOCKS, Integer.toString(maxLocks));
   }
 }
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/BlockMetadataManagerTest.java b/core/server/worker/src/test/java/alluxio/worker/block/BlockMetadataManagerTest.java
index 5dadef0c97..4389092643 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/BlockMetadataManagerTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/BlockMetadataManagerTest.java
@@ -383,7 +383,7 @@ public final class BlockMetadataManagerTest {
     dir.addTempBlockMeta(tempBlockMeta3);
     dir.addBlockMeta(blockMeta);
 
-    // Get temp blocks for sessionId1, expect to get tempBlock1 and tempBlock2
+    // Get temp blocks for sessionId1, expect to create tempBlock1 and tempBlock2
     List<TempBlockMeta> toRemove = mMetaManager.getSessionTempBlocks(sessionId1);
     List<Long> toRemoveBlockIds = new ArrayList<>(toRemove.size());
     for (TempBlockMeta tempBlockMeta : toRemove) {
@@ -401,7 +401,7 @@ public final class BlockMetadataManagerTest {
     assertTrue(dir.hasTempBlockMeta(tempBlockId3));
     assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));
 
-    // Get temp blocks for sessionId1 again, expect to get nothing
+    // Get temp blocks for sessionId1 again, expect to create nothing
     toRemove = mMetaManager.getSessionTempBlocks(sessionId1);
     toRemoveBlockIds = new ArrayList<>(toRemove.size());
     for (TempBlockMeta tempBlockMeta : toRemove) {
@@ -416,7 +416,7 @@ public final class BlockMetadataManagerTest {
     assertTrue(dir.hasTempBlockMeta(tempBlockId3));
     assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));
 
-    // Get temp blocks for sessionId2, expect to get tempBlock3
+    // Get temp blocks for sessionId2, expect to create tempBlock3
     toRemove = mMetaManager.getSessionTempBlocks(sessionId2);
     toRemoveBlockIds = new ArrayList<>(toRemove.size());
     for (TempBlockMeta tempBlockMeta : toRemove) {
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/BlockWorkerTest.java b/core/server/worker/src/test/java/alluxio/worker/block/BlockWorkerTest.java
index 3a126cf898..df1635ec3c 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/BlockWorkerTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/BlockWorkerTest.java
@@ -24,10 +24,10 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import alluxio.AlluxioTestDirectory;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
 import alluxio.WorkerStorageTierAssoc;
 import alluxio.exception.BlockAlreadyExistsException;
@@ -61,7 +61,7 @@ import java.util.Set;
 @RunWith(PowerMockRunner.class)
 @PrepareForTest({BlockMasterClient.class, BlockMasterClientPool.class, FileSystemMasterClient.class,
     BlockHeartbeatReporter.class, BlockMetricsReporter.class, BlockMeta.class,
-    BlockStoreLocation.class, StorageDir.class, Configuration.class, UnderFileSystem.class,
+    BlockStoreLocation.class, StorageDir.class, ServerConfiguration.class, UnderFileSystem.class,
     BlockWorker.class, Sessions.class})
 public class BlockWorkerTest {
 
@@ -88,7 +88,7 @@ public class BlockWorkerTest {
           .put(PropertyKey.WORKER_TIERED_STORE_LEVEL1_ALIAS, "HDD")
           .put(PropertyKey.WORKER_TIERED_STORE_LEVEL1_DIRS_PATH, AlluxioTestDirectory
               .createTemporaryDirectory("WORKER_TIERED_STORE_LEVEL1_DIRS_PATH").getAbsolutePath())
-          .build());
+          .build(), ServerConfiguration.global());
 
   /**
    * Sets up all dependencies before a test runs.
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/SpaceReserverTest.java b/core/server/worker/src/test/java/alluxio/worker/block/SpaceReserverTest.java
index e2d6246ab5..55cef89e76 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/SpaceReserverTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/SpaceReserverTest.java
@@ -17,8 +17,9 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
+import alluxio.conf.ServerConfiguration;
 import alluxio.heartbeat.HeartbeatContext;
 import alluxio.heartbeat.HeartbeatScheduler;
 import alluxio.heartbeat.HeartbeatThread;
@@ -82,11 +83,12 @@ public class SpaceReserverTest {
 
     try (Closeable c = new ConfigurationRule(ImmutableMap.of(
         PropertyKey.WORKER_TIERED_STORE_LEVEL0_RESERVED_RATIO, "0.2",
-        PropertyKey.WORKER_TIERED_STORE_LEVEL1_RESERVED_RATIO, "0.3")).toResource()) {
+        PropertyKey.WORKER_TIERED_STORE_LEVEL1_RESERVED_RATIO, "0.3"),
+        ServerConfiguration.global()).toResource()) {
       SpaceReserver spaceReserver = new SpaceReserver(blockWorker);
 
       mExecutorService.submit(new HeartbeatThread(HeartbeatContext.WORKER_SPACE_RESERVER,
-          spaceReserver, 0));
+          spaceReserver, 0, ServerConfiguration.global()));
 
       // Run the space reserver once.
       HeartbeatScheduler.execute(HeartbeatContext.WORKER_SPACE_RESERVER);
@@ -126,11 +128,11 @@ public class SpaceReserverTest {
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_HIGH_WATERMARK_RATIO, "0.8");
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_LOW_WATERMARK_RATIO, "0.6");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       SpaceReserver spaceReserver = new SpaceReserver(blockWorker);
 
       mExecutorService.submit(new HeartbeatThread(HeartbeatContext.WORKER_SPACE_RESERVER,
-          spaceReserver, 0));
+          spaceReserver, 0, ServerConfiguration.global()));
 
       // Run the space reserver once.
       HeartbeatScheduler.execute(HeartbeatContext.WORKER_SPACE_RESERVER);
@@ -172,11 +174,11 @@ public class SpaceReserverTest {
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_HIGH_WATERMARK_RATIO, "0.8");
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_LOW_WATERMARK_RATIO, "0.6");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       SpaceReserver spaceReserver = new SpaceReserver(blockWorker);
 
       mExecutorService.submit(new HeartbeatThread(HeartbeatContext.WORKER_SPACE_RESERVER,
-          spaceReserver, 0));
+          spaceReserver, 0, ServerConfiguration.global()));
 
       // Run the space reserver once.
       HeartbeatScheduler.execute(HeartbeatContext.WORKER_SPACE_RESERVER);
@@ -219,11 +221,11 @@ public class SpaceReserverTest {
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_HIGH_WATERMARK_RATIO, "0.2");
         put(PropertyKey.WORKER_TIERED_STORE_LEVEL2_LOW_WATERMARK_RATIO, "0.1");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       SpaceReserver spaceReserver = new SpaceReserver(blockWorker);
 
       mExecutorService.submit(new HeartbeatThread(HeartbeatContext.WORKER_SPACE_RESERVER,
-          spaceReserver, 0));
+          spaceReserver, 0, ServerConfiguration.global()));
 
       // Run the space reserver once.
       HeartbeatScheduler.execute(HeartbeatContext.WORKER_SPACE_RESERVER);
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTest.java b/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTest.java
index 19bff06428..ee8c642fbb 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTest.java
@@ -20,9 +20,8 @@ import static org.mockito.Mockito.any;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.BlockAlreadyExistsException;
 import alluxio.exception.BlockDoesNotExistException;
 import alluxio.exception.ExceptionMessage;
@@ -86,13 +85,13 @@ public final class TieredBlockStoreTest {
    */
   @Before
   public void before() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
-    Configuration.set(PropertyKey.WORKER_TIERED_STORE_RESERVER_ENABLED, "false");
+    ServerConfiguration.reset();
+    ServerConfiguration.set(PropertyKey.WORKER_TIERED_STORE_RESERVER_ENABLED, "false");
     File tempFolder = mTestFolder.newFolder();
     TieredBlockStoreTestUtils.setupDefaultConf(tempFolder.getAbsolutePath());
     mBlockStore = new TieredBlockStore();
 
-    // TODO(bin): Avoid using reflection to get private members.
+    // TODO(bin): Avoid using reflection to create private members.
     Field field = mBlockStore.getClass().getDeclaredField("mMetaManager");
     field.setAccessible(true);
     mMetaManager = (BlockMetadataManager) field.get(mBlockStore);
@@ -497,7 +496,7 @@ public final class TieredBlockStoreTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get a writer for the block that does not
+   * Tests that an exception is thrown when trying to create a writer for the block that does not
    * exist.
    */
   @Test
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTestUtils.java b/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTestUtils.java
index e98800fb7b..05001418c0 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTestUtils.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/TieredBlockStoreTestUtils.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.io.BufferUtils;
 import alluxio.util.io.FileUtils;
 import alluxio.util.io.PathUtils;
@@ -46,7 +46,7 @@ public final class TieredBlockStoreTestUtils {
   public static final String WORKER_DATA_FOLDER = "/alluxioworker/";
 
   /**
-   * Sets up a {@link Configuration} for a {@link TieredBlockStore} with several tiers configured by
+   * Sets up a {@link ServerConfiguration} for a {@link TieredBlockStore} with several tiers configured by
    * the parameters. For simplicity, you can use {@link #setupDefaultConf(String)} which
    * calls this method with default values.
    *
@@ -79,9 +79,9 @@ public final class TieredBlockStoreTestUtils {
 
     tierPath = createDirHierarchy(baseDir, tierPath);
     if (workerDataFolder != null) {
-      Configuration.set(PropertyKey.WORKER_DATA_FOLDER, workerDataFolder);
+      ServerConfiguration.set(PropertyKey.WORKER_DATA_FOLDER, workerDataFolder);
     }
-    Configuration.set(PropertyKey.WORKER_TIERED_STORE_LEVELS, String.valueOf(nTier));
+    ServerConfiguration.set(PropertyKey.WORKER_TIERED_STORE_LEVELS, String.valueOf(nTier));
 
     // sets up each tier in turn
     for (int i = 0; i < nTier; i++) {
@@ -90,7 +90,7 @@ public final class TieredBlockStoreTestUtils {
   }
 
   /**
-   * Sets up a {@link Configuration} for a {@link TieredBlockStore} with only *one tier* configured
+   * Sets up a {@link ServerConfiguration} for a {@link TieredBlockStore} with only *one tier* configured
    * by the parameters. For simplicity, you can use {@link #setupDefaultConf(String)} which
    * sets up the tierBlockStore with default values.
    *
@@ -111,14 +111,14 @@ public final class TieredBlockStoreTestUtils {
       tierPath = createDirHierarchy(baseDir, tierPath);
     }
     if (workerDataFolder != null) {
-      Configuration.set(PropertyKey.WORKER_DATA_FOLDER, workerDataFolder);
+      ServerConfiguration.set(PropertyKey.WORKER_DATA_FOLDER, workerDataFolder);
     }
-    Configuration.set(PropertyKey.WORKER_TIERED_STORE_LEVELS, String.valueOf(1));
+    ServerConfiguration.set(PropertyKey.WORKER_TIERED_STORE_LEVELS, String.valueOf(1));
     setupConfTier(tierOrdinal, tierAlias, tierPath, tierCapacity);
   }
 
   /**
-   * Sets up a specific tier's {@link Configuration} for a {@link TieredBlockStore}.
+   * Sets up a specific tier's {@link ServerConfiguration} for a {@link TieredBlockStore}.
    *
    * @param tierAlias alias of the tier
    * @param tierPath absolute path of the tier
@@ -131,17 +131,17 @@ public final class TieredBlockStoreTestUtils {
     Preconditions.checkArgument(tierPath.length == tierCapacity.length,
         "tierPath and tierCapacity should have the same length");
 
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_ALIAS.format(ordinal),
             tierAlias);
 
     String tierPathString = StringUtils.join(tierPath, ",");
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(ordinal),
             tierPathString);
 
     String tierCapacityString = StringUtils.join(ArrayUtils.toObject(tierCapacity), ",");
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_QUOTA.format(ordinal),
             tierCapacityString);
   }
@@ -211,7 +211,7 @@ public final class TieredBlockStoreTestUtils {
   }
 
   /**
-   * Sets up a {@link Configuration} with default values of {@link #TIER_ORDINAL},
+   * Sets up a {@link ServerConfiguration} with default values of {@link #TIER_ORDINAL},
    * {@link #TIER_ALIAS}, {@link #TIER_PATH} with the baseDir as path prefix,
    * {@link #TIER_CAPACITY_BYTES}.
    *
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/UfsInputStreamManagerTest.java b/core/server/worker/src/test/java/alluxio/worker/block/UfsInputStreamManagerTest.java
index 21cd8cca56..f011d7c9ac 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/UfsInputStreamManagerTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/UfsInputStreamManagerTest.java
@@ -21,7 +21,8 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.test.util.ConcurrencyUtils;
 import alluxio.underfs.SeekableUnderFileInputStream;
 import alluxio.underfs.UnderFileSystem;
@@ -110,7 +111,7 @@ public final class UfsInputStreamManagerTest {
       {
         put(PropertyKey.WORKER_UFS_INSTREAM_CACHE_EXPIRARTION_TIME, "2");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       mManager = new UfsInputStreamManager();
       // check out a stream
       InputStream instream =
@@ -134,7 +135,7 @@ public final class UfsInputStreamManagerTest {
         // use very large number
         put(PropertyKey.WORKER_UFS_INSTREAM_CACHE_EXPIRARTION_TIME, "200000");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       mManager = new UfsInputStreamManager();
       List<Thread> threads = new ArrayList<>();
       int numCheckOutPerThread = 10;
@@ -179,7 +180,7 @@ public final class UfsInputStreamManagerTest {
       {
         put(PropertyKey.WORKER_UFS_INSTREAM_CACHE_EXPIRARTION_TIME, "20");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       mManager = new UfsInputStreamManager();
       List<Thread> threads = new ArrayList<>();
       int numCheckOutPerThread = 4;
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/UnderFileSystemBlockReaderTest.java b/core/server/worker/src/test/java/alluxio/worker/block/UnderFileSystemBlockReaderTest.java
index a69c3f04dc..8f2568030a 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/UnderFileSystemBlockReaderTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/UnderFileSystemBlockReaderTest.java
@@ -20,9 +20,11 @@ import static org.mockito.Mockito.any;
 
 import alluxio.AlluxioTestDirectory;
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.WorkerOutOfSpaceException;
 import alluxio.proto.dataserver.Protocol;
 import alluxio.underfs.UfsManager;
@@ -55,6 +57,7 @@ public final class UnderFileSystemBlockReaderTest {
   private UfsManager mUfsManager;
   private UfsInputStreamManager mUfsInstreamManager;
   private Protocol.OpenUfsBlockOptions mOpenUfsBlockOptions;
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
 
   /** Rule to create a new temporary folder during each test. */
   @Rule
@@ -73,11 +76,11 @@ public final class UnderFileSystemBlockReaderTest {
               .getAbsolutePath());
           put(PropertyKey.WORKER_TIERED_STORE_LEVELS, "1");
         }
-      });
+      }, mConf);
 
   @Before
   public void before() throws Exception {
-    String ufsFolder = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsFolder = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String testFilePath = File.createTempFile("temp", null, new File(ufsFolder)).getAbsolutePath();
     byte[] buffer = BufferUtils.getIncreasingByteArray((int) TEST_BLOCK_SIZE * 2);
     BufferUtils.writeBufferToFile(testFilePath, buffer);
@@ -86,7 +89,7 @@ public final class UnderFileSystemBlockReaderTest {
     mUfsManager = mock(UfsManager.class);
     mUfsInstreamManager = new UfsInputStreamManager();
     UfsClient ufsClient = new UfsClient(
-        () -> UnderFileSystem.Factory.create(testFilePath),
+        () -> UnderFileSystem.Factory.create(testFilePath, mConf),
         new AlluxioURI(testFilePath));
     when(mUfsManager.get(anyLong())).thenReturn(ufsClient);
 
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorContractTest.java b/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorContractTest.java
index 7d35458a28..a10e2409aa 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorContractTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorContractTest.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.allocator;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.reflect.ClassPath;
 import com.google.common.reflect.Reflection;
@@ -64,7 +64,7 @@ public final class AllocatorContractTest extends AllocatorTestBase {
   @Test
   public void shouldNotAllocate() throws Exception {
     for (String strategyName : mStrategies) {
-      Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, strategyName);
+      ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, strategyName);
       resetManagerView();
       Allocator allocator = Allocator.Factory.create(getManagerView());
       assertTempBlockMeta(allocator, mAnyDirInTierLoc1, DEFAULT_RAM_SIZE + 1, false);
@@ -81,7 +81,7 @@ public final class AllocatorContractTest extends AllocatorTestBase {
   @Test
   public void shouldAllocate() throws Exception {
     for (String strategyName : mStrategies) {
-      Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, strategyName);
+      ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, strategyName);
       resetManagerView();
       Allocator tierAllocator = Allocator.Factory.create(getManagerView());
       for (int i = 0; i < DEFAULT_RAM_NUM; i++) {
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorFactoryTest.java b/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorFactoryTest.java
index 2830d696e3..540f1b6014 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorFactoryTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/allocator/AllocatorFactoryTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.block.allocator;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.worker.block.BlockMetadataManagerView;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
 
@@ -46,7 +46,7 @@ public final class AllocatorFactoryTest {
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -55,7 +55,7 @@ public final class AllocatorFactoryTest {
    */
   @Test
   public void createGreedyAllocator() {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, GreedyAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, GreedyAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(mManagerView);
     Assert.assertTrue(allocator instanceof GreedyAllocator);
   }
@@ -66,7 +66,7 @@ public final class AllocatorFactoryTest {
    */
   @Test
   public void createMaxFreeAllocator() {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(mManagerView);
     Assert.assertTrue(allocator instanceof MaxFreeAllocator);
   }
@@ -77,7 +77,7 @@ public final class AllocatorFactoryTest {
    */
   @Test
   public void createRoundRobinAllocator() {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, RoundRobinAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, RoundRobinAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(mManagerView);
     Assert.assertTrue(allocator instanceof RoundRobinAllocator);
   }
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/allocator/GreedyAllocatorTest.java b/core/server/worker/src/test/java/alluxio/worker/block/allocator/GreedyAllocatorTest.java
index 1e009015d8..a1ada28feb 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/allocator/GreedyAllocatorTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/allocator/GreedyAllocatorTest.java
@@ -11,9 +11,8 @@
 
 package alluxio.worker.block.allocator;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 
 import org.junit.Test;
 
@@ -27,7 +26,7 @@ public final class GreedyAllocatorTest extends AllocatorTestBase {
    */
   @Test
   public void allocateBlock() throws Exception {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, GreedyAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, GreedyAllocator.class.getName());
     mAllocator = Allocator.Factory.create(getManagerView());
     //
     // idx | tier1 | tier2 | tier3
@@ -138,6 +137,6 @@ public final class GreedyAllocatorTest extends AllocatorTestBase {
     //  1               ├─── 1300   <--- alloc
     //  2               └─── 3000
     //
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 }
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/allocator/MaxFreeAllocatorTest.java b/core/server/worker/src/test/java/alluxio/worker/block/allocator/MaxFreeAllocatorTest.java
index 396c88935a..c626c4910f 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/allocator/MaxFreeAllocatorTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/allocator/MaxFreeAllocatorTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.block.allocator;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.junit.Test;
 
@@ -27,7 +27,7 @@ public final class MaxFreeAllocatorTest extends AllocatorTestBase {
    */
   @Test
   public void allocateBlock() throws Exception {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     mAllocator = Allocator.Factory.create(getManagerView());
     //
     // idx | tier1 | tier2 | tier3
@@ -78,6 +78,6 @@ public final class MaxFreeAllocatorTest extends AllocatorTestBase {
     //  1               ├─── 3000
     //  2               └─── 3000
     //
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 }
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/allocator/RoundRobinAllocatorTest.java b/core/server/worker/src/test/java/alluxio/worker/block/allocator/RoundRobinAllocatorTest.java
index 829e62741a..12a17f6750 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/allocator/RoundRobinAllocatorTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/allocator/RoundRobinAllocatorTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.worker.block.allocator;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.junit.Test;
 
@@ -27,7 +27,7 @@ public final class RoundRobinAllocatorTest extends AllocatorTestBase {
    */
   @Test
   public void allocateBlock() throws Exception {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, RoundRobinAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, RoundRobinAllocator.class.getName());
     mAllocator = Allocator.Factory.create(getManagerView());
     //
     // idx | tier1 | tier2 | tier3
@@ -218,6 +218,6 @@ public final class RoundRobinAllocatorTest extends AllocatorTestBase {
     //  1               ├─── 700   <--- alloc
     //  2               └─── 0
     //
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 }
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorContractTest.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorContractTest.java
index 50714d6b87..39041a6ef1 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorContractTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorContractTest.java
@@ -12,6 +12,7 @@
 package alluxio.worker.block.evictor;
 
 import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.worker.block.BlockStoreLocation;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
 import alluxio.worker.block.meta.StorageDir;
@@ -101,7 +102,7 @@ public final class EvictorContractTest extends EvictorTestBase {
    */
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorFactoryTest.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorFactoryTest.java
index 5c279cab75..4a083d33e2 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorFactoryTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorFactoryTest.java
@@ -11,9 +11,10 @@
 
 package alluxio.worker.block.evictor;
 
-import alluxio.Configuration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.worker.block.BlockMetadataManager;
 import alluxio.worker.block.BlockMetadataManagerView;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
@@ -60,7 +61,7 @@ public class EvictorFactoryTest {
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -70,8 +71,8 @@ public class EvictorFactoryTest {
    */
   @Test
   public void createGreedyEvictor() {
-    Configuration.set(PropertyKey.WORKER_EVICTOR_CLASS, GreedyEvictor.class.getName());
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_EVICTOR_CLASS, GreedyEvictor.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(sBlockMetadataManagerView);
     Evictor evictor = Evictor.Factory.create(sBlockMetadataManagerView, allocator);
     Assert.assertTrue(evictor instanceof GreedyEvictor);
@@ -84,8 +85,8 @@ public class EvictorFactoryTest {
    */
   @Test
   public void createLRUEvictor() {
-    Configuration.set(PropertyKey.WORKER_EVICTOR_CLASS, LRUEvictor.class.getName());
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_EVICTOR_CLASS, LRUEvictor.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(sBlockMetadataManagerView);
     Evictor evictor = Evictor.Factory.create(sBlockMetadataManagerView, allocator);
     Assert.assertTrue(evictor instanceof LRUEvictor);
@@ -98,7 +99,7 @@ public class EvictorFactoryTest {
    */
   @Test
   public void createDefaultEvictor() {
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(sBlockMetadataManagerView);
     Evictor evictor = Evictor.Factory.create(sBlockMetadataManagerView, allocator);
     Assert.assertTrue(evictor instanceof LRUEvictor);
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestBase.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestBase.java
index 747a86a53a..5076e63ee2 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestBase.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestBase.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.evictor;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.worker.block.BlockMetadataManager;
 import alluxio.worker.block.BlockMetadataManagerView;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
@@ -74,8 +74,8 @@ public class EvictorTestBase {
     mManagerView =
         new BlockMetadataManagerView(mMetaManager, Collections.<Long>emptySet(),
             Collections.<Long>emptySet());
-    Configuration.set(PropertyKey.WORKER_EVICTOR_CLASS, evictorClassName);
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_EVICTOR_CLASS, evictorClassName);
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     mAllocator = Allocator.Factory.create(mManagerView);
     mEvictor = Evictor.Factory.create(mManagerView, mAllocator);
   }
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestUtils.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestUtils.java
index 0acf5d6175..7b3710e358 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestUtils.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/EvictorTestUtils.java
@@ -36,7 +36,7 @@ public class EvictorTestUtils {
    * @param plan the eviction plan
    * @param meta the metadata manager
    * @return true if blocks are in the same dir otherwise false
-   * @throws BlockDoesNotExistException if fail to get metadata of a block
+   * @throws BlockDoesNotExistException if fail to create metadata of a block
    */
   public static boolean blocksInTheSameDir(EvictionPlan plan, BlockMetadataManager meta)
       throws BlockDoesNotExistException {
@@ -74,7 +74,7 @@ public class EvictorTestUtils {
    *         {@link #blocksInTheSameDir(EvictionPlan, BlockMetadataManager)} and
    *         {@link #requestSpaceSatisfied(long, EvictionPlan, BlockMetadataManager)} are true,
    *         otherwise false
-   * @throws alluxio.exception.BlockDoesNotExistException when fail to get metadata of a block
+   * @throws alluxio.exception.BlockDoesNotExistException when fail to create metadata of a block
    */
   public static boolean validNonCascadingPlan(long bytesToBeAvailable, EvictionPlan plan,
       BlockMetadataManager metaManager) throws BlockDoesNotExistException {
@@ -195,7 +195,7 @@ public class EvictorTestUtils {
    * @param plan the eviction plan, should not be null
    * @param meta the metadata manager
    * @return true if the request can be satisfied otherwise false
-   * @throws alluxio.exception.BlockDoesNotExistException if can not get metadata of a block
+   * @throws alluxio.exception.BlockDoesNotExistException if can not create metadata of a block
    */
   public static boolean requestSpaceSatisfied(long bytesToBeAvailable, EvictionPlan plan,
       BlockMetadataManager meta) throws BlockDoesNotExistException {
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRFUEvictorTest.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRFUEvictorTest.java
index be11758b2d..66fd2b6546 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRFUEvictorTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRFUEvictorTest.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.evictor;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.worker.block.BlockMetadataManager;
 import alluxio.worker.block.BlockMetadataManagerView;
 import alluxio.worker.block.BlockStoreEventListener;
@@ -66,12 +66,12 @@ public class LRFUEvictorTest {
     mManagerView =
         new BlockMetadataManagerView(mMetaManager, Collections.<Long>emptySet(),
             Collections.<Long>emptySet());
-    Configuration.set(PropertyKey.WORKER_EVICTOR_CLASS, LRFUEvictor.class.getName());
-    Configuration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_EVICTOR_CLASS, LRFUEvictor.class.getName());
+    ServerConfiguration.set(PropertyKey.WORKER_ALLOCATOR_CLASS, MaxFreeAllocator.class.getName());
     Allocator allocator = Allocator.Factory.create(mManagerView);
-    mStepFactor = Configuration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_STEP_FACTOR);
+    mStepFactor = ServerConfiguration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_STEP_FACTOR);
     mAttenuationFactor =
-        Configuration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR);
+        ServerConfiguration.getDouble(PropertyKey.WORKER_EVICTOR_LRFU_ATTENUATION_FACTOR);
     mEvictor = Evictor.Factory.create(mManagerView, allocator);
   }
 
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRUEvictorTest.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRUEvictorTest.java
index 998eba65fc..d56ef867e9 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRUEvictorTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/LRUEvictorTest.java
@@ -11,7 +11,7 @@
 
 package alluxio.worker.block.evictor;
 
-import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.worker.block.BlockStoreEventListener;
 import alluxio.worker.block.BlockStoreLocation;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
@@ -40,7 +40,7 @@ public class LRUEvictorTest extends EvictorTestBase {
    */
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   // access the block to update evictor
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/evictor/PartialLRUEvictorTest.java b/core/server/worker/src/test/java/alluxio/worker/block/evictor/PartialLRUEvictorTest.java
index 7dcd77995b..34b3c967b8 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/evictor/PartialLRUEvictorTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/evictor/PartialLRUEvictorTest.java
@@ -12,6 +12,7 @@
 package alluxio.worker.block.evictor;
 
 import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.worker.block.BlockStoreLocation;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
 import alluxio.worker.block.meta.StorageDir;
@@ -41,7 +42,7 @@ public class PartialLRUEvictorTest extends EvictorTestBase {
    */
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageDirTest.java b/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageDirTest.java
index ee6575cd59..b06e3567f4 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageDirTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageDirTest.java
@@ -346,7 +346,7 @@ public final class StorageDirTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get the metadata of a block which does not
+   * Tests that an exception is thrown when trying to create the metadata of a block which does not
    * exist.
    */
   @Test
@@ -416,7 +416,7 @@ public final class StorageDirTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get the metadata of a temporary block that
+   * Tests that an exception is thrown when trying to create the metadata of a temporary block that
    * does not exist.
    */
   @Test
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierTest.java b/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierTest.java
index d4ca24f68e..922663a453 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierTest.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.block.meta;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.util.io.PathUtils;
 import alluxio.worker.block.TieredBlockStoreTestUtils;
@@ -118,7 +118,7 @@ public class StorageTierTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get a directory by a non-existing index.
+   * Tests that an exception is thrown when trying to create a directory by a non-existing index.
    */
   @Test
   public void getDir() {
@@ -146,7 +146,7 @@ public class StorageTierTest {
   public void blankStorageTier() throws Exception {
     PropertyKey tierDirCapacityConf =
         PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_QUOTA.format(0);
-    Configuration.unset(tierDirCapacityConf);
+    ServerConfiguration.unset(tierDirCapacityConf);
     mThrown.expect(RuntimeException.class);
     mThrown.expectMessage(ExceptionMessage.UNDEFINED_CONFIGURATION_KEY.getMessage(
         PropertyKey.WORKER_TIERED_STORE_LEVEL0_DIRS_QUOTA.getName()));
@@ -157,7 +157,7 @@ public class StorageTierTest {
   public void tolerantFailureInStorageDir() throws Exception {
     PropertyKey tierDirPathConf =
         PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(0);
-    Configuration.set(tierDirPathConf, "/dev/null/invalid," + mTestDirPath1);
+    ServerConfiguration.set(tierDirPathConf, "/dev/null/invalid," + mTestDirPath1);
     mTier = StorageTier.newStorageTier("MEM");
     List<StorageDir> dirs = mTier.getStorageDirs();
     Assert.assertEquals(1, dirs.size());
diff --git a/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierViewTest.java b/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierViewTest.java
index 1c17f7abef..1b102401e2 100644
--- a/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierViewTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/block/meta/StorageTierViewTest.java
@@ -76,7 +76,7 @@ public class StorageTierViewTest {
   }
 
   /**
-   * Tests that an exception is thrown when trying to get a storage directory view with a bad index.
+   * Tests that an exception is thrown when trying to create a storage directory view with a bad index.
    */
   @Test
   public void getDirViewBadIndex() {
diff --git a/core/server/worker/src/test/java/alluxio/worker/file/FileDataManagerTest.java b/core/server/worker/src/test/java/alluxio/worker/file/FileDataManagerTest.java
index 3497d33119..6b09f7f48a 100644
--- a/core/server/worker/src/test/java/alluxio/worker/file/FileDataManagerTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/file/FileDataManagerTest.java
@@ -23,9 +23,9 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Sessions;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -76,7 +76,7 @@ public final class FileDataManagerTest {
     mUfsManager = mock(UfsManager.class);
     mBlockWorker = mock(BlockWorker.class);
     mMockRateLimiter =
-        new MockRateLimiter(Configuration.getBytes(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT));
+        new MockRateLimiter(ServerConfiguration.getBytes(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT));
     mCopyCounter = new AtomicInteger(0);
     mManager = new FileDataManager(mBlockWorker, mMockRateLimiter.getGuavaRateLimiter(),
         mUfsManager, () -> mMockFileSystem, (r, w) -> mCopyCounter.incrementAndGet());
@@ -88,7 +88,7 @@ public final class FileDataManagerTest {
 
   @After
   public void after() throws IOException {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -130,10 +130,10 @@ public final class FileDataManagerTest {
   @Ignore
   @Test
   public void persistFileRateLimiting() throws Exception {
-    Configuration.set(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT_ENABLED, "true");
-    Configuration.set(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT, "100");
+    ServerConfiguration.set(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT_ENABLED, "true");
+    ServerConfiguration.set(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT, "100");
     mMockRateLimiter =
-        new MockRateLimiter(Configuration.getBytes(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT));
+        new MockRateLimiter(ServerConfiguration.getBytes(PropertyKey.WORKER_FILE_PERSIST_RATE_LIMIT));
     mManager = new FileDataManager(mBlockWorker, mMockRateLimiter.getGuavaRateLimiter(),
         mUfsManager, () -> mMockFileSystem, (r, w) -> mCopyCounter.incrementAndGet());
 
@@ -155,7 +155,7 @@ public final class FileDataManagerTest {
           .thenReturn(mockedBlockMeta);
     }
 
-    String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     when(mUfs.isDirectory(ufsRoot)).thenReturn(true);
 
     OutputStream outputStream = new ByteArrayOutputStream();
@@ -237,7 +237,7 @@ public final class FileDataManagerTest {
           .readBlockRemote(Sessions.CHECKPOINT_SESSION_ID, blockId, blockId);
     }
 
-    String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     when(mUfs.isDirectory(ufsRoot)).thenReturn(true);
     OutputStream outputStream = mock(OutputStream.class);
 
@@ -274,7 +274,7 @@ public final class FileDataManagerTest {
           .thenReturn(reader);
     }
 
-    String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     when(mUfs.isDirectory(ufsRoot)).thenReturn(true);
     OutputStream outputStream = mock(OutputStream.class);
 
diff --git a/core/server/worker/src/test/java/alluxio/worker/file/UnderFileSystemUtilsTest.java b/core/server/worker/src/test/java/alluxio/worker/file/UnderFileSystemUtilsTest.java
index 0203a82f02..c072dbe56d 100644
--- a/core/server/worker/src/test/java/alluxio/worker/file/UnderFileSystemUtilsTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/file/UnderFileSystemUtilsTest.java
@@ -20,6 +20,7 @@ import static org.mockito.Mockito.anyString;
 import alluxio.AlluxioURI;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.security.authorization.Mode;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.options.MkdirsOptions;
@@ -170,7 +171,7 @@ public final class UnderFileSystemUtilsTest {
   }
 
   private MkdirsOptions createMkdirsOptions(String owner) {
-    return MkdirsOptions.defaults().setCreateParent(false).setOwner(owner).setGroup(mGroup)
+    return MkdirsOptions.defaults(ServerConfiguration.global()).setCreateParent(false).setOwner(owner).setGroup(mGroup)
         .setMode(mMode);
   }
 
diff --git a/core/server/worker/src/test/java/alluxio/worker/grpc/UfsFallbackBlockWriteHandlerTest.java b/core/server/worker/src/test/java/alluxio/worker/grpc/UfsFallbackBlockWriteHandlerTest.java
index 76dc3ef5ff..072e16b5d2 100644
--- a/core/server/worker/src/test/java/alluxio/worker/grpc/UfsFallbackBlockWriteHandlerTest.java
+++ b/core/server/worker/src/test/java/alluxio/worker/grpc/UfsFallbackBlockWriteHandlerTest.java
@@ -14,9 +14,10 @@ package alluxio.worker.grpc;
 import alluxio.AlluxioTestDirectory;
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
 import alluxio.grpc.RequestType;
 import alluxio.grpc.WriteRequest;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.network.protocol.databuffer.DataBuffer;
 import alluxio.proto.dataserver.Protocol;
 import alluxio.underfs.UfsManager;
@@ -71,7 +72,7 @@ public class UfsFallbackBlockWriteHandlerTest extends AbstractWriteHandlerTest {
               .getAbsolutePath());
           put(PropertyKey.WORKER_TIERED_STORE_LEVELS, "1");
         }
-      });
+      }, ServerConfiguration.global());
 
   @Before
   public void before() throws Exception {
diff --git a/examples/src/main/java/alluxio/cli/AlluxioFrameworkIntegrationTest.java b/examples/src/main/java/alluxio/cli/AlluxioFrameworkIntegrationTest.java
index 610fb7f071..f0a8f8fde2 100644
--- a/examples/src/main/java/alluxio/cli/AlluxioFrameworkIntegrationTest.java
+++ b/examples/src/main/java/alluxio/cli/AlluxioFrameworkIntegrationTest.java
@@ -12,9 +12,9 @@
 package alluxio.cli;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.BlockMasterClient;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
@@ -22,6 +22,7 @@ import alluxio.client.file.FileSystem;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterClientConfig;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.WaitForOptions;
 import alluxio.util.io.PathUtils;
 
@@ -44,6 +45,9 @@ import java.util.Map.Entry;
 public final class AlluxioFrameworkIntegrationTest {
   private static final Logger LOG = LoggerFactory.getLogger(AlluxioFrameworkIntegrationTest.class);
 
+  private static final InstancedConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private static final String JDK_URL =
       "https://s3-us-west-2.amazonaws.com/alluxio-mesos/jdk-7u79-macosx-x64.tar.gz";
   private static final String JDK_PATH = "jdk1.7.0_79.jdk/Contents/Home";
@@ -98,7 +102,7 @@ public final class AlluxioFrameworkIntegrationTest {
       startAlluxioFramework(env);
       LOG.info("Launched Alluxio cluster, waiting for worker to register with master");
       try (final BlockMasterClient client =
-          BlockMasterClient.Factory.create(MasterClientConfig.defaults())) {
+          BlockMasterClient.Factory.create(MasterClientConfig.defaults(sConf), sConf)) {
         CommonUtils.waitFor("Alluxio worker to register with master", () -> {
           try {
             try {
@@ -120,7 +124,7 @@ public final class AlluxioFrameworkIntegrationTest {
   }
 
   private void startAlluxioFramework(Map<String, String> extraEnv) {
-    String startScript = PathUtils.concatPath(Configuration.get(PropertyKey.HOME),
+    String startScript = PathUtils.concatPath(sConf.get(PropertyKey.HOME),
         "integration", "mesos", "bin", "alluxio-mesos-start.sh");
     ProcessBuilder pb = new ProcessBuilder(startScript, mMesosAddress);
     Map<String, String> env = pb.environment();
@@ -182,7 +186,7 @@ public final class AlluxioFrameworkIntegrationTest {
   }
 
   private static void stopAlluxioFramework() throws Exception {
-    String stopScript = PathUtils.concatPath(Configuration.get(PropertyKey.HOME),
+    String stopScript = PathUtils.concatPath(sConf.get(PropertyKey.HOME),
         "integration", "mesos", "bin", "alluxio-mesos-stop.sh");
     ProcessBuilder pb = new ProcessBuilder(stopScript);
     pb.start().waitFor();
@@ -191,7 +195,7 @@ public final class AlluxioFrameworkIntegrationTest {
   }
 
   private static void stopAlluxio() throws Exception {
-    String stopScript = PathUtils.concatPath(Configuration.get(PropertyKey.HOME),
+    String stopScript = PathUtils.concatPath(sConf.get(PropertyKey.HOME),
         "bin", "alluxio-stop.sh");
     ProcessBuilder pb = new ProcessBuilder(stopScript, "all");
     pb.start().waitFor();
diff --git a/examples/src/main/java/alluxio/cli/JournalCrashTest.java b/examples/src/main/java/alluxio/cli/JournalCrashTest.java
index 2259fafe85..99c8a5e261 100644
--- a/examples/src/main/java/alluxio/cli/JournalCrashTest.java
+++ b/examples/src/main/java/alluxio/cli/JournalCrashTest.java
@@ -12,8 +12,8 @@
 package alluxio.cli;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.client.file.FileSystem;
 import alluxio.exception.AlluxioException;
@@ -21,6 +21,7 @@ import alluxio.exception.FileAlreadyExistsException;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.WritePType;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.PathUtils;
 
 import org.apache.commons.cli.CommandLine;
@@ -41,6 +42,9 @@ import java.util.List;
  */
 public final class JournalCrashTest {
 
+  private static final InstancedConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private JournalCrashTest() {} // prevent instantiation
 
   /**
@@ -381,7 +385,7 @@ public final class JournalCrashTest {
    * Starts Alluxio Master by executing the launch script.
    */
   private static void startMaster() {
-    String alluxioStartPath = PathUtils.concatPath(Configuration.get(PropertyKey.HOME),
+    String alluxioStartPath = PathUtils.concatPath(sConf.get(PropertyKey.HOME),
         "bin", "alluxio-start.sh");
     String startMasterCommand = String.format("%s master", alluxioStartPath);
     try {
@@ -398,7 +402,7 @@ public final class JournalCrashTest {
    */
   private static void stopCluster() {
     String alluxioStopPath =
-        PathUtils.concatPath(Configuration.get(PropertyKey.HOME), "bin", "alluxio-stop.sh");
+        PathUtils.concatPath(sConf.get(PropertyKey.HOME), "bin", "alluxio-stop.sh");
     String stopClusterCommand = String.format("%s all", alluxioStopPath);
     try {
       Runtime.getRuntime().exec(stopClusterCommand).waitFor();
diff --git a/examples/src/main/java/alluxio/examples/Performance.java b/examples/src/main/java/alluxio/examples/Performance.java
index 2949e637d3..ee27d2fb28 100644
--- a/examples/src/main/java/alluxio/examples/Performance.java
+++ b/examples/src/main/java/alluxio/examples/Performance.java
@@ -12,15 +12,16 @@
 package alluxio.examples;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.FormatUtils;
 
 import com.google.common.base.Preconditions;
@@ -579,6 +580,8 @@ public final class Performance {
       System.exit(-1);
     }
 
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+
     HostAndPort masterAddress = HostAndPort.fromString(args[0]);
     sFileName = args[1];
     sBlockSizeBytes = Integer.parseInt(args[2]);
@@ -592,7 +595,7 @@ public final class Performance {
     sFileBytes = sBlocksPerFile * sBlockSizeBytes;
     sFilesBytes = sFileBytes * sFiles;
 
-    long fileBufferBytes = Configuration.getBytes(PropertyKey.USER_FILE_BUFFER_BYTES);
+    long fileBufferBytes = conf.getBytes(PropertyKey.USER_FILE_BUFFER_BYTES);
     sResultPrefix = String.format(
         "Threads %d FilesPerThread %d TotalFiles %d "
             + "BLOCK_SIZE_KB %d BLOCKS_PER_FILE %d FILE_SIZE_MB %d "
@@ -602,8 +605,8 @@ public final class Performance {
 
     CommonUtils.warmUpLoop();
 
-    Configuration.set(PropertyKey.MASTER_HOSTNAME, masterAddress.getHost());
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, Integer.toString(masterAddress.getPort()));
+    conf.set(PropertyKey.MASTER_HOSTNAME, masterAddress.getHost());
+    conf.set(PropertyKey.MASTER_RPC_PORT, Integer.toString(masterAddress.getPort()));
 
     if (testCase == 1) {
       sResultPrefix = "AlluxioFilesWriteTest " + sResultPrefix;
diff --git a/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreOperations.java b/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreOperations.java
index 1aac79ea13..7e543b8a4f 100644
--- a/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreOperations.java
+++ b/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreOperations.java
@@ -12,9 +12,9 @@
 package alluxio.examples.keyvalue;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.cli.CliUtils;
 import alluxio.client.keyvalue.KeyValueIterator;
@@ -22,6 +22,7 @@ import alluxio.client.keyvalue.KeyValuePair;
 import alluxio.client.keyvalue.KeyValueStoreReader;
 import alluxio.client.keyvalue.KeyValueStoreWriter;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.BufferUtils;
 
 import org.slf4j.Logger;
@@ -42,6 +43,9 @@ public final class KeyValueStoreOperations implements Callable<Boolean> {
   private final int mPartitionLength = Constants.MB;
   private final int mNumKeyValuePairs = 10;
 
+  private static final InstancedConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private AlluxioURI mStoreUri;
   private Map<ByteBuffer, ByteBuffer> mKeyValuePairs = new HashMap<>();
 
@@ -54,11 +58,10 @@ public final class KeyValueStoreOperations implements Callable<Boolean> {
 
   @Override
   public Boolean call() throws Exception {
-    Configuration.set(PropertyKey.KEY_VALUE_ENABLED, String.valueOf(true));
-    Configuration
-        .set(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(mPartitionLength));
+    sConf.set(PropertyKey.KEY_VALUE_ENABLED, String.valueOf(true));
+    sConf.set(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(mPartitionLength));
 
-    KeyValueSystem kvs = KeyValueSystem.Factory.create();
+    KeyValueSystem kvs = KeyValueSystem.Factory.create(sConf);
 
     KeyValueStoreWriter writer = kvs.createStore(mStoreUri);
     putKeyValuePairs(writer);
@@ -93,7 +96,7 @@ public final class KeyValueStoreOperations implements Callable<Boolean> {
       return false;
     }
 
-    // API: KeyValueStoreReader#get
+    // API: KeyValueStoreReader#create
     for (Map.Entry<ByteBuffer, ByteBuffer> pair : mKeyValuePairs.entrySet()) {
       ByteBuffer expectedValue = pair.getValue();
       ByteBuffer gotValue = reader.get(pair.getKey());
@@ -130,7 +133,7 @@ public final class KeyValueStoreOperations implements Callable<Boolean> {
       System.exit(-1);
     }
 
-    if (!Configuration.getBoolean(PropertyKey.KEY_VALUE_ENABLED)) {
+    if (!sConf.getBoolean(PropertyKey.KEY_VALUE_ENABLED)) {
       System.out.println("Alluxio key value service is disabled. To run this test, please set "
           + PropertyKey.KEY_VALUE_ENABLED + " to be true and restart the cluster.");
       System.exit(-1);
diff --git a/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreQuickStart.java b/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreQuickStart.java
index ed44424a4d..f63bdb9827 100644
--- a/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreQuickStart.java
+++ b/examples/src/main/java/alluxio/examples/keyvalue/KeyValueStoreQuickStart.java
@@ -16,12 +16,17 @@ import alluxio.RuntimeConstants;
 import alluxio.client.keyvalue.KeyValueStoreReader;
 import alluxio.client.keyvalue.KeyValueStoreWriter;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 
 /**
  * A quick start tutorial for creating a key-value store, putting and getting some key-value pairs.
  */
 public final class KeyValueStoreQuickStart {
 
+  private static final InstancedConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private KeyValueStoreQuickStart() {} // prevent instantiation
 
   /**
@@ -37,7 +42,7 @@ public final class KeyValueStoreQuickStart {
     }
 
     AlluxioURI storeUri = new AlluxioURI(args[0]);
-    KeyValueSystem kvs = KeyValueSystem.Factory.create();
+    KeyValueSystem kvs = KeyValueSystem.Factory.create(sConf);
 
     // Creates a store.
     KeyValueStoreWriter writer = kvs.createStore(storeUri);
diff --git a/examples/src/main/java/alluxio/examples/keyvalue/SameKeyValueStoresTest.java b/examples/src/main/java/alluxio/examples/keyvalue/SameKeyValueStoresTest.java
index e48ebca984..e6b0d0ae82 100644
--- a/examples/src/main/java/alluxio/examples/keyvalue/SameKeyValueStoresTest.java
+++ b/examples/src/main/java/alluxio/examples/keyvalue/SameKeyValueStoresTest.java
@@ -18,6 +18,8 @@ import alluxio.client.keyvalue.KeyValueIterator;
 import alluxio.client.keyvalue.KeyValuePair;
 import alluxio.client.keyvalue.KeyValueStoreReader;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.FormatUtils;
 import alluxio.util.io.BufferUtils;
 
@@ -33,6 +35,9 @@ import java.util.concurrent.Callable;
 public final class SameKeyValueStoresTest implements Callable<Boolean> {
   private static final Logger LOG = LoggerFactory.getLogger(SameKeyValueStoresTest.class);
 
+  private static final InstancedConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private final AlluxioURI mStoreUri1;
   private final AlluxioURI mStoreUri2;
 
@@ -47,7 +52,7 @@ public final class SameKeyValueStoresTest implements Callable<Boolean> {
 
   @Override
   public Boolean call() throws Exception {
-    KeyValueSystem kvs = KeyValueSystem.Factory.create();
+    KeyValueSystem kvs = KeyValueSystem.Factory.create(sConf);
     KeyValueStoreReader reader1 = kvs.openStore(mStoreUri1);
     KeyValueStoreReader reader2 = kvs.openStore(mStoreUri2);
     boolean pass = areTheSameStores(reader1, reader2);
diff --git a/examples/src/main/java/alluxio/examples/keyvalue/ShowKeyValueStore.java b/examples/src/main/java/alluxio/examples/keyvalue/ShowKeyValueStore.java
index c488d9706f..2583d5a2e7 100644
--- a/examples/src/main/java/alluxio/examples/keyvalue/ShowKeyValueStore.java
+++ b/examples/src/main/java/alluxio/examples/keyvalue/ShowKeyValueStore.java
@@ -17,6 +17,8 @@ import alluxio.client.keyvalue.KeyValueIterator;
 import alluxio.client.keyvalue.KeyValuePair;
 import alluxio.client.keyvalue.KeyValueStoreReader;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.FormatUtils;
 import alluxio.util.io.BufferUtils;
 
@@ -24,6 +26,10 @@ import alluxio.util.io.BufferUtils;
  * Prints out (key, value) pairs, or only keys, or only values in a key-value store.
  */
 public final class ShowKeyValueStore {
+
+  private static final InstancedConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private static void show(KeyValuePair pair, String scope) {
     String key = FormatUtils.byteArrayToHexString(BufferUtils.newByteArrayFromByteBuffer(
         pair.getKey()));
@@ -60,7 +66,8 @@ public final class ShowKeyValueStore {
       System.exit(-1);
     }
 
-    KeyValueStoreReader reader = KeyValueSystem.Factory.create().openStore(new AlluxioURI(args[0]));
+    KeyValueStoreReader reader =
+        KeyValueSystem.Factory.create(sConf).openStore(new AlluxioURI(args[0]));
     KeyValueIterator iterator = reader.iterator();
     while (iterator.hasNext()) {
       show(iterator.next(), args[1]);
diff --git a/integration/authorization/hdfs/src/main/java/alluxio/security/authorization/AuthorizationPluginConstants.java b/integration/authorization/hdfs/src/main/java/alluxio/security/authorization/AuthorizationPluginConstants.java
new file mode 100644
index 0000000000..7a54ed057d
--- /dev/null
+++ b/integration/authorization/hdfs/src/main/java/alluxio/security/authorization/AuthorizationPluginConstants.java
@@ -0,0 +1,22 @@
+/*
+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0
+ * (the "License"). You may not use this work except in compliance with the License, which is
+ * available at www.apache.org/licenses/LICENSE-2.0
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied, as more fully set forth in the License.
+ *
+ * See the NOTICE file distributed with this work for information regarding copyright ownership.
+ */
+
+package alluxio.security.authorization;
+
+/**
+ * Ufs constants from compilation time by maven.
+ */
+public final class AuthorizationPluginConstants {
+  /* Ranger version, specified in maven property. **/
+  public static final String AUTH_VERSION = "ranger-hdp-2.6";
+
+  private AuthorizationPluginConstants() {} // prevent instantiation
+}
diff --git a/integration/checker/src/main/java/alluxio/checker/CheckerUtils.java b/integration/checker/src/main/java/alluxio/checker/CheckerUtils.java
index 576ab7e7cc..1f73059865 100644
--- a/integration/checker/src/main/java/alluxio/checker/CheckerUtils.java
+++ b/integration/checker/src/main/java/alluxio/checker/CheckerUtils.java
@@ -11,7 +11,8 @@
 
 package alluxio.checker;
 
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileSystem;
@@ -99,16 +100,16 @@ public final class CheckerUtils {
    * @param reportWriter save user-facing messages to a generated file
    * @return true if Alluxio HA mode is supported, false otherwise
    */
-  public static boolean supportAlluxioHA(PrintWriter reportWriter) {
-    if (alluxio.Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
+  public static boolean supportAlluxioHA(PrintWriter reportWriter, AlluxioConfiguration conf) {
+    if (conf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
       reportWriter.println("Alluixo is running in high availability mode.\n");
-      if (!alluxio.Configuration.isSet(PropertyKey.ZOOKEEPER_ADDRESS)) {
+      if (!conf.isSet(PropertyKey.ZOOKEEPER_ADDRESS)) {
         reportWriter.println("Please set Zookeeper address to support "
             + "Alluxio high availability mode.\n");
         return false;
       } else {
         reportWriter.printf("Zookeeper address is: %s.%n",
-            alluxio.Configuration.get(PropertyKey.ZOOKEEPER_ADDRESS));
+            conf.get(PropertyKey.ZOOKEEPER_ADDRESS));
       }
     }
     return true;
diff --git a/integration/checker/src/main/java/alluxio/checker/SparkIntegrationChecker.java b/integration/checker/src/main/java/alluxio/checker/SparkIntegrationChecker.java
index 59254208d1..860b72deda 100644
--- a/integration/checker/src/main/java/alluxio/checker/SparkIntegrationChecker.java
+++ b/integration/checker/src/main/java/alluxio/checker/SparkIntegrationChecker.java
@@ -13,6 +13,9 @@ package alluxio.checker;
 
 import alluxio.checker.CheckerUtils.Status;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 import com.beust.jcommander.JCommander;
 import com.beust.jcommander.Parameter;
 import org.apache.spark.api.java.JavaPairRDD;
@@ -71,7 +74,7 @@ public class SparkIntegrationChecker implements Serializable{
    * @param reportWriter save user-facing messages to a generated file
    * @return performIntegrationChecks results
    */
-  private Status run(JavaSparkContext sc, PrintWriter reportWriter) {
+  private Status run(JavaSparkContext sc, PrintWriter reportWriter, AlluxioConfiguration conf) {
     // Check whether Spark driver can recognize Alluxio classes and filesystem
     Status driverStatus = CheckerUtils.performIntegrationChecks();
     String driverAddress = sc.getConf().get("spark.driver.host");
@@ -90,7 +93,7 @@ public class SparkIntegrationChecker implements Serializable{
         break;
     }
 
-    if (!CheckerUtils.supportAlluxioHA(reportWriter)) {
+    if (!CheckerUtils.supportAlluxioHA(reportWriter, conf)) {
       return Status.FAIL_TO_SUPPORT_HA;
     }
 
@@ -189,6 +192,7 @@ public class SparkIntegrationChecker implements Serializable{
    * @param args optional argument mPartitions may be passed in
    */
   public static void main(String[] args) throws Exception {
+    AlluxioConfiguration alluxioConf = new InstancedConfiguration(ConfigurationUtils.defaults());
     SparkIntegrationChecker checker = new SparkIntegrationChecker();
     JCommander jCommander = new JCommander(checker, args);
     jCommander.setProgramName("SparkIntegrationChecker");
@@ -200,7 +204,7 @@ public class SparkIntegrationChecker implements Serializable{
       JavaSparkContext sc = new JavaSparkContext(conf);
 
       checker.printConfigInfo(conf, reportWriter);
-      Status resultStatus = checker.run(sc, reportWriter);
+      Status resultStatus = checker.run(sc, reportWriter, alluxioConf);
       checker.printResultInfo(resultStatus, reportWriter);
       reportWriter.flush();
       System.exit(resultStatus.equals(Status.SUCCESS) ? 0 : 1);
diff --git a/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java b/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java
index 2d01a68ae2..03557e8bb5 100644
--- a/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java
+++ b/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuse.java
@@ -11,10 +11,10 @@
 
 package alluxio.fuse;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.*;
 import alluxio.client.file.FileSystem;
 
+import alluxio.util.*;
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.CommandLineParser;
 import org.apache.commons.cli.DefaultParser;
@@ -44,7 +44,7 @@ public final class AlluxioFuse {
 
   /**
    * Running this class will mount the file system according to
-   * the options passed to this function {@link #parseOptions(String[])}.
+   * the options passed to this function {@link #parseOptions(String[], AlluxioConfiguration)}.
    * The user-space fuse application will stay on the foreground and keep
    * the file system mounted. The user can unmount the file system by
    * gracefully killing (SIGINT) the process.
@@ -52,13 +52,14 @@ public final class AlluxioFuse {
    * @param args arguments to run the command line
    */
   public static void main(String[] args) {
-    final AlluxioFuseOptions opts = parseOptions(args);
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    final AlluxioFuseOptions opts = parseOptions(args, conf);
     if (opts == null) {
       System.exit(1);
     }
 
     final FileSystem tfs = FileSystem.Factory.get();
-    final AlluxioFuseFileSystem fs = new AlluxioFuseFileSystem(tfs, opts);
+    final AlluxioFuseFileSystem fs = new AlluxioFuseFileSystem(tfs, opts, conf);
     final List<String> fuseOpts = opts.getFuseOpts();
     // Force direct_io in FUSE: writes and reads bypass the kernel page
     // cache and go directly to alluxio. This avoids extra memory copies
@@ -79,7 +80,7 @@ public final class AlluxioFuse {
    * @param args CLI args
    * @return Alluxio-FUSE configuration options
    */
-  private static AlluxioFuseOptions parseOptions(String[] args) {
+  private static AlluxioFuseOptions parseOptions(String[] args, AlluxioConfiguration alluxioConf) {
     final Options opts = new Options();
     final Option mntPoint = Option.builder("m")
         .hasArg()
@@ -138,14 +139,14 @@ public final class AlluxioFuse {
           }
         }
       }
-      // check if the user has specified his own max_write, otherwise get it
+      // check if the user has specified his own max_write, otherwise create it
       // from conf
       if (noUserMaxWrite) {
-        final long maxWrite = Configuration.getBytes(PropertyKey.FUSE_MAXWRITE_BYTES);
+        final long maxWrite = alluxioConf.getBytes(PropertyKey.FUSE_MAXWRITE_BYTES);
         fuseOpts.add(String.format("-omax_write=%d", maxWrite));
       }
 
-      final boolean fuseDebug = Configuration.getBoolean(PropertyKey.FUSE_DEBUG_ENABLED);
+      final boolean fuseDebug = alluxioConf.getBoolean(PropertyKey.FUSE_DEBUG_ENABLED);
 
       return new AlluxioFuseOptions(mntPointValue, alluxioRootValue, fuseDebug, fuseOpts);
     } catch (ParseException e) {
diff --git a/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseFileSystem.java b/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseFileSystem.java
index a32fecc254..1d6db974a0 100644
--- a/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseFileSystem.java
+++ b/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseFileSystem.java
@@ -12,8 +12,7 @@
 package alluxio.fuse;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.*;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.collections.IndexDefinition;
@@ -110,6 +109,7 @@ public final class AlluxioFuseFileSystem extends FuseStubFS {
   private final IndexedSet<OpenFileEntry> mOpenFiles;
 
   private long mNextOpenFileId;
+  private final String mFsName;
 
   /**
    * Creates a new instance of {@link AlluxioFuseFileSystem}.
@@ -117,16 +117,17 @@ public final class AlluxioFuseFileSystem extends FuseStubFS {
    * @param fs Alluxio file system
    * @param opts options
    */
-  public AlluxioFuseFileSystem(FileSystem fs, AlluxioFuseOptions opts) {
+  public AlluxioFuseFileSystem(FileSystem fs, AlluxioFuseOptions opts, AlluxioConfiguration conf) {
     super();
+    mFsName = conf.get(PropertyKey.FUSE_FS_NAME);
     mFileSystem = fs;
     mAlluxioRootPath = Paths.get(opts.getAlluxioRoot());
     mNextOpenFileId = 0L;
     mOpenFiles = new IndexedSet<>(ID_INDEX, PATH_INDEX);
 
-    final int maxCachedPaths = Configuration.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX);
+    final int maxCachedPaths = conf.getInt(PropertyKey.FUSE_CACHED_PATHS_MAX);
     mIsUserGroupTranslation
-        = Configuration.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);
+        = conf.getBoolean(PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED);
     mPathResolverCache = CacheBuilder.newBuilder()
         .maximumSize(maxCachedPaths)
         .build(new PathCacheLoader());
@@ -185,7 +186,7 @@ public final class AlluxioFuseFileSystem extends FuseStubFS {
         userName = AlluxioFuseUtils.getUserName(uid);
         if (userName.isEmpty()) {
           // This should never be reached
-          LOG.error("Failed to get user name from uid {}", uid);
+          LOG.error("Failed to create user name from uid {}", uid);
           return -ErrorCodes.EFAULT();
         }
         optionsBuilder.setOwner(userName);
@@ -397,7 +398,7 @@ public final class AlluxioFuseFileSystem extends FuseStubFS {
    */
   @Override
   public String getFSName() {
-    return Configuration.get(PropertyKey.FUSE_FS_NAME);
+    return mFsName;
   }
 
   /**
diff --git a/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseUtils.java b/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseUtils.java
index 5879ef6e6d..e35bf86d82 100644
--- a/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseUtils.java
+++ b/integration/fuse/src/main/java/alluxio/fuse/AlluxioFuseUtils.java
@@ -69,7 +69,7 @@ public final class AlluxioFuseUtils {
     try {
       return Long.parseLong(result);
     } catch (NumberFormatException e) {
-      LOG.error("Failed to get gid from group name {}.", groupName);
+      LOG.error("Failed to create gid from group name {}.", groupName);
       return -1;
     }
   }
@@ -145,7 +145,7 @@ public final class AlluxioFuseUtils {
     try {
       output = ShellUtils.execCommand("id", option, username).trim();
     } catch (IOException e) {
-      LOG.error("Failed to get id from {} with option {}", username, option);
+      LOG.error("Failed to create id from {} with option {}", username, option);
       return -1;
     }
     return Long.parseLong(output);
diff --git a/integration/fuse/src/test/java/alluxio/fuse/AlluxioFuseFileSystemTest.java b/integration/fuse/src/test/java/alluxio/fuse/AlluxioFuseFileSystemTest.java
index 89c242df40..80aa493cc1 100644
--- a/integration/fuse/src/test/java/alluxio/fuse/AlluxioFuseFileSystemTest.java
+++ b/integration/fuse/src/test/java/alluxio/fuse/AlluxioFuseFileSystemTest.java
@@ -29,7 +29,9 @@ import static org.mockito.Mockito.times;
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
@@ -65,11 +67,12 @@ public class AlluxioFuseFileSystemTest {
   private AlluxioFuseFileSystem mFuseFs;
   private FileSystem mFileSystem;
   private FuseFileInfo mFileInfo;
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
 
   @Rule
   public ConfigurationRule mConfiguration =
       new ConfigurationRule(ImmutableMap.of(PropertyKey.FUSE_CACHED_PATHS_MAX, "0",
-          PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED, "true"));
+          PropertyKey.FUSE_USER_GROUP_TRANSLATION_ENABLED, "true"), mConf);
 
   @Before
   public void before() throws Exception {
@@ -79,7 +82,7 @@ public class AlluxioFuseFileSystemTest {
 
     mFileSystem = mock(FileSystem.class);
     try {
-      mFuseFs = new AlluxioFuseFileSystem(mFileSystem, opts);
+      mFuseFs = new AlluxioFuseFileSystem(mFileSystem, opts, mConf);
     } catch (UnsatisfiedLinkError e) {
       // stop test and ignore if FuseFileSystem fails to create due to missing libfuse library
       Assume.assumeNoException(e);
diff --git a/integration/mesos/src/main/java/alluxio/mesos/AlluxioFramework.java b/integration/mesos/src/main/java/alluxio/mesos/AlluxioFramework.java
index b8981c2333..43ae1b8760 100644
--- a/integration/mesos/src/main/java/alluxio/mesos/AlluxioFramework.java
+++ b/integration/mesos/src/main/java/alluxio/mesos/AlluxioFramework.java
@@ -11,8 +11,8 @@
 
 package alluxio.mesos;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
 
@@ -61,18 +61,18 @@ public class AlluxioFramework {
     Protos.FrameworkInfo.Builder frameworkInfo = Protos.FrameworkInfo.newBuilder()
         .setName("alluxio").setCheckpoint(true);
 
-    if (Configuration.isSet(PropertyKey.INTEGRATION_MESOS_ROLE)) {
-      frameworkInfo.setRole(Configuration.get(PropertyKey.INTEGRATION_MESOS_ROLE));
+    if (ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_ROLE)) {
+      frameworkInfo.setRole(ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_ROLE));
     }
-    if (Configuration.isSet(PropertyKey.INTEGRATION_MESOS_USER)) {
-      frameworkInfo.setUser(Configuration.get(PropertyKey.INTEGRATION_MESOS_USER));
+    if (ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_USER)) {
+      frameworkInfo.setUser(ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_USER));
     } else {
       // Setting the user to an empty string will prompt Mesos to set it to the current user.
       frameworkInfo.setUser("");
     }
 
-    if (Configuration.isSet(PropertyKey.INTEGRATION_MESOS_PRINCIPAL)) {
-      frameworkInfo.setPrincipal(Configuration.get(PropertyKey.INTEGRATION_MESOS_PRINCIPAL));
+    if (ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_PRINCIPAL)) {
+      frameworkInfo.setPrincipal(ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_PRINCIPAL));
     }
 
     // Publish WebUI url to mesos master.
@@ -99,21 +99,21 @@ public class AlluxioFramework {
    */
   private static String createMasterWebUrl() {
     InetSocketAddress masterWeb = NetworkAddressUtils.getConnectAddress(
-        ServiceType.MASTER_WEB);
+        ServiceType.MASTER_WEB, ServerConfiguration.global());
     return "http://" + masterWeb.getHostString() + ":" + masterWeb.getPort();
   }
 
   private static Protos.Credential createCredential() {
-    if (!(Configuration.isSet(PropertyKey.INTEGRATION_MESOS_PRINCIPAL)
-        && Configuration.isSet(PropertyKey.INTEGRATION_MESOS_SECRET))) {
+    if (!(ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_PRINCIPAL)
+        && ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_SECRET))) {
       return null;
     }
 
     try {
       Protos.Credential.Builder credentialBuilder = Protos.Credential.newBuilder()
-          .setPrincipal(Configuration.get(PropertyKey.INTEGRATION_MESOS_PRINCIPAL)).setSecret(
+          .setPrincipal(ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_PRINCIPAL)).setSecret(
               ByteString.copyFrom(
-                  Configuration.get(PropertyKey.INTEGRATION_MESOS_SECRET).getBytes("UTF-8")));
+                  ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_SECRET).getBytes("UTF-8")));
 
       return credentialBuilder.build();
     } catch (UnsupportedEncodingException ex) {
diff --git a/integration/mesos/src/main/java/alluxio/mesos/AlluxioMasterExecutor.java b/integration/mesos/src/main/java/alluxio/mesos/AlluxioMasterExecutor.java
index 2e8953177e..702ba312d3 100644
--- a/integration/mesos/src/main/java/alluxio/mesos/AlluxioMasterExecutor.java
+++ b/integration/mesos/src/main/java/alluxio/mesos/AlluxioMasterExecutor.java
@@ -12,6 +12,7 @@
 package alluxio.mesos;
 
 import alluxio.cli.Format;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.AlluxioMaster;
 import alluxio.master.journal.JournalSystem;
 import alluxio.master.journal.JournalUtils;
@@ -79,7 +80,7 @@ public class AlluxioMasterExecutor implements Executor {
           JournalSystem journalSystem =
               new JournalSystem.Builder().setLocation(JournalUtils.getJournalLocation()).build();
           if (!journalSystem.isFormatted()) {
-            Format.format(Format.Mode.MASTER);
+            Format.format(Format.Mode.MASTER, ServerConfiguration.global());
           }
           AlluxioMaster.main(new String[] {});
 
diff --git a/integration/mesos/src/main/java/alluxio/mesos/AlluxioScheduler.java b/integration/mesos/src/main/java/alluxio/mesos/AlluxioScheduler.java
index 62f0c99db3..8b8181998d 100644
--- a/integration/mesos/src/main/java/alluxio/mesos/AlluxioScheduler.java
+++ b/integration/mesos/src/main/java/alluxio/mesos/AlluxioScheduler.java
@@ -11,9 +11,9 @@
 
 package alluxio.mesos;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.conf.Source.Type;
 import alluxio.util.FormatUtils;
 import alluxio.util.io.PathUtils;
@@ -108,13 +108,13 @@ public class AlluxioScheduler implements Scheduler {
 
   @Override
   public void resourceOffers(SchedulerDriver driver, List<Protos.Offer> offers) {
-    long masterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
+    long masterCpu = ServerConfiguration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
     long masterMem =
-        Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;
-    long workerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
+        ServerConfiguration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB;
+    long workerCpu = ServerConfiguration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
     long workerOverheadMem =
-        Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;
-    long ramdiskMem = Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB;
+        ServerConfiguration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB;
+    long ramdiskMem = ServerConfiguration.getBytes(PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB;
 
     LOG.info("Master launched {}, master count {}, "
         + "requested master cpu {} mem {} MB and required master hostname {}",
@@ -143,7 +143,7 @@ public class AlluxioScheduler implements Scheduler {
       if (!mMasterLaunched
           && offerCpu >= masterCpu
           && offerMem >= masterMem
-          && mMasterCount < Configuration
+          && mMasterCount < ServerConfiguration
               .getInt(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NODE_COUNT)
           && OfferUtils.hasAvailableMasterPorts(offer)
           && (mRequiredMasterHostname == null
@@ -165,7 +165,7 @@ public class AlluxioScheduler implements Scheduler {
                             .addVariables(
                                 Protos.Environment.Variable.newBuilder()
                                     .setName("ALLUXIO_UNDERFS_ADDRESS")
-                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))
+                                    .setValue(ServerConfiguration.get(PropertyKey.UNDERFS_ADDRESS))
                                     .build())
                             .addVariables(
                                 Protos.Environment.Variable.newBuilder()
@@ -176,7 +176,7 @@ public class AlluxioScheduler implements Scheduler {
         // pre-build resource list here, then use it to build Protos.Task later.
         resources = getMasterRequiredResources(masterCpu, masterMem);
         mMasterHostname = offer.getHostname();
-        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);
+        mTaskName = ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_MASTER_NAME);
         mMasterCount++;
         mMasterTaskId = mLaunchedTasks;
       } else if (mMasterLaunched
@@ -210,7 +210,7 @@ public class AlluxioScheduler implements Scheduler {
                             .addVariables(
                                 Protos.Environment.Variable.newBuilder()
                                     .setName("ALLUXIO_UNDERFS_ADDRESS")
-                                    .setValue(Configuration.get(PropertyKey.UNDERFS_ADDRESS))
+                                    .setValue(ServerConfiguration.get(PropertyKey.UNDERFS_ADDRESS))
                                     .build())
                             .addVariables(
                                 Protos.Environment.Variable.newBuilder()
@@ -221,7 +221,7 @@ public class AlluxioScheduler implements Scheduler {
         // pre-build resource list here, then use it to build Protos.Task later.
         resources = getWorkerRequiredResources(workerCpu, ramdiskMem + workerOverheadMem);
         mWorkers.add(offer.getHostname());
-        mTaskName = Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);
+        mTaskName = ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_WORKER_NAME);
       } else {
         // The resource offer cannot be used to start either master or a worker.
         LOG.info("Declining offer {}", offer.getId().getValue());
@@ -262,10 +262,10 @@ public class AlluxioScheduler implements Scheduler {
 
   private String createAlluxioSiteProperties() {
     StringBuilder siteProperties = new StringBuilder();
-    for (PropertyKey key : Configuration.keySet()) {
-      if (Configuration.isSet(key)
-          && Configuration.getSource(key).getType() != Type.DEFAULT) {
-        siteProperties.append(String.format("%s=%s%n", key.getName(), Configuration.get(key)));
+    for (PropertyKey key : ServerConfiguration.keySet()) {
+      if (ServerConfiguration.isSet(key)
+          && ServerConfiguration.getSource(key).getType() != Type.DEFAULT) {
+        siteProperties.append(String.format("%s=%s%n", key.getName(), ServerConfiguration.get(key)));
       }
     }
     return siteProperties.toString();
@@ -276,7 +276,7 @@ public class AlluxioScheduler implements Scheduler {
     commands.add(String.format("echo 'Starting Alluxio with %s'", command));
     if (installJavaFromUrl()) {
       commands
-          .add("export JAVA_HOME=" + Configuration.get(PropertyKey.INTEGRATION_MESOS_JDK_PATH));
+          .add("export JAVA_HOME=" + ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_JDK_PATH));
       commands.add("export PATH=$PATH:$JAVA_HOME/bin");
     }
 
@@ -292,7 +292,7 @@ public class AlluxioScheduler implements Scheduler {
       commands.add("mv alluxio* alluxio_tmp");
       commands.add("mv alluxio_tmp alluxio");
     }
-    String home = installAlluxioFromUrl() ? "alluxio" : Configuration.get(PropertyKey.HOME);
+    String home = installAlluxioFromUrl() ? "alluxio" : ServerConfiguration.get(PropertyKey.HOME);
     commands
         .add(String.format("cp %s conf", PathUtils.concatPath(home, "conf", "log4j.properties")));
     commands.add(PathUtils.concatPath(home, "integration", "mesos", "bin", command));
@@ -342,11 +342,11 @@ public class AlluxioScheduler implements Scheduler {
         .setType(Protos.Value.Type.RANGES)
         .setRanges(Protos.Value.Ranges.newBuilder()
             .addRange(Protos.Value.Range.newBuilder()
-                .setBegin(Configuration.getLong(PropertyKey.MASTER_WEB_PORT))
-                .setEnd(Configuration.getLong(PropertyKey.MASTER_WEB_PORT)))
+                .setBegin(ServerConfiguration.getLong(PropertyKey.MASTER_WEB_PORT))
+                .setEnd(ServerConfiguration.getLong(PropertyKey.MASTER_WEB_PORT)))
             .addRange((Protos.Value.Range.newBuilder()
-                .setBegin(Configuration.getLong(PropertyKey.MASTER_RPC_PORT))
-                .setEnd(Configuration.getLong(PropertyKey.MASTER_RPC_PORT))))).build());
+                .setBegin(ServerConfiguration.getLong(PropertyKey.MASTER_RPC_PORT))
+                .setEnd(ServerConfiguration.getLong(PropertyKey.MASTER_RPC_PORT))))).build());
     return resources;
   }
 
@@ -359,11 +359,11 @@ public class AlluxioScheduler implements Scheduler {
         .setType(Protos.Value.Type.RANGES)
         .setRanges(Protos.Value.Ranges.newBuilder()
             .addRange(Protos.Value.Range.newBuilder()
-                .setBegin(Configuration.getLong(PropertyKey.WORKER_RPC_PORT))
-                .setEnd(Configuration.getLong(PropertyKey.WORKER_RPC_PORT)))
+                .setBegin(ServerConfiguration.getLong(PropertyKey.WORKER_RPC_PORT))
+                .setEnd(ServerConfiguration.getLong(PropertyKey.WORKER_RPC_PORT)))
             .addRange((Protos.Value.Range.newBuilder()
-                .setBegin(Configuration.getLong(PropertyKey.WORKER_WEB_PORT))
-                .setEnd(Configuration.getLong(PropertyKey.WORKER_WEB_PORT))))).build());
+                .setBegin(ServerConfiguration.getLong(PropertyKey.WORKER_WEB_PORT))
+                .setEnd(ServerConfiguration.getLong(PropertyKey.WORKER_WEB_PORT))))).build());
     return resources;
   }
 
@@ -404,25 +404,25 @@ public class AlluxioScheduler implements Scheduler {
     List<URI> dependencies = new ArrayList<>();
     if (installJavaFromUrl()) {
       dependencies.add(CommandInfo.URI.newBuilder()
-          .setValue(Configuration.get(PropertyKey.INTEGRATION_MESOS_JDK_URL)).setExtract(true)
+          .setValue(ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_JDK_URL)).setExtract(true)
           .build());
     }
     if (installAlluxioFromUrl()) {
       dependencies.add(CommandInfo.URI.newBuilder()
-          .setValue(Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL))
+          .setValue(ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL))
           .setExtract(true).build());
     }
     return dependencies;
   }
 
   private static boolean installJavaFromUrl() {
-    return Configuration.isSet(PropertyKey.INTEGRATION_MESOS_JDK_URL) && !Configuration
+    return ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_JDK_URL) && !ServerConfiguration
         .get(PropertyKey.INTEGRATION_MESOS_JDK_URL).equalsIgnoreCase(Constants.MESOS_LOCAL_INSTALL);
   }
 
   private static boolean installAlluxioFromUrl() {
-    return Configuration.isSet(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL)
-        && !Configuration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL)
+    return ServerConfiguration.isSet(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL)
+        && !ServerConfiguration.get(PropertyKey.INTEGRATION_MESOS_ALLUXIO_JAR_URL)
             .equalsIgnoreCase(Constants.MESOS_LOCAL_INSTALL);
   }
 }
diff --git a/integration/mesos/src/main/java/alluxio/mesos/AlluxioWorkerExecutor.java b/integration/mesos/src/main/java/alluxio/mesos/AlluxioWorkerExecutor.java
index 6ba88859ca..841a065079 100644
--- a/integration/mesos/src/main/java/alluxio/mesos/AlluxioWorkerExecutor.java
+++ b/integration/mesos/src/main/java/alluxio/mesos/AlluxioWorkerExecutor.java
@@ -12,6 +12,7 @@
 package alluxio.mesos;
 
 import alluxio.cli.Format;
+import alluxio.conf.ServerConfiguration;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 import alluxio.worker.AlluxioWorker;
 
@@ -74,7 +75,7 @@ public class AlluxioWorkerExecutor implements Executor {
           Thread.currentThread().setContextClassLoader(
               UnderFileSystemFactoryRegistry.class.getClassLoader());
 
-          Format.format(Format.Mode.WORKER);
+          Format.format(Format.Mode.WORKER, ServerConfiguration.global());
           AlluxioWorker.main(new String[] {});
 
           status =
diff --git a/integration/mesos/src/main/java/alluxio/mesos/OfferUtils.java b/integration/mesos/src/main/java/alluxio/mesos/OfferUtils.java
index 4d76f54a83..ccf2a8be52 100644
--- a/integration/mesos/src/main/java/alluxio/mesos/OfferUtils.java
+++ b/integration/mesos/src/main/java/alluxio/mesos/OfferUtils.java
@@ -11,9 +11,9 @@
 
 package alluxio.mesos;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import org.apache.mesos.Protos;
 import org.slf4j.Logger;
@@ -35,8 +35,8 @@ public final class OfferUtils {
     Protos.Value.Ranges ranges = getOfferedPorts(offer);
 
     return ranges != null
-        && hasAvailablePorts(Configuration.getInt(PropertyKey.MASTER_WEB_PORT), ranges)
-        && hasAvailablePorts(Configuration.getInt(PropertyKey.MASTER_RPC_PORT), ranges);
+        && hasAvailablePorts(ServerConfiguration.getInt(PropertyKey.MASTER_WEB_PORT), ranges)
+        && hasAvailablePorts(ServerConfiguration.getInt(PropertyKey.MASTER_RPC_PORT), ranges);
   }
 
   /**
@@ -47,8 +47,8 @@ public final class OfferUtils {
     Protos.Value.Ranges ranges = getOfferedPorts(offer);
 
     return ranges != null
-        && hasAvailablePorts(Configuration.getInt(PropertyKey.WORKER_WEB_PORT), ranges)
-        && hasAvailablePorts(Configuration.getInt(PropertyKey.WORKER_RPC_PORT), ranges);
+        && hasAvailablePorts(ServerConfiguration.getInt(PropertyKey.WORKER_WEB_PORT), ranges)
+        && hasAvailablePorts(ServerConfiguration.getInt(PropertyKey.WORKER_RPC_PORT), ranges);
   }
 
   private static boolean hasAvailablePorts(int port, Protos.Value.Ranges ranges) {
diff --git a/integration/yarn/src/main/java/alluxio/yarn/ApplicationMaster.java b/integration/yarn/src/main/java/alluxio/yarn/ApplicationMaster.java
index 4d1d0a46e2..585426545f 100644
--- a/integration/yarn/src/main/java/alluxio/yarn/ApplicationMaster.java
+++ b/integration/yarn/src/main/java/alluxio/yarn/ApplicationMaster.java
@@ -11,9 +11,11 @@
 
 package alluxio.yarn;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.FormatUtils;
 import alluxio.util.io.PathUtils;
 import alluxio.util.network.NetworkAddressUtils;
@@ -106,6 +108,8 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
   /** Network address of the container allocated for Alluxio master. */
   private String mMasterContainerNetAddress;
 
+  private final AlluxioConfiguration mAlluxioConf;
+
   private volatile ContainerAllocator mContainerAllocator;
 
   /**
@@ -131,7 +135,8 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
    * @param masterAddress the address at which to start the Alluxio master
    * @param resourcePath an hdfs path shared by all yarn nodes which can be used to share resources
    */
-  public ApplicationMaster(int numWorkers, String masterAddress, String resourcePath) {
+  public ApplicationMaster(int numWorkers, String masterAddress, String resourcePath,
+      AlluxioConfiguration alluxioConf) {
     this(numWorkers, masterAddress, resourcePath, YarnClient.createYarnClient(),
         NMClient.createNMClient(), new AMRMClientAsyncFactory() {
           @Override
@@ -139,7 +144,7 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
               CallbackHandler handler) {
             return AMRMClientAsync.createAMRMClientAsync(heartbeatMs, handler);
           }
-        });
+        }, alluxioConf);
   }
 
   /**
@@ -155,24 +160,26 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
    * @param amrmFactory a factory for creating an {@link AMRMClientAsync}
    */
   public ApplicationMaster(int numWorkers, String masterAddress, String resourcePath,
-      YarnClient yarnClient, NMClient nMClient, AMRMClientAsyncFactory amrmFactory) {
-    mMasterCpu = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
+      YarnClient yarnClient, NMClient nMClient, AMRMClientAsyncFactory amrmFactory,
+      AlluxioConfiguration alluxioConf) {
+    mMasterCpu = alluxioConf.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
     mMasterMemInMB =
-        (int) (Configuration.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB);
-    mWorkerCpu = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
+        (int) (alluxioConf.getBytes(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB);
+    mWorkerCpu = alluxioConf.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
     // TODO(binfan): request worker container and ramdisk container separately
     // memory for running worker
     mWorkerMemInMB =
-        (int) (Configuration.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB);
+        (int) (alluxioConf.getBytes(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB);
     // memory for running ramdisk
-    mRamdiskMemInMB = (int) (Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB);
-    mMaxWorkersPerHost = Configuration.getInt(PropertyKey.INTEGRATION_YARN_WORKERS_PER_HOST_MAX);
+    mRamdiskMemInMB = (int) (alluxioConf.getBytes(PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB);
+    mMaxWorkersPerHost = alluxioConf.getInt(PropertyKey.INTEGRATION_YARN_WORKERS_PER_HOST_MAX);
     mNumWorkers = numWorkers;
     mMasterAddress = masterAddress;
     mResourcePath = resourcePath;
     mApplicationDoneLatch = new CountDownLatch(1);
     mYarnClient = yarnClient;
     mNMClient = nMClient;
+    mAlluxioConf = alluxioConf;
     // Heartbeat to the resource manager every 500ms.
     mRMClient = amrmFactory.createAMRMClientAsync(500, this);
   }
@@ -190,7 +197,7 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
     try {
       LOG.info("Starting Application Master with args {}", Arrays.toString(args));
       final CommandLine cliParser = new GnuParser().parse(options, args);
-
+      AlluxioConfiguration alluxioConf = new InstancedConfiguration(ConfigurationUtils.defaults());
       YarnConfiguration conf = new YarnConfiguration();
       UserGroupInformation.setConfiguration(conf);
       if (UserGroupInformation.isSecurityEnabled()) {
@@ -203,12 +210,12 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
         ugi.doAs(new PrivilegedExceptionAction<Void>() {
           @Override
           public Void run() throws Exception {
-            runApplicationMaster(cliParser);
+            runApplicationMaster(cliParser, alluxioConf);
             return null;
           }
         });
       } else {
-        runApplicationMaster(cliParser);
+        runApplicationMaster(cliParser, alluxioConf);
       }
     } catch (Exception e) {
       LOG.error("Error running Application Master", e);
@@ -221,13 +228,14 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
    *
    * @param cliParser client arguments parser
    */
-  private static void runApplicationMaster(final CommandLine cliParser) throws Exception {
+  private static void runApplicationMaster(final CommandLine cliParser,
+      AlluxioConfiguration alluxioConf) throws Exception {
     int numWorkers = Integer.parseInt(cliParser.getOptionValue("num_workers", "1"));
     String masterAddress = cliParser.getOptionValue("master_address");
     String resourcePath = cliParser.getOptionValue("resource_path");
 
     ApplicationMaster applicationMaster =
-        new ApplicationMaster(numWorkers, masterAddress, resourcePath);
+        new ApplicationMaster(numWorkers, masterAddress, resourcePath, alluxioConf);
     applicationMaster.start();
     applicationMaster.requestAndLaunchContainers();
     applicationMaster.waitForShutdown();
@@ -302,7 +310,8 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
     mYarnClient.start();
 
     // Register with ResourceManager
-    String hostname = NetworkAddressUtils.getLocalHostName();
+    String hostname =
+        NetworkAddressUtils.getLocalHostName((int)mAlluxioConf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));
     mRMClient.registerApplicationMaster(hostname, 0 /* port */, "" /* tracking url */);
     LOG.info("ApplicationMaster registered");
   }
@@ -412,7 +421,7 @@ public final class ApplicationMaster implements AMRMClientAsync.CallbackHandler
    */
   private boolean masterExists() {
 
-    String webPort = Configuration.get(PropertyKey.MASTER_WEB_PORT);
+    String webPort = mAlluxioConf.get(PropertyKey.MASTER_WEB_PORT);
 
     try {
       URL myURL = new URL("http://" + mMasterAddress + ":" + webPort + Constants.REST_API_PREFIX + "/master/version");
diff --git a/integration/yarn/src/main/java/alluxio/yarn/Client.java b/integration/yarn/src/main/java/alluxio/yarn/Client.java
index a70dfa1767..6852a42a95 100644
--- a/integration/yarn/src/main/java/alluxio/yarn/Client.java
+++ b/integration/yarn/src/main/java/alluxio/yarn/Client.java
@@ -11,11 +11,13 @@
 
 package alluxio.yarn;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.PathUtils;
 import alluxio.yarn.YarnUtils.YarnContainerType;
 
@@ -122,10 +124,13 @@ public final class Client {
   /** Command line options. */
   private Options mOptions;
 
+  private final AlluxioConfiguration mAlluxioConf;
+
   /**
    * Constructs a new client for launching an Alluxio application master.
    */
-  public Client() {
+  public Client(AlluxioConfiguration alluxioConf) {
+    mAlluxioConf = alluxioConf;
     mOptions = new Options();
     mOptions.addOption("appname", true, "Application Name. Default 'Alluxio'");
     mOptions.addOption("priority", true, "Application Priority. Default 0");
@@ -151,8 +156,8 @@ public final class Client {
    * @param args Command line arguments
    * @throws ParseException if an error occurs when parsing the argument
    */
-  public Client(String[] args) throws ParseException {
-    this();
+  public Client(String[] args, AlluxioConfiguration alluxioConf) throws ParseException {
+    this(alluxioConf);
     parseArgs(args);
   }
 
@@ -161,7 +166,9 @@ public final class Client {
    */
   public static void main(String[] args) {
     try {
-      Client client = new Client();
+
+      AlluxioConfiguration alluxioConf = new InstancedConfiguration(ConfigurationUtils.defaults());
+      Client client = new Client(alluxioConf);
       System.out.println("Initializing Client");
       if (!client.parseArgs(args)) {
         System.out.println("Cannot parse commandline: " + Arrays.toString(args));
@@ -219,7 +226,7 @@ public final class Client {
     mAmVCores = Integer.parseInt(cliParser.getOptionValue("am_vcores", "1"));
     mNumWorkers = Integer.parseInt(cliParser.getOptionValue("num_workers", "1"));
     mMaxWorkersPerHost =
-        Configuration.getInt(PropertyKey.INTEGRATION_YARN_WORKERS_PER_HOST_MAX);
+        mAlluxioConf.getInt(PropertyKey.INTEGRATION_YARN_WORKERS_PER_HOST_MAX);
 
     Preconditions.checkArgument(mAmMemoryInMB > 0,
         "Invalid memory specified for application master, " + "exiting. Specified memory="
@@ -286,22 +293,22 @@ public final class Client {
           .getMessage("ApplicationMaster", "virtual cores", mAmVCores, maxVCores));
     }
 
-    int masterMemInMB = (int) (Configuration.getBytes(
+    int masterMemInMB = (int) (mAlluxioConf.getBytes(
         PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB);
     if (masterMemInMB > maxMem) {
       throw new RuntimeException(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES
           .getMessage("Alluxio Master", "memory", masterMemInMB, maxMem));
     }
 
-    int masterVCores = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
+    int masterVCores = mAlluxioConf.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
     if (masterVCores > maxVCores) {
       throw new RuntimeException(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES
           .getMessage("Alluxio Master", "virtual cores", masterVCores, maxVCores));
     }
 
-    int workerMemInMB = (int) (Configuration.getBytes(
+    int workerMemInMB = (int) (mAlluxioConf.getBytes(
         PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB);
-    int ramdiskMemInMB = (int) (Configuration.getBytes(
+    int ramdiskMemInMB = (int) (mAlluxioConf.getBytes(
         PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB);
 
     if ((workerMemInMB + ramdiskMemInMB) > maxMem) {
@@ -309,7 +316,7 @@ public final class Client {
           .getMessage("Alluxio Worker", "memory", (workerMemInMB + ramdiskMemInMB), maxMem));
     }
 
-    int workerVCore = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
+    int workerVCore = mAlluxioConf.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
     if (workerVCore > maxVCores) {
       throw new RuntimeException(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES
           .getMessage("Alluxio Worker", "virtual cores", workerVCore, maxVCores));
diff --git a/integration/yarn/src/test/java/alluxio/yarn/ClientTest.java b/integration/yarn/src/test/java/alluxio/yarn/ClientTest.java
index 049e0402fc..1c416f0a97 100644
--- a/integration/yarn/src/test/java/alluxio/yarn/ClientTest.java
+++ b/integration/yarn/src/test/java/alluxio/yarn/ClientTest.java
@@ -14,10 +14,10 @@ package alluxio.yarn;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.doReturn;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 
 import org.apache.hadoop.yarn.api.protocolrecords.GetNewApplicationResponse;
@@ -44,6 +44,7 @@ import org.powermock.modules.junit4.PowerMockRunner;
 public final class ClientTest {
 
   private YarnClient mYarnClient;
+  private InstancedConfiguration mConf = ConfigurationTestUtils.defaults();
 
   @Rule
   public ExpectedException mThrown = ExpectedException.none();
@@ -58,7 +59,7 @@ public final class ClientTest {
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    mConf = ConfigurationTestUtils.defaults();
   }
 
   @Test
@@ -74,7 +75,7 @@ public final class ClientTest {
         "-am_memory", Integer.toString(appMasterMem),
         "-am_vcores", "2"
     };
-    Client client = new Client(args);
+    Client client = new Client(args, mConf);
     client.run();
   }
 
@@ -92,75 +93,75 @@ public final class ClientTest {
         "-am_memory", Integer.toString(appMasterMem),
         "-am_vcores", Integer.toString(appMasterCore)
     };
-    Client client = new Client(args);
+    Client client = new Client(args, mConf);
     client.run();
   }
 
   @Test
   public void notEnoughMemoryForAlluxioMaster() throws Exception {
-    Configuration.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM, "2048.00MB");
-    Configuration.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU, "4");
-    int masterMemInMB = (int) (Configuration.getBytes(
+    mConf.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM, "2048.00MB");
+    mConf.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU, "4");
+    int masterMemInMB = (int) (mConf.getBytes(
         PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB);
     Resource resource = Resource.newInstance(masterMemInMB / 2, 4);
     generateMaxAllocation(resource);
     mThrown.expect(RuntimeException.class);
     mThrown.expectMessage(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES.getMessage(
         "Alluxio Master", "memory", masterMemInMB, resource.getMemory()));
-    Client client = new Client();
+    Client client = new Client(mConf);
     client.run();
   }
 
   @Test
   public void notEnoughVCoreForAlluxioMaster() throws Exception {
-    Configuration.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM, "2048.00MB");
-    Configuration.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU, "4");
-    int masterMemInMB = (int) (Configuration.getBytes(
+    mConf.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM, "2048.00MB");
+    mConf.set(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU, "4");
+    int masterMemInMB = (int) (mConf.getBytes(
         PropertyKey.INTEGRATION_MASTER_RESOURCE_MEM) / Constants.MB);
-    int masterVCores = Configuration.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
+    int masterVCores = mConf.getInt(PropertyKey.INTEGRATION_MASTER_RESOURCE_CPU);
     Resource resource = Resource.newInstance(masterMemInMB, 3);
     generateMaxAllocation(resource);
     mThrown.expect(RuntimeException.class);
     mThrown.expectMessage(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES.getMessage(
         "Alluxio Master", "virtual cores", masterVCores, resource.getVirtualCores()));
-    Client client = new Client();
+    Client client = new Client(mConf);
     client.run();
   }
 
   @Test
   public void notEnoughMemoryForAlluxioWorker() throws Exception {
-    Configuration.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM, "2048.00MB");
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "4096.00MB");
-    Configuration.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU, "8");
-    int workerMemInMB = (int) (Configuration.getBytes(
+    mConf.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM, "2048.00MB");
+    mConf.set(PropertyKey.WORKER_MEMORY_SIZE, "4096.00MB");
+    mConf.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU, "8");
+    int workerMemInMB = (int) (mConf.getBytes(
         PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB);
-    int ramdiskMemInMB = (int) (Configuration.getBytes(
+    int ramdiskMemInMB = (int) (mConf.getBytes(
         PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB);
     Resource resource = Resource.newInstance((workerMemInMB + ramdiskMemInMB) / 2, 4);
     generateMaxAllocation(resource);
     mThrown.expect(RuntimeException.class);
     mThrown.expectMessage(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES.getMessage(
         "Alluxio Worker", "memory", (workerMemInMB + ramdiskMemInMB), resource.getMemory()));
-    Client client = new Client();
+    Client client = new Client(mConf);
     client.run();
   }
 
   @Test
   public void notEnoughVCoreForAlluxioWorker() throws Exception {
-    Configuration.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM, "2048.00MB");
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "4096.00MB");
-    Configuration.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU, "8");
-    int workerMemInMB = (int) (Configuration.getBytes(
+    mConf.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM, "2048.00MB");
+    mConf.set(PropertyKey.WORKER_MEMORY_SIZE, "4096.00MB");
+    mConf.set(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU, "8");
+    int workerMemInMB = (int) (mConf.getBytes(
         PropertyKey.INTEGRATION_WORKER_RESOURCE_MEM) / Constants.MB);
-    int ramdiskMemInMB = (int) (Configuration.getBytes(
+    int ramdiskMemInMB = (int) (mConf.getBytes(
         PropertyKey.WORKER_MEMORY_SIZE) / Constants.MB);
-    int workerVCore = Configuration.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
+    int workerVCore = mConf.getInt(PropertyKey.INTEGRATION_WORKER_RESOURCE_CPU);
     Resource resource = Resource.newInstance((workerMemInMB + ramdiskMemInMB), 4);
     generateMaxAllocation(resource);
     mThrown.expect(RuntimeException.class);
     mThrown.expectMessage(ExceptionMessage.YARN_NOT_ENOUGH_RESOURCES.getMessage(
         "Alluxio Worker", "virtual cores", workerVCore, resource.getVirtualCores()));
-    Client client = new Client();
+    Client client = new Client(mConf);
     client.run();
   }
 
diff --git a/job/client/src/main/java/alluxio/client/job/JobContext.java b/job/client/src/main/java/alluxio/client/job/JobContext.java
index cef9f1629b..2394056331 100644
--- a/job/client/src/main/java/alluxio/client/job/JobContext.java
+++ b/job/client/src/main/java/alluxio/client/job/JobContext.java
@@ -11,6 +11,8 @@
 
 package alluxio.client.job;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterInquireClient;
 import alluxio.resource.CloseableResource;
@@ -37,8 +39,6 @@ import javax.annotation.concurrent.ThreadSafe;
  */
 @ThreadSafe
 public final class JobContext implements Closeable  {
-  public static final JobContext INSTANCE = create();
-
   /** The shared master inquire client associated with the {@link JobContext}. */
   @GuardedBy("this")
   private MasterInquireClient mJobMasterInquireClient;
@@ -49,10 +49,9 @@ public final class JobContext implements Closeable  {
    *
    * @return the context
    */
-  @VisibleForTesting
-  static JobContext create() {
+  public static JobContext create(AlluxioConfiguration alluxioConf) {
     JobContext context = new JobContext();
-    context.init();
+    context.init(alluxioConf);
     return context;
   }
 
@@ -64,9 +63,9 @@ public final class JobContext implements Closeable  {
   /**
    * Initializes the context. Only called in the factory methods and reset.
    */
-  private synchronized void init() {
-    mJobMasterInquireClient = MasterInquireClient.Factory.createForJobMaster();
-    mJobMasterClientPool = new JobMasterClientPool();
+  private synchronized void init(AlluxioConfiguration alluxioConf) {
+    mJobMasterInquireClient = MasterInquireClient.Factory.createForJobMaster(alluxioConf);
+    mJobMasterClientPool = new JobMasterClientPool(alluxioConf);
   }
 
   /**
diff --git a/job/client/src/main/java/alluxio/client/job/JobGrpcClientUtils.java b/job/client/src/main/java/alluxio/client/job/JobGrpcClientUtils.java
index 8bc1c5dabe..acbd366e61 100644
--- a/job/client/src/main/java/alluxio/client/job/JobGrpcClientUtils.java
+++ b/job/client/src/main/java/alluxio/client/job/JobGrpcClientUtils.java
@@ -12,6 +12,7 @@
 package alluxio.client.job;
 
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.job.JobConfig;
 import alluxio.job.wire.JobInfo;
 import alluxio.job.wire.Status;
@@ -45,19 +46,19 @@ public final class JobGrpcClientUtils {
    * @param config configuration for the job to run
    * @param attempts number of times to try running the job before giving up
    */
-  public static void run(JobConfig config, int attempts) throws InterruptedException {
+  public static void run(JobConfig config, int attempts, AlluxioConfiguration alluxioConf) throws InterruptedException {
     CountingRetry retryPolicy = new CountingRetry(attempts);
     while (retryPolicy.attempt()) {
       long jobId;
       try (JobMasterClient client =
-          JobMasterClient.Factory.create(JobMasterClientConfig.defaults())) {
+          JobMasterClient.Factory.create(JobMasterClientConfig.defaults(alluxioConf), alluxioConf)) {
         jobId = client.run(config);
       } catch (Exception e) {
         // job could not be started, retry
         LOG.warn("Exception encountered when starting a job.", e);
         continue;
       }
-      JobInfo jobInfo = waitFor(jobId);
+      JobInfo jobInfo = waitFor(jobId, alluxioConf);
       if (jobInfo == null) {
         // job status could not be fetched, give up
         break;
@@ -111,10 +112,10 @@ public final class JobGrpcClientUtils {
    * @param jobId the ID of the job to wait for
    * @return the job info for the job once it finishes or null if the job status cannot be fetched
    */
-  private static JobInfo waitFor(final long jobId) throws InterruptedException {
+  private static JobInfo waitFor(final long jobId, AlluxioConfiguration alluxioConf) throws InterruptedException {
     final AtomicReference<JobInfo> finishedJobInfo = new AtomicReference<>();
     try (final JobMasterClient client =
-        JobMasterClient.Factory.create(JobMasterClientConfig.defaults())) {
+        JobMasterClient.Factory.create(JobMasterClientConfig.defaults(alluxioConf), alluxioConf)) {
       CommonUtils.waitFor("Job to finish", ()-> {
         JobInfo jobInfo;
         try {
diff --git a/job/client/src/main/java/alluxio/client/job/JobMasterClient.java b/job/client/src/main/java/alluxio/client/job/JobMasterClient.java
index ca70c4cef6..6df5bbcbab 100644
--- a/job/client/src/main/java/alluxio/client/job/JobMasterClient.java
+++ b/job/client/src/main/java/alluxio/client/job/JobMasterClient.java
@@ -12,6 +12,7 @@
 package alluxio.client.job;
 
 import alluxio.Client;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.job.JobConfig;
 import alluxio.job.wire.JobInfo;
 import alluxio.worker.job.JobMasterClientConfig;
@@ -37,8 +38,9 @@ public interface JobMasterClient extends Client {
      * @param conf job master client configuration
      * @return a new {@link JobMasterClient} instance
      */
-    public static JobMasterClient create(JobMasterClientConfig conf) {
-      return new RetryHandlingJobMasterClient(conf);
+    public static JobMasterClient create(JobMasterClientConfig conf,
+        AlluxioConfiguration alluxioConf) {
+      return new RetryHandlingJobMasterClient(conf, alluxioConf);
     }
   }
 
diff --git a/job/client/src/main/java/alluxio/client/job/JobMasterClientPool.java b/job/client/src/main/java/alluxio/client/job/JobMasterClientPool.java
index 1b11cc8578..f54e6c55dc 100644
--- a/job/client/src/main/java/alluxio/client/job/JobMasterClientPool.java
+++ b/job/client/src/main/java/alluxio/client/job/JobMasterClientPool.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.job;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.resource.ResourcePool;
 import alluxio.worker.job.JobMasterClientConfig;
 
@@ -30,13 +30,15 @@ import javax.annotation.concurrent.ThreadSafe;
 @ThreadSafe
 public final class JobMasterClientPool extends ResourcePool<JobMasterClient> {
   private final Queue<JobMasterClient> mClientList;
+  private final AlluxioConfiguration mAlluxioConf;
 
   /**
    * Creates a new job master client pool.
    */
-  public JobMasterClientPool() {
-    super(Configuration.getInt(PropertyKey.JOB_MASTER_CLIENT_THREADS));
+  public JobMasterClientPool(AlluxioConfiguration alluxioConf) {
+    super(alluxioConf.getInt(PropertyKey.JOB_MASTER_CLIENT_THREADS));
     mClientList = new ConcurrentLinkedQueue<>();
+    mAlluxioConf = alluxioConf;
   }
 
   @Override
@@ -49,7 +51,8 @@ public final class JobMasterClientPool extends ResourcePool<JobMasterClient> {
 
   @Override
   protected JobMasterClient createNewResource() {
-    JobMasterClient client = JobMasterClient.Factory.create(JobMasterClientConfig.defaults());
+    JobMasterClient client = JobMasterClient.Factory.create(JobMasterClientConfig.defaults(
+        mAlluxioConf), mAlluxioConf);
     mClientList.add(client);
     return client;
   }
diff --git a/job/client/src/main/java/alluxio/client/job/RetryHandlingJobMasterClient.java b/job/client/src/main/java/alluxio/client/job/RetryHandlingJobMasterClient.java
index 0a0d3878c8..72f551c643 100644
--- a/job/client/src/main/java/alluxio/client/job/RetryHandlingJobMasterClient.java
+++ b/job/client/src/main/java/alluxio/client/job/RetryHandlingJobMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.client.job;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.CancelPRequest;
 import alluxio.grpc.GetJobStatusPRequest;
 import alluxio.grpc.JobMasterClientServiceGrpc;
@@ -30,6 +31,7 @@ import io.grpc.StatusRuntimeException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.List;
+import java.util.function.Consumer;
 
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -47,8 +49,9 @@ public final class RetryHandlingJobMasterClient extends AbstractMasterClient
    *
    * @param conf master client configuration
    */
-  public RetryHandlingJobMasterClient(JobMasterClientConfig conf) {
-    super(conf);
+  public RetryHandlingJobMasterClient(JobMasterClientConfig conf,
+      AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
@@ -67,7 +70,7 @@ public final class RetryHandlingJobMasterClient extends AbstractMasterClient
   }
 
   @Override
-  protected void beforeConnect() throws IOException {
+  protected void beforeConnect(Consumer<AlluxioConfiguration> configurationUpdateCallback) throws IOException {
     // Job master client does not load cluster-default configuration because only the master
     // will use this client
   }
diff --git a/job/client/src/main/java/alluxio/worker/job/JobMasterClient.java b/job/client/src/main/java/alluxio/worker/job/JobMasterClient.java
index b89277aae5..f4e544b1d7 100644
--- a/job/client/src/main/java/alluxio/worker/job/JobMasterClient.java
+++ b/job/client/src/main/java/alluxio/worker/job/JobMasterClient.java
@@ -12,6 +12,7 @@
 package alluxio.worker.job;
 
 import alluxio.Client;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ConnectionFailedException;
 import alluxio.grpc.JobCommand;
@@ -39,8 +40,9 @@ public interface JobMasterClient extends Client {
      * @param conf job master client configuration
      * @return a new {@link JobMasterClient} instance
      */
-    public static JobMasterClient create(JobMasterClientConfig conf) {
-      return new RetryHandlingJobMasterClient(conf);
+    public static JobMasterClient create(JobMasterClientConfig conf,
+        AlluxioConfiguration alluxioConf) {
+      return new RetryHandlingJobMasterClient(conf, alluxioConf);
     }
   }
 
diff --git a/job/client/src/main/java/alluxio/worker/job/JobMasterClientConfig.java b/job/client/src/main/java/alluxio/worker/job/JobMasterClientConfig.java
index c08b063e8d..5cbe064a4c 100644
--- a/job/client/src/main/java/alluxio/worker/job/JobMasterClientConfig.java
+++ b/job/client/src/main/java/alluxio/worker/job/JobMasterClientConfig.java
@@ -11,6 +11,7 @@
 
 package alluxio.worker.job;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.master.MasterClientConfig;
 import alluxio.master.MasterInquireClient.Factory;
 
@@ -22,9 +23,9 @@ public class JobMasterClientConfig extends MasterClientConfig {
   /**
    * @return a master client configuration with default values
    */
-  public static JobMasterClientConfig defaults() {
+  public static JobMasterClientConfig defaults(AlluxioConfiguration alluxioConf) {
     JobMasterClientConfig conf = new JobMasterClientConfig();
-    conf.withMasterInquireClient(Factory.createForJobMaster());
+    conf.withMasterInquireClient(Factory.createForJobMaster(alluxioConf));
     return conf;
   }
 }
diff --git a/job/client/src/main/java/alluxio/worker/job/RetryHandlingJobMasterClient.java b/job/client/src/main/java/alluxio/worker/job/RetryHandlingJobMasterClient.java
index f0560cfe8b..3abe5f7e2d 100644
--- a/job/client/src/main/java/alluxio/worker/job/RetryHandlingJobMasterClient.java
+++ b/job/client/src/main/java/alluxio/worker/job/RetryHandlingJobMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.worker.job;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.JobCommand;
 import alluxio.grpc.JobHeartbeatPRequest;
 import alluxio.grpc.JobMasterWorkerServiceGrpc;
@@ -24,6 +25,7 @@ import alluxio.wire.WorkerNetAddress;
 
 import java.io.IOException;
 import java.util.List;
+import java.util.function.Consumer;
 
 import javax.annotation.concurrent.ThreadSafe;
 
@@ -41,8 +43,9 @@ public final class RetryHandlingJobMasterClient extends AbstractMasterClient
    *
    * @param conf job master client configuration
    */
-  public RetryHandlingJobMasterClient(JobMasterClientConfig conf) {
-    super(conf);
+  public RetryHandlingJobMasterClient(JobMasterClientConfig conf,
+      AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
@@ -61,7 +64,7 @@ public final class RetryHandlingJobMasterClient extends AbstractMasterClient
   }
 
   @Override
-  protected void beforeConnect() throws IOException {
+  protected void beforeConnect(Consumer<AlluxioConfiguration> configurationUpdateCallback) throws IOException {
     // Job master client does not load cluster-default because job worker has loaded it on start
   }
 
diff --git a/job/client/src/test/java/alluxio/client/job/JobContextTest.java b/job/client/src/test/java/alluxio/client/job/JobContextTest.java
index d514fbf487..ef35781a66 100644
--- a/job/client/src/test/java/alluxio/client/job/JobContextTest.java
+++ b/job/client/src/test/java/alluxio/client/job/JobContextTest.java
@@ -14,7 +14,10 @@ package alluxio.client.job;
 import static org.junit.Assert.assertEquals;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.collect.ImmutableMap;
 import org.junit.Rule;
@@ -24,15 +27,17 @@ import org.junit.Test;
  * Unit tests for {@link JobContext}.
  */
 public final class JobContextTest {
+  private static final InstancedConfiguration sConfiguration = ConfigurationTestUtils.defaults();
+
   @Rule
   public ConfigurationRule mConf = new ConfigurationRule(ImmutableMap.of(
       PropertyKey.MASTER_HOSTNAME, "host1",
       PropertyKey.JOB_MASTER_HOSTNAME, "host2"
-  ));
+  ), sConfiguration);
 
   @Test
   public void getAddress() throws Exception {
-    try (JobContext context = JobContext.create()) {
+    try (JobContext context = JobContext.create(sConfiguration)) {
       assertEquals("host2", context.getJobMasterAddress().getHostName());
     }
   }
diff --git a/job/server/src/main/java/alluxio/job/load/LoadDefinition.java b/job/server/src/main/java/alluxio/job/load/LoadDefinition.java
index 580bd6ffa7..974bdf7e2e 100644
--- a/job/server/src/main/java/alluxio/job/load/LoadDefinition.java
+++ b/job/server/src/main/java/alluxio/job/load/LoadDefinition.java
@@ -12,12 +12,14 @@
 package alluxio.job.load;
 
 import alluxio.AlluxioURI;
+import alluxio.ClientContext;
 import alluxio.Constants;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.BaseFileSystem;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.status.FailedPreconditionException;
 import alluxio.job.AbstractVoidJobDefinition;
 import alluxio.job.JobMasterContext;
@@ -59,7 +61,7 @@ public final class LoadDefinition
    * Constructs a new {@link LoadDefinition}.
    */
   public LoadDefinition() {
-    mFileSystem = BaseFileSystem.get(FileSystemContext.get());
+    mFileSystem = BaseFileSystem.create(ClientContext.create(null, ServerConfiguration.copyProperties()));
   }
 
   /**
@@ -79,7 +81,8 @@ public final class LoadDefinition
     // Filter out workers which have no local job worker available.
     List<String> missingJobWorkerHosts = new ArrayList<>();
     List<BlockWorkerInfo> workers = new ArrayList<>();
-    for (BlockWorkerInfo worker : AlluxioBlockStore.create().getAllWorkers()) {
+    for (BlockWorkerInfo worker :
+        AlluxioBlockStore.create(null, ServerConfiguration.global()).getAllWorkers()) {
       if (jobWorkersByAddress.containsKey(worker.getNetAddress().getHost())) {
         workers.add(worker);
       } else {
@@ -135,7 +138,7 @@ public final class LoadDefinition
       JobWorkerContext jobWorkerContext) throws Exception {
     for (LoadTask task : tasks) {
       JobUtils
-          .loadBlock(mFileSystem, FileSystemContext.get(), config.getFilePath(), task.getBlockId());
+          .loadBlock(mFileSystem, FileSystemContext.create(), config.getFilePath(), task.getBlockId());
       LOG.info("Loaded block " + task.getBlockId());
     }
     return null;
diff --git a/job/server/src/main/java/alluxio/job/move/MoveDefinition.java b/job/server/src/main/java/alluxio/job/move/MoveDefinition.java
index 067d240c0f..27488ca372 100644
--- a/job/server/src/main/java/alluxio/job/move/MoveDefinition.java
+++ b/job/server/src/main/java/alluxio/job/move/MoveDefinition.java
@@ -12,8 +12,9 @@
 package alluxio.job.move;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.ClientContext;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
@@ -97,8 +98,11 @@ public final class MoveDefinition
    * Constructs a new {@link MoveDefinition}.
    */
   public MoveDefinition() {
-    mFileSystemContext = FileSystemContext.get();
-    mFileSystem = BaseFileSystem.get(FileSystemContext.get());
+    mFileSystemContext = FileSystemContext.create();
+    mFileSystem =
+        BaseFileSystem.create(
+            ClientContext.create(mFileSystemContext.getParentSubject(),
+                ServerConfiguration.copyProperties()));
   }
 
   /**
@@ -166,7 +170,7 @@ public final class MoveDefinition
     checkMoveValid(config);
 
     List<BlockWorkerInfo> alluxioWorkerInfoList =
-        AlluxioBlockStore.create(mFileSystemContext).getAllWorkers();
+        AlluxioBlockStore.create(mFileSystemContext, ServerConfiguration.global()).getAllWorkers();
     Preconditions.checkState(!jobWorkerInfoList.isEmpty(), "No workers are available");
 
     List<URIStatus> allPathStatuses = getPathStatuses(source);
@@ -276,7 +280,7 @@ public final class MoveDefinition
   public SerializableVoid runTask(MoveConfig config, ArrayList<MoveCommand> commands,
       JobWorkerContext jobWorkerContext) throws Exception {
     WriteType writeType = config.getWriteType() == null
-        ? Configuration.getEnum(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class)
+        ? ServerConfiguration.getEnum(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.class)
         : WriteType.valueOf(config.getWriteType());
     for (MoveCommand command : commands) {
       move(command, writeType.toProto(), mFileSystem);
diff --git a/job/server/src/main/java/alluxio/job/persist/PersistDefinition.java b/job/server/src/main/java/alluxio/job/persist/PersistDefinition.java
index 859162a8ea..6782b5089a 100644
--- a/job/server/src/main/java/alluxio/job/persist/PersistDefinition.java
+++ b/job/server/src/main/java/alluxio/job/persist/PersistDefinition.java
@@ -12,6 +12,7 @@
 package alluxio.job.persist;
 
 import alluxio.AlluxioURI;
+import alluxio.ClientContext;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.BaseFileSystem;
@@ -20,6 +21,7 @@ import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
 import alluxio.collections.Pair;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.OpenFilePOptions;
 import alluxio.grpc.ReadPType;
 import alluxio.job.AbstractVoidJobDefinition;
@@ -64,8 +66,9 @@ public final class PersistDefinition
    * Constructs a new {@link PersistDefinition}.
    */
   public PersistDefinition() {
-    mFileSystemContext = FileSystemContext.get();
-    mFileSystem = BaseFileSystem.get(FileSystemContext.get());
+    mFileSystemContext = FileSystemContext.create();
+    mFileSystem = BaseFileSystem.create(ClientContext.create(mFileSystemContext.getParentSubject(),
+        ServerConfiguration.copyProperties()));
   }
 
   /**
@@ -88,7 +91,7 @@ public final class PersistDefinition
 
     AlluxioURI uri = new AlluxioURI(config.getFilePath());
     List<BlockWorkerInfo> alluxioWorkerInfoList =
-        AlluxioBlockStore.create(mFileSystemContext).getAllWorkers();
+        AlluxioBlockStore.create(mFileSystemContext, ServerConfiguration.global()).getAllWorkers();
     BlockWorkerInfo workerWithMostBlocks = JobUtils.getWorkerWithMostBlocks(alluxioWorkerInfoList,
         mFileSystem.getStatus(uri).getFileBlockInfos());
 
@@ -153,7 +156,7 @@ public final class PersistDefinition
         while (!ufs.isDirectory(curUfsPath.toString()) && curAlluxioPath != null) {
           URIStatus curDirStatus = fs.getStatus(curAlluxioPath);
           ufsDirsToMakeWithOptions.push(new Pair<>(curUfsPath.toString(),
-              MkdirsOptions.defaults().setCreateParent(false).setOwner(curDirStatus.getOwner())
+              MkdirsOptions.defaults(ServerConfiguration.global()).setCreateParent(false).setOwner(curDirStatus.getOwner())
                   .setGroup(curDirStatus.getGroup())
                   .setMode(new Mode((short) curDirStatus.getMode()))));
           curAlluxioPath = curAlluxioPath.getParent();
@@ -172,7 +175,8 @@ public final class PersistDefinition
         }
         URIStatus uriStatus = fs.getStatus(uri);
         OutputStream out = closer.register(
-            ufs.create(dstPath.toString(), CreateOptions.defaults().setOwner(uriStatus.getOwner())
+            ufs.create(dstPath.toString(),
+                CreateOptions.defaults(ServerConfiguration.global()).setOwner(uriStatus.getOwner())
                 .setGroup(uriStatus.getGroup()).setMode(new Mode((short) uriStatus.getMode()))));
         bytesWritten = IOUtils.copyLarge(in, out);
         incrementPersistedMetric(ufsClient.getUfsMountPointUri(), bytesWritten);
diff --git a/job/server/src/main/java/alluxio/job/replicate/EvictDefinition.java b/job/server/src/main/java/alluxio/job/replicate/EvictDefinition.java
index ae7087bff9..6b1df1ebb3 100644
--- a/job/server/src/main/java/alluxio/job/replicate/EvictDefinition.java
+++ b/job/server/src/main/java/alluxio/job/replicate/EvictDefinition.java
@@ -11,6 +11,8 @@
 
 package alluxio.job.replicate;
 
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.block.stream.BlockWorkerClient;
@@ -56,7 +58,7 @@ public final class EvictDefinition
    * Constructs a new {@link EvictDefinition}.
    */
   public EvictDefinition() {
-    mFileSystemContext = FileSystemContext.get();
+    mFileSystemContext = FileSystemContext.create();
   }
 
   /**
@@ -81,7 +83,8 @@ public final class EvictDefinition
     long blockId = config.getBlockId();
     int numReplicas = config.getReplicas();
 
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mFileSystemContext);
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mFileSystemContext,
+        ServerConfiguration.global());
     BlockInfo blockInfo = blockStore.getInfo(blockId);
 
     Set<String> hosts = new HashSet<>();
@@ -111,10 +114,12 @@ public final class EvictDefinition
   @Override
   public SerializableVoid runTask(EvictConfig config, SerializableVoid args,
       JobWorkerContext jobWorkerContext) throws Exception {
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create();
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mFileSystemContext,
+        ServerConfiguration.global());
 
     long blockId = config.getBlockId();
-    String localHostName = NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC);
+    String localHostName = NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC,
+        ServerConfiguration.global());
     List<BlockWorkerInfo> workerInfoList = blockStore.getAllWorkers();
     WorkerNetAddress localNetAddress = null;
 
@@ -131,7 +136,7 @@ public final class EvictDefinition
 
     RemoveBlockRequest request = RemoveBlockRequest.newBuilder().setBlockId(blockId).build();
     try (BlockWorkerClient blockWorker =
-             FileSystemContext.get().acquireBlockWorkerClient(localNetAddress)) {
+             FileSystemContext.create().acquireBlockWorkerClient(localNetAddress)) {
       blockWorker.removeBlock(request);
     } catch (NotFoundException e) {
       // Instead of throwing this exception, we continue here because the block to evict does not
diff --git a/job/server/src/main/java/alluxio/job/replicate/ReplicateDefinition.java b/job/server/src/main/java/alluxio/job/replicate/ReplicateDefinition.java
index f42db3a773..dbb8229d31 100644
--- a/job/server/src/main/java/alluxio/job/replicate/ReplicateDefinition.java
+++ b/job/server/src/main/java/alluxio/job/replicate/ReplicateDefinition.java
@@ -14,6 +14,7 @@ package alluxio.job.replicate;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
+import alluxio.conf.ServerConfiguration;
 import alluxio.job.AbstractVoidJobDefinition;
 import alluxio.job.JobMasterContext;
 import alluxio.job.JobWorkerContext;
@@ -52,7 +53,7 @@ public final class ReplicateDefinition
    * Constructs a new {@link ReplicateDefinition} instance.
    */
   public ReplicateDefinition() {
-    this(FileSystemContext.get());
+    this(FileSystemContext.create());
   }
 
   /**
@@ -89,7 +90,8 @@ public final class ReplicateDefinition
     int numReplicas = config.getReplicas();
     Preconditions.checkArgument(numReplicas > 0);
 
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mFileSystemContext);
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mFileSystemContext,
+        ServerConfiguration.global());
     BlockInfo blockInfo = blockStore.getInfo(blockId);
 
     Set<String> hosts = new HashSet<>();
diff --git a/job/server/src/main/java/alluxio/job/util/JobUtils.java b/job/server/src/main/java/alluxio/job/util/JobUtils.java
index 41f3a0d9b8..1c9e731245 100644
--- a/job/server/src/main/java/alluxio/job/util/JobUtils.java
+++ b/job/server/src/main/java/alluxio/job/util/JobUtils.java
@@ -13,6 +13,7 @@ package alluxio.job.util;
 
 import alluxio.AlluxioURI;
 import alluxio.client.Cancelable;
+import alluxio.client.ReadType;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.FileSystem;
@@ -23,6 +24,9 @@ import alluxio.client.file.options.OutStreamOptions;
 import alluxio.client.file.policy.LocalFirstPolicy;
 import alluxio.collections.IndexDefinition;
 import alluxio.collections.IndexedSet;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.NotFoundException;
@@ -103,9 +107,10 @@ public final class JobUtils {
    */
   public static void loadBlock(FileSystem fs, FileSystemContext context, String path, long blockId)
       throws AlluxioException, IOException {
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create(context);
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(context, ServerConfiguration.global());
 
-    String localHostName = NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC);
+    String localHostName = NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC,
+        ServerConfiguration.global());
     List<BlockWorkerInfo> workerInfoList = blockStore.getAllWorkers();
     WorkerNetAddress localNetAddress = null;
 
@@ -130,8 +135,9 @@ public final class JobUtils {
         OpenFilePOptions.newBuilder().setReadType(ReadPType.NO_CACHE)
             .setFileReadLocationPolicy(LocalFirstPolicy.class.getCanonicalName()).build();
 
-    InStreamOptions inOptions = new InStreamOptions(status, openOptions);
-    OutStreamOptions outOptions = OutStreamOptions.defaults();
+    AlluxioConfiguration conf = ServerConfiguration.global();
+    InStreamOptions inOptions = new InStreamOptions(status, openOptions, conf);
+    OutStreamOptions outOptions = OutStreamOptions.defaults(conf);
 
     // use -1 to reuse the existing block size for this block
     try (OutputStream outputStream =
diff --git a/job/server/src/main/java/alluxio/master/AlluxioJobMasterProcess.java b/job/server/src/main/java/alluxio/master/AlluxioJobMasterProcess.java
index 36be262286..6a28e874fd 100644
--- a/job/server/src/main/java/alluxio/master/AlluxioJobMasterProcess.java
+++ b/job/server/src/main/java/alluxio/master/AlluxioJobMasterProcess.java
@@ -11,8 +11,9 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.grpc.GrpcService;
 import alluxio.master.job.JobMaster;
@@ -88,13 +89,15 @@ public class AlluxioJobMasterProcess implements JobMasterProcess {
   private final MetricsServlet mMetricsServlet = new MetricsServlet(MetricsSystem.METRIC_REGISTRY);
 
   AlluxioJobMasterProcess(JournalSystem journalSystem) {
-    if (!Configuration.containsKey(PropertyKey.MASTER_HOSTNAME)) {
-      Configuration.set(PropertyKey.MASTER_HOSTNAME, NetworkAddressUtils.getLocalHostName());
+    if (!ServerConfiguration.isSet(PropertyKey.MASTER_HOSTNAME)) {
+      ServerConfiguration.set(PropertyKey.MASTER_HOSTNAME,
+          NetworkAddressUtils.getLocalHostName(
+              (int)ServerConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)));
     }
     mUfsManager = new JobUfsManager();
     mJournalSystem = Preconditions.checkNotNull(journalSystem, "journalSystem");
-    mMinWorkerThreads = Configuration.getInt(PropertyKey.MASTER_WORKER_THREADS_MIN);
-    mMaxWorkerThreads = Configuration.getInt(PropertyKey.MASTER_WORKER_THREADS_MAX);
+    mMinWorkerThreads = ServerConfiguration.getInt(PropertyKey.MASTER_WORKER_THREADS_MIN);
+    mMaxWorkerThreads = ServerConfiguration.getInt(PropertyKey.MASTER_WORKER_THREADS_MAX);
 
     Preconditions.checkArgument(mMaxWorkerThreads >= mMinWorkerThreads,
         PropertyKey.MASTER_WORKER_THREADS_MAX + " can not be less than "
@@ -106,23 +109,25 @@ public class AlluxioJobMasterProcess implements JobMasterProcess {
       // use (any random free port).
       // In a production or any real deployment setup, port '0' should not be used as it will make
       // deployment more complicated.
-      if (!Configuration.getBoolean(PropertyKey.TEST_MODE)) {
-        Preconditions.checkState(Configuration.getInt(PropertyKey.JOB_MASTER_RPC_PORT) > 0,
+      if (!ServerConfiguration.getBoolean(PropertyKey.TEST_MODE)) {
+        Preconditions.checkState(ServerConfiguration.getInt(PropertyKey.JOB_MASTER_RPC_PORT) > 0,
             "Master rpc port is only allowed to be zero in test mode.");
-        Preconditions.checkState(Configuration.getInt(PropertyKey.JOB_MASTER_WEB_PORT) > 0,
+        Preconditions.checkState(ServerConfiguration.getInt(PropertyKey.JOB_MASTER_WEB_PORT) > 0,
             "Master web port is only allowed to be zero in test mode.");
       }
       InetSocketAddress configuredAddress =
-          NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_RPC);
+          NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_RPC, ServerConfiguration.global());
       if (configuredAddress.getPort() == 0) {
         mBindSocket = new ServerSocket(0);
         mPort = mBindSocket.getLocalPort();
-        Configuration.set(PropertyKey.JOB_MASTER_RPC_PORT, Integer.toString(mPort));
+        ServerConfiguration.set(PropertyKey.JOB_MASTER_RPC_PORT, Integer.toString(mPort));
       } else {
         mPort = configuredAddress.getPort();
       }
-      mRpcBindAddress = NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_RPC);
-      mRpcConnectAddress = NetworkAddressUtils.getConnectAddress(ServiceType.JOB_MASTER_RPC);
+      mRpcBindAddress = NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_RPC,
+          ServerConfiguration.global());
+      mRpcConnectAddress = NetworkAddressUtils.getConnectAddress(ServiceType.JOB_MASTER_RPC,
+          ServerConfiguration.global());
 
       // Create master.
       createMaster();
@@ -238,10 +243,10 @@ public class AlluxioJobMasterProcess implements JobMasterProcess {
             + "bindHost={}, connectHost={}, rpcPort={}, webPort={}",
         RuntimeConstants.VERSION,
         startMessage,
-        NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_RPC),
-        NetworkAddressUtils.getConnectAddress(ServiceType.JOB_MASTER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.JOB_MASTER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.JOB_MASTER_WEB));
+        NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getConnectAddress(ServiceType.JOB_MASTER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.JOB_MASTER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.JOB_MASTER_WEB, ServerConfiguration.global()));
 
     startServingRPCServer();
     LOG.info("Alluxio job master ended");
@@ -249,9 +254,10 @@ public class AlluxioJobMasterProcess implements JobMasterProcess {
 
   protected void startServingWebServer() {
     mWebServer = new JobMasterWebServer(ServiceType.JOB_MASTER_WEB.getServiceName(),
-        NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_WEB), this);
+        NetworkAddressUtils.getBindAddress(ServiceType.JOB_MASTER_WEB, ServerConfiguration.global()),
+        this);
     // reset master web port
-    Configuration.set(PropertyKey.JOB_MASTER_WEB_PORT, Integer.toString(mWebServer.getLocalPort()));
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_WEB_PORT, Integer.toString(mWebServer.getLocalPort()));
     mWebServer.addHandler(mMetricsServlet.getHandler());
     mWebServer.start();
   }
@@ -279,7 +285,8 @@ public class AlluxioJobMasterProcess implements JobMasterProcess {
       }
 
       LOG.info("Starting gRPC server on address {}", mRpcBindAddress);
-      GrpcServerBuilder serverBuilder = GrpcServerBuilder.forAddress(mRpcBindAddress);
+      GrpcServerBuilder serverBuilder = GrpcServerBuilder.forAddress(mRpcBindAddress,
+          ServerConfiguration.global());
       registerServices(serverBuilder, mJobMaster.getServices());
 
       mGrpcServer = serverBuilder.build().start();
diff --git a/job/server/src/main/java/alluxio/master/AlluxioJobMasterRestServiceHandler.java b/job/server/src/main/java/alluxio/master/AlluxioJobMasterRestServiceHandler.java
index 92791c9675..44e8255873 100644
--- a/job/server/src/main/java/alluxio/master/AlluxioJobMasterRestServiceHandler.java
+++ b/job/server/src/main/java/alluxio/master/AlluxioJobMasterRestServiceHandler.java
@@ -11,8 +11,8 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.ConfigurationValueOptions;
 import alluxio.RestUtils;
 import alluxio.RuntimeConstants;
 import alluxio.web.JobMasterWebServer;
@@ -58,7 +58,7 @@ public final class AlluxioJobMasterRestServiceHandler {
   }
 
   /**
-   * @summary get the Alluxio job master information
+   * @summary create the Alluxio job master information
    * @param rawConfiguration if it's true, raw configuration values are returned,
    *    otherwise, they are looked up; if it's not provided in URL queries, then
    *    it is null, which means false.
@@ -82,14 +82,14 @@ public final class AlluxioJobMasterRestServiceHandler {
               .setVersion(RuntimeConstants.VERSION)
               .setWorkers(mJobMaster.getJobMaster().getWorkerInfoList());
       return result;
-    });
+    }, ServerConfiguration.global());
   }
 
   private Map<String, String> getConfigurationInternal(boolean raw) {
     if (raw) {
-      return Configuration.toMap(ConfigurationValueOptions.defaults().useRawValue(raw));
+      return ServerConfiguration.toMap(ConfigurationValueOptions.defaults().useRawValue(raw));
     } else {
-      return Configuration.toMap();
+      return ServerConfiguration.toMap();
     }
   }
 }
diff --git a/job/server/src/main/java/alluxio/master/JobMasterProcess.java b/job/server/src/main/java/alluxio/master/JobMasterProcess.java
index 4cec6b9b77..b3130b08ba 100644
--- a/job/server/src/main/java/alluxio/master/JobMasterProcess.java
+++ b/job/server/src/main/java/alluxio/master/JobMasterProcess.java
@@ -11,10 +11,10 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
 import alluxio.Process;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.master.job.JobMaster;
 import alluxio.master.journal.JournalSystem;
 import alluxio.master.journal.JournalUtils;
@@ -43,7 +43,7 @@ public interface JobMasterProcess extends Process {
       JournalSystem journalSystem = new JournalSystem.Builder()
           .setLocation(URIUtils.appendPathOrDie(journalLocation, Constants.JOB_JOURNAL_NAME))
           .build();
-      if (Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
+      if (ServerConfiguration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
         PrimarySelector primarySelector = PrimarySelector.Factory.createZkJobPrimarySelector();
         return new FaultTolerantAlluxioJobMasterProcess(journalSystem, primarySelector);
       }
diff --git a/job/server/src/main/java/alluxio/master/file/FileSystemMasterClient.java b/job/server/src/main/java/alluxio/master/file/FileSystemMasterClient.java
index 56cfa80800..2b3236aebd 100644
--- a/job/server/src/main/java/alluxio/master/file/FileSystemMasterClient.java
+++ b/job/server/src/main/java/alluxio/master/file/FileSystemMasterClient.java
@@ -13,6 +13,7 @@ package alluxio.master.file;
 
 import alluxio.AbstractMasterClient;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.FileSystemMasterWorkerServiceGrpc;
 import alluxio.grpc.GetFileInfoPRequest;
 import alluxio.grpc.GetUfsInfoPRequest;
@@ -40,8 +41,8 @@ public final class FileSystemMasterClient extends AbstractMasterClient {
    *
    * @param conf master client configuration
    */
-  public FileSystemMasterClient(MasterClientConfig conf) {
-    super(conf);
+  public FileSystemMasterClient(MasterClientConfig conf, AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
@@ -65,7 +66,7 @@ public final class FileSystemMasterClient extends AbstractMasterClient {
   }
 
   /**
-   * @param fileId the id of the file for which to get the {@link FileInfo}
+   * @param fileId the id of the file for which to create the {@link FileInfo}
    * @return the file info for the given file id
    */
   public FileInfo getFileInfo(final long fileId) throws IOException {
diff --git a/job/server/src/main/java/alluxio/master/job/JobCoordinator.java b/job/server/src/main/java/alluxio/master/job/JobCoordinator.java
index c23b5058ad..9a3b03756e 100644
--- a/job/server/src/main/java/alluxio/master/job/JobCoordinator.java
+++ b/job/server/src/main/java/alluxio/master/job/JobCoordinator.java
@@ -101,7 +101,7 @@ public final class JobCoordinator {
   }
 
   private synchronized void start() throws JobDoesNotExistException {
-    // get the job definition
+    // create the job definition
     LOG.info("Starting job {}", mJobInfo.getJobConfig());
     JobDefinition<JobConfig, ?, ?> definition =
         JobDefinitionRegistry.INSTANCE.getJobDefinition(mJobInfo.getJobConfig());
@@ -259,7 +259,7 @@ public final class JobCoordinator {
    * @throws Exception if any error occurs
    */
   private String join(List<TaskInfo> taskInfoList) throws Exception {
-    // get the job definition
+    // create the job definition
     JobDefinition<JobConfig, Serializable, Serializable> definition =
         JobDefinitionRegistry.INSTANCE.getJobDefinition(mJobInfo.getJobConfig());
     Map<WorkerInfo, Serializable> taskResults = Maps.newHashMap();
diff --git a/job/server/src/main/java/alluxio/master/job/JobMaster.java b/job/server/src/main/java/alluxio/master/job/JobMaster.java
index 455ec6c526..f1f7c30811 100644
--- a/job/server/src/main/java/alluxio/master/job/JobMaster.java
+++ b/job/server/src/main/java/alluxio/master/job/JobMaster.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.job;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.clock.SystemClock;
 import alluxio.collections.IndexDefinition;
 import alluxio.collections.IndexedSet;
@@ -71,7 +71,7 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class JobMaster extends AbstractNonJournaledMaster {
   private static final Logger LOG = LoggerFactory.getLogger(JobMaster.class);
   private static final long RETENTION_MS =
-      Configuration.getLong(PropertyKey.JOB_MASTER_FINISHED_JOB_RETENTION_MS);
+      ServerConfiguration.getLong(PropertyKey.JOB_MASTER_FINISHED_JOB_RETENTION_MS);
 
   // Worker metadata management.
   private final IndexDefinition<MasterWorkerInfo, Long> mIdIndex =
@@ -167,7 +167,8 @@ public final class JobMaster extends AbstractNonJournaledMaster {
       getExecutorService()
           .submit(new HeartbeatThread(HeartbeatContext.JOB_MASTER_LOST_WORKER_DETECTION,
               new LostWorkerDetectionHeartbeatExecutor(),
-              Configuration.getInt(PropertyKey.JOB_MASTER_LOST_WORKER_INTERVAL_MS)));
+              ServerConfiguration.getInt(PropertyKey.JOB_MASTER_LOST_WORKER_INTERVAL_MS),
+              ServerConfiguration.global()));
     }
   }
 
@@ -367,7 +368,7 @@ public final class JobMaster extends AbstractNonJournaledMaster {
 
     @Override
     public void heartbeat() {
-      int masterWorkerTimeoutMs = Configuration.getInt(PropertyKey.JOB_MASTER_WORKER_TIMEOUT_MS);
+      int masterWorkerTimeoutMs = ServerConfiguration.getInt(PropertyKey.JOB_MASTER_WORKER_TIMEOUT_MS);
       List<MasterWorkerInfo> lostWorkers = new ArrayList<MasterWorkerInfo>();
       // Run under shared lock for mWorkers
       try (LockResource workersLockShared = new LockResource(mWorkerRWLock.readLock())) {
diff --git a/job/server/src/main/java/alluxio/master/job/JobMasterClientRestServiceHandler.java b/job/server/src/main/java/alluxio/master/job/JobMasterClientRestServiceHandler.java
index 932aba5efa..6cac7e0946 100644
--- a/job/server/src/main/java/alluxio/master/job/JobMasterClientRestServiceHandler.java
+++ b/job/server/src/main/java/alluxio/master/job/JobMasterClientRestServiceHandler.java
@@ -13,6 +13,7 @@ package alluxio.master.job;
 
 import alluxio.Constants;
 import alluxio.RestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.job.JobConfig;
 import alluxio.job.ServiceConstants;
 import alluxio.job.wire.JobInfo;
@@ -66,7 +67,7 @@ public final class JobMasterClientRestServiceHandler {
       public String call() throws Exception {
         return Constants.JOB_MASTER_CLIENT_SERVICE_NAME;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -80,7 +81,7 @@ public final class JobMasterClientRestServiceHandler {
       public Integer call() throws Exception {
         return Constants.JOB_MASTER_CLIENT_SERVICE_VERSION;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -98,7 +99,7 @@ public final class JobMasterClientRestServiceHandler {
         mJobMaster.cancel(jobId);
         return null;
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -116,7 +117,7 @@ public final class JobMasterClientRestServiceHandler {
       public JobInfo call() throws Exception {
         return mJobMaster.getStatus(jobId);
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -132,7 +133,7 @@ public final class JobMasterClientRestServiceHandler {
       public List<Long> call() throws Exception {
         return mJobMaster.list();
       }
-    });
+    }, ServerConfiguration.global());
   }
 
   /**
@@ -150,6 +151,6 @@ public final class JobMasterClientRestServiceHandler {
       public Long call() throws Exception {
         return mJobMaster.run(jobConfig);
       }
-    });
+    }, ServerConfiguration.global());
   }
 }
diff --git a/job/server/src/main/java/alluxio/underfs/JobUfsManager.java b/job/server/src/main/java/alluxio/underfs/JobUfsManager.java
index acf0d3cba1..7cfbf6f436 100644
--- a/job/server/src/main/java/alluxio/underfs/JobUfsManager.java
+++ b/job/server/src/main/java/alluxio/underfs/JobUfsManager.java
@@ -12,6 +12,7 @@
 package alluxio.underfs;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.status.NotFoundException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.UfsInfo;
@@ -42,7 +43,9 @@ public final class JobUfsManager extends AbstractUfsManager {
    * Constructs an instance of {@link JobUfsManager}.
    */
   public JobUfsManager() {
-    mMasterClient = mCloser.register(new FileSystemMasterClient(MasterClientConfig.defaults()));
+    mMasterClient =
+        mCloser.register(new FileSystemMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global()));
   }
 
   @Override
@@ -58,18 +61,19 @@ public final class JobUfsManager extends AbstractUfsManager {
       info = mMasterClient.getUfsInfo(mountId);
     } catch (IOException e) {
       throw new UnavailableException(
-          String.format("Failed to get UFS info for mount point with id %d", mountId), e);
+          String.format("Failed to create UFS info for mount point with id %d", mountId), e);
     }
     Preconditions.checkState((info.hasUri() && info.hasProperties()), "unknown mountId");
     super.addMount(mountId, new AlluxioURI(info.getUri()),
-        UnderFileSystemConfiguration.defaults().setReadOnly(info.getProperties().getReadOnly())
+        UnderFileSystemConfiguration.defaults(ServerConfiguration.global()).setReadOnly(info.getProperties().getReadOnly())
             .setShared(info.getProperties().getShared())
-            .setMountSpecificConf(info.getProperties().getPropertiesMap()));
+            .createMountSpecificConf(info.getProperties().getPropertiesMap()));
     UfsClient ufsClient = super.get(mountId);
     try (CloseableResource<UnderFileSystem> ufsResource = ufsClient.acquireUfsResource()) {
       UnderFileSystem ufs = ufsResource.get();
       ufs.connectFromWorker(
-          NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.WORKER_RPC));
+          NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.WORKER_RPC,
+              ServerConfiguration.global()));
     } catch (IOException e) {
       removeMount(mountId);
       throw new UnavailableException(
diff --git a/job/server/src/main/java/alluxio/worker/AlluxioJobWorker.java b/job/server/src/main/java/alluxio/worker/AlluxioJobWorker.java
index f72c0ac492..e693873143 100644
--- a/job/server/src/main/java/alluxio/worker/AlluxioJobWorker.java
+++ b/job/server/src/main/java/alluxio/worker/AlluxioJobWorker.java
@@ -11,10 +11,11 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
+import alluxio.Server;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
 import alluxio.ProcessUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.MasterInquireClient;
 import alluxio.retry.RetryUtils;
@@ -48,7 +49,7 @@ public final class AlluxioJobWorker {
       System.exit(-1);
     }
 
-    if (!ConfigurationUtils.masterHostConfigured()) {
+    if (!ConfigurationUtils.masterHostConfigured(ServerConfiguration.global())) {
       System.out.println(String.format(
           "Cannot run alluxio job worker; master hostname is not "
               + "configured. Please modify %s to either set %s or configure zookeeper with "
@@ -58,7 +59,7 @@ public final class AlluxioJobWorker {
       System.exit(1);
     }
 
-    if (!ConfigurationUtils.jobMasterHostConfigured()) {
+    if (!ConfigurationUtils.jobMasterHostConfigured(ServerConfiguration.global())) {
       System.out.println(String.format(
           "Cannot run alluxio job worker; job master hostname is not "
               + "configured. Please modify %s to either set %s or configure zookeeper with "
@@ -69,12 +70,14 @@ public final class AlluxioJobWorker {
     }
 
     CommonUtils.PROCESS_TYPE.set(CommonUtils.ProcessType.JOB_WORKER);
-    MasterInquireClient masterInquireClient = MasterInquireClient.Factory.create();
+    MasterInquireClient masterInquireClient =
+        MasterInquireClient.Factory.create(ServerConfiguration.global());
     try {
       RetryUtils.retry("load cluster default configuration with master", () -> {
         InetSocketAddress masterAddress = masterInquireClient.getPrimaryRpcAddress();
-        Configuration.loadClusterDefault(masterAddress);
-      }, RetryUtils.defaultWorkerMasterClientRetry());
+        ServerConfiguration.loadClusterDefaults(masterAddress);
+      },
+          RetryUtils.defaultWorkerMasterClientRetry(ServerConfiguration.getDuration(PropertyKey.WORKER_MASTER_CONNECT_RETRY_TIMEOUT)));
     } catch (IOException e) {
       ProcessUtils.fatalError(LOG,
           "Failed to load cluster default configuration for job worker: %s", e.getMessage());
diff --git a/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerProcess.java b/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerProcess.java
index 7a1eb617a3..258a6cc207 100644
--- a/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerProcess.java
+++ b/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerProcess.java
@@ -11,8 +11,10 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
+import alluxio.Constants;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.grpc.GrpcServer;
 import alluxio.grpc.GrpcServerBuilder;
@@ -84,11 +86,12 @@ public final class AlluxioJobWorkerProcess implements JobWorkerProcess {
 
       // Setup web server
       mWebServer = new JobWorkerWebServer(ServiceType.JOB_WORKER_WEB.getServiceName(),
-          NetworkAddressUtils.getBindAddress(ServiceType.JOB_WORKER_WEB), this);
+          NetworkAddressUtils.getBindAddress(ServiceType.JOB_WORKER_WEB, ServerConfiguration.global()),
+          this);
 
       // Random port binding.
       InetSocketAddress configuredBindAddress =
-              NetworkAddressUtils.getBindAddress(ServiceType.JOB_WORKER_RPC);
+              NetworkAddressUtils.getBindAddress(ServiceType.JOB_WORKER_RPC, ServerConfiguration.global());
       if (configuredBindAddress.getPort() == 0) {
         mBindSocket = new ServerSocket(0);
         mRPCPort = mBindSocket.getLocalPort();
@@ -96,9 +99,9 @@ public final class AlluxioJobWorkerProcess implements JobWorkerProcess {
         mRPCPort = configuredBindAddress.getPort();
       }
       // Reset worker RPC port based on assigned port number
-      Configuration.set(PropertyKey.JOB_WORKER_RPC_PORT, Integer.toString(mRPCPort));
+      ServerConfiguration.set(PropertyKey.JOB_WORKER_RPC_PORT, Integer.toString(mRPCPort));
       mRpcAddress =
-          NetworkAddressUtils.getConnectAddress(ServiceType.JOB_WORKER_RPC);
+          NetworkAddressUtils.getConnectAddress(ServiceType.JOB_WORKER_RPC, ServerConfiguration.global());
     } catch (Exception e) {
       LOG.error(e.getMessage(), e);
       throw Throwables.propagate(e);
@@ -163,10 +166,10 @@ public final class AlluxioJobWorkerProcess implements JobWorkerProcess {
     LOG.info("Alluxio job worker version {} started. "
             + "bindHost={}, connectHost={}, rpcPort={}, webPort={}",
         RuntimeConstants.VERSION,
-        NetworkAddressUtils.getBindAddress(ServiceType.JOB_WORKER_RPC),
-        NetworkAddressUtils.getConnectAddress(ServiceType.JOB_WORKER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.JOB_WORKER_RPC),
-        NetworkAddressUtils.getPort(ServiceType.JOB_WORKER_WEB));
+        NetworkAddressUtils.getBindAddress(ServiceType.JOB_WORKER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getConnectAddress(ServiceType.JOB_WORKER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.JOB_WORKER_RPC, ServerConfiguration.global()),
+        NetworkAddressUtils.getPort(ServiceType.JOB_WORKER_WEB, ServerConfiguration.global()));
 
     startServingRPCServer();
     LOG.info("Alluxio job worker ended");
@@ -215,10 +218,10 @@ public final class AlluxioJobWorkerProcess implements JobWorkerProcess {
   @Override
   public WorkerNetAddress getAddress() {
     return new WorkerNetAddress()
-        .setHost(NetworkAddressUtils.getConnectHost(ServiceType.JOB_WORKER_RPC))
-        .setRpcPort(Configuration.getInt(PropertyKey.JOB_WORKER_RPC_PORT))
-        .setDataPort(Configuration.getInt(PropertyKey.JOB_WORKER_DATA_PORT))
-        .setWebPort(Configuration.getInt(PropertyKey.JOB_WORKER_WEB_PORT));
+        .setHost(NetworkAddressUtils.getConnectHost(ServiceType.JOB_WORKER_RPC, ServerConfiguration.global()))
+        .setRpcPort(ServerConfiguration.getInt(PropertyKey.JOB_WORKER_RPC_PORT))
+        .setDataPort(ServerConfiguration.getInt(PropertyKey.JOB_WORKER_DATA_PORT))
+        .setWebPort(ServerConfiguration.getInt(PropertyKey.JOB_WORKER_WEB_PORT));
   }
 
   private void startWorkers() throws Exception {
diff --git a/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerRestServiceHandler.java b/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerRestServiceHandler.java
index afbdaf9617..92ca2343b8 100644
--- a/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerRestServiceHandler.java
+++ b/job/server/src/main/java/alluxio/worker/AlluxioJobWorkerRestServiceHandler.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RestUtils;
 import alluxio.RuntimeConstants;
 import alluxio.web.JobWorkerWebServer;
@@ -41,7 +41,7 @@ import javax.ws.rs.core.Response;
 @NotThreadSafe
 @Path(AlluxioJobWorkerRestServiceHandler.SERVICE_PREFIX)
 @Produces(MediaType.APPLICATION_JSON)
-public final class AlluxioJobWorkerRestServiceHandler {
+public final class  AlluxioJobWorkerRestServiceHandler {
   public static final String SERVICE_PREFIX = "job_worker";
 
   // endpoints
@@ -61,7 +61,7 @@ public final class AlluxioJobWorkerRestServiceHandler {
   }
 
   /**
-   * @summary get the Alluxio job worker information
+   * @summary create the Alluxio job worker information
    * @param rawConfiguration if it's true, raw configuration values are returned,
    *    otherwise, they are looked up; if it's not provided in URL queries, then
    *    it is null, which means false.
@@ -84,11 +84,11 @@ public final class AlluxioJobWorkerRestServiceHandler {
               .setUptimeMs(mJobWorker.getUptimeMs())
               .setVersion(RuntimeConstants.VERSION);
       return result;
-    });
+    }, ServerConfiguration.global());
   }
 
   private Map<String, String> getConfigurationInternal(boolean raw) {
-    Set<Map.Entry<String, String>> properties = Configuration.toMap().entrySet();
+    Set<Map.Entry<String, String>> properties = ServerConfiguration.toMap().entrySet();
     SortedMap<String, String> configuration = new TreeMap<>();
     for (Map.Entry<String, String> entry : properties) {
       String key = entry.getKey();
@@ -96,7 +96,7 @@ public final class AlluxioJobWorkerRestServiceHandler {
         if (raw) {
           configuration.put(key, entry.getValue());
         } else {
-          configuration.put(key, Configuration.get(PropertyKey.fromString(key)));
+          configuration.put(key, ServerConfiguration.get(PropertyKey.fromString(key)));
         }
       }
     }
diff --git a/job/server/src/main/java/alluxio/worker/JobWorker.java b/job/server/src/main/java/alluxio/worker/JobWorker.java
index 2a003f25de..874cd2a8a3 100644
--- a/job/server/src/main/java/alluxio/worker/JobWorker.java
+++ b/job/server/src/main/java/alluxio/worker/JobWorker.java
@@ -11,9 +11,10 @@
 
 package alluxio.worker;
 
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.Server;
 import alluxio.exception.ConnectionFailedException;
 import alluxio.grpc.GrpcService;
@@ -68,7 +69,9 @@ public final class JobWorker extends AbstractWorker {
     super(
         Executors.newFixedThreadPool(1, ThreadFactoryUtils.build("job-worker-heartbeat-%d", true)));
     mUfsManager = ufsManager;
-    mJobMasterClient = JobMasterClient.Factory.create(JobMasterClientConfig.defaults());
+    mJobMasterClient =
+        JobMasterClient.Factory.create(JobMasterClientConfig.defaults(ServerConfiguration.global()),
+        ServerConfiguration.global());
     mTaskExecutorManager = new TaskExecutorManager();
   }
 
@@ -90,12 +93,12 @@ public final class JobWorker extends AbstractWorker {
   @Override
   public void start(WorkerNetAddress address) throws IOException {
     // Start serving metrics system, this will not block
-    MetricsSystem.startSinks();
+    MetricsSystem.startSinks(ServerConfiguration.get(PropertyKey.METRICS_CONF_FILE));
 
     try {
       JobWorkerIdRegistry.registerWorker(mJobMasterClient, address);
     } catch (ConnectionFailedException e) {
-      LOG.error("Failed to get a worker id from job master", e);
+      LOG.error("Failed to create a worker id from job master", e);
       throw Throwables.propagate(e);
     }
 
@@ -103,7 +106,8 @@ public final class JobWorker extends AbstractWorker {
         new HeartbeatThread(HeartbeatContext.JOB_WORKER_COMMAND_HANDLING,
             new CommandHandlingExecutor(mTaskExecutorManager, mUfsManager, mJobMasterClient,
                 address),
-            Configuration.getInt(PropertyKey.JOB_MASTER_WORKER_HEARTBEAT_INTERVAL_MS)));
+            ServerConfiguration.getInt(PropertyKey.JOB_MASTER_WORKER_HEARTBEAT_INTERVAL_MS),
+            ServerConfiguration.global()));
   }
 
   @Override
diff --git a/job/server/src/main/java/alluxio/worker/JobWorkerIdRegistry.java b/job/server/src/main/java/alluxio/worker/JobWorkerIdRegistry.java
index 45d38d0ecb..42f33a6dd6 100644
--- a/job/server/src/main/java/alluxio/worker/JobWorkerIdRegistry.java
+++ b/job/server/src/main/java/alluxio/worker/JobWorkerIdRegistry.java
@@ -22,7 +22,7 @@ import java.util.concurrent.atomic.AtomicLong;
 import javax.annotation.concurrent.NotThreadSafe;
 
 /**
- * The single place to get, set, and update job worker id.
+ * The single place to create, set, and update job worker id.
  *
  * This class should be the only source of job worker id within the same job worker process.
  */
@@ -38,11 +38,11 @@ public final class JobWorkerIdRegistry {
   private JobWorkerIdRegistry() {}
 
   /**
-   * Registers with {@link JobMaster} to get a new job worker id.
+   * Registers with {@link JobMaster} to create a new job worker id.
    *
    * @param jobMasterClient the job master client to be used for RPC
    * @param workerAddress current worker address
-   * @throws IOException when fails to get a new worker id
+   * @throws IOException when fails to create a new worker id
    * @throws ConnectionFailedException if network connection failed
    */
   public static void registerWorker(JobMasterClient jobMasterClient, WorkerNetAddress workerAddress)
diff --git a/job/server/src/main/java/alluxio/worker/job/task/TaskExecutor.java b/job/server/src/main/java/alluxio/worker/job/task/TaskExecutor.java
index e9395cb2b6..dda65d316a 100644
--- a/job/server/src/main/java/alluxio/worker/job/task/TaskExecutor.java
+++ b/job/server/src/main/java/alluxio/worker/job/task/TaskExecutor.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.job.task;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.job.JobConfig;
 import alluxio.job.JobDefinition;
 import alluxio.job.JobDefinitionRegistry;
@@ -82,7 +82,7 @@ public final class TaskExecutor implements Runnable {
       mTaskExecutorManager.notifyTaskCancellation(mJobId, mTaskId);
       return;
     } catch (Throwable t) {
-      if (Configuration.getBoolean(PropertyKey.DEBUG)) {
+      if (ServerConfiguration.getBoolean(PropertyKey.DEBUG)) {
         mTaskExecutorManager.notifyTaskFailure(mJobId, mTaskId, ExceptionUtils.getStackTrace(t));
       } else {
         mTaskExecutorManager.notifyTaskFailure(mJobId, mTaskId, t.getMessage());
diff --git a/job/server/src/test/java/alluxio/job/load/LoadDefinitionTest.java b/job/server/src/test/java/alluxio/job/load/LoadDefinitionTest.java
index eab15baef6..f9cf051584 100644
--- a/job/server/src/test/java/alluxio/job/load/LoadDefinitionTest.java
+++ b/job/server/src/test/java/alluxio/job/load/LoadDefinitionTest.java
@@ -12,11 +12,13 @@
 package alluxio.job.load;
 
 import alluxio.AlluxioURI;
+import alluxio.ConfigurationTestUtils;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.job.JobMasterContext;
 import alluxio.job.load.LoadDefinition.LoadTask;
 import alluxio.wire.BlockInfo;
@@ -75,7 +77,7 @@ public class LoadDefinitionTest {
     mMockFileSystem = PowerMockito.mock(FileSystem.class);
     mMockBlockStore = PowerMockito.mock(AlluxioBlockStore.class);
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    PowerMockito.when(AlluxioBlockStore.create()).thenReturn(mMockBlockStore);
+    PowerMockito.when(AlluxioBlockStore.create(ServerConfiguration.global())).thenReturn(mMockBlockStore);
     Mockito.when(mMockBlockStore.getAllWorkers()).thenReturn(BLOCK_WORKERS);
   }
 
diff --git a/job/server/src/test/java/alluxio/job/move/MoveDefinitionRunTaskTest.java b/job/server/src/test/java/alluxio/job/move/MoveDefinitionRunTaskTest.java
index 08ad3bba0c..ae871ca8d7 100644
--- a/job/server/src/test/java/alluxio/job/move/MoveDefinitionRunTaskTest.java
+++ b/job/server/src/test/java/alluxio/job/move/MoveDefinitionRunTaskTest.java
@@ -18,12 +18,14 @@ import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
 import alluxio.AlluxioURI;
+import alluxio.ConfigurationTestUtils;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.MockFileInStream;
 import alluxio.client.file.MockFileOutStream;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.DeletePOptions;
 import alluxio.grpc.WritePType;
@@ -65,11 +67,12 @@ public final class MoveDefinitionRunTaskTest {
 
   @Before
   public void before() throws Exception {
+    AlluxioConfiguration conf = ConfigurationTestUtils.defaults();
     mMockFileSystem = Mockito.mock(FileSystem.class);
     mMockFileSystemContext = PowerMockito.mock(FileSystemContext.class);
-    mMockInStream = new MockFileInStream(FileSystemContext.get(), TEST_SOURCE_CONTENTS);
+    mMockInStream = new MockFileInStream(FileSystemContext.create(), TEST_SOURCE_CONTENTS, conf);
     when(mMockFileSystem.openFile(new AlluxioURI(TEST_SOURCE))).thenReturn(mMockInStream);
-    mMockOutStream = new MockFileOutStream();
+    mMockOutStream = new MockFileOutStream(conf);
     when(mMockFileSystem.createFile(eq(new AlluxioURI(TEST_DESTINATION)),
         any(CreateFilePOptions.class))).thenReturn(mMockOutStream);
     mMockUfsManager = Mockito.mock(UfsManager.class);
diff --git a/job/server/src/test/java/alluxio/job/move/MoveDefinitionSelectExecutorsTest.java b/job/server/src/test/java/alluxio/job/move/MoveDefinitionSelectExecutorsTest.java
index bf12b4dcf6..cbe36d02a5 100644
--- a/job/server/src/test/java/alluxio/job/move/MoveDefinitionSelectExecutorsTest.java
+++ b/job/server/src/test/java/alluxio/job/move/MoveDefinitionSelectExecutorsTest.java
@@ -22,6 +22,7 @@ import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileAlreadyExistsException;
 import alluxio.exception.FileDoesNotExistException;
@@ -92,7 +93,7 @@ public final class MoveDefinitionSelectExecutorsTest {
     mMockFileSystem = Mockito.mock(FileSystem.class);
     mMockUfsManager = Mockito.mock(UfsManager.class);
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    PowerMockito.when(AlluxioBlockStore.create(mMockFileSystemContext)).thenReturn(mMockBlockStore);
+    PowerMockito.when(AlluxioBlockStore.create(mMockFileSystemContext, ServerConfiguration.global())).thenReturn(mMockBlockStore);
     when(mMockBlockStore.getAllWorkers()).thenReturn(BLOCK_WORKERS);
     createDirectory("/");
   }
diff --git a/job/server/src/test/java/alluxio/job/persist/PersistDefinitionTest.java b/job/server/src/test/java/alluxio/job/persist/PersistDefinitionTest.java
index e9daeb77ad..64c44fcb9a 100644
--- a/job/server/src/test/java/alluxio/job/persist/PersistDefinitionTest.java
+++ b/job/server/src/test/java/alluxio/job/persist/PersistDefinitionTest.java
@@ -16,6 +16,7 @@ import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.job.JobMasterContext;
 import alluxio.job.util.SerializableVoid;
 import alluxio.wire.BlockInfo;
@@ -55,7 +56,8 @@ public final class PersistDefinitionTest {
     mMockFileSystemContext = PowerMockito.mock(FileSystemContext.class);
     mMockBlockStore = PowerMockito.mock(AlluxioBlockStore.class);
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    PowerMockito.when(AlluxioBlockStore.create(mMockFileSystemContext)).thenReturn(mMockBlockStore);
+    PowerMockito.when(AlluxioBlockStore.create(mMockFileSystemContext,
+        ServerConfiguration.global())).thenReturn(mMockBlockStore);
   }
 
   @Test
diff --git a/job/server/src/test/java/alluxio/job/replicate/EvictDefinitionTest.java b/job/server/src/test/java/alluxio/job/replicate/EvictDefinitionTest.java
index b17ed3a614..61a7dd4c48 100644
--- a/job/server/src/test/java/alluxio/job/replicate/EvictDefinitionTest.java
+++ b/job/server/src/test/java/alluxio/job/replicate/EvictDefinitionTest.java
@@ -13,6 +13,7 @@ package alluxio.job.replicate;
 
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystemContext;
+import alluxio.conf.ServerConfiguration;
 import alluxio.job.JobMasterContext;
 import alluxio.job.util.SerializableVoid;
 import alluxio.wire.BlockInfo;
@@ -79,7 +80,7 @@ public final class EvictDefinitionTest {
     blockInfo.setLocations(blockLocations);
     Mockito.when(mMockBlockStore.getInfo(TEST_BLOCK_ID)).thenReturn(blockInfo);
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    PowerMockito.when(AlluxioBlockStore.create(mMockFileSystemContext)).thenReturn(mMockBlockStore);
+    PowerMockito.when(AlluxioBlockStore.create(mMockFileSystemContext, ServerConfiguration.global())).thenReturn(mMockBlockStore);
 
     EvictConfig config = new EvictConfig(TEST_BLOCK_ID, replicas);
     EvictDefinition definition = new EvictDefinition(mMockFileSystemContext);
diff --git a/job/server/src/test/java/alluxio/job/replicate/ReplicateDefinitionTest.java b/job/server/src/test/java/alluxio/job/replicate/ReplicateDefinitionTest.java
index a24b2d89bf..b5c6522b95 100644
--- a/job/server/src/test/java/alluxio/job/replicate/ReplicateDefinitionTest.java
+++ b/job/server/src/test/java/alluxio/job/replicate/ReplicateDefinitionTest.java
@@ -36,6 +36,8 @@ import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
 import alluxio.client.file.options.InStreamOptions;
 import alluxio.client.file.options.OutStreamOptions;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.NotFoundException;
 import alluxio.job.JobMasterContext;
@@ -84,7 +86,8 @@ public final class ReplicateDefinitionTest {
   private static final WorkerNetAddress ADDRESS_3 =
       new WorkerNetAddress().setHost("host3").setDataPort(10);
   private static final WorkerNetAddress LOCAL_ADDRESS =
-      new WorkerNetAddress().setHost(NetworkAddressUtils.getLocalHostName()).setDataPort(10);
+      new WorkerNetAddress().setHost(NetworkAddressUtils.getLocalHostName((int)ServerConfiguration.getMs(
+          PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS))).setDataPort(10);
   private static final WorkerInfo WORKER_INFO_1 = new WorkerInfo().setAddress(ADDRESS_1);
   private static final WorkerInfo WORKER_INFO_2 = new WorkerInfo().setAddress(ADDRESS_2);
   private static final WorkerInfo WORKER_INFO_3 = new WorkerInfo().setAddress(ADDRESS_3);
@@ -122,7 +125,7 @@ public final class ReplicateDefinitionTest {
     blockInfo.setLocations(blockLocations);
     when(mMockBlockStore.getInfo(TEST_BLOCK_ID)).thenReturn(blockInfo);
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    when(AlluxioBlockStore.create(mMockFileSystemContext)).thenReturn(mMockBlockStore);
+    when(AlluxioBlockStore.create(mMockFileSystemContext, ServerConfiguration.global())).thenReturn(mMockBlockStore);
 
     String path = "/test";
     ReplicateConfig config = new ReplicateConfig(path, TEST_BLOCK_ID, numReplicas);
@@ -156,7 +159,7 @@ public final class ReplicateDefinitionTest {
         .thenReturn(new BlockInfo().setBlockId(TEST_BLOCK_ID)
             .setLocations(Lists.newArrayList(new BlockLocation().setWorkerAddress(ADDRESS_1))));
     PowerMockito.mockStatic(AlluxioBlockStore.class);
-    when(AlluxioBlockStore.create(mMockFileSystemContext)).thenReturn(mMockBlockStore);
+    when(AlluxioBlockStore.create(mMockFileSystemContext, ServerConfiguration.global())).thenReturn(mMockBlockStore);
 
     ReplicateConfig config = new ReplicateConfig(path, TEST_BLOCK_ID, 1 /* value not used */);
     ReplicateDefinition definition =
diff --git a/job/server/src/test/java/alluxio/master/job/JobMasterTest.java b/job/server/src/test/java/alluxio/master/job/JobMasterTest.java
index 7e310f1fb3..782efeb066 100644
--- a/job/server/src/test/java/alluxio/master/job/JobMasterTest.java
+++ b/job/server/src/test/java/alluxio/master/job/JobMasterTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.master.job;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.ResourceExhaustedException;
 import alluxio.job.JobConfig;
@@ -55,7 +55,7 @@ public final class JobMasterTest {
   @Before
   public void before() throws Exception {
     // Can't use ConfigurationRule due to conflicts with PowerMock.
-    Configuration.set(PropertyKey.JOB_MASTER_JOB_CAPACITY, TEST_JOB_MASTER_JOB_CAPACITY);
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_JOB_CAPACITY, TEST_JOB_MASTER_JOB_CAPACITY);
     mJobMaster =
         new JobMaster(new MasterContext(new NoopJournalSystem()), Mockito.mock(UfsManager.class));
     mJobMaster.start(true);
@@ -64,7 +64,7 @@ public final class JobMasterTest {
   @After
   public void after() throws Exception {
     mJobMaster.stop();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionReader.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionReader.java
index 04fa2f5e0c..016e20d632 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionReader.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionReader.java
@@ -12,6 +12,7 @@
 package alluxio.client.keyvalue;
 
 import alluxio.client.block.AlluxioBlockStore;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.util.io.BufferUtils;
 import alluxio.wire.BlockInfo;
@@ -27,7 +28,7 @@ import javax.annotation.concurrent.NotThreadSafe;
 
 /**
  * Default implementation of {@link KeyValuePartitionReader} to talk to a remote key-value worker to
- * get the value of a given key.
+ * create the value of a given key.
  */
 @NotThreadSafe
 final class BaseKeyValuePartitionReader implements KeyValuePartitionReader {
@@ -41,12 +42,13 @@ final class BaseKeyValuePartitionReader implements KeyValuePartitionReader {
    *
    * @param blockId blockId of the key-value file to read from
    */
-  BaseKeyValuePartitionReader(long blockId) throws AlluxioException, IOException {
+  BaseKeyValuePartitionReader(long blockId, AlluxioConfiguration conf) throws AlluxioException,
+                                                                              IOException {
     mBlockId = blockId;
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create();
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(conf);
     BlockInfo info = blockStore.getInfo(mBlockId);
     WorkerNetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();
-    mClient = new KeyValueWorkerClient(workerAddr);
+    mClient = new KeyValueWorkerClient(workerAddr, conf);
     mClosed = false;
   }
 
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriter.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriter.java
index 217101b645..636cd521ee 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriter.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriter.java
@@ -11,9 +11,7 @@
 
 package alluxio.client.keyvalue;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
 import alluxio.client.AbstractOutStream;
 import alluxio.util.io.ByteIOUtils;
 
@@ -58,7 +56,7 @@ final class BaseKeyValuePartitionWriter implements KeyValuePartitionWriter {
    *
    * @param fileOutStream output stream to store the key-value file
    */
-  BaseKeyValuePartitionWriter(AbstractOutStream fileOutStream) {
+  BaseKeyValuePartitionWriter(AbstractOutStream fileOutStream, long partitionSizeBytesMax) {
     mFileOutStream = Preconditions.checkNotNull(fileOutStream, "fileOutStream");
     // TODO(binfan): write a header in the file
 
@@ -66,7 +64,7 @@ final class BaseKeyValuePartitionWriter implements KeyValuePartitionWriter {
     mIndex = LinearProbingIndex.createEmptyIndex();
     mClosed = false;
     mCanceled = false;
-    mMaxSizeBytes = Configuration.getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX);
+    mMaxSizeBytes = partitionSizeBytesMax;
   }
 
   @Override
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreReader.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreReader.java
index 14db30c030..618a9232fe 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreReader.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreReader.java
@@ -12,6 +12,7 @@
 package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.PartitionInfo;
 import alluxio.master.MasterClientConfig;
@@ -40,17 +41,20 @@ class BaseKeyValueStoreReader implements KeyValueStoreReader {
   /** A list of partitions of the store. */
   private final List<PartitionInfo> mPartitions;
 
+  private final AlluxioConfiguration mConf;
+
   /**
    * Constructs a {@link BaseKeyValueStoreReader} instance.
    *
    * @param uri URI of the key-value store
    */
-  BaseKeyValueStoreReader(AlluxioURI uri) throws IOException {
+  BaseKeyValueStoreReader(AlluxioURI uri, AlluxioConfiguration conf) throws IOException {
     // TODO(binfan): use a thread pool to manage the client.
     LOG.info("Create KeyValueStoreReader for {}", uri);
-    mMasterClient = new KeyValueMasterClient(MasterClientConfig.defaults());
+    mMasterClient = new KeyValueMasterClient(MasterClientConfig.defaults(conf), conf);
     mPartitions = mMasterClient.getPartitionInfo(uri);
     mMasterClient.close();
+    mConf = conf;
   }
 
   @Override
@@ -84,7 +88,8 @@ class BaseKeyValueStoreReader implements KeyValueStoreReader {
       } else {
         // The key is either in this partition or not in the key-value store
         long blockId = partition.getBlockId();
-        try (KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId)) {
+        try (KeyValuePartitionReader reader =
+                 KeyValuePartitionReader.Factory.create(blockId, mConf)) {
           return reader.get(key);
         }
       }
@@ -94,7 +99,7 @@ class BaseKeyValueStoreReader implements KeyValueStoreReader {
 
   @Override
   public KeyValueIterator iterator() throws IOException, AlluxioException {
-    return new KeyValueStoreIterator(mPartitions);
+    return new KeyValueStoreIterator(mPartitions, mConf);
   }
 
   @Override
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreWriter.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreWriter.java
index 1ba9a0bd19..44ea35401e 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreWriter.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueStoreWriter.java
@@ -13,6 +13,7 @@ package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.PreconditionMessage;
@@ -58,15 +59,18 @@ class BaseKeyValueStoreWriter implements KeyValueStoreWriter {
   /** Byte array of the last input key. */
   private byte[] mLastKey = null;
 
+  private final AlluxioConfiguration mConf;
+
   /**
    * Constructs a {@link BaseKeyValueStoreWriter}. This constructor will create a new key-value
    * store at the given {@link AlluxioURI}.
    *
    * @param uri URI of the store
    */
-  BaseKeyValueStoreWriter(AlluxioURI uri) throws IOException {
+  BaseKeyValueStoreWriter(AlluxioURI uri, AlluxioConfiguration conf) throws IOException {
     LOG.info("Create KeyValueStoreWriter for {}", uri);
-    mMasterClient = new KeyValueMasterClient(MasterClientConfig.defaults());
+    mConf = conf;
+    mMasterClient = new KeyValueMasterClient(MasterClientConfig.defaults(conf), conf);
 
     mStoreUri = Preconditions.checkNotNull(uri, "uri");
     mMasterClient.createStore(mStoreUri);
@@ -122,7 +126,7 @@ class BaseKeyValueStoreWriter implements KeyValueStoreWriter {
       if (mWriter != null) {
         completePartition();
       }
-      mWriter = KeyValuePartitionWriter.Factory.create(getPartitionName());
+      mWriter = KeyValuePartitionWriter.Factory.create(getPartitionName(), mConf);
       mKeyStart = null;
       mKeyLimit = null;
     }
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueSystem.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueSystem.java
index 86e4ff129a..6b87a396b8 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueSystem.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/BaseKeyValueSystem.java
@@ -13,6 +13,7 @@ package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
 import alluxio.annotation.PublicApi;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.FileDoesNotExistException;
 import alluxio.exception.InvalidPathException;
@@ -36,19 +37,22 @@ import javax.annotation.concurrent.ThreadSafe;
 @PublicApi
 @ThreadSafe
 public final class BaseKeyValueSystem implements KeyValueSystem {
-  private final KeyValueMasterClient mMasterClient =
-      new KeyValueMasterClient(MasterClientConfig.defaults());
+  private final KeyValueMasterClient mMasterClient;
+  private final AlluxioConfiguration mConf;
 
   /**
    * Constructs a new {@link BaseKeyValueSystem}.
    */
-  public BaseKeyValueSystem() {}
+  public BaseKeyValueSystem(AlluxioConfiguration conf) {
+    mMasterClient = new KeyValueMasterClient(MasterClientConfig.defaults(conf), conf);
+    mConf = conf;
+  }
 
   @Override
   public KeyValueStoreReader openStore(AlluxioURI uri) throws IOException, AlluxioException {
     Preconditions.checkNotNull(uri, PreconditionMessage.URI_KEY_VALUE_STORE_NULL);
     try {
-      return new BaseKeyValueStoreReader(uri);
+      return new BaseKeyValueStoreReader(uri, mConf);
     } catch (UnavailableException e) {
       throw e;
     } catch (AlluxioStatusException e) {
@@ -60,7 +64,7 @@ public final class BaseKeyValueSystem implements KeyValueSystem {
   public KeyValueStoreWriter createStore(AlluxioURI uri) throws IOException, AlluxioException {
     Preconditions.checkNotNull(uri, PreconditionMessage.URI_KEY_VALUE_STORE_NULL);
     try {
-      return new BaseKeyValueStoreWriter(uri);
+      return new BaseKeyValueStoreWriter(uri, mConf);
     } catch (UnavailableException e) {
       throw e;
     } catch (AlluxioStatusException e) {
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReader.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReader.java
index a65c10732d..a5fa3b171b 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReader.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReader.java
@@ -84,7 +84,7 @@ public final class ByteBufferKeyValuePartitionReader implements KeyValuePartitio
   @Override
   public ByteBuffer get(ByteBuffer key) throws IOException {
     Preconditions.checkState(!mClosed);
-    LOG.trace("get: key");
+    LOG.trace("create: key");
     return mIndex.get(key, mPayloadReader);
   }
 
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueIterable.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueIterable.java
index ce9316a78f..2fdc470fb2 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueIterable.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueIterable.java
@@ -19,7 +19,7 @@ import java.io.IOException;
 /**
  * Interface to be implemented in classes that support iterating over key-value pairs.
  *
- * TODO(cc): Try to get rid of KeyValueIterable and KeyValueIterator when AlluxioException becomes
+ * TODO(cc): Try to create rid of KeyValueIterable and KeyValueIterator when AlluxioException becomes
  * a subclass of IOException.
  */
 @PublicApi
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueMasterClient.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueMasterClient.java
index 364edd95dc..26c4d0754a 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueMasterClient.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueMasterClient.java
@@ -14,6 +14,7 @@ package alluxio.client.keyvalue;
 import alluxio.AbstractMasterClient;
 import alluxio.AlluxioURI;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.CompletePartitionPRequest;
 import alluxio.grpc.CompleteStorePRequest;
 import alluxio.grpc.CreateStorePRequest;
@@ -47,8 +48,8 @@ public final class KeyValueMasterClient extends AbstractMasterClient {
    *
    * @param conf master client configuration
    */
-  public KeyValueMasterClient(MasterClientConfig conf) {
-    super(conf);
+  public KeyValueMasterClient(MasterClientConfig conf, AlluxioConfiguration alluxioConf) {
+    super(conf, alluxioConf);
   }
 
   @Override
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionReader.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionReader.java
index 006f492dba..11cc09c751 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionReader.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionReader.java
@@ -13,6 +13,7 @@ package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 
 import com.google.common.base.Preconditions;
@@ -41,7 +42,7 @@ public interface KeyValuePartitionReader extends Closeable, KeyValueIterable {
      * @param uri Alluxio URI of the key-value partition to use as input
      * @return an instance of a {@link KeyValuePartitionReader}
      */
-    public static KeyValuePartitionReader create(AlluxioURI uri)
+    public static KeyValuePartitionReader create(AlluxioURI uri, AlluxioConfiguration conf)
         throws AlluxioException, IOException {
       Preconditions.checkNotNull(uri, "uri");
       FileSystem fs = FileSystem.Factory.get();
@@ -49,7 +50,7 @@ public interface KeyValuePartitionReader extends Closeable, KeyValueIterable {
       // Each partition file should only contain one block.
       // TODO(binfan): throw exception if a partition file has more than one blocks
       long blockId = blockIds.get(0);
-      return new BaseKeyValuePartitionReader(blockId);
+      return new BaseKeyValuePartitionReader(blockId, conf);
     }
 
     /**
@@ -59,9 +60,9 @@ public interface KeyValuePartitionReader extends Closeable, KeyValueIterable {
      * @param blockId blockId the key-value partition to use as input
      * @return an instance of a {@link KeyValuePartitionReader}
      */
-    public static KeyValuePartitionReader create(long blockId)
+    public static KeyValuePartitionReader create(long blockId, AlluxioConfiguration conf)
         throws AlluxioException, IOException {
-      return new BaseKeyValuePartitionReader(blockId);
+      return new BaseKeyValuePartitionReader(blockId, conf);
     }
   }
 
@@ -69,7 +70,7 @@ public interface KeyValuePartitionReader extends Closeable, KeyValueIterable {
    * Gets the value associated with the given key in the key-value partition, returning null if the
    * key is not found.
    *
-   * @param key key to get, cannot be null
+   * @param key key to create, cannot be null
    * @return bytes of the value if found, null otherwise
    */
   byte[] get(byte[] key) throws IOException, AlluxioException;
@@ -79,7 +80,7 @@ public interface KeyValuePartitionReader extends Closeable, KeyValueIterable {
    * key is not found. Both key and value are in ByteBuffer to make zero-copy possible for better
    * performance.
    *
-   * @param key key to get, cannot be null
+   * @param key key to create, cannot be null
    * @return bytes of the value if found, null otherwise
    */
   ByteBuffer get(ByteBuffer key) throws IOException, AlluxioException;
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionWriter.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionWriter.java
index b5e8900aa0..884c8cd699 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionWriter.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValuePartitionWriter.java
@@ -12,8 +12,7 @@
 package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.*;
 import alluxio.client.Cancelable;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
@@ -44,15 +43,15 @@ public interface KeyValuePartitionWriter extends Closeable, Cancelable {
      * @param uri URI of the key-value partition file to write to
      * @return an instance of a {@link KeyValuePartitionWriter}
      */
-    public static KeyValuePartitionWriter create(AlluxioURI uri)
+    public static KeyValuePartitionWriter create(AlluxioURI uri, AlluxioConfiguration conf)
         throws AlluxioException, IOException {
       Preconditions.checkNotNull(uri, "uri");
       FileSystem fs = FileSystem.Factory.get();
       CreateFilePOptions options = CreateFilePOptions.newBuilder()
-          .setBlockSizeBytes(Configuration.getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX))
+          .setBlockSizeBytes(conf.getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX))
           .setRecursive(true).build();
       FileOutStream fileOutStream = fs.createFile(uri, options);
-      return new BaseKeyValuePartitionWriter(fileOutStream);
+      return new BaseKeyValuePartitionWriter(fileOutStream, conf.getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX));
     }
   }
 
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreIterator.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreIterator.java
index ae13ecff3d..7cb7456382 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreIterator.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreIterator.java
@@ -11,6 +11,7 @@
 
 package alluxio.client.keyvalue;
 
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.PartitionInfo;
 
@@ -34,16 +35,19 @@ public final class KeyValueStoreIterator implements KeyValueIterator {
   /** Iterator of the partition being visited. */
   private KeyValueIterator mPartitionIterator;
 
+  private final AlluxioConfiguration mConf;
+
   /**
    * @param partitions the partitions to use
    */
-  public KeyValueStoreIterator(List<PartitionInfo> partitions)
+  public KeyValueStoreIterator(List<PartitionInfo> partitions, AlluxioConfiguration conf)
       throws IOException, AlluxioException {
     mPartitions = Preconditions.checkNotNull(partitions, "partitions");
+    mConf = conf;
     if (mPartitions.size() > 0) {
       mPartitionIndex = 0;
       long blockId = mPartitions.get(0).getBlockId();
-      KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId);
+      KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId, conf);
       mPartitionIterator = reader.iterator();
     }
   }
@@ -65,7 +69,7 @@ public final class KeyValueStoreIterator implements KeyValueIterator {
       mPartitionIndex++;
       if (mPartitionIndex < mPartitions.size()) {
         long blockId = mPartitions.get(mPartitionIndex).getBlockId();
-        KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId);
+        KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId, mConf);
         mPartitionIterator = reader.iterator();
       } else {
         mPartitionIterator = null;
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreReader.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreReader.java
index 6d65392325..78d410216a 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreReader.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueStoreReader.java
@@ -28,7 +28,7 @@ public interface KeyValueStoreReader extends Closeable, KeyValueIterable {
    * values (e.g., larger than 10KB), {@link #get(ByteBuffer)} might be more efficient by taking
    * advantage from zero-copy.
    *
-   * @param key key to get, cannot be null
+   * @param key key to create, cannot be null
    * @return value associated with the given key, or null if not found
    */
   byte[] get(byte[] key) throws IOException, AlluxioException;
@@ -36,7 +36,7 @@ public interface KeyValueStoreReader extends Closeable, KeyValueIterable {
   /**
    * Gets the value associated with {@code key}, returns null if not found.
    *
-   * @param key key to get, cannot be null
+   * @param key key to create, cannot be null
    * @return value associated with the given key, or null if not found
    */
   ByteBuffer get(ByteBuffer key) throws IOException, AlluxioException;
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueSystem.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueSystem.java
index 0db13e648f..799e384149 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueSystem.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueSystem.java
@@ -13,6 +13,7 @@ package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
 import alluxio.annotation.PublicApi;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.FileDoesNotExistException;
 import alluxio.exception.InvalidPathException;
@@ -36,9 +37,9 @@ public interface KeyValueSystem {
     /**
      * @return a {@link KeyValueSystem} instance
      */
-    public static synchronized KeyValueSystem create() {
+    public static synchronized KeyValueSystem create(AlluxioConfiguration conf) {
       if (sKeyValueSystem == null) {
-        sKeyValueSystem = new BaseKeyValueSystem();
+        sKeyValueSystem = new BaseKeyValueSystem(conf);
       }
       return sKeyValueSystem;
     }
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueWorkerClient.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueWorkerClient.java
index d0373dc0b7..d8fd5be35f 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueWorkerClient.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/KeyValueWorkerClient.java
@@ -13,6 +13,7 @@ package alluxio.client.keyvalue;
 
 import alluxio.AbstractClient;
 import alluxio.Constants;
+import alluxio.conf.*;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.GetNextKeysPRequest;
 import alluxio.grpc.GetPRequest;
@@ -47,8 +48,8 @@ public final class KeyValueWorkerClient extends AbstractClient {
    *
    * @param workerNetAddress location of the worker to connect to
    */
-  public KeyValueWorkerClient(WorkerNetAddress workerNetAddress) {
-    super(null, NetworkAddressUtils.getRpcPortSocketAddress(workerNetAddress));
+  public KeyValueWorkerClient(WorkerNetAddress workerNetAddress, AlluxioConfiguration conf) {
+    super(null, conf, NetworkAddressUtils.getRpcPortSocketAddress(workerNetAddress));
   }
 
   @Override
@@ -75,7 +76,7 @@ public final class KeyValueWorkerClient extends AbstractClient {
    * Gets the value of a given {@code key} from a specific key-value block.
    *
    * @param blockId The id of the block
-   * @param key the key to get the value for
+   * @param key the key to create the value for
    * @return ByteBuffer of value, or null if not found
    */
   public ByteBuffer get(final long blockId, final ByteBuffer key)
@@ -93,7 +94,7 @@ public final class KeyValueWorkerClient extends AbstractClient {
   /**
    * Gets a batch of keys next to the current key in the partition.
    * <p>
-   * If current key is null, it means get the initial batch of keys.
+   * If current key is null, it means create the initial batch of keys.
    * If there are no more next keys, an empty list is returned.
    *
    * @param blockId the id of the partition
diff --git a/keyvalue/client/src/main/java/alluxio/client/keyvalue/LinearProbingIndex.java b/keyvalue/client/src/main/java/alluxio/client/keyvalue/LinearProbingIndex.java
index 18b6d253c7..e9a6883e24 100644
--- a/keyvalue/client/src/main/java/alluxio/client/keyvalue/LinearProbingIndex.java
+++ b/keyvalue/client/src/main/java/alluxio/client/keyvalue/LinearProbingIndex.java
@@ -145,7 +145,7 @@ public final class LinearProbingIndex implements Index {
 
   /**
    * @param key the key
-   * @param reader the reader to be used to get key from payload
+   * @param reader the reader to be used to create key from payload
    * @return bucket offset in the {@link Index} of the key, -1 if no such key is found
    */
   private int bucketOffset(ByteBuffer key, PayloadReader reader) {
diff --git a/keyvalue/client/src/test/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriterTest.java b/keyvalue/client/src/test/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriterTest.java
index 54656f013d..b58da6adc6 100644
--- a/keyvalue/client/src/test/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriterTest.java
+++ b/keyvalue/client/src/test/java/alluxio/client/keyvalue/BaseKeyValuePartitionWriterTest.java
@@ -17,12 +17,12 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertNull;
 
-import alluxio.Configuration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
 import alluxio.client.ByteArrayOutStream;
 
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -38,8 +38,11 @@ public final class BaseKeyValuePartitionWriterTest {
   private static final byte[] VALUE1 = "value1".getBytes();
   private static final byte[] VALUE2 = "value2_bar".getBytes();
 
+  private static InstancedConfiguration sConf = ConfigurationTestUtils.defaults();
+
   private ByteArrayOutStream mOutStream = new ByteArrayOutStream();
-  private BaseKeyValuePartitionWriter mWriter = new BaseKeyValuePartitionWriter(mOutStream);
+  private BaseKeyValuePartitionWriter mWriter = new BaseKeyValuePartitionWriter(mOutStream,
+      sConf.getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX));
 
   @Rule
   public final ExpectedException mThrown = ExpectedException.none();
@@ -133,12 +136,12 @@ public final class BaseKeyValuePartitionWriterTest {
   @Test
   public void canPutKeyValue() throws Exception {
     long size = mWriter.byteCount() + KEY1.length + VALUE1.length + 2 * Constants.BYTES_IN_INTEGER;
-    Configuration.set(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(size));
-    mWriter = new BaseKeyValuePartitionWriter(mOutStream);
+    sConf.set(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(size));
+    mWriter = new BaseKeyValuePartitionWriter(mOutStream, sConf.getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX));
     assertTrue(mWriter.canPut(KEY1, VALUE1));
     mWriter.put(KEY1, VALUE1);
     assertFalse(mWriter.canPut(KEY1, VALUE1));
-    ConfigurationTestUtils.resetConfiguration();
+    sConf = ConfigurationTestUtils.defaults();
   }
 
   /**
diff --git a/keyvalue/client/src/test/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReaderTest.java b/keyvalue/client/src/test/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReaderTest.java
index d985687b90..c23682d46c 100644
--- a/keyvalue/client/src/test/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReaderTest.java
+++ b/keyvalue/client/src/test/java/alluxio/client/keyvalue/ByteBufferKeyValuePartitionReaderTest.java
@@ -11,8 +11,10 @@
 
 package alluxio.client.keyvalue;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.client.ByteArrayOutStream;
 
+import alluxio.conf.PropertyKey;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.BeforeClass;
@@ -39,7 +41,8 @@ public final class ByteBufferKeyValuePartitionReaderTest {
   @BeforeClass
   public static void beforeClass() throws Exception {
     ByteArrayOutStream outStream = new ByteArrayOutStream();
-    BaseKeyValuePartitionWriter writer = new BaseKeyValuePartitionWriter(outStream);
+    BaseKeyValuePartitionWriter writer = new BaseKeyValuePartitionWriter(outStream,
+        ConfigurationTestUtils.defaults().getBytes(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX));
     writer.put(KEY1, VALUE1);
     writer.put(KEY2, VALUE2);
     writer.close();
diff --git a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputFormat.java b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputFormat.java
index 76c6290c2e..8fea6b7485 100644
--- a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputFormat.java
+++ b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputFormat.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.annotation.PublicApi;
 import alluxio.client.keyvalue.KeyValueMasterClient;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.PartitionInfo;
 import alluxio.master.MasterClientConfig;
 
@@ -43,13 +44,16 @@ import javax.annotation.concurrent.ThreadSafe;
 @PublicApi
 @ThreadSafe
 public final class KeyValueInputFormat extends InputFormat<BytesWritable, BytesWritable> {
-  private final KeyValueMasterClient mKeyValueMasterClient =
-      new KeyValueMasterClient(MasterClientConfig.defaults());
+  private final KeyValueMasterClient mKeyValueMasterClient;
+  private final AlluxioConfiguration mConf;
 
   /**
    * Constructs a new {@link KeyValueInputFormat}.
    */
-  public KeyValueInputFormat() {}
+  public KeyValueInputFormat(AlluxioConfiguration conf) {
+    mKeyValueMasterClient = new KeyValueMasterClient(MasterClientConfig.defaults(conf), conf);
+    mConf = conf;
+  }
 
   /**
    * Returns a list of {@link KeyValueInputSplit} where each split is one key-value partition.
@@ -68,7 +72,7 @@ public final class KeyValueInputFormat extends InputFormat<BytesWritable, BytesW
         List<PartitionInfo> partitionInfos =
             mKeyValueMasterClient.getPartitionInfo(new AlluxioURI(path.toString()));
         for (PartitionInfo partitionInfo : partitionInfos) {
-          splits.add(new KeyValueInputSplit(partitionInfo));
+          splits.add(new KeyValueInputSplit(partitionInfo, mConf));
         }
       }
     } catch (Exception e) {
@@ -80,6 +84,6 @@ public final class KeyValueInputFormat extends InputFormat<BytesWritable, BytesW
   @Override
   public RecordReader<BytesWritable, BytesWritable> createRecordReader(InputSplit inputSplit,
       TaskAttemptContext taskContext) throws IOException {
-    return new KeyValueRecordReader();
+    return new KeyValueRecordReader(mConf);
   }
 }
diff --git a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputSplit.java b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputSplit.java
index 9289da6b1f..66c02b71f9 100644
--- a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputSplit.java
+++ b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueInputSplit.java
@@ -14,6 +14,7 @@ package alluxio.hadoop.mapreduce;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.AlluxioStatusException;
 import alluxio.grpc.PartitionInfo;
 
@@ -44,8 +45,8 @@ final class KeyValueInputSplit extends InputSplit implements Writable {
    * Default constructor, to be used together with {@link #readFields(DataInput)} when
    * de-serializing {@link KeyValueInputSplit}.
    */
-  public KeyValueInputSplit() {
-    mBlockStore = AlluxioBlockStore.create();
+  public KeyValueInputSplit(AlluxioConfiguration conf) {
+    mBlockStore = AlluxioBlockStore.create(conf);
     mBlockId = INVALID_BLOCK_ID;
   }
 
@@ -54,8 +55,8 @@ final class KeyValueInputSplit extends InputSplit implements Writable {
    *
    * @param partitionInfo the partition info
    */
-  public KeyValueInputSplit(PartitionInfo partitionInfo) {
-    mBlockStore = AlluxioBlockStore.create();
+  public KeyValueInputSplit(PartitionInfo partitionInfo, AlluxioConfiguration conf) {
+    mBlockStore = AlluxioBlockStore.create(conf);
     mBlockId = partitionInfo.getBlockId();
   }
 
diff --git a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputCommitter.java b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputCommitter.java
index 4b1c54a393..140aa014ae 100644
--- a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputCommitter.java
+++ b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputCommitter.java
@@ -13,6 +13,7 @@ package alluxio.hadoop.mapreduce;
 
 import alluxio.annotation.PublicApi;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 
 import org.apache.hadoop.fs.FileSystem;
@@ -38,7 +39,7 @@ import javax.annotation.concurrent.ThreadSafe;
 public final class KeyValueOutputCommitter extends FileOutputCommitter {
   private static final Logger LOG = LoggerFactory.getLogger(KeyValueOutputCommitter.class);
 
-  private static final KeyValueSystem KEY_VALUE_SYSTEM = KeyValueSystem.Factory.create();
+  private final KeyValueSystem mKeyValueSystem;
 
   /**
    * Constructor.
@@ -46,9 +47,11 @@ public final class KeyValueOutputCommitter extends FileOutputCommitter {
    * @param outputPath the job's output path, or null if the output committer is a noop
    * @param taskContext the task's context
    */
-  public KeyValueOutputCommitter(Path outputPath, TaskAttemptContext taskContext)
+  public KeyValueOutputCommitter(Path outputPath, TaskAttemptContext taskContext,
+      AlluxioConfiguration conf)
       throws IOException {
     super(outputPath, taskContext);
+    mKeyValueSystem = KeyValueSystem.Factory.create(conf);
   }
 
   /**
@@ -72,7 +75,7 @@ public final class KeyValueOutputCommitter extends FileOutputCommitter {
   @Override
   public void commitTask(TaskAttemptContext taskContext) throws IOException {
     try {
-      KEY_VALUE_SYSTEM.mergeStore(KeyValueOutputFormat.getTaskOutputURI(taskContext),
+      mKeyValueSystem.mergeStore(KeyValueOutputFormat.getTaskOutputURI(taskContext),
           KeyValueOutputFormat.getJobOutputURI(taskContext));
     } catch (AlluxioException e) {
       throw new IOException(e);
@@ -92,7 +95,7 @@ public final class KeyValueOutputCommitter extends FileOutputCommitter {
     // keep the code compile with early Hadoop versions, we catch this exception.
     try {
       try {
-        KEY_VALUE_SYSTEM.deleteStore(KeyValueOutputFormat.getTaskOutputURI(taskContext));
+        mKeyValueSystem.deleteStore(KeyValueOutputFormat.getTaskOutputURI(taskContext));
       } catch (AlluxioException e) {
         throw new IOException(e);
       }
diff --git a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputFormat.java b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputFormat.java
index 78b2d29f26..56790f9eb5 100644
--- a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputFormat.java
+++ b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueOutputFormat.java
@@ -14,6 +14,7 @@ package alluxio.hadoop.mapreduce;
 import alluxio.AlluxioURI;
 import alluxio.annotation.PublicApi;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 
 import org.apache.hadoop.fs.Path;
@@ -43,11 +44,15 @@ import javax.annotation.concurrent.ThreadSafe;
 @ThreadSafe
 public final class KeyValueOutputFormat extends FileOutputFormat<BytesWritable, BytesWritable> {
   private OutputCommitter mCommitter;
+  private final AlluxioConfiguration mConf;
+
 
   /**
    * Constructs a new {@link KeyValueOutputFormat}.
    */
-  public KeyValueOutputFormat() {}
+  public KeyValueOutputFormat(AlluxioConfiguration conf) {
+    mConf = conf;
+  }
 
   /**
    * @param taskContext MapReduce task context
@@ -69,7 +74,7 @@ public final class KeyValueOutputFormat extends FileOutputFormat<BytesWritable,
   @Override
   public RecordWriter<BytesWritable, BytesWritable> getRecordWriter(
       TaskAttemptContext taskAttemptContext) throws IOException {
-    return new KeyValueRecordWriter(getTaskOutputURI(taskAttemptContext));
+    return new KeyValueRecordWriter(getTaskOutputURI(taskAttemptContext), mConf);
   }
 
   /**
@@ -83,7 +88,7 @@ public final class KeyValueOutputFormat extends FileOutputFormat<BytesWritable,
   public void checkOutputSpecs(JobContext jobContext) throws IOException {
     super.checkOutputSpecs(jobContext);
     try {
-      KeyValueSystem.Factory.create().createStore(KeyValueOutputFormat.getJobOutputURI(jobContext))
+      KeyValueSystem.Factory.create(mConf).createStore(KeyValueOutputFormat.getJobOutputURI(jobContext))
           .close();
     } catch (AlluxioException e) {
       throw new IOException(e);
@@ -98,7 +103,7 @@ public final class KeyValueOutputFormat extends FileOutputFormat<BytesWritable,
   public OutputCommitter getOutputCommitter(TaskAttemptContext taskContext) throws IOException {
     if (mCommitter == null) {
       mCommitter = new KeyValueOutputCommitter(new Path(KeyValueOutputFormat.getJobOutputURI(
-          taskContext).toString()), taskContext);
+          taskContext).toString()), taskContext, mConf);
     }
     return mCommitter;
   }
diff --git a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordReader.java b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordReader.java
index bc8d7f6f1e..bd4f136791 100644
--- a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordReader.java
+++ b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordReader.java
@@ -15,6 +15,7 @@ import alluxio.client.keyvalue.KeyValueIterator;
 import alluxio.client.keyvalue.KeyValuePair;
 import alluxio.client.keyvalue.KeyValuePartitionReader;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.util.io.BufferUtils;
 
@@ -48,10 +49,14 @@ final class KeyValueRecordReader extends RecordReader<BytesWritable, BytesWritab
   /** Current value. */
   private BytesWritable mCurrentValue;
 
+  private final AlluxioConfiguration mConf;
+
   /**
    * Creates a {@link KeyValueRecordReader} for generating key-value pairs of a partition.
    */
-  public KeyValueRecordReader() {}
+  public KeyValueRecordReader(AlluxioConfiguration conf) {
+    mConf = conf;
+  }
 
   @Override
   public void initialize(InputSplit split, TaskAttemptContext context)
@@ -62,7 +67,7 @@ final class KeyValueRecordReader extends RecordReader<BytesWritable, BytesWritab
         throw new IOException("Split is required to be KeyValueInputSplit");
       }
       mReader =
-          KeyValuePartitionReader.Factory.create(((KeyValueInputSplit) split).getPartitionId());
+          KeyValuePartitionReader.Factory.create(((KeyValueInputSplit) split).getPartitionId(), mConf);
       mKeyValuePairIterator = mReader.iterator();
       mNumVisitedKeyValuePairs = 0;
       mNumKeyValuePairs = mReader.size();
diff --git a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordWriter.java b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordWriter.java
index cbc09ffa2a..2ef9484ed9 100644
--- a/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordWriter.java
+++ b/keyvalue/hadoop/src/main/java/alluxio/hadoop/mapreduce/KeyValueRecordWriter.java
@@ -14,6 +14,7 @@ package alluxio.hadoop.mapreduce;
 import alluxio.AlluxioURI;
 import alluxio.client.keyvalue.KeyValueStoreWriter;
 import alluxio.client.keyvalue.KeyValueSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 
 import org.apache.hadoop.io.BytesWritable;
@@ -37,9 +38,9 @@ final class KeyValueRecordWriter extends RecordWriter<BytesWritable, BytesWritab
    *
    * @param storeUri the URI for the temporary key-value store to be created by this record writer
    */
-  public KeyValueRecordWriter(AlluxioURI storeUri) throws IOException {
+  public KeyValueRecordWriter(AlluxioURI storeUri, AlluxioConfiguration conf) throws IOException {
     try {
-      mWriter = KeyValueSystem.Factory.create().createStore(storeUri);
+      mWriter = KeyValueSystem.Factory.create(conf).createStore(storeUri);
     } catch (AlluxioException e) {
       throw new IOException(e);
     }
diff --git a/keyvalue/server/src/main/java/alluxio/master/keyvalue/KeyValueMasterFactory.java b/keyvalue/server/src/main/java/alluxio/master/keyvalue/KeyValueMasterFactory.java
index b588a23e9b..3e084de6e8 100644
--- a/keyvalue/server/src/main/java/alluxio/master/keyvalue/KeyValueMasterFactory.java
+++ b/keyvalue/server/src/main/java/alluxio/master/keyvalue/KeyValueMasterFactory.java
@@ -11,10 +11,10 @@
 
 package alluxio.master.keyvalue;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
 import alluxio.master.CoreMasterContext;
+import alluxio.conf.PropertyKey;
 import alluxio.master.MasterFactory;
 import alluxio.master.MasterRegistry;
 import alluxio.master.file.FileSystemMaster;
@@ -38,7 +38,7 @@ public final class KeyValueMasterFactory implements MasterFactory<CoreMasterCont
 
   @Override
   public boolean isEnabled() {
-    return Configuration.getBoolean(PropertyKey.KEY_VALUE_ENABLED);
+    return ServerConfiguration.getBoolean(PropertyKey.KEY_VALUE_ENABLED);
   }
 
   @Override
diff --git a/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerClientServiceHandler.java b/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerClientServiceHandler.java
index 06fba786e8..0825160ce5 100644
--- a/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerClientServiceHandler.java
+++ b/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerClientServiceHandler.java
@@ -110,7 +110,7 @@ public final class KeyValueWorkerClientServiceHandler
         }
       } catch (InvalidWorkerStateException e) {
         // We shall never reach here
-        LOG.error("Reaching invalid state to get all keys", e);
+        LOG.error("Reaching invalid state to create all keys", e);
       } finally {
         mBlockWorker.unlockBlock(lockId);
       }
@@ -129,7 +129,7 @@ public final class KeyValueWorkerClientServiceHandler
         response.setSize(getReader(sessionId, lockId, request.getBlockId()).size());
       } catch (InvalidWorkerStateException e) {
         // We shall never reach here
-        LOG.error("Reaching invalid state to get size", e);
+        LOG.error("Reaching invalid state to create size", e);
       } finally {
         mBlockWorker.unlockBlock(lockId);
       }
@@ -138,7 +138,7 @@ public final class KeyValueWorkerClientServiceHandler
   }
 
   /**
-   * Internal logic to get value from the given block.
+   * Internal logic to create value from the given block.
    *
    * @param blockId Block Id
    * @param keyBuffer bytes of key
@@ -153,7 +153,7 @@ public final class KeyValueWorkerClientServiceHandler
       return getReader(sessionId, lockId, blockId).get(keyBuffer);
     } catch (InvalidWorkerStateException e) {
       // We shall never reach here
-      LOG.error("Reaching invalid state to get a key", e);
+      LOG.error("Reaching invalid state to create a key", e);
     } finally {
       mBlockWorker.unlockBlock(lockId);
     }
diff --git a/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerFactory.java b/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerFactory.java
index 6a473131bd..7b601c4661 100644
--- a/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerFactory.java
+++ b/keyvalue/server/src/main/java/alluxio/worker/keyvalue/KeyValueWorkerFactory.java
@@ -11,8 +11,8 @@
 
 package alluxio.worker.keyvalue;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UfsManager;
 import alluxio.worker.WorkerFactory;
 import alluxio.worker.WorkerRegistry;
@@ -37,7 +37,7 @@ public final class KeyValueWorkerFactory implements WorkerFactory {
 
   @Override
   public boolean isEnabled() {
-    return Configuration.getBoolean(PropertyKey.KEY_VALUE_ENABLED);
+    return ServerConfiguration.getBoolean(PropertyKey.KEY_VALUE_ENABLED);
   }
 
   @Override
diff --git a/logserver/src/main/java/alluxio/logserver/AlluxioLogServerProcess.java b/logserver/src/main/java/alluxio/logserver/AlluxioLogServerProcess.java
index 755ffc5663..9b472eb04f 100644
--- a/logserver/src/main/java/alluxio/logserver/AlluxioLogServerProcess.java
+++ b/logserver/src/main/java/alluxio/logserver/AlluxioLogServerProcess.java
@@ -11,9 +11,9 @@
 
 package alluxio.logserver;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Process;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.util.CommonUtils;
 import alluxio.util.WaitForOptions;
 
@@ -67,10 +67,10 @@ public class AlluxioLogServerProcess implements Process {
    * @param baseLogsDir base directory to store the logs pushed from remote Alluxio servers
    */
   public AlluxioLogServerProcess(String baseLogsDir) {
-    mPort = Configuration.getInt(PropertyKey.LOGSERVER_PORT);
+    mPort = ServerConfiguration.getInt(PropertyKey.LOGSERVER_PORT);
     // The log server serves the logging requests from Alluxio servers.
-    mMinNumberOfThreads = Configuration.getInt(PropertyKey.LOGSERVER_THREADS_MIN);
-    mMaxNumberOfThreads = Configuration.getInt(PropertyKey.LOGSERVER_THREADS_MAX);
+    mMinNumberOfThreads = ServerConfiguration.getInt(PropertyKey.LOGSERVER_THREADS_MIN);
+    mMaxNumberOfThreads = ServerConfiguration.getInt(PropertyKey.LOGSERVER_THREADS_MAX);
     mBaseLogsDir = baseLogsDir;
     mStopped = true;
   }
diff --git a/minicluster/src/main/java/alluxio/master/AbstractLocalAlluxioCluster.java b/minicluster/src/main/java/alluxio/master/AbstractLocalAlluxioCluster.java
index 31dbdc09a4..834319ad57 100644
--- a/minicluster/src/main/java/alluxio/master/AbstractLocalAlluxioCluster.java
+++ b/minicluster/src/main/java/alluxio/master/AbstractLocalAlluxioCluster.java
@@ -12,9 +12,9 @@
 package alluxio.master;
 
 import alluxio.AlluxioTestDirectory;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.Format;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
@@ -80,7 +80,7 @@ public abstract class AbstractLocalAlluxioCluster {
     setupTest();
     startMasters();
     // Reset the file system context to make sure the correct master RPC port is used.
-    FileSystemContext.get().reset(Configuration.global());
+    FileSystemContext.create().reset();
     startWorkers();
     startProxy();
 
@@ -161,28 +161,28 @@ public abstract class AbstractLocalAlluxioCluster {
    * Sets up corresponding directories for tests.
    */
   protected void setupTest() throws IOException {
-    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot();
-    String underfsAddress = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
+    String underfsAddress = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
 
     // Deletes the ufs dir for this test from to avoid permission problems
     UnderFileSystemUtils.deleteDirIfExists(ufs, underfsAddress);
 
-    // Creates ufs dir. This must be called before starting UFS with UnderFileSystemCluster.get().
+    // Creates ufs dir. This must be called before starting UFS with UnderFileSystemCluster.create().
     UnderFileSystemUtils.mkdirIfNotExists(ufs, underfsAddress);
 
     // Creates storage dirs for worker
-    int numLevel = Configuration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
+    int numLevel = ServerConfiguration.getInt(PropertyKey.WORKER_TIERED_STORE_LEVELS);
     for (int level = 0; level < numLevel; level++) {
       PropertyKey tierLevelDirPath =
           PropertyKey.Template.WORKER_TIERED_STORE_LEVEL_DIRS_PATH.format(level);
-      String[] dirPaths = Configuration.get(tierLevelDirPath).split(",");
+      String[] dirPaths = ServerConfiguration.get(tierLevelDirPath).split(",");
       for (String dirPath : dirPaths) {
         FileUtils.createDir(dirPath);
       }
     }
 
     // Formats the journal
-    Format.format(Format.Mode.MASTER);
+    Format.format(Format.Mode.MASTER, ServerConfiguration.global());
   }
 
   /**
@@ -192,7 +192,7 @@ public abstract class AbstractLocalAlluxioCluster {
     stopFS();
     reset();
     LoginUserTestUtils.resetLoginUser();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
@@ -211,7 +211,7 @@ public abstract class AbstractLocalAlluxioCluster {
    */
   public void formatAndRestartMasters() throws Exception {
     stopMasters();
-    Format.format(Format.Mode.MASTER);
+    Format.format(Format.Mode.MASTER, ServerConfiguration.global());
     startMasters();
   }
 
@@ -256,23 +256,23 @@ public abstract class AbstractLocalAlluxioCluster {
   }
 
   /**
-   * Creates a default {@link Configuration} for testing.
+   * Creates a default {@link ServerConfiguration} for testing.
    */
   public void initConfiguration() throws IOException {
     setAlluxioWorkDirectory();
     setHostname();
 
     for (Entry<PropertyKey, String> entry : ConfigurationTestUtils
-        .testConfigurationDefaults(mHostname, mWorkDirectory).entrySet()) {
-      Configuration.set(entry.getKey(), entry.getValue());
+        .testConfigurationDefaults(ServerConfiguration.global(), mHostname, mWorkDirectory).entrySet()) {
+      ServerConfiguration.set(entry.getKey(), entry.getValue());
     }
 
-    Configuration.set(PropertyKey.TEST_MODE, true);
-    Configuration.set(PropertyKey.MASTER_RPC_PORT, 0);
-    Configuration.set(PropertyKey.MASTER_WEB_PORT, 0);
-    Configuration.set(PropertyKey.PROXY_WEB_PORT, 0);
-    Configuration.set(PropertyKey.WORKER_RPC_PORT, 0);
-    Configuration.set(PropertyKey.WORKER_WEB_PORT, 0);
+    ServerConfiguration.set(PropertyKey.MASTER_RPC_PORT, 0);
+    ServerConfiguration.set(PropertyKey.TEST_MODE, true);
+    ServerConfiguration.set(PropertyKey.MASTER_WEB_PORT, 0);
+    ServerConfiguration.set(PropertyKey.PROXY_WEB_PORT, 0);
+    ServerConfiguration.set(PropertyKey.WORKER_RPC_PORT, 0);
+    ServerConfiguration.set(PropertyKey.WORKER_WEB_PORT, 0);
   }
 
   /**
@@ -306,7 +306,7 @@ public abstract class AbstractLocalAlluxioCluster {
    * Resets the cluster to original state.
    */
   protected void reset() {
-    ClientTestUtils.resetClient();
+    ClientTestUtils.resetClient(ServerConfiguration.global());
     GroupMappingServiceTestUtils.resetCache();
   }
 
@@ -314,9 +314,7 @@ public abstract class AbstractLocalAlluxioCluster {
    * Resets the client pools to the original state.
    */
   protected void resetClientPools() throws IOException {
-    Configuration.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
-    FileSystemContext.clearCache();
-    FileSystemContext.get().reset(Configuration.global());
+    ServerConfiguration.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
   }
 
   /**
diff --git a/minicluster/src/main/java/alluxio/master/LocalAlluxioCluster.java b/minicluster/src/main/java/alluxio/master/LocalAlluxioCluster.java
index 536a549ca7..5d8dbf0c6b 100644
--- a/minicluster/src/main/java/alluxio/master/LocalAlluxioCluster.java
+++ b/minicluster/src/main/java/alluxio/master/LocalAlluxioCluster.java
@@ -31,7 +31,7 @@ import javax.annotation.concurrent.NotThreadSafe;
  * // Create a cluster instance
  * localAlluxioCluster = new LocalAlluxioCluster(WORKER_CAPACITY_BYTES, BLOCK_SIZE_BYTES);
  * // If you have special conf parameter to set for integration tests:
- * Configuration testConf = localAlluxioCluster.newTestConf();
+ * ServerConfiguration testConf = localAlluxioCluster.newTestConf();
  * testConf.set(Constants.USER_FILE_BUFFER_BYTES, String.valueOf(BUFFER_BYTES));
  * // After setting up the test conf, start this local cluster:
  * localAlluxioCluster.start(testConf);
diff --git a/minicluster/src/main/java/alluxio/master/LocalAlluxioJobCluster.java b/minicluster/src/main/java/alluxio/master/LocalAlluxioJobCluster.java
index 59250d1178..993f567ba0 100644
--- a/minicluster/src/main/java/alluxio/master/LocalAlluxioJobCluster.java
+++ b/minicluster/src/main/java/alluxio/master/LocalAlluxioJobCluster.java
@@ -11,8 +11,8 @@
 
 package alluxio.master;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ConnectionFailedException;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.worker.JobWorkerProcess;
@@ -118,15 +118,15 @@ public final class LocalAlluxioJobCluster {
   private void updateTestConf() throws IOException {
     setHostname();
 
-    Configuration.set(PropertyKey.JOB_MASTER_BIND_HOST, mHostname);
-    Configuration.set(PropertyKey.JOB_MASTER_HOSTNAME, mHostname);
-    Configuration.set(PropertyKey.JOB_MASTER_RPC_PORT, Integer.toString(0));
-    Configuration.set(PropertyKey.JOB_MASTER_WEB_PORT, Integer.toString(0));
-    Configuration.set(PropertyKey.JOB_MASTER_WEB_BIND_HOST, mHostname);
-    Configuration.set(PropertyKey.JOB_WORKER_BIND_HOST, mHostname);
-    Configuration.set(PropertyKey.JOB_WORKER_RPC_PORT, Integer.toString(0));
-    Configuration.set(PropertyKey.JOB_WORKER_WEB_PORT, Integer.toString(0));
-    Configuration.set(PropertyKey.JOB_WORKER_WEB_BIND_HOST, mHostname);
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_BIND_HOST, mHostname);
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_HOSTNAME, mHostname);
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_RPC_PORT, Integer.toString(0));
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_WEB_PORT, Integer.toString(0));
+    ServerConfiguration.set(PropertyKey.JOB_MASTER_WEB_BIND_HOST, mHostname);
+    ServerConfiguration.set(PropertyKey.JOB_WORKER_BIND_HOST, mHostname);
+    ServerConfiguration.set(PropertyKey.JOB_WORKER_RPC_PORT, Integer.toString(0));
+    ServerConfiguration.set(PropertyKey.JOB_WORKER_WEB_PORT, Integer.toString(0));
+    ServerConfiguration.set(PropertyKey.JOB_WORKER_WEB_BIND_HOST, mHostname);
   }
 
   /**
@@ -137,7 +137,7 @@ public final class LocalAlluxioJobCluster {
    */
   private void startMaster() throws IOException, ConnectionFailedException {
     mMaster = JobMasterProcess.Factory.create();
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.JOB_MASTER_RPC_PORT, String.valueOf(mMaster.getRpcAddress().getPort()));
     Runnable runMaster = new Runnable() {
       @Override
diff --git a/minicluster/src/main/java/alluxio/master/LocalAlluxioMaster.java b/minicluster/src/main/java/alluxio/master/LocalAlluxioMaster.java
index 9d585b7553..e86271409a 100644
--- a/minicluster/src/main/java/alluxio/master/LocalAlluxioMaster.java
+++ b/minicluster/src/main/java/alluxio/master/LocalAlluxioMaster.java
@@ -12,9 +12,9 @@
 package alluxio.master;
 
 import alluxio.AlluxioTestDirectory;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.master.journal.JournalType;
@@ -58,8 +58,8 @@ public final class LocalAlluxioMaster {
   private Thread mSecondaryMasterThread;
 
   private LocalAlluxioMaster() throws IOException {
-    mHostname = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC);
-    mJournalFolder = Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
+    mHostname = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC, ServerConfiguration.global());
+    mJournalFolder = ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
   }
 
   /**
@@ -70,7 +70,7 @@ public final class LocalAlluxioMaster {
   public static LocalAlluxioMaster create() throws IOException {
     String workDirectory = uniquePath();
     FileUtils.deletePathRecursively(workDirectory);
-    Configuration.set(PropertyKey.WORK_DIR, workDirectory);
+    ServerConfiguration.set(PropertyKey.WORK_DIR, workDirectory);
     return create(workDirectory);
   }
 
diff --git a/minicluster/src/main/java/alluxio/master/MultiMasterLocalAlluxioCluster.java b/minicluster/src/main/java/alluxio/master/MultiMasterLocalAlluxioCluster.java
index 415ffb996e..751a76d756 100644
--- a/minicluster/src/main/java/alluxio/master/MultiMasterLocalAlluxioCluster.java
+++ b/minicluster/src/main/java/alluxio/master/MultiMasterLocalAlluxioCluster.java
@@ -12,9 +12,9 @@
 package alluxio.master;
 
 import alluxio.AlluxioTestDirectory;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.underfs.UnderFileSystem;
@@ -182,10 +182,10 @@ public final class MultiMasterLocalAlluxioCluster extends AbstractLocalAlluxioCl
 
   @Override
   protected void startMasters() throws IOException {
-    Configuration.set(PropertyKey.ZOOKEEPER_ENABLED, "true");
-    Configuration.set(PropertyKey.ZOOKEEPER_ADDRESS, mCuratorServer.getConnectString());
-    Configuration.set(PropertyKey.ZOOKEEPER_ELECTION_PATH, "/election");
-    Configuration.set(PropertyKey.ZOOKEEPER_LEADER_PATH, "/leader");
+    ServerConfiguration.set(PropertyKey.ZOOKEEPER_ENABLED, "true");
+    ServerConfiguration.set(PropertyKey.ZOOKEEPER_ADDRESS, mCuratorServer.getConnectString());
+    ServerConfiguration.set(PropertyKey.ZOOKEEPER_ELECTION_PATH, "/election");
+    ServerConfiguration.set(PropertyKey.ZOOKEEPER_LEADER_PATH, "/leader");
 
     for (int k = 0; k < mNumOfMasters; k++) {
       final LocalAlluxioMaster master = LocalAlluxioMaster.create(mWorkDirectory);
@@ -194,13 +194,13 @@ public final class MultiMasterLocalAlluxioCluster extends AbstractLocalAlluxioCl
           master.getAddress());
       mMasters.add(master);
       // Each master should generate a new port for binding
-      Configuration.set(PropertyKey.MASTER_RPC_PORT, "0");
+      ServerConfiguration.set(PropertyKey.MASTER_RPC_PORT, "0");
     }
 
     // Create the UFS directory after LocalAlluxioMaster construction, because LocalAlluxioMaster
     // sets UNDERFS_ADDRESS.
-    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot();
-    String path = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
+    String path = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     if (ufs.isDirectory(path)) {
       ufs.deleteDirectory(path, DeleteOptions.defaults().setRecursive(true));
     }
@@ -222,13 +222,13 @@ public final class MultiMasterLocalAlluxioCluster extends AbstractLocalAlluxioCl
       }
     }
     // Use first master port
-    Configuration.set(PropertyKey.MASTER_RPC_PORT,
+    ServerConfiguration.set(PropertyKey.MASTER_RPC_PORT,
         String.valueOf(getLocalAlluxioMaster().getRpcLocalPort()));
   }
 
   @Override
   public void startWorkers() throws Exception {
-    Configuration.set(PropertyKey.WORKER_BLOCK_THREADS_MAX, "100");
+    ServerConfiguration.set(PropertyKey.WORKER_BLOCK_THREADS_MAX, "100");
     super.startWorkers();
   }
 
diff --git a/minicluster/src/main/java/alluxio/multi/process/ExternalProcess.java b/minicluster/src/main/java/alluxio/multi/process/ExternalProcess.java
index ecfd088d0d..dda95fc212 100644
--- a/minicluster/src/main/java/alluxio/multi/process/ExternalProcess.java
+++ b/minicluster/src/main/java/alluxio/multi/process/ExternalProcess.java
@@ -11,7 +11,7 @@
 
 package alluxio.multi.process;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.util.io.PathUtils;
 
 import com.google.common.base.Preconditions;
diff --git a/minicluster/src/main/java/alluxio/multi/process/Master.java b/minicluster/src/main/java/alluxio/multi/process/Master.java
index fb31e3256e..951188afd0 100644
--- a/minicluster/src/main/java/alluxio/multi/process/Master.java
+++ b/minicluster/src/main/java/alluxio/multi/process/Master.java
@@ -11,7 +11,7 @@
 
 package alluxio.multi.process;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableMap;
diff --git a/minicluster/src/main/java/alluxio/multi/process/MultiProcessCluster.java b/minicluster/src/main/java/alluxio/multi/process/MultiProcessCluster.java
index e1e2254761..2714eb3fae 100644
--- a/minicluster/src/main/java/alluxio/multi/process/MultiProcessCluster.java
+++ b/minicluster/src/main/java/alluxio/multi/process/MultiProcessCluster.java
@@ -13,11 +13,12 @@ package alluxio.multi.process;
 
 import alluxio.AlluxioTestDirectory;
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.ClientContext;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.Format;
 import alluxio.client.MetaMasterClient;
 import alluxio.client.RetryHandlingMetaMasterClient;
@@ -191,8 +192,11 @@ public final class MultiProcessCluster {
         throw new IllegalStateException("Unknown deploy mode: " + mDeployMode.toString());
     }
 
-    for (Entry<PropertyKey, String> entry : ConfigurationTestUtils.testConfigurationDefaults(
-        NetworkAddressUtils.getLocalHostName(), mWorkDir.getAbsolutePath()).entrySet()) {
+    for (Entry<PropertyKey, String> entry :
+        ConfigurationTestUtils.testConfigurationDefaults(ServerConfiguration.global(),
+        NetworkAddressUtils.getLocalHostName(
+            (int)ServerConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)),
+        mWorkDir.getAbsolutePath()).entrySet()) {
       // Don't overwrite explicitly set properties.
       if (mProperties.containsKey(entry.getKey())) {
         continue;
@@ -309,9 +313,12 @@ public final class MultiProcessCluster {
    */
   public synchronized FileSystem getFileSystemClient() {
     Preconditions.checkState(mState == State.STARTED,
-        "must be in the started state to get an fs client, but state was %s", mState);
+        "must be in the started state to create an fs client, but state was %s", mState);
     MasterInquireClient inquireClient = getMasterInquireClient();
-    return Factory.get(mCloser.register(FileSystemContext.create(null, inquireClient)));
+    ClientContext ctx = ClientContext.create(null, ServerConfiguration.copyProperties());
+    mCloser.register(FileSystemContext.create(null, inquireClient,
+        ServerConfiguration.global()));
+    return Factory.get(ctx);
   }
 
   /**
@@ -319,9 +326,9 @@ public final class MultiProcessCluster {
    */
   public synchronized MetaMasterClient getMetaMasterClient() {
     Preconditions.checkState(mState == State.STARTED,
-        "must be in the started state to get a meta master client, but state was %s", mState);
+        "must be in the started state to create a meta master client, but state was %s", mState);
     return new RetryHandlingMetaMasterClient(new MasterClientConfig()
-        .withMasterInquireClient(getMasterInquireClient()));
+        .withMasterInquireClient(getMasterInquireClient()), ServerConfiguration.global());
   }
 
   /**
@@ -329,13 +336,13 @@ public final class MultiProcessCluster {
    */
   public synchronized Clients getClients() {
     Preconditions.checkState(mState == State.STARTED,
-        "must be in the started state to get a meta master client, but state was %s", mState);
-    MasterClientConfig config = MasterClientConfig.defaults()
+        "must be in the started state to create a meta master client, but state was %s", mState);
+    MasterClientConfig config = MasterClientConfig.defaults(ServerConfiguration.global())
         .withMasterInquireClient(getMasterInquireClient());
     return new Clients(getFileSystemClient(),
-        new RetryHandlingFileSystemMasterClient(config),
-        new RetryHandlingMetaMasterClient(config),
-        new RetryHandlingBlockMasterClient(config));
+        new RetryHandlingFileSystemMasterClient(config, ServerConfiguration.global()),
+        new RetryHandlingMetaMasterClient(config, ServerConfiguration.global()),
+        new RetryHandlingBlockMasterClient(config, ServerConfiguration.global()));
   }
 
   /**
@@ -578,8 +585,8 @@ public final class MultiProcessCluster {
       return;
     }
     try (Closeable c = new ConfigurationRule(PropertyKey.MASTER_JOURNAL_FOLDER,
-        mProperties.get(PropertyKey.MASTER_JOURNAL_FOLDER)).toResource()) {
-      Format.format(Format.Mode.MASTER);
+        mProperties.get(PropertyKey.MASTER_JOURNAL_FOLDER), ServerConfiguration.global()).toResource()) {
+      Format.format(Format.Mode.MASTER, ServerConfiguration.global());
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
@@ -603,8 +610,9 @@ public final class MultiProcessCluster {
         return new PollingMasterInquireClient(addresses);
       case ZOOKEEPER_HA:
         return ZkMasterInquireClient.getClient(mCuratorServer.getConnectString(),
-            Configuration.get(PropertyKey.ZOOKEEPER_ELECTION_PATH),
-            Configuration.get(PropertyKey.ZOOKEEPER_LEADER_PATH));
+            ServerConfiguration.get(PropertyKey.ZOOKEEPER_ELECTION_PATH),
+            ServerConfiguration.get(PropertyKey.ZOOKEEPER_LEADER_PATH),
+            ServerConfiguration.getInt(PropertyKey.ZOOKEEPER_LEADER_INQUIRY_RETRY_COUNT));
       default:
         throw new IllegalStateException("Unknown deploy mode: " + mDeployMode.toString());
     }
@@ -661,7 +669,7 @@ public final class MultiProcessCluster {
   private List<MasterNetAddress> generateMasterAddresses(int numMasters) throws IOException {
     List<MasterNetAddress> addrs = new ArrayList<>();
     for (int i = 0; i < numMasters; i++) {
-      addrs.add(new MasterNetAddress(NetworkAddressUtils.getLocalHostName(),
+      addrs.add(new MasterNetAddress(NetworkAddressUtils.getLocalHostName((int)ServerConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)),
           getNewPort(), getNewPort(), getNewPort()));
     }
     return addrs;
diff --git a/minicluster/src/main/java/alluxio/multi/process/Worker.java b/minicluster/src/main/java/alluxio/multi/process/Worker.java
index 51f51b3eee..810463eb09 100644
--- a/minicluster/src/main/java/alluxio/multi/process/Worker.java
+++ b/minicluster/src/main/java/alluxio/multi/process/Worker.java
@@ -11,7 +11,7 @@
 
 package alluxio.multi.process;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.base.Preconditions;
 import org.slf4j.Logger;
diff --git a/shell/src/main/java/alluxio/cli/ConfigurationDocGenerator.java b/shell/src/main/java/alluxio/cli/ConfigurationDocGenerator.java
index 7b91029175..dfccc72195 100644
--- a/shell/src/main/java/alluxio/cli/ConfigurationDocGenerator.java
+++ b/shell/src/main/java/alluxio/cli/ConfigurationDocGenerator.java
@@ -11,8 +11,9 @@
 
 package alluxio.cli;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.PathUtils;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -213,7 +214,7 @@ public final class ConfigurationDocGenerator {
   public static void main(String[] args) throws IOException {
     Collection<? extends PropertyKey> defaultKeys = PropertyKey.defaultKeys();
     defaultKeys.removeIf(key -> key.isHidden());
-    String homeDir = Configuration.get(PropertyKey.HOME);
+    String homeDir = new InstancedConfiguration(ConfigurationUtils.defaults()).get(PropertyKey.HOME);
     // generate CSV files
     String filePath = PathUtils.concatPath(homeDir, CSV_FILE_DIR);
     writeCSVFile(defaultKeys, filePath);
diff --git a/shell/src/main/java/alluxio/cli/GetConf.java b/shell/src/main/java/alluxio/cli/GetConf.java
index 0c2d6c941a..849236c161 100644
--- a/shell/src/main/java/alluxio/cli/GetConf.java
+++ b/shell/src/main/java/alluxio/cli/GetConf.java
@@ -11,9 +11,10 @@
 
 package alluxio.cli;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationValueOptions;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.ConfigurationValueOptions;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.RetryHandlingMetaMasterConfigClient;
 import alluxio.grpc.ConfigProperty;
 import alluxio.master.MasterClientConfig;
@@ -132,18 +133,18 @@ public final class GetConf {
   }
 
   /**
-   * Implements get configuration.
+   * Implements create configuration.
    *
    * @param args list of arguments
    * @return 0 on success, 1 on failures
    */
-  public static int getConf(String... args) {
+  public static int getConf(AlluxioConfiguration conf, String... args) {
     return getConfImpl(
-        () -> new RetryHandlingMetaMasterConfigClient(MasterClientConfig.defaults()), args);
+        () -> new RetryHandlingMetaMasterConfigClient(MasterClientConfig.defaults(conf), conf), args);
   }
 
   /**
-   * Implements get configuration.
+   * Implements create configuration.
    *
    * @param clientSupplier a functor to return a config client of meta master
    * @param args list of arguments
@@ -151,7 +152,8 @@ public final class GetConf {
    */
   @VisibleForTesting
   public static int getConfImpl(
-      Supplier<RetryHandlingMetaMasterConfigClient> clientSupplier, String... args) {
+      Supplier<RetryHandlingMetaMasterClient> clientSupplier,
+      AlluxioConfiguration conf, String... args) {
     CommandLineParser parser = new DefaultParser();
     CommandLine cmd;
     try {
@@ -168,16 +170,16 @@ public final class GetConf {
       try (RetryHandlingMetaMasterConfigClient client = clientSupplier.get()) {
         client.getConfiguration().forEach(prop -> confMap.put(prop.getName(), prop));
       } catch (IOException e) {
-        System.out.println("Unable to get master-side configuration: " + e.getMessage());
+        System.out.println("Unable to create master-side configuration: " + e.getMessage());
         return -1;
       }
     } else {
       // load local configuration
-      for (PropertyKey key : Configuration.keySet()) {
+      for (PropertyKey key : conf.keySet()) {
         if (key.isBuiltIn()) {
           ConfigProperty.Builder config = ConfigProperty.newBuilder().setName(key.getName())
-              .setSource(Configuration.getSource(key).toString());
-          String val = Configuration.getOrDefault(key, null,
+              .setSource(conf.getSource(key).toString());
+          String val = conf.getOrDefault(key, null,
               ConfigurationValueOptions.defaults().useDisplayValue(true));
           if (val != null) {
             config.setValue(val);
@@ -261,7 +263,7 @@ public final class GetConf {
    * @param args the arguments to specify the unit (optional) and configuration key (optional)
    */
   public static void main(String[] args) {
-    System.exit(getConf(args));
+    System.exit(getConf(new InstancedConfiguration(ConfigurationUtils.defaults()), args));
   }
 
   private GetConf() {} // this class is not intended for instantiation
diff --git a/shell/src/main/java/alluxio/cli/GetConfKey.java b/shell/src/main/java/alluxio/cli/GetConfKey.java
index 4c0dfd3b4c..98fe375d5d 100644
--- a/shell/src/main/java/alluxio/cli/GetConfKey.java
+++ b/shell/src/main/java/alluxio/cli/GetConfKey.java
@@ -11,7 +11,7 @@
 
 package alluxio.cli;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 
 import com.google.common.collect.ImmutableMap;
 
@@ -47,7 +47,7 @@ public final class GetConfKey {
   }
 
   /**
-   * Implements get configuration key.
+   * Implements create configuration key.
    *
    * @param args the arguments to specify the environment variable name
    * @return 0 on success, 1 on failures
diff --git a/shell/src/main/java/alluxio/cli/LogLevel.java b/shell/src/main/java/alluxio/cli/LogLevel.java
index e9ed69031d..5bf927ae33 100644
--- a/shell/src/main/java/alluxio/cli/LogLevel.java
+++ b/shell/src/main/java/alluxio/cli/LogLevel.java
@@ -14,6 +14,9 @@ package alluxio.cli;
 import alluxio.Constants;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.HttpUtils;
 import alluxio.util.network.NetworkAddressUtils;
 import alluxio.util.network.NetworkAddressUtils.ServiceType;
@@ -66,7 +69,7 @@ public final class LogLevel {
           .longOpt(LOG_NAME_OPTION_NAME)
           .hasArg(true)
           .desc("The logger's name(e.g. alluxio.master.file.DefaultFileSystemMaster)"
-              + " you want to get or set level.")
+              + " you want to create or set level.")
           .build();
   private static final String LEVEL_OPTION_NAME = "level";
   private static final Option LEVEL_OPTION =
@@ -97,11 +100,12 @@ public final class LogLevel {
    * @param args list of arguments contains target, logName and level
    * @exception ParseException if there is an error in parsing
    */
-  public static void logLevel(String[] args) throws ParseException, IOException {
+  public static void logLevel(String[] args, AlluxioConfiguration conf) throws ParseException,
+                                                                               IOException {
     CommandLineParser parser = new DefaultParser();
     CommandLine cmd = parser.parse(OPTIONS, args, true /* stopAtNonOption */);
 
-    List<TargetInfo> targets = parseOptTarget(cmd);
+    List<TargetInfo> targets = parseOptTarget(cmd, conf);
     String logName = parseOptLogName(cmd);
     String level = parseOptLevel(cmd);
 
@@ -110,7 +114,7 @@ public final class LogLevel {
     }
   }
 
-  private static List<TargetInfo> parseOptTarget(CommandLine cmd) throws IOException {
+  private static List<TargetInfo> parseOptTarget(CommandLine cmd, AlluxioConfiguration conf) throws IOException {
     String[] targets;
     if (cmd.hasOption(TARGET_OPTION_NAME)) {
       String argTarget = cmd.getOptionValue(TARGET_OPTION_NAME);
@@ -124,18 +128,18 @@ public final class LogLevel {
     } else {
       targets = new String[]{ROLE_MASTER, ROLE_WORKERS};
     }
-    return getTargetInfos(targets);
+    return getTargetInfos(targets, conf);
   }
 
-  private static List<TargetInfo> getTargetInfos(String[] targets) throws IOException {
+  private static List<TargetInfo> getTargetInfos(String[] targets, AlluxioConfiguration conf) throws IOException {
     List<TargetInfo> targetInfoList = new ArrayList<>();
     for (String target : targets) {
       if (target.equals(ROLE_MASTER)) {
-        String masterHost = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_WEB);
-        int masterPort = NetworkAddressUtils.getPort(ServiceType.MASTER_WEB);
+        String masterHost = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_WEB, conf);
+        int masterPort = NetworkAddressUtils.getPort(ServiceType.MASTER_WEB, conf);
         targetInfoList.add(new TargetInfo(masterHost, masterPort, ROLE_MASTER));
       } else if (target.equals(ROLE_WORKERS)) {
-        AlluxioBlockStore alluxioBlockStore = AlluxioBlockStore.create();
+        AlluxioBlockStore alluxioBlockStore = AlluxioBlockStore.create(conf);
         List<BlockWorkerInfo> workerInfoList = alluxioBlockStore.getAllWorkers();
         for (BlockWorkerInfo workerInfo : workerInfoList) {
           WorkerNetAddress netAddress = workerInfo.getNetAddress();
@@ -200,7 +204,7 @@ public final class LogLevel {
   public static void main(String[] args) {
     int exitCode = 1;
     try {
-      logLevel(args);
+      logLevel(args, new InstancedConfiguration(ConfigurationUtils.defaults()));
       exitCode = 0;
     } catch (ParseException e) {
       printHelp("Unable to parse input args: " + e.getMessage());
diff --git a/shell/src/main/java/alluxio/cli/ValidateConf.java b/shell/src/main/java/alluxio/cli/ValidateConf.java
index d9121af076..632d5b4c7e 100644
--- a/shell/src/main/java/alluxio/cli/ValidateConf.java
+++ b/shell/src/main/java/alluxio/cli/ValidateConf.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli;
 
-import alluxio.Configuration;
-
+import alluxio.conf.InstancedConfiguration;
+import alluxio.util.ConfigurationUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -33,7 +33,7 @@ public final class ValidateConf {
   public static void main(String[] args) {
     LOG.info("Validating configuration.");
     try {
-      Configuration.validate();
+      new InstancedConfiguration(ConfigurationUtils.defaults()).validate();
       LOG.info("Configuration is valid.");
     } catch (IllegalStateException e) {
       LOG.error("Configuration is invalid: {}", e.getMessage());
diff --git a/shell/src/main/java/alluxio/cli/fs/FileSystemShell.java b/shell/src/main/java/alluxio/cli/fs/FileSystemShell.java
index b7286db003..bb82f0f3fa 100644
--- a/shell/src/main/java/alluxio/cli/fs/FileSystemShell.java
+++ b/shell/src/main/java/alluxio/cli/fs/FileSystemShell.java
@@ -11,9 +11,10 @@
 
 package alluxio.cli.fs;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.AbstractShell;
 import alluxio.cli.Command;
 import alluxio.client.file.FileSystem;
@@ -48,8 +49,8 @@ public final class FileSystemShell extends AbstractShell {
    */
   public static void main(String[] argv) throws IOException {
     int ret;
-
-    if (!ConfigurationUtils.masterHostConfigured() && argv.length > 0 && !argv[0].equals("help")) {
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    if (!ConfigurationUtils.masterHostConfigured(conf) && argv.length > 0 && !argv[0].equals("help")) {
       System.out.println(String.format(
           "Cannot run alluxio fs shell; master hostname is not "
               + "configured. Please modify %s to either set %s or configure zookeeper with "
@@ -60,8 +61,8 @@ public final class FileSystemShell extends AbstractShell {
     }
 
     // Reduce the RPC retry max duration to fall earlier for CLIs
-    Configuration.set(PropertyKey.USER_RPC_RETRY_MAX_DURATION, "5s", Source.DEFAULT);
-    try (FileSystemShell shell = new FileSystemShell()) {
+    conf.set(PropertyKey.USER_RPC_RETRY_MAX_DURATION, "5s", Source.DEFAULT);
+    try (FileSystemShell shell = new FileSystemShell(conf)) {
       ret = shell.run(argv);
     }
     System.exit(ret);
@@ -70,8 +71,8 @@ public final class FileSystemShell extends AbstractShell {
   /**
    * Creates a new instance of {@link FileSystemShell}.
    */
-  public FileSystemShell() {
-    super(CMD_ALIAS);
+  public FileSystemShell(InstancedConfiguration conf) {
+    super(CMD_ALIAS, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/FileSystemShellUtils.java b/shell/src/main/java/alluxio/cli/fs/FileSystemShellUtils.java
index 08d638ba77..394b4f2e67 100644
--- a/shell/src/main/java/alluxio/cli/fs/FileSystemShellUtils.java
+++ b/shell/src/main/java/alluxio/cli/fs/FileSystemShellUtils.java
@@ -12,9 +12,9 @@
 package alluxio.cli.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
@@ -52,8 +52,8 @@ public final class FileSystemShellUtils {
    * @param path the path to obtain the local path from
    * @return the local path in string format
    */
-  public static String getFilePath(String path) throws IOException {
-    path = validatePath(path);
+  public static String getFilePath(String path, AlluxioConfiguration conf) throws IOException {
+    path = validatePath(path, conf);
     if (path.startsWith(Constants.HEADER)) {
       path = path.substring(Constants.HEADER.length());
     } else if (path.startsWith(Constants.HEADER_FT)) {
@@ -71,7 +71,7 @@ public final class FileSystemShellUtils {
    *         part is provided, the host and port are retrieved from property,
    *         alluxio.master.hostname and alluxio.master.port, respectively.
    */
-  public static String validatePath(String path) throws IOException {
+  public static String validatePath(String path, AlluxioConfiguration conf) throws IOException {
     if (path.startsWith(Constants.HEADER) || path.startsWith(Constants.HEADER_FT)) {
       if (!path.contains(":")) {
         throw new IOException("Invalid Path: " + path + ". Use " + Constants.HEADER
@@ -80,9 +80,9 @@ public final class FileSystemShellUtils {
         return path;
       }
     } else {
-      String hostname = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC);
-      int port =  Configuration.getInt(PropertyKey.MASTER_RPC_PORT);
-      if (Configuration.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
+      String hostname = NetworkAddressUtils.getConnectHost(ServiceType.MASTER_RPC, conf);
+      int port =  conf.getInt(PropertyKey.MASTER_RPC_PORT);
+      if (conf.getBoolean(PropertyKey.ZOOKEEPER_ENABLED)) {
         return PathUtils.concatPath(Constants.HEADER_FT + hostname + ":" + port, path);
       }
       return PathUtils.concatPath(Constants.HEADER + hostname + ":" + port, path);
diff --git a/shell/src/main/java/alluxio/cli/fs/command/AbstractFileSystemCommand.java b/shell/src/main/java/alluxio/cli/fs/command/AbstractFileSystemCommand.java
index c38585fe41..39f4df4c26 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/AbstractFileSystemCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/AbstractFileSystemCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.cli.Command;
 import alluxio.cli.fs.FileSystemShellUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 
 import com.google.common.base.Joiner;
@@ -34,9 +35,11 @@ import java.util.List;
 public abstract class AbstractFileSystemCommand implements Command {
 
   protected FileSystem mFileSystem;
+  protected AlluxioConfiguration mConfiguration;
 
-  protected AbstractFileSystemCommand(FileSystem fs) {
+  protected AbstractFileSystemCommand(FileSystem fs, AlluxioConfiguration alluxioConf) {
     mFileSystem = fs;
+    mConfiguration = alluxioConf;
   }
 
   /**
diff --git a/shell/src/main/java/alluxio/cli/fs/command/CatCommand.java b/shell/src/main/java/alluxio/cli/fs/command/CatCommand.java
index 4abde4ef9e..869ef04771 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/CatCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/CatCommand.java
@@ -17,6 +17,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileDoesNotExistException;
@@ -37,8 +38,8 @@ public final class CatCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public CatCommand(FileSystem fs) {
-    super(fs);
+  public CatCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/CheckConsistencyCommand.java b/shell/src/main/java/alluxio/cli/fs/command/CheckConsistencyCommand.java
index 901b55e1c2..143c37eee9 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/CheckConsistencyCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/CheckConsistencyCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemUtils;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.CheckConsistencyPOptions;
@@ -45,8 +46,8 @@ public class CheckConsistencyCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public CheckConsistencyCommand(FileSystem fs) {
-    super(fs);
+  public CheckConsistencyCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/ChecksumCommand.java b/shell/src/main/java/alluxio/cli/fs/command/ChecksumCommand.java
index 263b1a3cce..006571ae68 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/ChecksumCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/ChecksumCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileDoesNotExistException;
@@ -39,8 +40,8 @@ public final class ChecksumCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public ChecksumCommand(FileSystem fs) {
-    super(fs);
+  public ChecksumCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/ChgrpCommand.java b/shell/src/main/java/alluxio/cli/fs/command/ChgrpCommand.java
index b9eacc367a..31d3e21139 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/ChgrpCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/ChgrpCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.SetAttributePOptions;
@@ -46,8 +47,8 @@ public final class ChgrpCommand extends AbstractFileSystemCommand {
    *
    * @param fs an Alluxio file system handle
    */
-  public ChgrpCommand(FileSystem fs) {
-    super(fs);
+  public ChgrpCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/ChmodCommand.java b/shell/src/main/java/alluxio/cli/fs/command/ChmodCommand.java
index 8baa1d07cf..d173bfa699 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/ChmodCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/ChmodCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.SetAttributePOptions;
@@ -48,8 +49,8 @@ public final class ChmodCommand extends AbstractFileSystemCommand {
    *
    * @param fs an Alluxio file system handle
    */
-  public ChmodCommand(FileSystem fs) {
-    super(fs);
+  public ChmodCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/ChownCommand.java b/shell/src/main/java/alluxio/cli/fs/command/ChownCommand.java
index 4ac995077f..968ee6714e 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/ChownCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/ChownCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.SetAttributePOptions;
@@ -49,8 +50,8 @@ public final class ChownCommand extends AbstractFileSystemCommand {
    *
    * @param fs an Alluxio file system handle
    */
-  public ChownCommand(FileSystem fs) {
-    super(fs);
+  public ChownCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/CopyFromLocalCommand.java b/shell/src/main/java/alluxio/cli/fs/command/CopyFromLocalCommand.java
index f3966b5800..491db3dd29 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/CopyFromLocalCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/CopyFromLocalCommand.java
@@ -13,6 +13,7 @@ package alluxio.cli.fs.command;
 
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -35,9 +36,9 @@ public final class CopyFromLocalCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public CopyFromLocalCommand(FileSystem fs) {
-    super(fs);
-    mCpCommand = new CpCommand(fs);
+  public CopyFromLocalCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
+    mCpCommand = new CpCommand(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/CopyToLocalCommand.java b/shell/src/main/java/alluxio/cli/fs/command/CopyToLocalCommand.java
index 52dada9f4c..f6777df176 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/CopyToLocalCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/CopyToLocalCommand.java
@@ -13,6 +13,7 @@ package alluxio.cli.fs.command;
 
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -34,9 +35,9 @@ public final class CopyToLocalCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public CopyToLocalCommand(FileSystem fs) {
-    super(fs);
-    mCpCommand = new CpCommand(fs);
+  public CopyToLocalCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
+    mCpCommand = new CpCommand(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/CountCommand.java b/shell/src/main/java/alluxio/cli/fs/command/CountCommand.java
index e82a24b54f..5a06ace891 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/CountCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/CountCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -34,8 +35,8 @@ public final class CountCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public CountCommand(FileSystem fs) {
-    super(fs);
+  public CountCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/CpCommand.java b/shell/src/main/java/alluxio/cli/fs/command/CpCommand.java
index 2627b3db7b..024f118527 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/CpCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/CpCommand.java
@@ -12,9 +12,9 @@
 package alluxio.cli.fs.command;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
@@ -66,8 +66,8 @@ public final class CpCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public CpCommand(FileSystem fs) {
-    super(fs);
+  public CpCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -403,7 +403,7 @@ public final class CpCommand extends AbstractFileSystemCommand {
       try (Closer closer = Closer.create()) {
         CreateFilePOptions createOptions = CreateFilePOptions.newBuilder()
             .setFileWriteLocationPolicy(
-                Configuration.get(PropertyKey.USER_FILE_COPY_FROM_LOCAL_WRITE_LOCATION_POLICY))
+                mConfiguration.get(PropertyKey.USER_FILE_COPY_FROM_LOCAL_WRITE_LOCATION_POLICY))
             .build();
         os = closer.register(mFileSystem.createFile(dstPath, createOptions));
         FileInputStream in = closer.register(new FileInputStream(src));
diff --git a/shell/src/main/java/alluxio/cli/fs/command/DistributedLoadCommand.java b/shell/src/main/java/alluxio/cli/fs/command/DistributedLoadCommand.java
index 1700bf417a..f656e7bdad 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/DistributedLoadCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/DistributedLoadCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.client.job.JobGrpcClientUtils;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.job.load.LoadConfig;
@@ -41,8 +42,8 @@ public final class DistributedLoadCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public DistributedLoadCommand(FileSystem fs) {
-    super(fs);
+  public DistributedLoadCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -101,7 +102,7 @@ public final class DistributedLoadCommand extends AbstractFileSystemCommand {
       Thread thread = JobGrpcClientUtils.createProgressThread(System.out);
       thread.start();
       try {
-        JobGrpcClientUtils.run(new LoadConfig(filePath.getPath(), replication), 3);
+        JobGrpcClientUtils.run(new LoadConfig(filePath.getPath(), replication), 3, mConfiguration);
       } finally {
         thread.interrupt();
       }
diff --git a/shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java b/shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java
index 7b1d535069..b61f8ef20c 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/DistributedMvCommand.java
@@ -16,6 +16,7 @@ import alluxio.Constants;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.job.JobGrpcClientUtils;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.job.move.MoveConfig;
@@ -35,8 +36,8 @@ public final class DistributedMvCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public DistributedMvCommand(FileSystem fs) {
-    super(fs);
+  public DistributedMvCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -60,7 +61,8 @@ public final class DistributedMvCommand extends AbstractFileSystemCommand {
     Thread thread = JobGrpcClientUtils.createProgressThread(2 * Constants.SECOND_MS, System.out);
     thread.start();
     try {
-      JobGrpcClientUtils.run(new MoveConfig(srcPath.getPath(), dstPath.getPath(), null, true), 3);
+      JobGrpcClientUtils.run(new MoveConfig(srcPath.getPath(), dstPath.getPath(), null, true),
+      3, mConfiguration);
     } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
       return -1;
diff --git a/shell/src/main/java/alluxio/cli/fs/command/DuCommand.java b/shell/src/main/java/alluxio/cli/fs/command/DuCommand.java
index 6b08c96477..7d268b1ffc 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/DuCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/DuCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.ListStatusPOptions;
@@ -67,8 +68,8 @@ public final class DuCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public DuCommand(FileSystem fs) {
-    super(fs);
+  public DuCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -99,7 +100,7 @@ public final class DuCommand extends AbstractFileSystemCommand {
   /**
    * Gets and prints the size information of the input path according to options.
    *
-   * @param path the path to get size info of
+   * @param path the path to create size info of
    * @param statuses the statuses of files and folders
    * @param readable whether to print info of human readable format
    * @param summarize whether to display the aggregate summary lengths
@@ -143,10 +144,10 @@ public final class DuCommand extends AbstractFileSystemCommand {
 
   /**
    * Gets the size and its percentage information, if readable option is provided,
-   * get the size in human readable format.
+   * create the size in human readable format.
    *
    * @param readable whether to print info of human readable format
-   * @param size the size to get information from
+   * @param size the size to create information from
    * @param totalSize the total size to calculate percentage information
    * @return the formatted value and percentage information
    */
diff --git a/shell/src/main/java/alluxio/cli/fs/command/FileInfoCommand.java b/shell/src/main/java/alluxio/cli/fs/command/FileInfoCommand.java
index 9473acb600..b13d9a3640 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/FileInfoCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/FileInfoCommand.java
@@ -13,6 +13,7 @@ package alluxio.cli.fs.command;
 
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import org.apache.commons.cli.CommandLine;
@@ -30,8 +31,8 @@ public final class FileInfoCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public FileInfoCommand(FileSystem fs) {
-    super(fs);
+  public FileInfoCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/FreeCommand.java b/shell/src/main/java/alluxio/cli/fs/command/FreeCommand.java
index 018132bce6..76dbe19e51 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/FreeCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/FreeCommand.java
@@ -12,8 +12,8 @@
 package alluxio.cli.fs.command;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.exception.AlluxioException;
@@ -51,8 +51,8 @@ public final class FreeCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public FreeCommand(FileSystem fs) {
-    super(fs);
+  public FreeCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -69,7 +69,7 @@ public final class FreeCommand extends AbstractFileSystemCommand {
   protected void runPlainPath(AlluxioURI path, CommandLine cl)
       throws AlluxioException, IOException {
     int interval =
-        Math.toIntExact(Configuration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS));
+        Math.toIntExact(mConfiguration.getMs(PropertyKey.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS));
     FreePOptions options =
         FreePOptions.newBuilder().setRecursive(true).setForced(cl.hasOption("f")).build();
     mFileSystem.free(path, options);
diff --git a/shell/src/main/java/alluxio/cli/fs/command/GetCapacityBytesCommand.java b/shell/src/main/java/alluxio/cli/fs/command/GetCapacityBytesCommand.java
index 918dcd4333..f1c0b27f77 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/GetCapacityBytesCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/GetCapacityBytesCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.cli.CommandUtils;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import org.apache.commons.cli.CommandLine;
@@ -28,12 +29,12 @@ import javax.annotation.concurrent.ThreadSafe;
 @ThreadSafe
 public final class GetCapacityBytesCommand extends AbstractFileSystemCommand {
   /**
-   * Constructs a new instance to get the capacity of the {@link FileSystem}.
+   * Constructs a new instance to create the capacity of the {@link FileSystem}.
    *
    * @param fs the filesystem of Alluxio
    */
-  public GetCapacityBytesCommand(FileSystem fs) {
-    super(fs);
+  public GetCapacityBytesCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -48,7 +49,7 @@ public final class GetCapacityBytesCommand extends AbstractFileSystemCommand {
 
   @Override
   public int run(CommandLine cl) throws IOException {
-    AlluxioBlockStore alluxioBlockStore = AlluxioBlockStore.create();
+    AlluxioBlockStore alluxioBlockStore = AlluxioBlockStore.create(mConfiguration);
     long capacityBytes = alluxioBlockStore.getCapacityBytes();
     System.out.println("Capacity Bytes: " + capacityBytes);
     return 0;
diff --git a/shell/src/main/java/alluxio/cli/fs/command/GetFaclCommand.java b/shell/src/main/java/alluxio/cli/fs/command/GetFaclCommand.java
index 9933b7bf48..8a72f2e877 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/GetFaclCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/GetFaclCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -33,8 +34,8 @@ public final class GetFaclCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public GetFaclCommand(FileSystem fs) {
-    super(fs);
+  public GetFaclCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/GetUsedBytesCommand.java b/shell/src/main/java/alluxio/cli/fs/command/GetUsedBytesCommand.java
index 54f7528f64..8c4b07a720 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/GetUsedBytesCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/GetUsedBytesCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.cli.CommandUtils;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import org.apache.commons.cli.CommandLine;
@@ -28,12 +29,12 @@ import javax.annotation.concurrent.ThreadSafe;
 @ThreadSafe
 public final class GetUsedBytesCommand extends AbstractFileSystemCommand {
   /**
-   * Constructs a new instance to get the number of bytes used in the {@link FileSystem}.
+   * Constructs a new instance to create the number of bytes used in the {@link FileSystem}.
    *
    * @param fs the filesystem of Alluxio
    */
-  public GetUsedBytesCommand(FileSystem fs) {
-    super(fs);
+  public GetUsedBytesCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -48,7 +49,7 @@ public final class GetUsedBytesCommand extends AbstractFileSystemCommand {
 
   @Override
   public int run(CommandLine cl) throws IOException {
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create();
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mConfiguration);
     long usedBytes = blockStore.getUsedBytes();
     System.out.println("Used Bytes: " + usedBytes);
     return 0;
diff --git a/shell/src/main/java/alluxio/cli/fs/command/HeadCommand.java b/shell/src/main/java/alluxio/cli/fs/command/HeadCommand.java
index 200c14db87..3126ff0ea3 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/HeadCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/HeadCommand.java
@@ -17,6 +17,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.InvalidArgumentException;
@@ -48,8 +49,8 @@ public final class HeadCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public HeadCommand(FileSystem fs) {
-    super(fs);
+  public HeadCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/HelpCommand.java b/shell/src/main/java/alluxio/cli/fs/command/HelpCommand.java
index 71bf468c2b..bbb507e381 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/HelpCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/HelpCommand.java
@@ -15,6 +15,7 @@ import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
 import alluxio.cli.fs.FileSystemShellUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -65,8 +66,8 @@ public final class HelpCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public HelpCommand(FileSystem fs) {
-    super(fs);
+  public HelpCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/LeaderCommand.java b/shell/src/main/java/alluxio/cli/fs/command/LeaderCommand.java
index 184211e6cd..78040ef066 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/LeaderCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/LeaderCommand.java
@@ -15,6 +15,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.FileSystemMasterClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterInquireClient;
@@ -39,8 +40,8 @@ public final class LeaderCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public LeaderCommand(FileSystem fs) {
-    super(fs);
+  public LeaderCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -56,14 +57,14 @@ public final class LeaderCommand extends AbstractFileSystemCommand {
   @Override
   public int run(CommandLine cl) {
     try (CloseableResource<FileSystemMasterClient> client =
-        FileSystemContext.get().acquireMasterClientResource()) {
+        FileSystemContext.create().acquireMasterClientResource()) {
       try {
         InetSocketAddress address = client.get().getAddress();
         System.out.println(address.getHostName());
 
         List<InetSocketAddress> addresses = Arrays.asList(address);
         MasterInquireClient inquireClient = new PollingMasterInquireClient(addresses, () ->
-                new ExponentialBackoffRetry(50, 100, 2)
+                new ExponentialBackoffRetry(50, 100, 2), mConfiguration
         );
         try {
           inquireClient.getPrimaryRpcAddress();
@@ -71,7 +72,7 @@ public final class LeaderCommand extends AbstractFileSystemCommand {
           System.err.println("The leader is not currently serving requests.");
         }
       } catch (UnavailableException e) {
-        System.err.println("Failed to get the leader master.");
+        System.err.println("Failed to create the leader master.");
       }
     }
     return 0;
diff --git a/shell/src/main/java/alluxio/cli/fs/command/LoadCommand.java b/shell/src/main/java/alluxio/cli/fs/command/LoadCommand.java
index d311134b0e..6fed90004f 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/LoadCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/LoadCommand.java
@@ -18,6 +18,7 @@ import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.OpenFilePOptions;
@@ -51,8 +52,8 @@ public final class LoadCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public LoadCommand(FileSystem fs) {
-    super(fs);
+  public LoadCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -99,7 +100,7 @@ public final class LoadCommand extends AbstractFileSystemCommand {
       OpenFilePOptions options =
           OpenFilePOptions.newBuilder().setReadType(ReadPType.CACHE_PROMOTE).build();
       if (local) {
-        if (!FileSystemContext.get().hasLocalWorker()) {
+        if (!FileSystemContext.create().hasLocalWorker()) {
           System.out.println("When local option is specified,"
               + " there must be a local worker available");
           return;
diff --git a/shell/src/main/java/alluxio/cli/fs/command/LoadMetadataCommand.java b/shell/src/main/java/alluxio/cli/fs/command/LoadMetadataCommand.java
index 0984ba6866..f17622bc2d 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/LoadMetadataCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/LoadMetadataCommand.java
@@ -13,6 +13,7 @@ package alluxio.cli.fs.command;
 
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import org.apache.commons.cli.CommandLine;
@@ -35,8 +36,8 @@ public final class LoadMetadataCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public LoadMetadataCommand(FileSystem fs) {
-    super(fs);
+  public LoadMetadataCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/LocationCommand.java b/shell/src/main/java/alluxio/cli/fs/command/LocationCommand.java
index c688077b7c..3a1b543439 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/LocationCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/LocationCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.wire.BlockLocation;
@@ -37,8 +38,8 @@ public final class LocationCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public LocationCommand(FileSystem fs) {
-    super(fs);
+  public LocationCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -52,7 +53,7 @@ public final class LocationCommand extends AbstractFileSystemCommand {
     URIStatus status = mFileSystem.getStatus(plainPath);
 
     System.out.println(plainPath + " with file id " + status.getFileId() + " is on nodes: ");
-    AlluxioBlockStore blockStore = AlluxioBlockStore.create();
+    AlluxioBlockStore blockStore = AlluxioBlockStore.create(mConfiguration);
     for (long blockId : status.getBlockIds()) {
       for (BlockLocation location : blockStore.getInfo(blockId).getLocations()) {
         System.out.println(location.getWorkerAddress().getHost());
diff --git a/shell/src/main/java/alluxio/cli/fs/command/LsCommand.java b/shell/src/main/java/alluxio/cli/fs/command/LsCommand.java
index 540772e525..e672090269 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/LsCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/LsCommand.java
@@ -15,6 +15,8 @@ import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.InvalidArgumentException;
@@ -146,7 +148,7 @@ public final class LsCommand extends AbstractFileSystemCommand {
   public static String formatLsString(boolean hSize, boolean acl, boolean isFolder, String
       permission,
       String userName, String groupName, long size, long lastModifiedTime, int inAlluxioPercentage,
-      String persistenceState, String path) {
+      String persistenceState, String path, String dateFormatPattern) {
     String inAlluxioState;
     String sizeStr;
     if (isFolder) {
@@ -159,11 +161,12 @@ public final class LsCommand extends AbstractFileSystemCommand {
 
     if (acl) {
       return String.format(LS_FORMAT, permission, userName, groupName,
-          sizeStr, persistenceState, CommonUtils.convertMsToDate(lastModifiedTime),
+          sizeStr, persistenceState, CommonUtils.convertMsToDate(lastModifiedTime, dateFormatPattern),
           inAlluxioState, path);
     } else {
       return String.format(LS_FORMAT_NO_ACL, sizeStr,
-          persistenceState, CommonUtils.convertMsToDate(lastModifiedTime), inAlluxioState, path);
+          persistenceState, CommonUtils.convertMsToDate(lastModifiedTime, dateFormatPattern), inAlluxioState,
+          path);
     }
   }
 
@@ -172,11 +175,13 @@ public final class LsCommand extends AbstractFileSystemCommand {
     boolean hasExtended = status.getAcl().hasExtended()
         || !status.getDefaultAcl().isEmpty();
 
-    System.out.print(formatLsString(hSize, SecurityUtils.isSecurityEnabled(), status.isFolder(),
+    System.out.print(formatLsString(hSize, SecurityUtils.isSecurityEnabled(mConfiguration),
+        status.isFolder(),
         FormatUtils.formatMode((short) status.getMode(), status.isFolder(), hasExtended),
         status.getOwner(), status.getGroup(), status.getLength(),
         status.getLastModificationTimeMs(), status.getInAlluxioPercentage(),
-        status.getPersistenceState(), status.getPath()));
+        status.getPersistenceState(), status.getPath(),
+        mConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN)));
   }
 
   /**
@@ -185,8 +190,8 @@ public final class LsCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public LsCommand(FileSystem fs) {
-    super(fs);
+  public LsCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/MasterInfoCommand.java b/shell/src/main/java/alluxio/cli/fs/command/MasterInfoCommand.java
index 95255713c5..317dcbc059 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/MasterInfoCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/MasterInfoCommand.java
@@ -13,6 +13,7 @@ package alluxio.cli.fs.command;
 
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterInquireClient;
@@ -33,8 +34,8 @@ public final class MasterInfoCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the {@link FileSystem}
    */
-  public MasterInfoCommand(FileSystem fs) {
-    super(fs);
+  public MasterInfoCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -49,7 +50,7 @@ public final class MasterInfoCommand extends AbstractFileSystemCommand {
 
   @Override
   public int run(CommandLine cl) {
-    MasterInquireClient inquireClient = MasterInquireClient.Factory.create();
+    MasterInquireClient inquireClient = MasterInquireClient.Factory.create(mConfiguration);
     try {
       InetSocketAddress leaderAddress = inquireClient.getPrimaryRpcAddress();
       System.out.println("Current leader master: " + leaderAddress.toString());
diff --git a/shell/src/main/java/alluxio/cli/fs/command/MkdirCommand.java b/shell/src/main/java/alluxio/cli/fs/command/MkdirCommand.java
index cf95c01fa9..39ec5aaa96 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/MkdirCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/MkdirCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.CreateDirectoryPOptions;
@@ -36,8 +37,8 @@ public final class MkdirCommand extends AbstractFileSystemCommand {
    *
    * @param fs the filesystem of Alluxio
    */
-  public MkdirCommand(FileSystem fs) {
-    super(fs);
+  public MkdirCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/MountCommand.java b/shell/src/main/java/alluxio/cli/fs/command/MountCommand.java
index da6eee2a41..42f81d83bb 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/MountCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/MountCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.fsadmin.report.UfsCommand;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.MountPOptions;
@@ -64,8 +65,8 @@ public final class MountCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public MountCommand(FileSystem fs) {
-    super(fs);
+  public MountCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/MvCommand.java b/shell/src/main/java/alluxio/cli/fs/command/MvCommand.java
index 48f492ead3..2dd1db8ffb 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/MvCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/MvCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -32,8 +33,8 @@ public final class MvCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public MvCommand(FileSystem fs) {
-    super(fs);
+  public MvCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/PersistCommand.java b/shell/src/main/java/alluxio/cli/fs/command/PersistCommand.java
index 3bfbccce55..409b64d85d 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/PersistCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/PersistCommand.java
@@ -17,6 +17,7 @@ import alluxio.cli.fs.FileSystemShellUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemUtils;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.util.ThreadFactoryUtils;
@@ -60,8 +61,8 @@ public final class PersistCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public PersistCommand(FileSystem fs) {
-    super(fs);
+  public PersistCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/PinCommand.java b/shell/src/main/java/alluxio/cli/fs/command/PinCommand.java
index 84719a3571..c49906c2dd 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/PinCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/PinCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -33,8 +34,8 @@ public final class PinCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public PinCommand(FileSystem fs) {
-    super(fs);
+  public PinCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/RmCommand.java b/shell/src/main/java/alluxio/cli/fs/command/RmCommand.java
index 5822ff63e8..5213a2855f 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/RmCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/RmCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileDoesNotExistException;
@@ -60,8 +61,8 @@ public final class RmCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public RmCommand(FileSystem fs) {
-    super(fs);
+  public RmCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/SetFaclCommand.java b/shell/src/main/java/alluxio/cli/fs/command/SetFaclCommand.java
index 4d717a880e..bb07e1a803 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/SetFaclCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/SetFaclCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.SetAclPOptions;
@@ -80,8 +81,8 @@ public final class SetFaclCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public SetFaclCommand(FileSystem fs) {
-    super(fs);
+  public SetFaclCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/SetReplicationCommand.java b/shell/src/main/java/alluxio/cli/fs/command/SetReplicationCommand.java
index 5f00cdfbbf..6d014d11fb 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/SetReplicationCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/SetReplicationCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.SetAttributePOptions;
@@ -45,8 +46,8 @@ public final class SetReplicationCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public SetReplicationCommand(FileSystem fs) {
-    super(fs);
+  public SetReplicationCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/SetTtlCommand.java b/shell/src/main/java/alluxio/cli/fs/command/SetTtlCommand.java
index 87ab084a61..b3ab0b03db 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/SetTtlCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/SetTtlCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.cli.fs.FileSystemShellUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.util.CommonUtils;
@@ -51,8 +52,8 @@ public final class SetTtlCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public SetTtlCommand(FileSystem fs) {
-    super(fs);
+  public SetTtlCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/StatCommand.java b/shell/src/main/java/alluxio/cli/fs/command/StatCommand.java
index 9b67ffc564..08b9f60c1a 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/StatCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/StatCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -43,8 +44,8 @@ public final class StatCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public StatCommand(FileSystem fs) {
-    super(fs);
+  public StatCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
@@ -76,7 +77,7 @@ public final class StatCommand extends AbstractFileSystemCommand {
       } else {
         System.out.println(path + " is a file path.");
         System.out.println(status);
-        AlluxioBlockStore blockStore = AlluxioBlockStore.create();
+        AlluxioBlockStore blockStore = AlluxioBlockStore.create(mConfiguration);
         List<Long> blockIds = status.getBlockIds();
         if (blockIds.isEmpty()) {
           System.out.println("This file does not contain any blocks.");
diff --git a/shell/src/main/java/alluxio/cli/fs/command/TailCommand.java b/shell/src/main/java/alluxio/cli/fs/command/TailCommand.java
index 9ff9a3a9ad..23ad53fd72 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/TailCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/TailCommand.java
@@ -17,6 +17,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.InvalidArgumentException;
@@ -46,8 +47,8 @@ public final class TailCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public TailCommand(FileSystem fs) {
-    super(fs);
+  public TailCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/TestCommand.java b/shell/src/main/java/alluxio/cli/fs/command/TestCommand.java
index d33bd6331e..695eeef8d6 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/TestCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/TestCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -66,8 +67,8 @@ public final class TestCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public TestCommand(FileSystem fs) {
-    super(fs);
+  public TestCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/TouchCommand.java b/shell/src/main/java/alluxio/cli/fs/command/TouchCommand.java
index f7bc697d21..674c10a050 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/TouchCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/TouchCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -32,8 +33,8 @@ public final class TouchCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public TouchCommand(FileSystem fs) {
-    super(fs);
+  public TouchCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/UnmountCommand.java b/shell/src/main/java/alluxio/cli/fs/command/UnmountCommand.java
index 479a8b9268..2be4760d4e 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/UnmountCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/UnmountCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -32,8 +33,8 @@ public final class UnmountCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public UnmountCommand(FileSystem fs) {
-    super(fs);
+  public UnmountCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/UnpinCommand.java b/shell/src/main/java/alluxio/cli/fs/command/UnpinCommand.java
index c9504321b1..55c4b906f5 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/UnpinCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/UnpinCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 
@@ -33,8 +34,8 @@ public final class UnpinCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public UnpinCommand(FileSystem fs) {
-    super(fs);
+  public UnpinCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fs/command/UnsetTtlCommand.java b/shell/src/main/java/alluxio/cli/fs/command/UnsetTtlCommand.java
index 2ba22048e1..92fe503e0f 100644
--- a/shell/src/main/java/alluxio/cli/fs/command/UnsetTtlCommand.java
+++ b/shell/src/main/java/alluxio/cli/fs/command/UnsetTtlCommand.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.Constants;
 import alluxio.cli.CommandUtils;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.grpc.TtlAction;
@@ -34,8 +35,8 @@ public final class UnsetTtlCommand extends AbstractFileSystemCommand {
   /**
    * @param fs the filesystem of Alluxio
    */
-  public UnsetTtlCommand(FileSystem fs) {
-    super(fs);
+  public UnsetTtlCommand(FileSystem fs, AlluxioConfiguration conf) {
+    super(fs, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShell.java b/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShell.java
index bce522ac64..403ef71168 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShell.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShell.java
@@ -11,8 +11,8 @@
 
 package alluxio.cli.fsadmin;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.AbstractShell;
 import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
@@ -43,8 +43,8 @@ public final class FileSystemAdminShell extends AbstractShell {
   /**
    * Construct a new instance of {@link FileSystemAdminShell}.
    */
-  public FileSystemAdminShell() {
-    super(null);
+  public FileSystemAdminShell(InstancedConfiguration conf) {
+    super(null, conf);
   }
 
   /**
@@ -53,13 +53,14 @@ public final class FileSystemAdminShell extends AbstractShell {
    * @param args array of arguments given by the user's input from the terminal
    */
   public static void main(String[] args) {
-    if (!ConfigurationUtils.masterHostConfigured() && args.length > 0) {
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    if (!ConfigurationUtils.masterHostConfigured(conf) && args.length > 0) {
       System.out.println("Cannot run alluxio fsadmin shell as master hostname is not configured.");
       System.exit(1);
     }
     // Reduce the RPC retry max duration to fall earlier for CLIs
-    Configuration.set(PropertyKey.USER_RPC_RETRY_MAX_DURATION, "5s", Source.DEFAULT);
-    FileSystemAdminShell fsAdminShell = new FileSystemAdminShell();
+    conf.set(PropertyKey.USER_RPC_RETRY_MAX_DURATION, "5s", Source.DEFAULT);
+    FileSystemAdminShell fsAdminShell = new FileSystemAdminShell(conf);
     System.exit(fsAdminShell.run(args));
   }
 
@@ -71,9 +72,9 @@ public final class FileSystemAdminShell extends AbstractShell {
   @Override
   protected Map<String, Command> loadCommands() {
     Context context = new Context(
-        new RetryHandlingFileSystemMasterClient(MasterClientConfig.defaults()),
-        new RetryHandlingBlockMasterClient(MasterClientConfig.defaults()),
-        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults()),
+        new RetryHandlingFileSystemMasterClient(MasterClientConfig.defaults(mConfiguration), mConfiguration),
+        new RetryHandlingBlockMasterClient(MasterClientConfig.defaults(mConfiguration), mConfiguration),
+        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults(mConfiguration), mConfiguration),
         System.out
     );
     return CommandUtils.loadCommands(FileSystemAdminShell.class.getPackage().getName(),
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShellUtils.java b/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShellUtils.java
index 06773f9d50..c421401366 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShellUtils.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/FileSystemAdminShellUtils.java
@@ -13,6 +13,7 @@ package alluxio.cli.fsadmin;
 
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.FileSystemMasterClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterInquireClient;
 import alluxio.master.PollingMasterInquireClient;
@@ -51,15 +52,14 @@ public final class FileSystemAdminShellUtils {
    * Checks if the master client service is available.
    * Throws an exception if fails to determine that the master client service is running.
    */
-  public static void checkMasterClientService() throws IOException {
+  public static void checkMasterClientService(AlluxioConfiguration conf) throws IOException {
     try (CloseableResource<FileSystemMasterClient> client =
-      FileSystemContext.get().acquireMasterClientResource()) {
+      FileSystemContext.create().acquireMasterClientResource()) {
       InetSocketAddress address = client.get().getAddress();
 
       List<InetSocketAddress> addresses = Arrays.asList(address);
       MasterInquireClient inquireClient = new PollingMasterInquireClient(addresses, () ->
-          new ExponentialBackoffRetry(50, 100, 2)
-      );
+          new ExponentialBackoffRetry(50, 100, 2), conf);
       inquireClient.getPrimaryRpcAddress();
     } catch (UnavailableException e) {
       throw new IOException("Cannot connect to Alluxio leader master.");
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/command/DoctorCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/command/DoctorCommand.java
index 7fb2917872..3463b95e24 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/command/DoctorCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/command/DoctorCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fsadmin.command;
 import alluxio.cli.CommandUtils;
 import alluxio.cli.fsadmin.FileSystemAdminShellUtils;
 import alluxio.cli.fsadmin.doctor.ConfigurationCommand;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -41,11 +42,14 @@ public final class DoctorCommand extends AbstractFsAdminCommand {
     CONFIGURATION, // Show server-side configuration errors/warnings
   }
 
+  private final AlluxioConfiguration mConf;
+
   /**
    * @param context fsadmin command context
    */
-  public DoctorCommand(Context context) {
+  public DoctorCommand(Context context, AlluxioConfiguration conf) {
     super(context);
+    mConf = conf;
   }
 
   @Override
@@ -63,7 +67,7 @@ public final class DoctorCommand extends AbstractFsAdminCommand {
       return 0;
     }
 
-    FileSystemAdminShellUtils.checkMasterClientService();
+    FileSystemAdminShellUtils.checkMasterClientService(mConf);
 
     // Get the doctor category
     Command command = Command.ALL;
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/command/ReportCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/command/ReportCommand.java
index 6d4981cd12..cb437a973d 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/command/ReportCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/command/ReportCommand.java
@@ -17,6 +17,8 @@ import alluxio.cli.fsadmin.report.CapacityCommand;
 import alluxio.cli.fsadmin.report.MetricsCommand;
 import alluxio.cli.fsadmin.report.SummaryCommand;
 import alluxio.cli.fsadmin.report.UfsCommand;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.InvalidArgumentException;
 
 import com.google.common.annotations.VisibleForTesting;
@@ -70,11 +72,14 @@ public final class ReportCommand extends AbstractFsAdminCommand {
     UFS // Report under filesystem information
   }
 
+  private AlluxioConfiguration mConf;
+
   /**
    * @param context fsadmin command context
    */
-  public ReportCommand(Context context) {
+  public ReportCommand(Context context, AlluxioConfiguration conf) {
     super(context);
+    mConf = conf;
   }
 
   @Override
@@ -94,7 +99,7 @@ public final class ReportCommand extends AbstractFsAdminCommand {
       return 0;
     }
 
-    FileSystemAdminShellUtils.checkMasterClientService();
+    FileSystemAdminShellUtils.checkMasterClientService(mConf);
 
     // Get the report category
     Command command = Command.SUMMARY;
@@ -141,7 +146,8 @@ public final class ReportCommand extends AbstractFsAdminCommand {
         break;
       case SUMMARY:
         SummaryCommand summaryCommand = new SummaryCommand(
-            mMetaClient, mBlockClient, mPrintStream);
+            mMetaClient, mBlockClient, mConf.get(PropertyKey.USER_DATE_FORMAT_PATTERN),
+            mPrintStream);
         summaryCommand.run();
         break;
       case UFS:
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/doctor/ConfigurationCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/doctor/ConfigurationCommand.java
index f1a7833dcc..ceea683bbc 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/doctor/ConfigurationCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/doctor/ConfigurationCommand.java
@@ -33,7 +33,7 @@ public class ConfigurationCommand {
   /**
    * Creates a new instance of {@link ConfigurationCommand}.
    *
-   * @param metaMasterClient client to get server-side configuration report information
+   * @param metaMasterClient client to create server-side configuration report information
    * @param printStream stream to print configuration errors/warnings to
    */
   public ConfigurationCommand(MetaMasterClient metaMasterClient, PrintStream printStream) {
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/report/CapacityCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/report/CapacityCommand.java
index 18dae34861..1aefc4f3c3 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/report/CapacityCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/report/CapacityCommand.java
@@ -67,7 +67,7 @@ public class CapacityCommand {
   /**
    * Runs report capacity command.
    *
-   * @param cl CommandLine to get client options
+   * @param cl CommandLine to create client options
    * @return 0 on success, 1 otherwise
    */
   public int run(CommandLine cl) throws IOException {
@@ -84,7 +84,7 @@ public class CapacityCommand {
   /**
    * Generates capacity report.
    *
-   * @param options GetWorkerReportOptions to get worker report
+   * @param options GetWorkerReportOptions to create worker report
    */
   public void generateCapacityReport(GetWorkerReportOptions options) throws IOException {
     List<WorkerInfo> workerInfoList = mBlockMasterClient.getWorkerReport(options);
@@ -180,7 +180,7 @@ public class CapacityCommand {
   /**
    * Prints worker capacity information.
    *
-   * @param workerInfoList the worker info list to get info from
+   * @param workerInfoList the worker info list to create info from
    */
   private void printWorkerInfo(List<WorkerInfo> workerInfoList) {
     mIndentationLevel = 0;
@@ -222,7 +222,7 @@ public class CapacityCommand {
   /**
    * Prints worker information when only one tier exists.
    *
-   * @param workerInfoList the worker info list to get info from
+   * @param workerInfoList the worker info list to create info from
    */
   private void printShortWorkerInfo(List<WorkerInfo> workerInfoList) {
     String tier = mCapacityTierInfoMap.firstKey();
@@ -248,7 +248,7 @@ public class CapacityCommand {
 
   /**
    * Gets the info format according to the longest worker name.
-   * @param workerInfoList the worker info list to get info from
+   * @param workerInfoList the worker info list to create info from
    * @param isShort whether exists only one tier
    * @return the info format for printing long/short worker info
    */
@@ -270,7 +270,7 @@ public class CapacityCommand {
    * Gets the worker info options.
    *
    * @param cl CommandLine that contains the client options
-   * @return GetWorkerReportOptions to get worker information
+   * @return GetWorkerReportOptions to create worker information
    */
   private GetWorkerReportOptions getOptions(CommandLine cl) throws IOException {
     if (cl.getOptions().length > 1) {
@@ -302,7 +302,7 @@ public class CapacityCommand {
   /**
    * Gets the formatted tier values of a worker.
    *
-   * @param map the map to get worker tier values from
+   * @param map the map to create worker tier values from
    * @param workerName name of the worker
    * @return the formatted tier values of the input worker name
    */
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java
index 376b974f13..9538c2dc56 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/report/MetricsCommand.java
@@ -153,7 +153,7 @@ public class MetricsCommand {
   /**
    * Prints the metrics information.
    *
-   * @param metricName the metric name to get metric value
+   * @param metricName the metric name to create metric value
    * @param nickName the metric name to print
    * @param valueIsBytes whether the metric value is bytes
    */
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/report/SummaryCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/report/SummaryCommand.java
index 5c9f363962..ab1a750818 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/report/SummaryCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/report/SummaryCommand.java
@@ -14,6 +14,7 @@ package alluxio.cli.fsadmin.report;
 import alluxio.cli.fsadmin.FileSystemAdminShellUtils;
 import alluxio.client.block.BlockMasterClient;
 import alluxio.client.MetaMasterClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.MasterInfo;
 import alluxio.grpc.MasterInfoField;
 import alluxio.util.CommonUtils;
@@ -42,6 +43,7 @@ public class SummaryCommand {
   private MetaMasterClient mMetaMasterClient;
   private BlockMasterClient mBlockMasterClient;
   private PrintStream mPrintStream;
+  private final String mDateFormatPattern;
 
   /**
    * Creates a new instance of {@link SummaryCommand}.
@@ -51,10 +53,12 @@ public class SummaryCommand {
    * @param printStream stream to print summary information to
    */
   public SummaryCommand(MetaMasterClient metaMasterClient,
-      BlockMasterClient blockMasterClient, PrintStream printStream) {
+      BlockMasterClient blockMasterClient, String dateFormatPattern, PrintStream printStream) {
     mMetaMasterClient = metaMasterClient;
     mBlockMasterClient = blockMasterClient;
     mPrintStream = printStream;
+    mDateFormatPattern = dateFormatPattern;
+
   }
 
   /**
@@ -84,7 +88,7 @@ public class SummaryCommand {
     print("Master Address: " + masterInfo.getLeaderMasterAddress());
     print("Web Port: " + masterInfo.getWebPort());
     print("Rpc Port: " + masterInfo.getRpcPort());
-    print("Started: " + CommonUtils.convertMsToDate(masterInfo.getStartTimeMs()));
+    print("Started: " + CommonUtils.convertMsToDate(masterInfo.getStartTimeMs(), mDateFormatPattern));
     print("Uptime: " + CommonUtils.convertMsToClockTime(masterInfo.getUpTimeMs()));
     print("Version: " + masterInfo.getVersion());
     print("Safe Mode: " + masterInfo.getSafeMode());
diff --git a/shell/src/main/java/alluxio/cli/fsadmin/report/UfsCommand.java b/shell/src/main/java/alluxio/cli/fsadmin/report/UfsCommand.java
index f95d29c242..14d2d1f3a4 100644
--- a/shell/src/main/java/alluxio/cli/fsadmin/report/UfsCommand.java
+++ b/shell/src/main/java/alluxio/cli/fsadmin/report/UfsCommand.java
@@ -28,7 +28,7 @@ public class UfsCommand {
   /**
    * Creates a new instance of {@link UfsCommand}.
    *
-   * @param fileSystemMasterClient client to get mount table from
+   * @param fileSystemMasterClient client to create mount table from
    */
   public UfsCommand(FileSystemMasterClient fileSystemMasterClient) {
     mFileSystemMasterClient = fileSystemMasterClient;
@@ -49,7 +49,7 @@ public class UfsCommand {
   /**
    * Prints mount information for a mount table.
    *
-   * @param mountTable the mount table to get information from
+   * @param mountTable the mount table to create information from
    */
   public static void printMountInfo(Map<String, MountPointInfo> mountTable) {
     for (Map.Entry<String, MountPointInfo> entry : mountTable.entrySet()) {
@@ -78,7 +78,7 @@ public class UfsCommand {
 
   /**
    * Gets the align format according to the longest mount point/under storage path.
-   * @param mountTable the mount table to get information from
+   * @param mountTable the mount table to create information from
    * @return the align format for printing mounted info
    */
   private static String getAlignFormat(Map<String, MountPointInfo> mountTable) {
diff --git a/shell/src/main/java/alluxio/cli/job/JobShell.java b/shell/src/main/java/alluxio/cli/job/JobShell.java
index a145b86c60..a8c63b9184 100644
--- a/shell/src/main/java/alluxio/cli/job/JobShell.java
+++ b/shell/src/main/java/alluxio/cli/job/JobShell.java
@@ -12,7 +12,9 @@
 package alluxio.cli.job;
 
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.AbstractShell;
 import alluxio.cli.Command;
 import alluxio.cli.CommandUtils;
@@ -45,8 +47,9 @@ public final class JobShell extends AbstractShell {
    */
   public static void main(String[] argv) throws IOException {
     int ret;
+    InstancedConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
 
-    if (!ConfigurationUtils.masterHostConfigured() && argv.length > 0) {
+    if (!ConfigurationUtils.masterHostConfigured(conf) && argv.length > 0) {
       System.out.println(String.format(
           "Cannot run alluxio job shell; master hostname is not "
               + "configured. Please modify %s to either set %s or configure zookeeper with "
@@ -56,7 +59,7 @@ public final class JobShell extends AbstractShell {
       System.exit(1);
     }
 
-    try (JobShell shell = new JobShell()) {
+    try (JobShell shell = new JobShell(conf)) {
       ret = shell.run(argv);
     }
     System.exit(ret);
@@ -65,8 +68,8 @@ public final class JobShell extends AbstractShell {
   /**
    * Creates a new instance of {@link JobShell}.
    */
-  public JobShell() {
-    super(CMD_ALIAS);
+  public JobShell(InstancedConfiguration conf) {
+    super(CMD_ALIAS, conf);
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/cli/job/command/LeaderCommand.java b/shell/src/main/java/alluxio/cli/job/command/LeaderCommand.java
index ec329cb671..05f9d295a0 100644
--- a/shell/src/main/java/alluxio/cli/job/command/LeaderCommand.java
+++ b/shell/src/main/java/alluxio/cli/job/command/LeaderCommand.java
@@ -15,6 +15,7 @@ import alluxio.cli.CommandUtils;
 import alluxio.cli.fs.command.AbstractFileSystemCommand;
 import alluxio.client.file.FileSystem;
 import alluxio.client.job.JobContext;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.InvalidArgumentException;
 
 import org.apache.commons.cli.CommandLine;
@@ -37,8 +38,8 @@ public final class LeaderCommand extends AbstractFileSystemCommand {
    *
    * @param fs the Alluxio filesystem client
    */
-  public LeaderCommand(FileSystem fs) {
-    super(fs);
+  public LeaderCommand(FileSystem fs, AlluxioConfiguration alluxioConf) {
+    super(fs, alluxioConf);
   }
 
   @Override
@@ -54,11 +55,11 @@ public final class LeaderCommand extends AbstractFileSystemCommand {
   @Override
   public int run(CommandLine cl) {
     try {
-      InetSocketAddress address = JobContext.INSTANCE.getJobMasterAddress();
+      InetSocketAddress address = JobContext.create(mConfiguration).getJobMasterAddress();
       System.out.println(address.getHostName());
     } catch (Exception e) {
-      LOG.error("Failed to get the primary job master", e);
-      System.out.println("Failed to get the primary job master.");
+      LOG.error("Failed to create the primary job master", e);
+      System.out.println("Failed to create the primary job master.");
       return -1;
     }
     return 0;
diff --git a/shell/src/main/java/alluxio/cli/job/command/ListCommand.java b/shell/src/main/java/alluxio/cli/job/command/ListCommand.java
index 43398b7cc8..f18827509f 100644
--- a/shell/src/main/java/alluxio/cli/job/command/ListCommand.java
+++ b/shell/src/main/java/alluxio/cli/job/command/ListCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.fs.command.AbstractFileSystemCommand;
 import alluxio.client.file.FileSystem;
 import alluxio.client.job.JobContext;
 import alluxio.client.job.JobMasterClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.InvalidArgumentException;
 import alluxio.resource.CloseableResource;
@@ -41,8 +42,8 @@ public final class ListCommand extends AbstractFileSystemCommand {
    *
    * @param fs the Alluxio filesystem client
    */
-  public ListCommand(FileSystem fs) {
-    super(fs);
+  public ListCommand(FileSystem fs, AlluxioConfiguration alluxioConf) {
+    super(fs, alluxioConf);
   }
 
   @Override
@@ -58,7 +59,7 @@ public final class ListCommand extends AbstractFileSystemCommand {
   @Override
   public int run(CommandLine cl) throws AlluxioException, IOException {
     try (CloseableResource<JobMasterClient> client =
-        JobContext.INSTANCE.acquireMasterClientResource()) {
+        JobContext.create(mConfiguration).acquireMasterClientResource()) {
       List<Long> ids = client.get().list();
       for (long id : ids) {
         System.out.println(id);
diff --git a/shell/src/main/java/alluxio/cli/job/command/StatCommand.java b/shell/src/main/java/alluxio/cli/job/command/StatCommand.java
index 691100e986..866e9e00a7 100644
--- a/shell/src/main/java/alluxio/cli/job/command/StatCommand.java
+++ b/shell/src/main/java/alluxio/cli/job/command/StatCommand.java
@@ -16,6 +16,7 @@ import alluxio.cli.fs.command.AbstractFileSystemCommand;
 import alluxio.client.file.FileSystem;
 import alluxio.client.job.JobContext;
 import alluxio.client.job.JobMasterClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.status.InvalidArgumentException;
@@ -51,8 +52,8 @@ public final class StatCommand extends AbstractFileSystemCommand {
    *
    * @param fs the Alluxio filesystem client
    */
-  public StatCommand(FileSystem fs) {
-    super(fs);
+  public StatCommand(FileSystem fs, AlluxioConfiguration alluxioConf) {
+    super(fs, alluxioConf);
   }
 
   @Override
@@ -69,12 +70,12 @@ public final class StatCommand extends AbstractFileSystemCommand {
   public int run(CommandLine cl) throws AlluxioException, IOException {
     long id = Long.parseLong(cl.getArgs()[0]);
     try (CloseableResource<JobMasterClient> client =
-        JobContext.INSTANCE.acquireMasterClientResource()) {
+        JobContext.create(mConfiguration).acquireMasterClientResource()) {
       JobInfo info = client.get().getStatus(id);
       System.out.print(formatOutput(cl, info));
     } catch (Exception e) {
-      LOG.error("Failed to get status of the job", e);
-      System.out.println("Failed to get status of the job " + id);
+      LOG.error("Failed to create status of the job", e);
+      System.out.println("Failed to create status of the job " + id);
       return -1;
     }
     return 0;
diff --git a/shell/src/main/java/alluxio/common/RpcPortHealthCheckClient.java b/shell/src/main/java/alluxio/common/RpcPortHealthCheckClient.java
index ac5faaa20e..514a44cd3a 100644
--- a/shell/src/main/java/alluxio/common/RpcPortHealthCheckClient.java
+++ b/shell/src/main/java/alluxio/common/RpcPortHealthCheckClient.java
@@ -12,6 +12,7 @@
 package alluxio.common;
 
 import alluxio.HealthCheckClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.exception.status.UnauthenticatedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.grpc.ServiceType;
@@ -33,6 +34,7 @@ public class RpcPortHealthCheckClient implements HealthCheckClient {
   private final InetSocketAddress mNodeAddress;
   private final ServiceType mServiceType;
   private final Supplier<RetryPolicy> mRetryPolicySupplier;
+  private final AlluxioConfiguration mConf;
 
   /**
    * Creates a worker health check client.
@@ -43,10 +45,12 @@ public class RpcPortHealthCheckClient implements HealthCheckClient {
    */
   public RpcPortHealthCheckClient(InetSocketAddress nodeAddress,
       ServiceType serviceType,
-      Supplier<RetryPolicy> retryPolicySupplier) {
+      Supplier<RetryPolicy> retryPolicySupplier,
+      AlluxioConfiguration conf) {
     mNodeAddress = nodeAddress;
     mServiceType = serviceType;
     mRetryPolicySupplier = retryPolicySupplier;
+    mConf = conf;
   }
 
   @Override
@@ -55,7 +59,7 @@ public class RpcPortHealthCheckClient implements HealthCheckClient {
     while (retry.attempt()) {
       try {
         LOG.debug("Checking whether {} is listening for RPCs", mNodeAddress);
-        NetworkAddressUtils.pingService(mNodeAddress, mServiceType);
+        NetworkAddressUtils.pingService(mNodeAddress, mServiceType, mConf);
         LOG.debug("Successfully connected to {}", mNodeAddress);
         return true;
       } catch (UnavailableException e) {
diff --git a/shell/src/main/java/alluxio/jobmaster/AlluxioJobMasterMonitor.java b/shell/src/main/java/alluxio/jobmaster/AlluxioJobMasterMonitor.java
index 208076e6e8..6946280588 100644
--- a/shell/src/main/java/alluxio/jobmaster/AlluxioJobMasterMonitor.java
+++ b/shell/src/main/java/alluxio/jobmaster/AlluxioJobMasterMonitor.java
@@ -13,7 +13,10 @@ package alluxio.jobmaster;
 
 import alluxio.HealthCheckClient;
 import alluxio.RuntimeConstants;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.retry.ExponentialBackoffRetry;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
 import org.slf4j.Logger;
@@ -36,10 +39,10 @@ public final class AlluxioJobMasterMonitor {
           AlluxioJobMasterMonitor.class.getCanonicalName());
       LOG.warn("ignoring arguments");
     }
-
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
     HealthCheckClient client = new JobMasterHealthCheckClient(
-        NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.JOB_MASTER_RPC),
-        () -> new ExponentialBackoffRetry(50, 100, 2));
+        NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.JOB_MASTER_RPC, conf),
+        () -> new ExponentialBackoffRetry(50, 100, 2), conf);
     if (!client.isServing()) {
       System.exit(1);
     }
diff --git a/shell/src/main/java/alluxio/jobmaster/JobMasterHealthCheckClient.java b/shell/src/main/java/alluxio/jobmaster/JobMasterHealthCheckClient.java
index 3a238a76d6..7b8f2491e8 100644
--- a/shell/src/main/java/alluxio/jobmaster/JobMasterHealthCheckClient.java
+++ b/shell/src/main/java/alluxio/jobmaster/JobMasterHealthCheckClient.java
@@ -12,6 +12,7 @@
 package alluxio.jobmaster;
 
 import alluxio.common.RpcPortHealthCheckClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.ServiceType;
 import alluxio.retry.RetryPolicy;
 
@@ -34,7 +35,7 @@ public class JobMasterHealthCheckClient extends RpcPortHealthCheckClient {
    * @param retryPolicySupplier the retry policy supplier
    */
   public JobMasterHealthCheckClient(InetSocketAddress jobMasterAddress,
-      Supplier<RetryPolicy> retryPolicySupplier) {
-    super(jobMasterAddress, ServiceType.JOB_MASTER_CLIENT_SERVICE, retryPolicySupplier);
+      Supplier<RetryPolicy> retryPolicySupplier, AlluxioConfiguration conf) {
+    super(jobMasterAddress, ServiceType.JOB_MASTER_CLIENT_SERVICE, retryPolicySupplier, conf);
   }
 }
diff --git a/shell/src/main/java/alluxio/jobworker/AlluxioJobWorkerMonitor.java b/shell/src/main/java/alluxio/jobworker/AlluxioJobWorkerMonitor.java
index a29b6e0033..48cc9c747a 100644
--- a/shell/src/main/java/alluxio/jobworker/AlluxioJobWorkerMonitor.java
+++ b/shell/src/main/java/alluxio/jobworker/AlluxioJobWorkerMonitor.java
@@ -13,7 +13,10 @@ package alluxio.jobworker;
 
 import alluxio.HealthCheckClient;
 import alluxio.RuntimeConstants;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.retry.ExponentialBackoffRetry;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
 import org.slf4j.Logger;
@@ -36,10 +39,11 @@ public final class AlluxioJobWorkerMonitor {
               AlluxioJobWorkerMonitor.class.getCanonicalName());
       LOG.warn("ignoring arguments");
     }
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
 
     HealthCheckClient client = new JobWorkerHealthCheckClient(
-        NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.JOB_WORKER_RPC),
-        () -> new ExponentialBackoffRetry(50, 100, 2));
+        NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.JOB_WORKER_RPC, conf),
+        () -> new ExponentialBackoffRetry(50, 100, 2), conf);
     if (!client.isServing()) {
       System.exit(1);
     }
diff --git a/shell/src/main/java/alluxio/jobworker/JobWorkerHealthCheckClient.java b/shell/src/main/java/alluxio/jobworker/JobWorkerHealthCheckClient.java
index faa1a8aaa3..6e0d8aff17 100644
--- a/shell/src/main/java/alluxio/jobworker/JobWorkerHealthCheckClient.java
+++ b/shell/src/main/java/alluxio/jobworker/JobWorkerHealthCheckClient.java
@@ -12,6 +12,7 @@
 package alluxio.jobworker;
 
 import alluxio.common.RpcPortHealthCheckClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.ServiceType;
 import alluxio.retry.RetryPolicy;
 
@@ -34,7 +35,7 @@ public class JobWorkerHealthCheckClient extends RpcPortHealthCheckClient {
    * @param retryPolicySupplier the retry policy supplier
    */
   public JobWorkerHealthCheckClient(InetSocketAddress jobWorkerAddress,
-      Supplier<RetryPolicy> retryPolicySupplier) {
-    super(jobWorkerAddress, ServiceType.UNKNOWN_SERVICE, retryPolicySupplier);
+      Supplier<RetryPolicy> retryPolicySupplier, AlluxioConfiguration conf) {
+    super(jobWorkerAddress, ServiceType.UNKNOWN_SERVICE, retryPolicySupplier, conf);
   }
 }
diff --git a/shell/src/main/java/alluxio/master/MasterHealthCheckClient.java b/shell/src/main/java/alluxio/master/MasterHealthCheckClient.java
index 662b24a725..4bc158f406 100644
--- a/shell/src/main/java/alluxio/master/MasterHealthCheckClient.java
+++ b/shell/src/main/java/alluxio/master/MasterHealthCheckClient.java
@@ -15,7 +15,10 @@ import alluxio.AlluxioURI;
 import alluxio.Constants;
 import alluxio.HealthCheckClient;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.ShellUtils;
 
 import org.slf4j.Logger;
@@ -36,6 +39,7 @@ public class MasterHealthCheckClient implements HealthCheckClient {
   private String mAlluxioMasterName;
   private boolean mProcessCheck;
   private ExecutorService mExecutorService;
+  private AlluxioConfiguration mConf;
 
   /**
    * Builder for a {@link MasterHealthCheckClient}.
@@ -43,6 +47,7 @@ public class MasterHealthCheckClient implements HealthCheckClient {
   public static class Builder {
     private boolean mProcessCheck;
     private String mAlluxioMasterName;
+    private AlluxioConfiguration mConf;
 
     /**
      * Constructs the builder with default values.
@@ -50,6 +55,7 @@ public class MasterHealthCheckClient implements HealthCheckClient {
     public Builder() {
       mProcessCheck = true;
       mAlluxioMasterName = "alluxio.master.AlluxioMaster";
+      mConf = new InstancedConfiguration(ConfigurationUtils.defaults());
     }
 
     /**
@@ -61,6 +67,11 @@ public class MasterHealthCheckClient implements HealthCheckClient {
       return this;
     }
 
+    public Builder withConfiguration(AlluxioConfiguration conf) {
+      mConf = conf;
+      return this;
+    }
+
     /**
      * @param alluxioMasterName the Alluxio master process name
      * @return an instance of the builder
@@ -74,7 +85,7 @@ public class MasterHealthCheckClient implements HealthCheckClient {
      * @return a {@link MasterHealthCheckClient} for the current builder values
      */
     public HealthCheckClient build() {
-      return new MasterHealthCheckClient(mAlluxioMasterName, mProcessCheck);
+      return new MasterHealthCheckClient(mAlluxioMasterName, mProcessCheck, mConf);
     }
   }
 
@@ -114,7 +125,7 @@ public class MasterHealthCheckClient implements HealthCheckClient {
 
     @Override
     public void run() {
-      MasterInquireClient client = MasterInquireClient.Factory.create();
+      MasterInquireClient client = MasterInquireClient.Factory.create(mConf);
       try {
         while (true) {
           List<InetSocketAddress> addresses = client.getMasterRpcAddresses();
@@ -153,10 +164,12 @@ public class MasterHealthCheckClient implements HealthCheckClient {
    * @param alluxioMasterName the Alluxio master process name
    * @param processCheck whether to check the AlluxioMaster process is alive
    */
-  public MasterHealthCheckClient(String alluxioMasterName, boolean processCheck) {
+  public MasterHealthCheckClient(String alluxioMasterName, boolean processCheck,
+      AlluxioConfiguration conf) {
     mAlluxioMasterName = alluxioMasterName;
     mProcessCheck = processCheck;
     mExecutorService = Executors.newFixedThreadPool(2);
+    mConf = conf;
   }
 
   @Override
diff --git a/shell/src/main/java/alluxio/proxy/AlluxioProxyMonitor.java b/shell/src/main/java/alluxio/proxy/AlluxioProxyMonitor.java
index ed45c25a47..640281843f 100644
--- a/shell/src/main/java/alluxio/proxy/AlluxioProxyMonitor.java
+++ b/shell/src/main/java/alluxio/proxy/AlluxioProxyMonitor.java
@@ -13,7 +13,9 @@ package alluxio.proxy;
 
 import alluxio.HealthCheckClient;
 import alluxio.RuntimeConstants;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.retry.ExponentialBackoffRetry;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
 import org.slf4j.Logger;
@@ -38,7 +40,8 @@ public final class AlluxioProxyMonitor {
     }
 
     HealthCheckClient client = new ProxyHealthCheckClient(
-        NetworkAddressUtils.getBindAddress(NetworkAddressUtils.ServiceType.PROXY_WEB),
+        NetworkAddressUtils.getBindAddress(NetworkAddressUtils.ServiceType.PROXY_WEB,
+            new InstancedConfiguration(ConfigurationUtils.defaults())),
         () -> new ExponentialBackoffRetry(50, 100, 2));
     if (!client.isServing()) {
       System.exit(1);
diff --git a/shell/src/main/java/alluxio/worker/AlluxioWorkerMonitor.java b/shell/src/main/java/alluxio/worker/AlluxioWorkerMonitor.java
index 311ca88f48..1728903e5f 100644
--- a/shell/src/main/java/alluxio/worker/AlluxioWorkerMonitor.java
+++ b/shell/src/main/java/alluxio/worker/AlluxioWorkerMonitor.java
@@ -13,7 +13,10 @@ package alluxio.worker;
 
 import alluxio.HealthCheckClient;
 import alluxio.RuntimeConstants;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.retry.ExponentialBackoffRetry;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
 import org.slf4j.Logger;
@@ -36,10 +39,11 @@ public final class AlluxioWorkerMonitor {
           AlluxioWorkerMonitor.class.getCanonicalName());
       LOG.warn("ignoring arguments");
     }
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
 
     HealthCheckClient client = new WorkerHealthCheckClient(
-        NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.WORKER_RPC),
-        () -> new ExponentialBackoffRetry(50, 100, 2));
+        NetworkAddressUtils.getConnectAddress(NetworkAddressUtils.ServiceType.WORKER_RPC, conf),
+        () -> new ExponentialBackoffRetry(50, 100, 2), conf);
     if (!client.isServing()) {
       System.exit(1);
     }
diff --git a/shell/src/main/java/alluxio/worker/WorkerHealthCheckClient.java b/shell/src/main/java/alluxio/worker/WorkerHealthCheckClient.java
index 5d1c174969..1578b4d1f4 100644
--- a/shell/src/main/java/alluxio/worker/WorkerHealthCheckClient.java
+++ b/shell/src/main/java/alluxio/worker/WorkerHealthCheckClient.java
@@ -12,6 +12,7 @@
 package alluxio.worker;
 
 import alluxio.common.RpcPortHealthCheckClient;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.grpc.ServiceType;
 import alluxio.retry.RetryPolicy;
 
@@ -35,8 +36,8 @@ public class WorkerHealthCheckClient extends RpcPortHealthCheckClient {
    * @param retryPolicySupplier the retry policy supplier
    */
   public WorkerHealthCheckClient(InetSocketAddress jobWorkerAddress,
-      Supplier<RetryPolicy> retryPolicySupplier) {
+      Supplier<RetryPolicy> retryPolicySupplier, AlluxioConfiguration conf) {
     // TODO(ggezer) Send a valid value after FSWorker implementation.
-    super(jobWorkerAddress, ServiceType.UNKNOWN_SERVICE, retryPolicySupplier);
+    super(jobWorkerAddress, ServiceType.UNKNOWN_SERVICE, retryPolicySupplier, conf);
   }
 }
diff --git a/shell/src/test/java/alluxio/cli/fs/command/ChownCommandTest.java b/shell/src/test/java/alluxio/cli/fs/command/ChownCommandTest.java
index 864915353a..ce38836a8e 100644
--- a/shell/src/test/java/alluxio/cli/fs/command/ChownCommandTest.java
+++ b/shell/src/test/java/alluxio/cli/fs/command/ChownCommandTest.java
@@ -11,8 +11,10 @@
 
 package alluxio.cli.fs.command;
 
+import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.AlluxioException;
 
+import alluxio.util.ConfigurationUtils;
 import org.apache.commons.cli.CommandLine;
 import org.junit.After;
 import org.junit.Assert;
@@ -39,9 +41,12 @@ public class ChownCommandTest {
     System.setErr(null);
   }
 
+  private static final InstancedConfiguration sConf=
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   @Test
   public void chownPanicIllegalOwnerName() throws AlluxioException, IOException {
-    ChownCommand command = new ChownCommand(null);
+    ChownCommand command = new ChownCommand(null, sConf);
 
     String expectedOutput =
         String.format("Failed to parse user.1:group1 as user or user:group%n");
@@ -61,7 +66,7 @@ public class ChownCommandTest {
 
   @Test
   public void chownPanicIllegalGroupName() throws AlluxioException, IOException {
-    ChownCommand command = new ChownCommand(null);
+    ChownCommand command = new ChownCommand(null, sConf);
 
     String expectedOutput = String.format("Failed to parse user1:group.1 as user or user:group%n");
     verifyChownCommandReturnValueAndOutput(command, -1, expectedOutput,
diff --git a/shell/src/test/java/alluxio/cli/fsadmin/report/SummaryCommandTest.java b/shell/src/test/java/alluxio/cli/fsadmin/report/SummaryCommandTest.java
index 640fd22f76..50ed9bc656 100644
--- a/shell/src/test/java/alluxio/cli/fsadmin/report/SummaryCommandTest.java
+++ b/shell/src/test/java/alluxio/cli/fsadmin/report/SummaryCommandTest.java
@@ -17,8 +17,12 @@ import static org.mockito.Mockito.when;
 
 import alluxio.client.MetaMasterClient;
 import alluxio.client.block.BlockMasterClient;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.grpc.MasterInfo;
 import alluxio.util.CommonUtils;
+import alluxio.util.ConfigurationUtils;
 import alluxio.wire.BlockMasterInfo;
 
 import org.hamcrest.collection.IsIterableContainingInOrder;
@@ -37,6 +41,10 @@ import java.util.List;
 import java.util.Map;
 
 public class SummaryCommandTest {
+
+  private static final AlluxioConfiguration sConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
+
   private MetaMasterClient mMetaMasterClient;
   private BlockMasterClient mBlockMasterClient;
   private ByteArrayOutputStream mOutputStream;
@@ -94,18 +102,18 @@ public class SummaryCommandTest {
   @Test
   public void summary() throws IOException {
     SummaryCommand summaryCommand = new SummaryCommand(mMetaMasterClient,
-        mBlockMasterClient, mPrintStream);
+        mBlockMasterClient, sConf.get(PropertyKey.USER_DATE_FORMAT_PATTERN), mPrintStream);
     summaryCommand.run();
-    checkIfOutputValid();
+    checkIfOutputValid(sConf.get(PropertyKey.USER_DATE_FORMAT_PATTERN));
   }
 
   /**
    * Checks if the output is expected.
    */
-  private void checkIfOutputValid() {
+  private void checkIfOutputValid(String dateFormatPattern) {
     String output = new String(mOutputStream.toByteArray(), StandardCharsets.UTF_8);
     // Skip checking startTime which relies on system time zone
-    String startTime =  CommonUtils.convertMsToDate(1131242343122L);
+    String startTime =  CommonUtils.convertMsToDate(1131242343122L, dateFormatPattern);
     List<String> expectedOutput = Arrays.asList("Alluxio cluster summary: ",
         "    Master Address: testAddress",
         "    Web Port: 1231",
diff --git a/tests/src/main/java/alluxio/master/backcompat/BackwardsCompatibilityJournalGenerator.java b/tests/src/main/java/alluxio/master/backcompat/BackwardsCompatibilityJournalGenerator.java
index 06156a14b7..815a0c4fe5 100644
--- a/tests/src/main/java/alluxio/master/backcompat/BackwardsCompatibilityJournalGenerator.java
+++ b/tests/src/main/java/alluxio/master/backcompat/BackwardsCompatibilityJournalGenerator.java
@@ -14,6 +14,7 @@ package alluxio.master.backcompat;
 import alluxio.AlluxioURI;
 import alluxio.Constants;
 import alluxio.ProjectConstants;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.backcompat.ops.AsyncPersist;
 import alluxio.master.backcompat.ops.CreateDirectory;
 import alluxio.master.backcompat.ops.CreateFile;
@@ -87,7 +88,7 @@ public final class BackwardsCompatibilityJournalGenerator {
   public static void main(String[] args) throws Exception {
     BackwardsCompatibilityJournalGenerator generator = new BackwardsCompatibilityJournalGenerator();
     new JCommander(generator, args);
-    if (!LoginUser.get().getName().equals("root")) {
+    if (!LoginUser.get(ServerConfiguration.global()).getName().equals("root")) {
       System.err
           .printf("Journals must be generated as root so that they can be replayed by root%n");
       System.exit(-1);
diff --git a/tests/src/test/java/alluxio/client/cli/fs/AbstractFileSystemShellTest.java b/tests/src/test/java/alluxio/client/cli/fs/AbstractFileSystemShellTest.java
index e9b4b6a51c..bc93817a12 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/AbstractFileSystemShellTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/AbstractFileSystemShellTest.java
@@ -21,6 +21,7 @@ import alluxio.cli.job.JobShell;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.OpenFilePOptions;
 import alluxio.grpc.ReadPType;
@@ -60,11 +61,11 @@ public abstract class AbstractFileSystemShellTest extends AbstractShellIntegrati
   public final void before() throws Exception {
     mLocalAlluxioCluster = mLocalAlluxioClusterResource.get();
     mFileSystem = mLocalAlluxioCluster.getClient();
-    mFsShell = new FileSystemShell();
+    mFsShell = new FileSystemShell(ServerConfiguration.global());
     mLocalAlluxioJobCluster = new alluxio.master.LocalAlluxioJobCluster();
     mLocalAlluxioJobCluster.start();
     mJobMaster = mLocalAlluxioJobCluster.getMaster().getJobMaster();
-    mJobShell = new alluxio.cli.job.JobShell();
+    mJobShell = new alluxio.cli.job.JobShell(ServerConfiguration.global());
   }
 
   @After
diff --git a/tests/src/test/java/alluxio/client/cli/fs/AbstractShellIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/AbstractShellIntegrationTest.java
index 5e620592c3..75afaaf6bc 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/AbstractShellIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/AbstractShellIntegrationTest.java
@@ -12,7 +12,7 @@
 package alluxio.client.cli.fs;
 
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.SystemErrRule;
 import alluxio.SystemOutRule;
 import alluxio.testutils.BaseIntegrationTest;
diff --git a/tests/src/test/java/alluxio/client/cli/fs/ConfigurationDocGeneratorTest.java b/tests/src/test/java/alluxio/client/cli/fs/ConfigurationDocGeneratorTest.java
index 27a5f3e698..d3b8392208 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/ConfigurationDocGeneratorTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/ConfigurationDocGeneratorTest.java
@@ -14,8 +14,8 @@ package alluxio.client.cli.fs;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.ConfigurationDocGenerator;
 import alluxio.collections.Pair;
 import alluxio.util.io.PathUtils;
@@ -131,7 +131,7 @@ public class ConfigurationDocGeneratorTest {
 
     //assert file contents
     List<String> userFile = Files.readAllLines(p, StandardCharsets.UTF_8);
-    String defaultValue = Configuration.get(pKey);
+    String defaultValue = ServerConfiguration.get(pKey);
     checkFileContents(String.format("%s,\"%s\"", pKey, defaultValue), userFile, mFileType);
   }
 
diff --git a/tests/src/test/java/alluxio/client/cli/fs/FileSystemShellUtilsTest.java b/tests/src/test/java/alluxio/client/cli/fs/FileSystemShellUtilsTest.java
index 25d4418809..70a9ffcda9 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/FileSystemShellUtilsTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/FileSystemShellUtilsTest.java
@@ -12,6 +12,7 @@
 package alluxio.client.cli.fs;
 
 import alluxio.AlluxioURI;
+import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
 import alluxio.cli.Command;
 import alluxio.cli.fs.FileSystemShell;
@@ -68,7 +69,7 @@ public final class FileSystemShellUtilsTest {
             Constants.HEADER_FT + "localhost:19998/dir", "/dir", "dir"};
     String expected = "/dir";
     for (String path : paths) {
-      String result = FileSystemShellUtils.getFilePath(path);
+      String result = FileSystemShellUtils.getFilePath(path, ConfigurationTestUtils.defaults());
       Assert.assertEquals(expected, result);
     }
   }
diff --git a/tests/src/test/java/alluxio/client/cli/fs/GetConfKeyTest.java b/tests/src/test/java/alluxio/client/cli/fs/GetConfKeyTest.java
index 3ed0c6669e..28caeb5bfe 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/GetConfKeyTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/GetConfKeyTest.java
@@ -13,7 +13,7 @@ package alluxio.client.cli.fs;
 
 import static org.junit.Assert.assertEquals;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.SystemOutRule;
 import alluxio.cli.GetConfKey;
 
diff --git a/tests/src/test/java/alluxio/client/cli/fs/GetConfTest.java b/tests/src/test/java/alluxio/client/cli/fs/GetConfTest.java
index deaccdb298..3fe60695e1 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/GetConfTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/GetConfTest.java
@@ -13,8 +13,8 @@ package alluxio.client.cli.fs;
 
 import static org.junit.Assert.assertEquals;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.SystemOutRule;
 import alluxio.SystemPropertyRule;
 import alluxio.cli.GetConf;
@@ -43,23 +43,26 @@ public final class GetConfTest {
 
   @After
   public void after() {
-    Configuration.reset();
+    ServerConfiguration.reset();
   }
 
   @Test
   public void getConf() throws Exception {
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
-    assertEquals(0, GetConf.getConf(PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("2048\n", mOutputStream.toString());
 
     mOutputStream.reset();
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2MB");
-    assertEquals(0, GetConf.getConf(PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2MB");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("2MB\n", mOutputStream.toString());
 
     mOutputStream.reset();
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "Nonsense");
-    assertEquals(0, GetConf.getConf(PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "Nonsense");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("Nonsense\n", mOutputStream.toString());
   }
 
@@ -69,42 +72,47 @@ public final class GetConfTest {
         .setAlias(new String[] {"alluxio.test.property.alias"})
         .setDefaultValue("testValue")
         .build();
-    assertEquals(0, GetConf.getConf("alluxio.test.property.alias"));
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),"alluxio.test.property.alias"));
     assertEquals("testValue\n", mOutputStream.toString());
 
     mOutputStream.reset();
-    assertEquals(0, GetConf.getConf("alluxio.test.property"));
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),"alluxio.test.property"));
     assertEquals("testValue\n", mOutputStream.toString());
     PropertyKey.unregister(testProperty);
   }
 
   @Test
   public void getConfWithCorrectUnit() throws Exception {
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
-    assertEquals(0, GetConf.getConf("--unit", "B", PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(), "--unit", "B",
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("2048\n", mOutputStream.toString());
 
     mOutputStream.reset();
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
-    assertEquals(0, GetConf.getConf("--unit", "KB", PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),"--unit", "KB",
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("2\n", mOutputStream.toString());
 
     mOutputStream.reset();
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2MB");
-    assertEquals(0, GetConf.getConf("--unit", "KB", PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2MB");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(),"--unit", "KB",
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("2048\n", mOutputStream.toString());
 
     mOutputStream.reset();
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2MB");
-    assertEquals(0, GetConf.getConf("--unit", "MB", PropertyKey.WORKER_MEMORY_SIZE.toString()));
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2MB");
+    assertEquals(0, GetConf.getConf(ServerConfiguration.global(), "--unit", "MB",
+        PropertyKey.WORKER_MEMORY_SIZE.toString()));
     assertEquals("2\n", mOutputStream.toString());
   }
 
   @Test
   public void getConfWithWrongUnit() throws Exception {
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, "2048");
     assertEquals(1,
-        GetConf.getConf("--unit", "bad_unit", PropertyKey.WORKER_MEMORY_SIZE.toString()));
+        GetConf.getConf(ServerConfiguration.global(), "--unit", "bad_unit",
+            PropertyKey.WORKER_MEMORY_SIZE.toString()));
   }
 
   @Test
@@ -112,8 +120,9 @@ public final class GetConfTest {
     try (Closeable p = new SystemPropertyRule(ImmutableMap.of(
         PropertyKey.CONF_VALIDATION_ENABLED.toString(), "false",
         PropertyKey.ZOOKEEPER_ENABLED.toString(), "true")).toResource()) {
-      Configuration.reset();
-      assertEquals(0, GetConf.getConf(PropertyKey.ZOOKEEPER_ENABLED.toString()));
+      ServerConfiguration.reset();
+      assertEquals(0, GetConf.getConf(ServerConfiguration.global(),
+          PropertyKey.ZOOKEEPER_ENABLED.toString()));
       assertEquals("true\n", mOutputStream.toString());
     }
   }
@@ -126,7 +135,7 @@ public final class GetConfTest {
     List<ConfigProperty> configList = prepareConfigList();
     Mockito.when(client.getConfiguration()).thenReturn(configList);
 
-    assertEquals(0, GetConf.getConfImpl(() -> client, "--master"));
+    assertEquals(0, GetConf.getConfImpl(() -> client, ServerConfiguration.global(), "--master"));
     String expectedOutput = "alluxio.logger.type=MASTER_LOGGER\n"
         + "alluxio.master.audit.logger.type=MASTER_AUDIT_LOGGER\n"
         + "alluxio.master.hostname=localhost\n"
@@ -143,7 +152,8 @@ public final class GetConfTest {
         Mockito.mock(RetryHandlingMetaMasterConfigClient.class);
     List<ConfigProperty> configList = prepareConfigList();
     Mockito.when(client.getConfiguration()).thenReturn(configList);
-    assertEquals(0, GetConf.getConfImpl(() -> client, "--master", "--source"));
+    assertEquals(0, GetConf.getConfImpl(() -> client, ServerConfiguration.global(), "--master",
+        "--source"));
     // CHECKSTYLE.OFF: LineLengthExceed - Much more readable
     String expectedOutput =
         "alluxio.logger.type=MASTER_LOGGER (SYSTEM_PROPERTY)\n"
diff --git a/tests/src/test/java/alluxio/client/cli/fs/JobServiceFaultToleranceShellTest.java b/tests/src/test/java/alluxio/client/cli/fs/JobServiceFaultToleranceShellTest.java
index 9ff9e74acf..1c96553a04 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/JobServiceFaultToleranceShellTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/JobServiceFaultToleranceShellTest.java
@@ -18,6 +18,7 @@ import alluxio.AlluxioURI;
 import alluxio.ConfigurationTestUtils;
 import alluxio.cli.fs.FileSystemShell;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.LocalAlluxioJobCluster;
 import alluxio.master.MultiMasterLocalAlluxioCluster;
 import alluxio.testutils.BaseIntegrationTest;
@@ -54,7 +55,7 @@ public final class JobServiceFaultToleranceShellTest extends BaseIntegrationTest
     mLocalAlluxioJobCluster.stop();
     mLocalAlluxioCluster.stop();
     System.setOut(System.out);
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
@@ -64,7 +65,7 @@ public final class JobServiceFaultToleranceShellTest extends BaseIntegrationTest
       out.write("Hello".getBytes());
     }
 
-    try (FileSystemShell shell = new FileSystemShell()) {
+    try (FileSystemShell shell = new FileSystemShell(ServerConfiguration.global())) {
       int exitCode = shell.run("distributedMv", "/test", "/test2");
       assertEquals("Command failed, output: " + mOutput.toString(), 0, exitCode);
     }
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/CheckConsistencyCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/CheckConsistencyCommandIntegrationTest.java
index 1aecbdde78..1aa419cf5b 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/CheckConsistencyCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/CheckConsistencyCommandIntegrationTest.java
@@ -14,6 +14,7 @@ package alluxio.client.cli.fs.command;
 import alluxio.AlluxioURI;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.client.cli.fs.AbstractFileSystemShellTest;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.ExistsPOptions;
 import alluxio.grpc.LoadMetadataPType;
 import alluxio.grpc.WritePType;
@@ -56,7 +57,7 @@ public class CheckConsistencyCommandIntegrationTest extends AbstractFileSystemSh
     FileSystemTestUtils.createByteFile(mFileSystem, "/testRoot/testDir/testFileB",
             WritePType.CACHE_THROUGH, 20);
     String ufsPath = mFileSystem.getStatus(new AlluxioURI("/testRoot/testDir")).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     ufs.deleteDirectory(ufsPath, DeleteOptions.defaults().setRecursive(true));
     mFsShell.run("checkConsistency", "/testRoot");
     StringBuilder expected = new StringBuilder();
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/ChownCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/ChownCommandIntegrationTest.java
index af547f7f06..88575526a3 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/ChownCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/ChownCommandIntegrationTest.java
@@ -13,8 +13,9 @@ package alluxio.client.cli.fs.command;
 
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.WritePType;
 import alluxio.security.group.GroupMappingService;
@@ -47,7 +48,8 @@ public final class ChownCommandIntegrationTest extends AbstractFileSystemShellTe
 
   @Rule
   public ConfigurationRule mConfiguration = new ConfigurationRule(ImmutableMap
-      .of(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, FakeUserGroupsMapping.class.getName()));
+      .of(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, FakeUserGroupsMapping.class.getName()),
+      ServerConfiguration.global());
 
   /**
    * A simple structure to represent a user and its groups.
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/CopyFromLocalCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/CopyFromLocalCommandIntegrationTest.java
index f7701c0a80..8419622d1a 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/CopyFromLocalCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/CopyFromLocalCommandIntegrationTest.java
@@ -13,11 +13,12 @@ package alluxio.client.cli.fs.command;
 
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.SystemPropertyRule;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.client.cli.fs.AbstractFileSystemShellTest;
 import alluxio.client.cli.fs.FileSystemShellUtilsTest;
@@ -227,11 +228,11 @@ public final class CopyFromLocalCommandIntegrationTest extends AbstractFileSyste
   public void copyFromLocalMustCacheThenCacheThrough() throws Exception {
     File file = mTestFolder.newFile();
     try (Closeable c = new ConfigurationRule(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT,
-        WriteType.MUST_CACHE.toString()).toResource()) {
+        WriteType.MUST_CACHE.toString(), ServerConfiguration.global()).toResource()) {
       Assert.assertEquals(0, mFsShell.run("copyFromLocal", file.getAbsolutePath(), "/"));
     }
     try (Closeable c = new ConfigurationRule(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT,
-        WriteType.CACHE_THROUGH.toString()).toResource()) {
+        WriteType.CACHE_THROUGH.toString(), ServerConfiguration.global()).toResource()) {
       mOutput.reset();
       mFsShell.run("copyFromLocal", file.getAbsolutePath(), "/");
     }
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/HelpCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/HelpCommandIntegrationTest.java
index 3c0302b761..e7c0ba33b4 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/HelpCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/HelpCommandIntegrationTest.java
@@ -16,6 +16,7 @@ import alluxio.client.cli.fs.AbstractFileSystemShellTest;
 import alluxio.cli.fs.FileSystemShellUtils;
 import alluxio.cli.fs.command.HelpCommand;
 
+import alluxio.conf.ServerConfiguration;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -47,7 +48,7 @@ public final class HelpCommandIntegrationTest extends AbstractFileSystemShellTes
   @Test
   public void help() throws IOException {
     Assert.assertEquals(0, mFsShell.run("help", "help"));
-    HelpCommand cmd = new HelpCommand(mFileSystem);
+    HelpCommand cmd = new HelpCommand(mFileSystem, ServerConfiguration.global());
     StringWriter stringWriter = new StringWriter();
     PrintWriter printWriter = new PrintWriter(stringWriter);
     HelpCommand.printCommandInfo(cmd, printWriter);
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/LsCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/LsCommandIntegrationTest.java
index 2d98d0a5e8..c36bd98af7 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/LsCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/LsCommandIntegrationTest.java
@@ -12,10 +12,11 @@
 package alluxio.client.cli.fs.command;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.fs.command.LsCommand;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.client.cli.fs.AbstractFileSystemShellTest;
 import alluxio.client.cli.fs.FileSystemShellUtilsTest;
@@ -63,7 +64,7 @@ public final class LsCommandIntegrationTest extends AbstractFileSystemShellTest
     return String
         .format(LsCommand.LS_FORMAT, FormatUtils.formatMode((short) permission, isDir, hasExtended),
             testUser, testGroup, String.valueOf(size), persistenceState,
-            CommonUtils.convertMsToDate(createTime),
+            CommonUtils.convertMsToDate(createTime, ServerConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN)),
             isDir ? LsCommand.IN_ALLUXIO_STATE_DIR : inAlluxioState, path);
   }
 
@@ -93,7 +94,8 @@ public final class LsCommandIntegrationTest extends AbstractFileSystemShellTest
       sizeStr = hSize ? FormatUtils.getSizeFromBytes(size) : String.valueOf(size);
     }
     return String.format(LsCommand.LS_FORMAT_NO_ACL, sizeStr, persistenceState,
-        CommonUtils.convertMsToDate(createTime), inAlluxioState, path);
+        CommonUtils.convertMsToDate(createTime, ServerConfiguration.get(PropertyKey.USER_DATE_FORMAT_PATTERN)), inAlluxioState,
+        path);
   }
 
   // Helper function to create a set of files in the file system
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/PersistCommandTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/PersistCommandTest.java
index 1e3e5600a3..8112534c7f 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/PersistCommandTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/PersistCommandTest.java
@@ -12,9 +12,9 @@
 package alluxio.client.cli.fs.command;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.client.file.URIStatus;
 import alluxio.exception.ExceptionMessage;
@@ -53,7 +53,7 @@ public final class PersistCommandTest extends AbstractFileSystemShellTest {
   @Test
   public void persistDirectory() throws Exception {
     // Set the default write type to MUST_CACHE, so that directories are not persisted by default
-    Configuration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, "MUST_CACHE");
+    ServerConfiguration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, "MUST_CACHE");
     String testDir = FileSystemShellUtilsTest.resetFileHierarchy(mFileSystem);
     Assert.assertFalse(mFileSystem.getStatus(new AlluxioURI(testDir)).isPersisted());
     Assert
@@ -71,7 +71,7 @@ public final class PersistCommandTest extends AbstractFileSystemShellTest {
     checkFilePersisted(new AlluxioURI(testDir + "/foo/foobar2"), 20);
     checkFilePersisted(new AlluxioURI(testDir + "/bar/foobar3"), 30);
     checkFilePersisted(new AlluxioURI(testDir + "/foobar4"), 40);
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
@@ -99,7 +99,7 @@ public final class PersistCommandTest extends AbstractFileSystemShellTest {
    */
   @Test
   public void persistMultiFilesAndDirs() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, "MUST_CACHE");
+    ServerConfiguration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, "MUST_CACHE");
     String testDir = FileSystemShellUtilsTest.resetFileHierarchy(mFileSystem);
     Assert.assertFalse(mFileSystem.getStatus(new AlluxioURI(testDir)).isPersisted());
     Assert.assertFalse(mFileSystem.getStatus(new AlluxioURI(testDir + "/foo")).isPersisted());
@@ -118,7 +118,7 @@ public final class PersistCommandTest extends AbstractFileSystemShellTest {
     checkFilePersisted(new AlluxioURI(testDir + "/foo/foobar1"), 10);
     checkFilePersisted(new AlluxioURI(testDir + "/bar/foobar3"), 30);
     checkFilePersisted(new AlluxioURI(testDir + "/foobar4"), 40);
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
@@ -148,8 +148,8 @@ public final class PersistCommandTest extends AbstractFileSystemShellTest {
   @Test
   public void persistWithAncestorPermission() throws Exception {
     String ufsRoot =
-        PathUtils.concatPath(Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS));
-    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot();
+        PathUtils.concatPath(ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS));
+    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
     // Skip non-local and non-HDFS UFSs.
     Assume.assumeTrue(UnderFileSystemUtils.isLocal(ufs) || UnderFileSystemUtils.isHdfs(ufs));
 
diff --git a/tests/src/test/java/alluxio/client/cli/fs/command/SetFaclCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fs/command/SetFaclCommandIntegrationTest.java
index 14ecce6eb1..20759e8a51 100644
--- a/tests/src/test/java/alluxio/client/cli/fs/command/SetFaclCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fs/command/SetFaclCommandIntegrationTest.java
@@ -12,7 +12,7 @@
 package alluxio.client.cli.fs.command;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.cli.fs.AbstractFileSystemShellTest;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.client.file.URIStatus;
diff --git a/tests/src/test/java/alluxio/client/cli/fsadmin/AbstractFsAdminShellTest.java b/tests/src/test/java/alluxio/client/cli/fsadmin/AbstractFsAdminShellTest.java
index a0c9a9db4d..99d0bba577 100644
--- a/tests/src/test/java/alluxio/client/cli/fsadmin/AbstractFsAdminShellTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fsadmin/AbstractFsAdminShellTest.java
@@ -13,6 +13,7 @@ package alluxio.client.cli.fsadmin;
 
 import alluxio.cli.fsadmin.FileSystemAdminShell;
 import alluxio.client.cli.fs.AbstractShellIntegrationTest;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.LocalAlluxioCluster;
 
 import org.junit.After;
@@ -25,7 +26,7 @@ public class AbstractFsAdminShellTest extends AbstractShellIntegrationTest {
   @Before
   public final void before() throws Exception {
     mLocalAlluxioCluster = mLocalAlluxioClusterResource.get();
-    mFsAdminShell = new FileSystemAdminShell();
+    mFsAdminShell = new FileSystemAdminShell(ServerConfiguration.global());
   }
 
   @After
diff --git a/tests/src/test/java/alluxio/client/cli/fsadmin/command/ReportCommandIntegrationTest.java b/tests/src/test/java/alluxio/client/cli/fsadmin/command/ReportCommandIntegrationTest.java
index 7cc4d0cb03..ed8c79c4cb 100644
--- a/tests/src/test/java/alluxio/client/cli/fsadmin/command/ReportCommandIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/cli/fsadmin/command/ReportCommandIntegrationTest.java
@@ -11,9 +11,9 @@
 
 package alluxio.client.cli.fsadmin.command;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ProjectConstants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.cli.fsadmin.command.ReportCommand;
 import alluxio.client.cli.fsadmin.AbstractFsAdminShellTest;
 import alluxio.util.network.NetworkAddressUtils;
@@ -51,13 +51,13 @@ public final class ReportCommandIntegrationTest extends AbstractFsAdminShellTest
 
     // Check if meta master values are available
     String expectedMasterAddress = NetworkAddressUtils
-        .getConnectAddress(NetworkAddressUtils.ServiceType.MASTER_RPC).toString();
+        .getConnectAddress(NetworkAddressUtils.ServiceType.MASTER_RPC, ServerConfiguration.global()).toString();
     Assert.assertThat(output, CoreMatchers.containsString(
         "Master Address: " + expectedMasterAddress));
     Assert.assertThat(output, CoreMatchers.containsString(
-        "Web Port: " + Configuration.get(PropertyKey.MASTER_WEB_PORT)));
+        "Web Port: " + ServerConfiguration.get(PropertyKey.MASTER_WEB_PORT)));
     Assert.assertThat(output, CoreMatchers.containsString(
-        "Rpc Port: " + Configuration.get(PropertyKey.MASTER_RPC_PORT)));
+        "Rpc Port: " + ServerConfiguration.get(PropertyKey.MASTER_RPC_PORT)));
     Assert.assertFalse(output.contains("Started: 12-31-1969 16:00:00:000"));
     Assert.assertThat(output, CoreMatchers.containsString(
         "Version: " + ProjectConstants.VERSION));
diff --git a/tests/src/test/java/alluxio/client/fs/AbstractFileOutStreamIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/AbstractFileOutStreamIntegrationTest.java
index a9701c2b0b..2295095ced 100644
--- a/tests/src/test/java/alluxio/client/fs/AbstractFileOutStreamIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/AbstractFileOutStreamIntegrationTest.java
@@ -12,11 +12,12 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.OpenFilePOptions;
 import alluxio.grpc.ReadPType;
@@ -146,7 +147,7 @@ public abstract class AbstractFileOutStreamIntegrationTest extends BaseIntegrati
   protected void checkFileInUnderStorage(AlluxioURI filePath, int fileLen) throws Exception {
     URIStatus status = mFileSystem.getStatus(filePath);
     String checkpointPath = status.getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(checkpointPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(checkpointPath, ServerConfiguration.global());
 
     try (InputStream is = ufs.open(checkpointPath)) {
       byte[] res = new byte[(int) status.getLength()];
diff --git a/tests/src/test/java/alluxio/client/fs/CheckConsistencyIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/CheckConsistencyIntegrationTest.java
index 3efd385143..61b70c66f9 100644
--- a/tests/src/test/java/alluxio/client/fs/CheckConsistencyIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/CheckConsistencyIntegrationTest.java
@@ -13,8 +13,9 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.WritePType;
@@ -51,7 +52,8 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
           TEST_USER).build();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER,
+      ServerConfiguration.global());
 
   private FileSystemMaster mFileSystemMaster;
   private FileSystem mFileSystem;
@@ -87,7 +89,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
   @Test
   public void inconsistent() throws Exception {
     String ufsDirectory = mFileSystem.getStatus(DIRECTORY).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsDirectory);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsDirectory, ServerConfiguration.global());
     ufs.deleteDirectory(ufsDirectory, DeleteOptions.defaults().setRecursive(true));
 
     List<AlluxioURI> expected = Lists.newArrayList(FILE, DIRECTORY);
@@ -105,7 +107,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
   @Test
   public void partiallyInconsistent() throws Exception {
     String ufsFile = mFileSystem.getStatus(FILE).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile, ServerConfiguration.global());
     ufs.deleteFile(ufsFile);
     List<AlluxioURI> expected = Lists.newArrayList(FILE);
     Assert.assertEquals(expected, mFileSystemMaster.checkConsistency(new AlluxioURI("/"),
@@ -129,7 +131,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
     mFileSystem.createFile(topLevelFile, fileOptions).close();
     mFileSystem.createFile(thirdLevelFile, fileOptions).close();
     String ufsDirectory = mFileSystem.getStatus(nestedDir).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsDirectory);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsDirectory, ServerConfiguration.global());
     ufs.deleteDirectory(ufsDirectory, DeleteOptions.defaults().setRecursive(true));
 
     List<AlluxioURI> expected = Lists.newArrayList(nestedDir, thirdLevelFile);
@@ -147,7 +149,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
   @Test
   public void incorrectFileSize() throws Exception {
     String ufsFile = mFileSystem.getStatus(FILE).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile, ServerConfiguration.global());
     ufs.deleteFile(ufsFile);
     OutputStream out = ufs.create(ufsFile);
     out.write(1);
@@ -164,7 +166,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
   @Test
   public void notADirectory() throws Exception {
     String ufsDirectory = mFileSystem.getStatus(DIRECTORY).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsDirectory);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsDirectory, ServerConfiguration.global());
     ufs.deleteDirectory(ufsDirectory, DeleteOptions.defaults().setRecursive(true));
     ufs.create(ufsDirectory).close();
     List<AlluxioURI> expected = Lists.newArrayList(DIRECTORY, FILE);
@@ -182,7 +184,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
   @Test
   public void notAFile() throws Exception {
     String ufsFile = mFileSystem.getStatus(FILE).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile, ServerConfiguration.global());
     ufs.deleteFile(ufsFile);
     ufs.mkdirs(ufsFile);
     List<AlluxioURI> expected = Lists.newArrayList(FILE);
@@ -197,7 +199,7 @@ public class CheckConsistencyIntegrationTest extends BaseIntegrationTest {
   @Test
   public void inconsistentFile() throws Exception {
     String ufsFile = mFileSystem.getStatus(FILE).getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsFile, ServerConfiguration.global());
     ufs.deleteFile(ufsFile);
     List<AlluxioURI> expected = Lists.newArrayList(FILE);
     Assert.assertEquals(expected, mFileSystemMaster.checkConsistency(FILE,
diff --git a/tests/src/test/java/alluxio/client/fs/ConcurrentDeleteIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/ConcurrentDeleteIntegrationTest.java
index 2c7075fe17..70eb708587 100644
--- a/tests/src/test/java/alluxio/client/fs/ConcurrentDeleteIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ConcurrentDeleteIntegrationTest.java
@@ -14,10 +14,11 @@ package alluxio.client.fs;
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.WritePType;
@@ -68,7 +69,8 @@ public class ConcurrentDeleteIntegrationTest extends BaseIntegrationTest {
   private String mLocalUfsPath = Files.createTempDir().getAbsolutePath();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER,
+      ServerConfiguration.global());
 
   @Rule
   public LocalAlluxioClusterResource mLocalAlluxioClusterResource =
@@ -194,7 +196,7 @@ public class ConcurrentDeleteIntegrationTest extends BaseIntegrationTest {
         .unaryOperation(mFileSystem, ConcurrentFileSystemMasterUtils.UnaryOperation.DELETE, paths,
             LIMIT_MS);
 
-    // We should get an error for all but 1 delete
+    // We should create an error for all but 1 delete
     Assert.assertEquals(numThreads - 1, errors.size());
 
     List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI("/"));
@@ -218,7 +220,7 @@ public class ConcurrentDeleteIntegrationTest extends BaseIntegrationTest {
         .unaryOperation(mFileSystem, ConcurrentFileSystemMasterUtils.UnaryOperation.DELETE, paths,
             LIMIT_MS);
 
-    // We should get an error for all but 1 delete
+    // We should create an error for all but 1 delete
     Assert.assertEquals(numThreads - 1, errors.size());
     List<URIStatus> dirs = mFileSystem.listStatus(new AlluxioURI("/"));
     Assert.assertEquals(0, dirs.size());
diff --git a/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterCreateTest.java b/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterCreateTest.java
index 592b700df6..d42f0f9af1 100644
--- a/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterCreateTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterCreateTest.java
@@ -13,10 +13,10 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -67,7 +67,8 @@ public class ConcurrentFileSystemMasterCreateTest extends BaseIntegrationTest {
   private String mLocalUfsPath = Files.createTempDir().getAbsolutePath();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER,
+      ServerConfiguration.global());
 
   @Rule
   public LocalAlluxioClusterResource mLocalAlluxioClusterResource =
@@ -84,12 +85,12 @@ public class ConcurrentFileSystemMasterCreateTest extends BaseIntegrationTest {
   @Before
   public void before() {
     mFileSystem = FileSystem.Factory.get();
-    Configuration.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, "2b");
+    ServerConfiguration.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, "2b");
   }
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   /**
diff --git a/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterLoadMetadataTest.java b/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterLoadMetadataTest.java
index 0262436bfb..4affeb9c74 100644
--- a/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterLoadMetadataTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterLoadMetadataTest.java
@@ -14,9 +14,9 @@ package alluxio.client.fs;
 import static org.junit.Assert.assertEquals;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.testutils.LocalAlluxioClusterResource;
 
@@ -46,7 +46,7 @@ public final class ConcurrentFileSystemMasterLoadMetadataTest {
 
   @Test
   public void loadMetadataManyDirectories() throws Exception {
-    String ufsPath = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsPath = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     for (int i = 0; i < 5000; i++) {
       Files.createDirectory(Paths.get(ufsPath, "a" + i));
     }
@@ -62,7 +62,7 @@ public final class ConcurrentFileSystemMasterLoadMetadataTest {
 
   @Test
   public void loadMetadataManyFiles() throws Exception {
-    String ufsPath = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsPath = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     for (int i = 0; i < 5000; i++) {
       Files.createFile(Paths.get(ufsPath, "a" + i));
     }
diff --git a/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterSetTtlTest.java b/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterSetTtlTest.java
index b2ff32e9ac..eec9291de6 100644
--- a/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterSetTtlTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ConcurrentFileSystemMasterSetTtlTest.java
@@ -14,9 +14,10 @@ package alluxio.client.fs;
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.collections.ConcurrentHashSet;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.SetAttributePOptions;
 import alluxio.grpc.TtlAction;
@@ -67,7 +68,8 @@ public class ConcurrentFileSystemMasterSetTtlTest extends BaseIntegrationTest {
   private FileSystem mFileSystem;
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER,
+      ServerConfiguration.global());
 
   @ClassRule
   public static ManuallyScheduleHeartbeat sManuallySchedule =
diff --git a/tests/src/test/java/alluxio/client/fs/ConcurrentRenameIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/ConcurrentRenameIntegrationTest.java
index b7eb6ff475..228e05d28d 100644
--- a/tests/src/test/java/alluxio/client/fs/ConcurrentRenameIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ConcurrentRenameIntegrationTest.java
@@ -14,11 +14,12 @@ package alluxio.client.fs;
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.collections.ConcurrentHashSet;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
@@ -79,7 +80,8 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
   private String mLocalUfsPath = Files.createTempDir().getAbsolutePath();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER,
+      ServerConfiguration.global());
 
   @Rule
   public LocalAlluxioClusterResource mLocalAlluxioClusterResource =
@@ -169,7 +171,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get an error for all but 1 rename
+    // We should create an error for all but 1 rename
     Assert.assertEquals(numThreads - 1, errors.size());
 
     List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI("/"));
@@ -198,7 +200,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get an error for all but 1 rename
+    // We should create an error for all but 1 rename
     assertErrorsSizeEquals(errors, numThreads - 1);
     // Only one renamed dir should exist
     List<URIStatus> existingDirs = mFileSystem.listStatus(new AlluxioURI("/"));
@@ -226,7 +228,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get an error for all but 1 rename.
+    // We should create an error for all but 1 rename.
     assertErrorsSizeEquals(errors, numThreads - 1);
 
     List<URIStatus> files = mFileSystem.listStatus(new AlluxioURI("/"));
@@ -267,7 +269,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get no errors
+    // We should create no errors
     assertErrorsSizeEquals(errors, 0);
 
     List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
@@ -309,7 +311,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get no errors.
+    // We should create no errors.
     assertErrorsSizeEquals(errors, 0);
 
     List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
@@ -354,7 +356,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get no errors.
+    // We should create no errors.
     assertErrorsSizeEquals(errors, 0);
 
     List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
@@ -397,7 +399,7 @@ public class ConcurrentRenameIntegrationTest extends BaseIntegrationTest {
 
     ConcurrentHashSet<Throwable> errors = concurrentRename(srcs, dsts);
 
-    // We should get no errors.
+    // We should create no errors.
     assertErrorsSizeEquals(errors, 0);
 
     List<URIStatus> dir1Files = mFileSystem.listStatus(dir1);
diff --git a/tests/src/test/java/alluxio/client/fs/FileInStreamConcurrencyIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileInStreamConcurrencyIntegrationTest.java
index b9398f4700..f089b2a6e2 100644
--- a/tests/src/test/java/alluxio/client/fs/FileInStreamConcurrencyIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileInStreamConcurrencyIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
@@ -38,7 +38,7 @@ import java.util.List;
 public final class FileInStreamConcurrencyIntegrationTest extends BaseIntegrationTest {
   private static final int BLOCK_SIZE = 30;
   private static int sNumReadThreads =
-      Configuration.getInt(PropertyKey.USER_BLOCK_MASTER_CLIENT_THREADS) * 10;
+      ServerConfiguration.getInt(PropertyKey.USER_BLOCK_MASTER_CLIENT_THREADS) * 10;
 
   @ClassRule
   public static LocalAlluxioClusterResource sLocalAlluxioClusterResource =
diff --git a/tests/src/test/java/alluxio/client/fs/FileInStreamIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileInStreamIntegrationTest.java
index a7d4c6d0ed..55307061e6 100644
--- a/tests/src/test/java/alluxio/client/fs/FileInStreamIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileInStreamIntegrationTest.java
@@ -13,7 +13,7 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.ReadType;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
diff --git a/tests/src/test/java/alluxio/client/fs/FileOutStreamAsyncWriteJobIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileOutStreamAsyncWriteJobIntegrationTest.java
index d0b7f02858..57d823e2b9 100644
--- a/tests/src/test/java/alluxio/client/fs/FileOutStreamAsyncWriteJobIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileOutStreamAsyncWriteJobIntegrationTest.java
@@ -12,6 +12,7 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.SetAttributePOptions;
 import alluxio.grpc.TtlAction;
@@ -295,7 +296,7 @@ public final class FileOutStreamAsyncWriteJobIntegrationTest
     PersistenceTestUtils.pauseScheduler(mLocalAlluxioClusterResource);
     URIStatus status = createAsyncFile();
     String ufsPath = status.getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     mFileSystem.setAttribute(mUri, TEST_OPTIONS);
     checkFileInAlluxio(mUri, LEN);
     checkFileNotInUnderStorage(status.getUfsPath());
@@ -324,7 +325,7 @@ public final class FileOutStreamAsyncWriteJobIntegrationTest
     URIStatus status = createAsyncFile();
     PersistenceTestUtils.waitForJobScheduled(mLocalAlluxioClusterResource, status.getFileId());
     String ufsPath = status.getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     mFileSystem.setAttribute(mUri, TEST_OPTIONS);
     checkFileInAlluxio(mUri, LEN);
     checkFileNotInUnderStorage(status.getUfsPath());
@@ -356,7 +357,7 @@ public final class FileOutStreamAsyncWriteJobIntegrationTest
     checkFileInUnderStorage(mUri, LEN);
     URIStatus status = mFileSystem.getStatus(mUri);
     String ufsPath = status.getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     Assert.assertEquals(ModeUtils.protoToShort(TEST_OPTIONS.getMode()), status.getMode());
     Assert.assertEquals(TEST_OPTIONS.getTtl(), status.getTtl());
     Assert.assertEquals(TEST_OPTIONS.getTtlAction(), status.getTtlAction());
@@ -451,7 +452,7 @@ public final class FileOutStreamAsyncWriteJobIntegrationTest
     PersistenceTestUtils.pauseChecker(mLocalAlluxioClusterResource);
     URIStatus status = createAsyncFile();
     String ufsPath = status.getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     AlluxioURI newUri = new AlluxioURI(PathUtils.uniqPath());
     mFileSystem.createDirectory(newUri.getParent());
     mFileSystem.rename(mUri, newUri);
@@ -537,7 +538,7 @@ public final class FileOutStreamAsyncWriteJobIntegrationTest
    * @param ufsPath path of the tmp file
    */
   private void checkFileNotInUnderStorage(String ufsPath) throws Exception {
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     Assert.assertFalse(ufs.exists(ufsPath));
   }
 }
diff --git a/tests/src/test/java/alluxio/client/fs/FileOutStreamIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileOutStreamIntegrationTest.java
index c02d4e3785..cd0fb8c21d 100644
--- a/tests/src/test/java/alluxio/client/fs/FileOutStreamIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileOutStreamIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.policy.LocalFirstPolicy;
@@ -150,7 +150,7 @@ public final class FileOutStreamIntegrationTest extends AbstractFileOutStreamInt
     try (FileOutStream os = mFileSystem.createFile(filePath, CreateFilePOptions.newBuilder()
         .setWriteType(mWriteType.toProto()).setRecursive(true).build())) {
       os.write((byte) 0);
-      Thread.sleep((int) Configuration.getMs(PropertyKey.USER_HEARTBEAT_INTERVAL_MS) * 2);
+      Thread.sleep((int) ServerConfiguration.getMs(PropertyKey.USER_HEARTBEAT_INTERVAL_MS) * 2);
       os.write((byte) 1);
     }
     if (mWriteType.getAlluxioStorageType().isStore()) {
@@ -198,7 +198,7 @@ public final class FileOutStreamIntegrationTest extends AbstractFileOutStreamInt
       os.write(BufferUtils.getIncreasingByteArray(0, BLOCK_SIZE_BYTES * 3 + 1));
       os.cancel();
     }
-    long gracePeriod = Configuration.getMs(PropertyKey.MASTER_WORKER_HEARTBEAT_INTERVAL) * 2;
+    long gracePeriod = ServerConfiguration.getMs(PropertyKey.MASTER_WORKER_HEARTBEAT_INTERVAL) * 2;
     CommonUtils.sleepMs(gracePeriod);
     List<WorkerInfo> workers =
         mLocalAlluxioClusterResource.get().getLocalAlluxioMaster().getMasterProcess()
diff --git a/tests/src/test/java/alluxio/client/fs/FileSystemIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileSystemIntegrationTest.java
index 948f5a29ce..887ceef72d 100644
--- a/tests/src/test/java/alluxio/client/fs/FileSystemIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileSystemIntegrationTest.java
@@ -14,9 +14,9 @@ package alluxio.client.fs;
 import static org.junit.Assert.assertFalse;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
@@ -70,7 +70,7 @@ public final class FileSystemIntegrationTest extends BaseIntegrationTest {
     mFileSystem = mLocalAlluxioClusterResource.get().getClient();
     mWriteBoth = CreateFilePOptions.newBuilder().setRecursive(true)
         .setWriteType(WritePType.CACHE_THROUGH).build();
-    mUfs = UnderFileSystem.Factory.createForRoot();
+    mUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
   }
 
   @Test
@@ -182,7 +182,7 @@ public final class FileSystemIntegrationTest extends BaseIntegrationTest {
    */
   private String createAlternateUfs() throws Exception {
     AlluxioURI parentURI =
-        new AlluxioURI(Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS)).getParent();
+        new AlluxioURI(ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS)).getParent();
     String alternateUfsRoot = parentURI.join("alternateUnderFSStorage").toString();
     UnderFileSystemUtils.mkdirIfNotExists(mUfs, alternateUfsRoot);
     return alternateUfsRoot;
@@ -238,7 +238,7 @@ public final class FileSystemIntegrationTest extends BaseIntegrationTest {
   @Test
   public void mountPrefixUfs() throws Exception {
     // Primary UFS cannot be re-mounted
-    String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String ufsSubdir = PathUtils.concatPath(ufsRoot, "dir1");
     UnderFileSystemUtils.mkdirIfNotExists(mUfs, ufsSubdir);
     try {
@@ -275,7 +275,7 @@ public final class FileSystemIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void mountShadowUfs() throws Exception {
-    String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String ufsSubdir = PathUtils.concatPath(ufsRoot, "dir1");
     UnderFileSystemUtils.mkdirIfNotExists(mUfs, ufsSubdir);
 
diff --git a/tests/src/test/java/alluxio/client/fs/FileSystemMasterClientIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileSystemMasterClientIntegrationTest.java
index 7e1d6a7d30..f03bc96a49 100644
--- a/tests/src/test/java/alluxio/client/fs/FileSystemMasterClientIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileSystemMasterClientIntegrationTest.java
@@ -12,9 +12,10 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemMasterClient;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.status.NotFoundException;
 import alluxio.grpc.CreateFilePOptions;
@@ -45,7 +46,7 @@ public final class FileSystemMasterClientIntegrationTest extends BaseIntegration
   @Test
   public void openClose() throws AlluxioException, IOException {
     FileSystemMasterClient fsMasterClient =
-        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults());
+        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults(ServerConfiguration.global()), ServerConfiguration.global());
     AlluxioURI file = new AlluxioURI("/file");
     Assert.assertFalse(fsMasterClient.isConnected());
     fsMasterClient.connect();
@@ -66,7 +67,8 @@ public final class FileSystemMasterClientIntegrationTest extends BaseIntegration
     // The timeout will protect against this, and the change was to throw a IOException
     // in the cases we don't want to disconnect from master
     FileSystemMasterClient fsMasterClient =
-        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults());
+        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults(
+            ServerConfiguration.global()), ServerConfiguration.global());
     fsMasterClient.getStatus(new AlluxioURI("/doesNotExist"), GET_STATUS_OPTIONS);
     fsMasterClient.close();
   }
diff --git a/tests/src/test/java/alluxio/client/fs/FileSystemMasterIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileSystemMasterIntegrationTest.java
index f0f2f392ca..bd3b45677e 100644
--- a/tests/src/test/java/alluxio/client/fs/FileSystemMasterIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileSystemMasterIntegrationTest.java
@@ -16,10 +16,10 @@ import static org.junit.Assume.assumeFalse;
 
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
-import alluxio.PropertyKey.Name;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.PropertyKey.Name;
 import alluxio.client.block.BlockMasterClient;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
@@ -152,7 +152,8 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
   public ExpectedException mThrown = ExpectedException.none();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER);
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule(TEST_USER,
+      ServerConfiguration.global());
 
   private FileSystemMaster mFsMaster;
 
@@ -356,7 +357,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
         CreateDirectoryContext.defaults().setPersisted(true));
     mFsMaster.createDirectory(new AlluxioURI("/testFolder/child"),
         CreateDirectoryContext.defaults().setPersisted(true));
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     Files.createDirectory(Paths.get(ufs, "testFolder", "ufsOnlyDir"));
     try {
       mFsMaster.delete(new AlluxioURI("/testFolder"), DeleteContext
@@ -496,7 +497,9 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
     fs.delete(dir, DeletePOptions.newBuilder().setRecursive(true).build());
     assertFalse(fs.exists(dir));
     // Make sure that the blocks are cleaned up
-    BlockMasterClient blockClient = BlockMasterClient.Factory.create(MasterClientConfig.defaults());
+    BlockMasterClient blockClient =
+        BlockMasterClient.Factory.create(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global());
     CommonUtils.waitFor("data to be deleted", () -> {
       try {
         return blockClient.getUsedBytes() == 0;
@@ -803,7 +806,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
     Assert.assertEquals(alluxioFile.getName(), files.get(0).getName());
 
     // Add ufs only paths
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     Files.createDirectory(Paths.get(ufs, "ufs_dir"));
     Files.createFile(Paths.get(ufs, "ufs_file"));
 
@@ -839,7 +842,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
     AlluxioURI dir = new AlluxioURI("/dir/");
 
     // Add ufs nested file.
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     Files.createDirectory(Paths.get(ufs, "dir"));
     Files.createFile(Paths.get(ufs, "dir", "file"));
 
@@ -901,7 +904,8 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
     UnderFileSystem mockUfs = Mockito.mock(UnderFileSystem.class);
     UfsDirectoryStatus ufsStatus = new
         UfsDirectoryStatus("test", "owner", "group", (short) 511);
-    Mockito.when(mockUfsFactory.create(Matchers.eq(ufsBase), Matchers.any())).thenReturn(mockUfs);
+    Mockito.when(mockUfsFactory.create(Matchers.eq(ufsBase), Matchers.any(),
+        ServerConfiguration.global())).thenReturn(mockUfs);
     Mockito.when(mockUfs.isDirectory(ufsBase)).thenReturn(true);
     Mockito.when(mockUfs.resolveUri(new AlluxioURI(ufsBase), ""))
         .thenReturn(new AlluxioURI(ufsBase));
@@ -1152,7 +1156,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
    */
   @Test
   public void createDirectoryInNestedDirectories() throws Exception {
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String targetPath = Paths.get(ufs, "d1", "d2", "d3").toString();
     FileUtils.createDir(targetPath);
     FileUtils.changeLocalFilePermission(targetPath, new Mode((short) 0755).toString());
@@ -1177,7 +1181,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
    */
   @Test
   public void loadMetadataInNestedDirectories() throws Exception {
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String targetPath = Paths.get(ufs, "d1", "d2", "d3").toString();
     FileUtils.createDir(targetPath);
     FileUtils.changeLocalFilePermission(targetPath, new Mode((short) 0755).toString());
@@ -1201,7 +1205,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
    */
   @Test
   public void createNestedDirectories() throws Exception {
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String parentPath = Paths.get(ufs, "d1").toString();
     FileUtils.createDir(parentPath);
     FileUtils.changeLocalFilePermission(parentPath, new Mode((short) 0755).toString());
@@ -1228,7 +1232,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
     // Assume the user is not root. This test doesn't work as root because root *is* allowed to
     // create subdirectories even without execute permission on the parent directory.
     assumeFalse(ShellUtils.execCommand("id", "-u").trim().equals("0"));
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String parentPath = Paths.get(ufs, "d1").toString();
     FileUtils.createDir(parentPath);
     FileUtils.changeLocalFilePermission(parentPath, new Mode((short) 0600).toString());
@@ -1246,7 +1250,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
   @Test
   public void loadDirectoryTimestamps() throws Exception {
     String name = "d1";
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String ufsPath = Paths.get(ufs, name).toString();
     FileUtils.createDir(ufsPath);
     File file = new File(ufsPath);
@@ -1270,7 +1274,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
   @Test
   public void loadFileTimestamps() throws Exception {
     String name = "f1";
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String ufsPath = Paths.get(ufs, name).toString();
     FileUtils.createFile(ufsPath);
     File file = new File(ufsPath);
@@ -1295,7 +1299,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
   public void loadParentDirectoryTimestamps() throws Exception {
     String parentName = "d1";
     String childName = "d2";
-    String ufs = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    String ufs = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
     String parentUfsPath = Paths.get(ufs, parentName).toString();
     FileUtils.createDir(parentUfsPath);
     File file = new File(parentUfsPath);
@@ -1630,7 +1634,7 @@ public class FileSystemMasterIntegrationTest extends BaseIntegrationTest {
               .defaults(CreateDirectoryPOptions.newBuilder().setRecursive(true));
           mFsMaster.createDirectory(dstPath.getParent(), context);
         } catch (FileAlreadyExistsException | InvalidPathException e) {
-          // FileAlreadyExistsException: This is an acceptable exception to get, since we don't know
+          // FileAlreadyExistsException: This is an acceptable exception to create, since we don't know
           // if the parent has been created yet by another thread.
           // InvalidPathException: This could happen if we are renaming something that's a child of
           // the root.
diff --git a/tests/src/test/java/alluxio/client/fs/FileSystemUtilsIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FileSystemUtilsIntegrationTest.java
index 715fb6682d..bbf5f6e033 100644
--- a/tests/src/test/java/alluxio/client/fs/FileSystemUtilsIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FileSystemUtilsIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemUtils;
@@ -88,7 +88,8 @@ public class FileSystemUtilsIntegrationTest extends BaseIntegrationTest {
       @Override
       public void run() {
         try {
-          boolean completed = FileSystemUtils.waitCompleted(sFileSystem, uri);
+          boolean completed = FileSystemUtils.waitCompleted(sFileSystem, uri,
+              ServerConfiguration.getMs(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS));
           Assert.assertTrue(completed);
           completed = sFileSystem.getStatus(uri).isCompleted();
           Assert.assertTrue(completed);
@@ -142,17 +143,17 @@ public class FileSystemUtilsIntegrationTest extends BaseIntegrationTest {
         try {
           // set the slow default polling period to a more sensible value, in order
           // to speed up the tests artificial waiting times
-          String original = Configuration.get(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS);
-          Configuration.set(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS, "100");
+          String original = ServerConfiguration.get(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS);
+          ServerConfiguration.set(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS, "100");
           try {
             // The write will take at most 600ms I am waiting for at most 400ms - epsilon.
             boolean completed = FileSystemUtils.waitCompleted(sFileSystem, uri, 300,
-                TimeUnit.MILLISECONDS);
+                TimeUnit.MILLISECONDS, ServerConfiguration.getMs(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS));
             Assert.assertFalse(completed);
             completed = sFileSystem.getStatus(uri).isCompleted();
             Assert.assertFalse(completed);
           } finally {
-            Configuration.set(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS, original);
+            ServerConfiguration.set(PropertyKey.USER_FILE_WAITCOMPLETED_POLL_MS, original);
           }
         } catch (Exception e) {
           e.printStackTrace();
diff --git a/tests/src/test/java/alluxio/client/fs/FreeAndDeleteIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/FreeAndDeleteIntegrationTest.java
index 2650e4bf7e..0c63471a5b 100644
--- a/tests/src/test/java/alluxio/client/fs/FreeAndDeleteIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/FreeAndDeleteIntegrationTest.java
@@ -16,7 +16,7 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertFalse;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
diff --git a/tests/src/test/java/alluxio/client/fs/ImpersonationIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/ImpersonationIntegrationTest.java
index da7a0e04a7..410c308749 100644
--- a/tests/src/test/java/alluxio/client/fs/ImpersonationIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ImpersonationIntegrationTest.java
@@ -12,10 +12,9 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.URIStatus;
@@ -74,7 +73,7 @@ public final class ImpersonationIntegrationTest extends BaseIntegrationTest {
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Before
@@ -84,7 +83,7 @@ public final class ImpersonationIntegrationTest extends BaseIntegrationTest {
     FileSystem.Factory.get().setAttribute(new AlluxioURI("/"),
         SetAttributePOptions.newBuilder().setMode(new Mode((short) 0777).toProto()).build());
     // Enable client impersonation by default
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME, Constants.IMPERSONATION_HDFS_USER);
   }
 
@@ -97,9 +96,9 @@ public final class ImpersonationIntegrationTest extends BaseIntegrationTest {
   @Test
   @LocalAlluxioClusterResource.Config(confParams = {IMPERSONATION_GROUPS_CONFIG, "*"})
   public void impersonationNotUsed() throws Exception {
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME, Constants.IMPERSONATION_NONE);
-    FileSystemContext context = FileSystemContext.get(createHdfsSubject());
+    FileSystemContext context = FileSystemContext.create(createHdfsSubject(), ServerConfiguration.global());
     FileSystem fs = mLocalAlluxioClusterResource.get().getClient(context);
     fs.createFile(new AlluxioURI("/impersonation-test")).close();
     List<URIStatus> listing = fs.listStatus(new AlluxioURI("/"));
@@ -112,9 +111,9 @@ public final class ImpersonationIntegrationTest extends BaseIntegrationTest {
   @LocalAlluxioClusterResource.Config(confParams = {IMPERSONATION_GROUPS_CONFIG, "*"})
   public void impersonationArbitraryUserDisallowed() throws Exception {
     String arbitraryUser = "arbitrary_user";
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.SECURITY_LOGIN_IMPERSONATION_USERNAME, arbitraryUser);
-    FileSystemContext context = FileSystemContext.get(createHdfsSubject());
+    FileSystemContext context = FileSystemContext.create(createHdfsSubject(), ServerConfiguration.global());
     FileSystem fs = mLocalAlluxioClusterResource.get().getClient(context);
     fs.createFile(new AlluxioURI("/impersonation-test")).close();
     List<URIStatus> listing = fs.listStatus(new AlluxioURI("/"));
@@ -232,7 +231,7 @@ public final class ImpersonationIntegrationTest extends BaseIntegrationTest {
   }
 
   private void checkCreateFile(Subject subject, String expectedUser) throws Exception {
-    FileSystemContext context = FileSystemContext.get(subject);
+    FileSystemContext context = FileSystemContext.create(subject, ServerConfiguration.global());
     FileSystem fs = mLocalAlluxioClusterResource.get().getClient(context);
     fs.createFile(new AlluxioURI("/impersonation-test")).close();
     List<URIStatus> listing = fs.listStatus(new AlluxioURI("/"));
diff --git a/tests/src/test/java/alluxio/client/fs/IsolatedFileSystemIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/IsolatedFileSystemIntegrationTest.java
index f4a7582f93..635b3e075a 100644
--- a/tests/src/test/java/alluxio/client/fs/IsolatedFileSystemIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/IsolatedFileSystemIntegrationTest.java
@@ -13,7 +13,7 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
diff --git a/tests/src/test/java/alluxio/client/fs/LoadMetadataIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/LoadMetadataIntegrationTest.java
index 8e6eb23cb0..3cffc73c91 100644
--- a/tests/src/test/java/alluxio/client/fs/LoadMetadataIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/LoadMetadataIntegrationTest.java
@@ -13,10 +13,10 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -59,7 +59,7 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
   private String mLocalUfsPath = Files.createTempDir().getAbsolutePath();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule("test");
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule("test", ServerConfiguration.global());
 
   @Rule
   public LocalAlluxioClusterResource mLocalAlluxioClusterResource =
@@ -85,7 +85,7 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
@@ -174,7 +174,7 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void loadAlwaysConfiguration() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Always.toString());
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Always.toString());
     GetStatusPOptions options = GetStatusPOptions.getDefaultInstance();
     checkGetStatus("/mnt/dir1/dirA/fileDNE1", options, false, true);
     checkGetStatus("/mnt/dir1/dirA/fileDNE1", options, false, true);
@@ -182,7 +182,7 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void loadOnceConfiguration() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Once.toString());
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Once.toString());
     GetStatusPOptions options = GetStatusPOptions.getDefaultInstance();
     checkGetStatus("/mnt/dir1/dirA/fileDNE1", options, false, true);
     checkGetStatus("/mnt/dir1/dirA/fileDNE1", options, false, false);
@@ -190,7 +190,7 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void loadNeverConfiguration() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Never.toString());
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Never.toString());
     GetStatusPOptions options = GetStatusPOptions.getDefaultInstance();
     checkGetStatus("/mnt/dir1/dirA/fileDNE1", options, false, false);
     checkGetStatus("/mnt/dir1/dirA/fileDNE1", options, false, false);
@@ -198,7 +198,7 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void loadRecursive() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Once.toString());
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, LoadMetadataType.Once.toString());
     ListStatusPOptions options = ListStatusPOptions.newBuilder().setRecursive(true).build();
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
@@ -221,12 +221,12 @@ public class LoadMetadataIntegrationTest extends BaseIntegrationTest {
   }
 
   /**
-   * Checks the get status call with the specified parameters and expectations.
+   * Checks the create status call with the specified parameters and expectations.
    *
-   * @param path the path to get the status for
-   * @param options the options for the get status call
+   * @param path the path to create the status for
+   * @param options the options for the create status call
    * @param expectExists if true, the path should exist
-   * @param expectLoadFromUfs if true, the get status call will load from ufs
+   * @param expectLoadFromUfs if true, the create status call will load from ufs
    */
   private void checkGetStatus(final String path, GetStatusPOptions options, boolean expectExists,
       boolean expectLoadFromUfs)
diff --git a/tests/src/test/java/alluxio/client/fs/LocalFirstPolicyIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/LocalFirstPolicyIntegrationTest.java
index 7365cfd7d1..e94c53beea 100644
--- a/tests/src/test/java/alluxio/client/fs/LocalFirstPolicyIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/LocalFirstPolicyIntegrationTest.java
@@ -17,9 +17,10 @@ import alluxio.AlluxioTestDirectory;
 import alluxio.ConfigurationRule;
 import alluxio.ConfigurationTestUtils;
 import alluxio.Process;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.WritePType;
 import alluxio.master.AlluxioMasterProcess;
 import alluxio.master.MasterProcess;
@@ -48,11 +49,13 @@ public class LocalFirstPolicyIntegrationTest extends BaseIntegrationTest {
   private ExecutorService mExecutor;
 
   @Rule
-  public ConfigurationRule mConf = new ConfigurationRule(conf());
+  public ConfigurationRule mConf = new ConfigurationRule(conf(), ServerConfiguration.global());
 
   private static Map<PropertyKey, String> conf() {
-    Map<PropertyKey, String> map = ConfigurationTestUtils.testConfigurationDefaults(
-        NetworkAddressUtils.getLocalHostName(),
+    Map<PropertyKey, String> map =
+        ConfigurationTestUtils.testConfigurationDefaults(ServerConfiguration.global(),
+        NetworkAddressUtils.getLocalHostName(
+            (int)ServerConfiguration.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)),
         AlluxioTestDirectory.createTemporaryDirectory("tiered_identity_test").getAbsolutePath());
     map.put(PropertyKey.MASTER_RPC_PORT, "0");
     map.put(PropertyKey.MASTER_WEB_PORT, "0");
@@ -76,9 +79,11 @@ public class LocalFirstPolicyIntegrationTest extends BaseIntegrationTest {
   public void test() throws Exception {
     MasterProcess master = AlluxioMasterProcess.Factory.create();
     WorkerProcess worker1 = AlluxioWorkerProcess.Factory
-        .create(TieredIdentityFactory.fromString("node=node1,rack=rack1"));
+        .create(TieredIdentityFactory.fromString("node=node1,rack=rack1",
+            ServerConfiguration.global()));
     WorkerProcess worker2 = AlluxioWorkerProcess.Factory
-        .create(TieredIdentityFactory.fromString("node=node2,rack=rack2"));
+        .create(TieredIdentityFactory.fromString("node=node2,rack=rack2",
+            ServerConfiguration.global()));
 
     runProcess(mExecutor, master);
     runProcess(mExecutor, worker1);
@@ -93,7 +98,8 @@ public class LocalFirstPolicyIntegrationTest extends BaseIntegrationTest {
     // Write to the worker in node1
     {
       Whitebox.setInternalState(TieredIdentityFactory.class, "sInstance",
-          TieredIdentityFactory.fromString("node=node1,rack=rack1"));
+          TieredIdentityFactory.fromString("node=node1,rack=rack1",
+              ServerConfiguration.global()));
       try {
         FileSystemTestUtils.createByteFile(fs, "/file1", WritePType.MUST_CACHE, 100);
       } finally {
@@ -108,7 +114,8 @@ public class LocalFirstPolicyIntegrationTest extends BaseIntegrationTest {
     // Write to the worker in rack2
     {
       Whitebox.setInternalState(TieredIdentityFactory.class, "sInstance",
-          TieredIdentityFactory.fromString("node=node3,rack=rack2"));
+          TieredIdentityFactory.fromString("node=node3,rack=rack2",
+              ServerConfiguration.global()));
       try {
         FileSystemTestUtils.createByteFile(fs, "/file2", WritePType.MUST_CACHE, 10);
       } finally {
diff --git a/tests/src/test/java/alluxio/client/fs/MultiUfsMountIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/MultiUfsMountIntegrationTest.java
index 4644807d61..377a1971cc 100644
--- a/tests/src/test/java/alluxio/client/fs/MultiUfsMountIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/MultiUfsMountIntegrationTest.java
@@ -12,9 +12,10 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.MountPOptions;
 import alluxio.grpc.WritePType;
@@ -81,7 +82,7 @@ public final class MultiUfsMountIntegrationTest extends BaseIntegrationTest {
     mUfsUri1 = "ufs1://" + mFolder.newFolder().getAbsoluteFile();
     mUfsUri2 = "ufs2://" + mFolder.newFolder().getAbsoluteFile();
     mLocalUfs = new LocalUnderFileSystemFactory().create(mFolder.getRoot().getAbsolutePath(),
-        UnderFileSystemConfiguration.defaults());
+        UnderFileSystemConfiguration.defaults(), ServerConfiguration.global());
     mLocalAlluxioClusterResource.start();
     mLocalAlluxioCluster = mLocalAlluxioClusterResource.get();
     mFileSystem = mLocalAlluxioCluster.getClient();
diff --git a/tests/src/test/java/alluxio/client/fs/PersistMultipleMountsIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/PersistMultipleMountsIntegrationTest.java
index cd852f5aea..4c89b102ac 100644
--- a/tests/src/test/java/alluxio/client/fs/PersistMultipleMountsIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/PersistMultipleMountsIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.URIStatus;
 import alluxio.grpc.CreateFilePOptions;
@@ -50,12 +50,12 @@ public final class PersistMultipleMountsIntegrationTest
   public void before() throws Exception {
     super.before();
 
-    mUfsRoot = PathUtils.concatPath(Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS));
-    mUfs = UnderFileSystem.Factory.create(mUfsRoot);
+    mUfsRoot = PathUtils.concatPath(ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS));
+    mUfs = UnderFileSystem.Factory.create(mUfsRoot, ServerConfiguration.global());
 
     mMountedUfsRoot = mTempFolder.getRoot().getAbsolutePath();
     mFileSystem.mount(new AlluxioURI(MOUNT_PATH), new AlluxioURI(mMountedUfsRoot));
-    mMountedUfs = UnderFileSystem.Factory.create(mMountedUfsRoot);
+    mMountedUfs = UnderFileSystem.Factory.create(mMountedUfsRoot, ServerConfiguration.global());
   }
 
   @Test
diff --git a/tests/src/test/java/alluxio/client/fs/PersistPermissionIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/PersistPermissionIntegrationTest.java
index c248feef92..abc28ecef4 100644
--- a/tests/src/test/java/alluxio/client/fs/PersistPermissionIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/PersistPermissionIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.URIStatus;
 import alluxio.grpc.CreateFilePOptions;
@@ -42,8 +42,8 @@ public final class PersistPermissionIntegrationTest extends AbstractFileOutStrea
   public void before() throws Exception {
     super.before();
 
-    mUfsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
-    mUfs = UnderFileSystem.Factory.createForRoot();
+    mUfsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    mUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
   }
 
   @Test
diff --git a/tests/src/test/java/alluxio/client/fs/PinIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/PinIntegrationTest.java
index 30dd5069b5..0f2c974980 100644
--- a/tests/src/test/java/alluxio/client/fs/PinIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/PinIntegrationTest.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.SetAttributePOptions;
@@ -49,7 +50,7 @@ public final class PinIntegrationTest extends BaseIntegrationTest {
   @Before
   public final void before() throws Exception {
     mFileSystem = mLocalAlluxioClusterResource.get().getClient();
-    mFSMasterClient = new FileSystemMasterClient(MasterClientConfig.defaults());
+    mFSMasterClient = new FileSystemMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()));
     mSetPinned = SetAttributePOptions.newBuilder().setPinned(true).build();
     mUnsetPinned = SetAttributePOptions.newBuilder().setPinned(false).build();
   }
diff --git a/tests/src/test/java/alluxio/client/fs/ReadOnlyMountIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/ReadOnlyMountIntegrationTest.java
index 7eda2c8ad6..cd5dea9347 100644
--- a/tests/src/test/java/alluxio/client/fs/ReadOnlyMountIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/ReadOnlyMountIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.exception.AccessControlException;
@@ -60,8 +60,8 @@ public class ReadOnlyMountIntegrationTest extends BaseIntegrationTest {
     // Create another directory on the local filesystem, alongside the existing Ufs, to be used as
     // a second Ufs.
     AlluxioURI parentURI =
-        new AlluxioURI(Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS)).getParent();
-    mUfs = UnderFileSystem.Factory.createForRoot();
+        new AlluxioURI(ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS)).getParent();
+    mUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
     mAlternateUfsRoot = parentURI.join("alternateUnderFSStorage").toString();
     String ufsMountDir = PathUtils.concatPath(mAlternateUfsRoot, MOUNT_PATH);
     UnderFileSystemUtils.mkdirIfNotExists(mUfs, mAlternateUfsRoot);
diff --git a/tests/src/test/java/alluxio/client/fs/RemoteReadIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/RemoteReadIntegrationTest.java
index 1cc2ffc2e5..405b799122 100644
--- a/tests/src/test/java/alluxio/client/fs/RemoteReadIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/RemoteReadIntegrationTest.java
@@ -12,7 +12,8 @@
 package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.client.ReadType;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.stream.BlockInStream;
 import alluxio.client.block.stream.BlockInStream.BlockInStreamSource;
@@ -23,6 +24,7 @@ import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.client.file.URIStatus;
 import alluxio.client.file.options.InStreamOptions;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.PreconditionMessage;
 import alluxio.exception.status.NotFoundException;
 import alluxio.grpc.CreateFilePOptions;
@@ -244,14 +246,14 @@ public class RemoteReadIntegrationTest extends BaseIntegrationTest {
       FileSystemTestUtils.createByteFile(mFileSystem, uri, mWriteAlluxio, k);
 
       URIStatus status = mFileSystem.getStatus(uri);
-      InStreamOptions options = new InStreamOptions(status);
+      InStreamOptions options = new InStreamOptions(status, ServerConfiguration.global());
       long blockId = status.getBlockIds().get(0);
-      AlluxioBlockStore blockStore = AlluxioBlockStore.create();
+      AlluxioBlockStore blockStore = AlluxioBlockStore.create(ServerConfiguration.global());
       BlockInfo info = blockStore.getInfo(blockId);
       WorkerNetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();
       BlockInStream is =
-          BlockInStream.create(FileSystemContext.get(), options.getBlockInfo(blockId),
-              workerAddr, BlockInStreamSource.REMOTE, options);
+          BlockInStream.create(FileSystemContext.create(), options.getBlockInfo(blockId),
+              workerAddr, BlockInStreamSource.REMOTE, options, ServerConfiguration.global());
       byte[] ret = new byte[k];
       int value = is.read();
       int cnt = 0;
@@ -279,13 +281,13 @@ public class RemoteReadIntegrationTest extends BaseIntegrationTest {
       FileSystemTestUtils.createByteFile(mFileSystem, uri, mWriteAlluxio, k);
 
       URIStatus status = mFileSystem.getStatus(uri);
-      InStreamOptions options = new InStreamOptions(status);
+      InStreamOptions options = new InStreamOptions(status, ServerConfiguration.global());
       long blockId = status.getBlockIds().get(0);
-      BlockInfo info = AlluxioBlockStore.create().getInfo(blockId);
+      BlockInfo info = AlluxioBlockStore.create(ServerConfiguration.global()).getInfo(blockId);
       WorkerNetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();
       BlockInStream is =
-          BlockInStream.create(FileSystemContext.get(), options.getBlockInfo(blockId),
-              workerAddr, BlockInStreamSource.REMOTE, options);
+          BlockInStream.create(FileSystemContext.create(), options.getBlockInfo(blockId),
+              workerAddr, BlockInStreamSource.REMOTE, options, ServerConfiguration.global());
       byte[] ret = new byte[k];
       int read = is.read(ret);
       Assert
@@ -307,13 +309,13 @@ public class RemoteReadIntegrationTest extends BaseIntegrationTest {
       FileSystemTestUtils.createByteFile(mFileSystem, uri, mWriteAlluxio, k);
 
       URIStatus status = mFileSystem.getStatus(uri);
-      InStreamOptions options = new InStreamOptions(status);
+      InStreamOptions options = new InStreamOptions(status, ServerConfiguration.global());
       long blockId = status.getBlockIds().get(0);
-      BlockInfo info = AlluxioBlockStore.create().getInfo(blockId);
+      BlockInfo info = AlluxioBlockStore.create(ServerConfiguration.global()).getInfo(blockId);
       WorkerNetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();
       BlockInStream is =
-          BlockInStream.create(FileSystemContext.get(), options.getBlockInfo(blockId),
-              workerAddr, BlockInStreamSource.REMOTE, options);
+          BlockInStream.create(FileSystemContext.create(), options.getBlockInfo(blockId),
+              workerAddr, BlockInStreamSource.REMOTE, options, ServerConfiguration.global());
       byte[] ret = new byte[k / 2];
       int read = 0;
       while (read < k / 2) {
@@ -550,14 +552,14 @@ public class RemoteReadIntegrationTest extends BaseIntegrationTest {
       HeartbeatScheduler.execute(HeartbeatContext.WORKER_BLOCK_SYNC);
 
       URIStatus status = mFileSystem.getStatus(uri);
-      InStreamOptions options = new InStreamOptions(status);
+      InStreamOptions options = new InStreamOptions(status, ServerConfiguration.global());
       long blockId = status.getBlockIds().get(0);
-      BlockInfo info = AlluxioBlockStore.create().getInfo(blockId);
+      BlockInfo info = AlluxioBlockStore.create(ServerConfiguration.global()).getInfo(blockId);
 
       WorkerNetAddress workerAddr = info.getLocations().get(0).getWorkerAddress();
       BlockInStream is =
-          BlockInStream.create(FileSystemContext.get(), options.getBlockInfo(blockId),
-              workerAddr, BlockInStreamSource.REMOTE, options);
+          BlockInStream.create(FileSystemContext.create(), options.getBlockInfo(blockId),
+              workerAddr, BlockInStreamSource.REMOTE, options, ServerConfiguration.global());
       Assert.assertEquals(0, is.read());
       mFileSystem.delete(uri);
       HeartbeatScheduler.execute(HeartbeatContext.WORKER_BLOCK_SYNC);
@@ -573,8 +575,8 @@ public class RemoteReadIntegrationTest extends BaseIntegrationTest {
       // Try to create an in stream again, and it should fail.
       BlockInStream is2 = null;
       try {
-        is2 = BlockInStream.create(FileSystemContext.get(), options.getBlockInfo(blockId),
-            workerAddr, BlockInStreamSource.REMOTE, options);
+        is2 = BlockInStream.create(FileSystemContext.create(), options.getBlockInfo(blockId),
+            workerAddr, BlockInStreamSource.REMOTE, options, ServerConfiguration.global());
       } catch (NotFoundException e) {
         // Expected since the file has been deleted.
       } finally {
diff --git a/tests/src/test/java/alluxio/client/fs/TtlIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/TtlIntegrationTest.java
index 0ecbeba18a..b89c49cd0f 100644
--- a/tests/src/test/java/alluxio/client/fs/TtlIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/TtlIntegrationTest.java
@@ -15,7 +15,7 @@ import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.FileSystemMasterCommonPOptions;
diff --git a/tests/src/test/java/alluxio/client/fs/UfsFallbackFileOutStreamIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/UfsFallbackFileOutStreamIntegrationTest.java
index 040e1c752f..cbff9252d4 100644
--- a/tests/src/test/java/alluxio/client/fs/UfsFallbackFileOutStreamIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/UfsFallbackFileOutStreamIntegrationTest.java
@@ -13,9 +13,10 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.WritePType;
 import alluxio.master.file.meta.PersistenceState;
@@ -87,7 +88,7 @@ public class UfsFallbackFileOutStreamIntegrationTest extends AbstractFileOutStre
         put(PropertyKey.USER_FILE_BUFFER_BYTES, String.valueOf(mUserFileBufferSize));
         put(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, String.valueOf(mBlockSize));
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       AlluxioURI filePath = new AlluxioURI(PathUtils.uniqPath());
       CreateFilePOptions op = CreateFilePOptions.newBuilder()
           .setWriteType(WritePType.ASYNC_THROUGH).setRecursive(true).build();
@@ -119,7 +120,7 @@ public class UfsFallbackFileOutStreamIntegrationTest extends AbstractFileOutStre
         put(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, String.valueOf(mBlockSize));
         put(PropertyKey.USER_SHORT_CIRCUIT_ENABLED, "false");
       }
-    }).toResource()) {
+    }, ServerConfiguration.global()).toResource()) {
       AlluxioURI filePath = new AlluxioURI(PathUtils.uniqPath());
       CreateFilePOptions op = CreateFilePOptions.newBuilder()
           .setWriteType(WritePType.ASYNC_THROUGH).setRecursive(true).build();
diff --git a/tests/src/test/java/alluxio/client/fs/UfsSyncIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/UfsSyncIntegrationTest.java
index 3801908022..d1c58ca853 100644
--- a/tests/src/test/java/alluxio/client/fs/UfsSyncIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/UfsSyncIntegrationTest.java
@@ -15,9 +15,9 @@ import static org.junit.Assert.assertFalse;
 
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.BlockMasterClient;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
@@ -83,7 +83,7 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
   private String mLocalUfsPath = Files.createTempDir().getAbsolutePath();
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule("test");
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule("test", ServerConfiguration.global());
 
   @Rule
   public LocalAlluxioClusterResource mLocalAlluxioClusterResource =
@@ -91,7 +91,7 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
 
   @After
   public void after() throws Exception {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Before
@@ -515,7 +515,9 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
     assertFalse(mFileSystem.exists(new AlluxioURI(alluxioPath(EXISTING_FILE)),
         ExistsPOptions.newBuilder().setCommonOptions(PSYNC_ALWAYS).build()));
     mFileSystem.free(new AlluxioURI("/"), FreePOptions.newBuilder().setRecursive(true).build());
-    BlockMasterClient blockClient = BlockMasterClient.Factory.create(MasterClientConfig.defaults());
+    BlockMasterClient blockClient =
+        BlockMasterClient.Factory.create(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global());
     CommonUtils.waitFor("data to be freed", () -> {
       try {
         return blockClient.getUsedBytes() == 0;
@@ -527,7 +529,7 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void createNestedFileSync() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
 
     mFileSystem.createFile(new AlluxioURI(alluxioPath(NEW_NESTED_FILE)),
         CreateFilePOptions.newBuilder().setWriteType(WritePType.CACHE_THROUGH)
@@ -540,8 +542,8 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void recursiveSync() throws Exception {
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
-    Configuration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, "Never");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_LOAD_TYPE, "Never");
 
     // make nested directories/files in UFS
     new File(ufsPath("/dir1")).mkdirs();
@@ -564,13 +566,13 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
     }
 
     // Enable UFS sync, before next recursive setAttribute.
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
     long ttl = 123456789;
     mFileSystem.setAttribute(new AlluxioURI(alluxioPath("/dir1")),
         SetAttributePOptions.newBuilder().setRecursive(true).setTtl(ttl).build());
 
     // Verify recursive set TTL by getting info, without sync.
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
     URIStatus status = mFileSystem.getStatus(new AlluxioURI(alluxioPath(fileA)));
     Assert.assertEquals(ttl, status.getTtl());
 
@@ -579,13 +581,13 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
     Assert.assertTrue(new File(ufsPath(fileA)).delete());
 
     // Enable UFS sync, before next recursive setAttribute.
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "0");
     ttl = 987654321;
     mFileSystem.setAttribute(new AlluxioURI(alluxioPath("/dir1")),
         SetAttributePOptions.newBuilder().setRecursive(true).setTtl(ttl).build());
 
     // Verify recursive set TTL by getting info, without sync.
-    Configuration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
+    ServerConfiguration.set(PropertyKey.USER_FILE_METADATA_SYNC_INTERVAL, "-1");
     status = mFileSystem.getStatus(new AlluxioURI(alluxioPath(fileB)));
     Assert.assertEquals(ttl, status.getTtl());
 
@@ -668,7 +670,8 @@ public class UfsSyncIntegrationTest extends BaseIntegrationTest {
             + ") are inconsistent. path: " + uriStatus.getPath());
       }
       // Check fingerprint.
-      UnderFileSystem ufs = UnderFileSystem.Factory.create(uriStatus.getUfsPath());
+      UnderFileSystem ufs = UnderFileSystem.Factory.create(uriStatus.getUfsPath(),
+          ServerConfiguration.global());
       String ufsFingerprint = ufs.getFingerprint(uriStatus.getUfsPath());
       String alluxioFingerprint = uriStatus.getUfsFingerprint();
       if (!ufsFingerprint.equals(alluxioFingerprint)) {
diff --git a/tests/src/test/java/alluxio/client/fs/UnderStorageReadIntegrationTest.java b/tests/src/test/java/alluxio/client/fs/UnderStorageReadIntegrationTest.java
index 76b30f676d..b3eb804e3d 100644
--- a/tests/src/test/java/alluxio/client/fs/UnderStorageReadIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/fs/UnderStorageReadIntegrationTest.java
@@ -13,7 +13,7 @@ package alluxio.client.fs;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
diff --git a/tests/src/test/java/alluxio/client/hadoop/AbstractIOMapper.java b/tests/src/test/java/alluxio/client/hadoop/AbstractIOMapper.java
index 9868c4c88e..2c0b5a4fc1 100644
--- a/tests/src/test/java/alluxio/client/hadoop/AbstractIOMapper.java
+++ b/tests/src/test/java/alluxio/client/hadoop/AbstractIOMapper.java
@@ -104,7 +104,7 @@ public abstract class AbstractIOMapper<T> extends Configured implements
   /**
    * Map file name and offset into statistical data.
    * <p>
-   * The map task is to get the <tt>key</tt>, which contains the file name, and the <tt>value</tt>,
+   * The map task is to create the <tt>key</tt>, which contains the file name, and the <tt>value</tt>,
    * which is the offset within the file.
    *
    * The parameters are passed to the abstract method
diff --git a/tests/src/test/java/alluxio/client/hadoop/DFSIOIntegrationTest.java b/tests/src/test/java/alluxio/client/hadoop/DFSIOIntegrationTest.java
index 9d3b9caa50..568453f1e5 100644
--- a/tests/src/test/java/alluxio/client/hadoop/DFSIOIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/hadoop/DFSIOIntegrationTest.java
@@ -12,7 +12,7 @@
 package alluxio.client.hadoop;
 
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.hadoop.FileSystem;
 import alluxio.testutils.BaseIntegrationTest;
 import alluxio.testutils.LocalAlluxioClusterResource;
@@ -875,10 +875,10 @@ public class DFSIOIntegrationTest extends BaseIntegrationTest implements Tool {
    * @return
    */
   static long parseSize(String arg) {
-    String[] args = arg.split("\\D", 2); // get digits
+    String[] args = arg.split("\\D", 2); // create digits
     assert args.length <= 2;
     long nrBytes = Long.parseLong(args[0]);
-    String bytesMult = arg.substring(args[0].length()); // get byte multiple
+    String bytesMult = arg.substring(args[0].length()); // create byte multiple
     return nrBytes * ByteMultiple.parseString(bytesMult).value();
   }
 
diff --git a/tests/src/test/java/alluxio/client/hadoop/FileSystemAclIntegrationTest.java b/tests/src/test/java/alluxio/client/hadoop/FileSystemAclIntegrationTest.java
index e7487b4018..d90755cfd1 100644
--- a/tests/src/test/java/alluxio/client/hadoop/FileSystemAclIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/hadoop/FileSystemAclIntegrationTest.java
@@ -12,8 +12,9 @@
 package alluxio.client.hadoop;
 
 import alluxio.Constants;
+import alluxio.conf.ServerConfiguration;
 import alluxio.hadoop.HadoopClientTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.hadoop.FileSystem;
 import alluxio.security.authentication.AuthType;
 import alluxio.security.authorization.Mode;
@@ -93,8 +94,8 @@ public final class FileSystemAclIntegrationTest extends BaseIntegrationTest {
     URI uri = URI.create(sLocalAlluxioClusterResource.get().getMasterURI());
 
     sTFS = org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    sUfsRoot = alluxio.Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
-    sUfs = UnderFileSystem.Factory.createForRoot();
+    sUfsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    sUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
   }
 
   @After
@@ -463,7 +464,7 @@ public final class FileSystemAclIntegrationTest extends BaseIntegrationTest {
       sTFS.delete(file, false);
       // Create a file directly in UFS and set the corresponding mode.
       String ufsPath = PathUtils.concatPath(sUfsRoot, file);
-      sUfs.create(ufsPath, CreateOptions.defaults().setOwner("testuser").setGroup("testgroup")
+      sUfs.create(ufsPath, CreateOptions.defaults(ServerConfiguration.global()).setOwner("testuser").setGroup("testgroup")
           .setMode(new Mode((short) value))).close();
       Assert.assertTrue(sUfs.isFile(PathUtils.concatPath(sUfsRoot, file)));
       // Check the mode is consistent in Alluxio namespace once it's loaded from UFS to Alluxio.
@@ -489,7 +490,7 @@ public final class FileSystemAclIntegrationTest extends BaseIntegrationTest {
       // Create a directory directly in UFS and set the corresponding mode.
       String ufsPath = PathUtils.concatPath(sUfsRoot, dir);
       sUfs.mkdirs(ufsPath,
-          MkdirsOptions.defaults().setCreateParent(false).setOwner("testuser").setGroup("testgroup")
+          MkdirsOptions.defaults(ServerConfiguration.global()).setCreateParent(false).setOwner("testuser").setGroup("testgroup")
               .setMode(new Mode((short) value)));
       Assert.assertTrue(sUfs.isDirectory(PathUtils.concatPath(sUfsRoot, dir)));
       // Check the mode is consistent in Alluxio namespace once it's loaded from UFS to Alluxio.
@@ -502,7 +503,7 @@ public final class FileSystemAclIntegrationTest extends BaseIntegrationTest {
   public void s3GetPermission() throws Exception {
     Assume.assumeTrue(UnderFileSystemUtils.isS3(sUfs));
 
-    alluxio.Configuration.unset(PropertyKey.UNDERFS_S3_OWNER_ID_TO_USERNAME_MAPPING);
+    ServerConfiguration.unset(PropertyKey.UNDERFS_S3_OWNER_ID_TO_USERNAME_MAPPING);
     Path fileA = new Path("/s3GetPermissionFile");
     create(sTFS, fileA);
     Assert.assertTrue(sUfs.isFile(PathUtils.concatPath(sUfsRoot, fileA)));
@@ -519,7 +520,7 @@ public final class FileSystemAclIntegrationTest extends BaseIntegrationTest {
   public void gcsGetPermission() throws Exception {
     Assume.assumeTrue(UnderFileSystemUtils.isGcs(sUfs));
 
-    alluxio.Configuration.unset(PropertyKey.UNDERFS_GCS_OWNER_ID_TO_USERNAME_MAPPING);
+    ServerConfiguration.unset(PropertyKey.UNDERFS_GCS_OWNER_ID_TO_USERNAME_MAPPING);
     Path fileA = new Path("/gcsGetPermissionFile");
     create(sTFS, fileA);
     Assert.assertTrue(sUfs.isFile(PathUtils.concatPath(sUfsRoot, fileA)));
diff --git a/tests/src/test/java/alluxio/client/hadoop/FileSystemIntegrationTest.java b/tests/src/test/java/alluxio/client/hadoop/FileSystemIntegrationTest.java
index d5bee7f47d..8dedc69b5b 100644
--- a/tests/src/test/java/alluxio/client/hadoop/FileSystemIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/hadoop/FileSystemIntegrationTest.java
@@ -11,7 +11,7 @@
 
 package alluxio.client.hadoop;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.hadoop.FileSystem;
 import alluxio.security.authentication.AuthType;
 import alluxio.testutils.LocalAlluxioClusterResource;
diff --git a/tests/src/test/java/alluxio/client/hadoop/FileSystemRenameIntegrationTest.java b/tests/src/test/java/alluxio/client/hadoop/FileSystemRenameIntegrationTest.java
index 74cb889880..20edcac316 100644
--- a/tests/src/test/java/alluxio/client/hadoop/FileSystemRenameIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/hadoop/FileSystemRenameIntegrationTest.java
@@ -11,7 +11,8 @@
 
 package alluxio.client.hadoop;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.hadoop.FileSystem;
 import alluxio.testutils.BaseIntegrationTest;
 import alluxio.testutils.LocalAlluxioClusterResource;
@@ -70,8 +71,8 @@ public final class FileSystemRenameIntegrationTest extends BaseIntegrationTest {
     URI uri = URI.create(sLocalAlluxioClusterResource.get().getMasterURI());
 
     sTFS = org.apache.hadoop.fs.FileSystem.get(uri, conf);
-    sUfsRoot = alluxio.Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
-    sUfs = UnderFileSystem.Factory.createForRoot();
+    sUfsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    sUfs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
   }
 
   @Test
diff --git a/tests/src/test/java/alluxio/client/hadoop/FileSystemStatisticsTest.java b/tests/src/test/java/alluxio/client/hadoop/FileSystemStatisticsTest.java
index 387bc50536..0b1ca1ca94 100644
--- a/tests/src/test/java/alluxio/client/hadoop/FileSystemStatisticsTest.java
+++ b/tests/src/test/java/alluxio/client/hadoop/FileSystemStatisticsTest.java
@@ -11,7 +11,7 @@
 
 package alluxio.client.hadoop;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.grpc.WritePType;
 import alluxio.hadoop.FileSystem;
diff --git a/tests/src/test/java/alluxio/client/hadoop/HdfsFileInputStreamIntegrationTest.java b/tests/src/test/java/alluxio/client/hadoop/HdfsFileInputStreamIntegrationTest.java
index ebdb265d76..606c72a9ec 100644
--- a/tests/src/test/java/alluxio/client/hadoop/HdfsFileInputStreamIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/hadoop/HdfsFileInputStreamIntegrationTest.java
@@ -12,12 +12,13 @@
 package alluxio.client.hadoop;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.ReadType;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.exception.PreconditionMessage;
 import alluxio.grpc.WritePType;
@@ -67,7 +68,7 @@ public final class HdfsFileInputStreamIntegrationTest extends BaseIntegrationTes
       mUfsInputStream.close();
       mFileSystem.delete(new AlluxioURI(UFS_ONLY_FILE));
     }
-    HadoopClientTestUtils.resetClient();
+    HadoopClientTestUtils.resetClient(ServerConfiguration.global());
   }
 
   @Before
@@ -75,18 +76,18 @@ public final class HdfsFileInputStreamIntegrationTest extends BaseIntegrationTes
     mFileSystem = sLocalAlluxioClusterResource.get().getClient();
     FileSystemTestUtils
         .createByteFile(mFileSystem, IN_MEMORY_FILE, WritePType.CACHE_THROUGH, FILE_LEN);
-    mInMemInputStream = new HdfsFileInputStream(FileSystemContext.get(),
-        new AlluxioURI(IN_MEMORY_FILE), null);
+    mInMemInputStream = new HdfsFileInputStream(FileSystemContext.create(),
+        new AlluxioURI(IN_MEMORY_FILE), null, ServerConfiguration.global());
   }
 
   private void createUfsInStream(ReadType readType) throws Exception {
-    String defaultReadType = alluxio.Configuration.get(PropertyKey.USER_FILE_READ_TYPE_DEFAULT);
-    alluxio.Configuration.set(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, readType.name());
-    FileSystemTestUtils.createByteFile(mFileSystem, UFS_ONLY_FILE, WritePType.THROUGH,
+    String defaultReadType = ServerConfiguration.get(PropertyKey.USER_FILE_READ_TYPE_DEFAULT);
+    ServerConfiguration.set(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, readType.name());
+    FileSystemTestUtils.createByteFile(mFileSystem, UFS_ONLY_FILE, WritePType.WRITE_THROUGH,
         FILE_LEN);
-    mUfsInputStream = new HdfsFileInputStream(FileSystemContext.get(),
-        new AlluxioURI(UFS_ONLY_FILE), null);
-    alluxio.Configuration.set(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, defaultReadType);
+    mUfsInputStream = new HdfsFileInputStream(FileSystemContext.create(),
+        new AlluxioURI(UFS_ONLY_FILE), null, ServerConfiguration.global());
+    ServerConfiguration.set(PropertyKey.USER_FILE_READ_TYPE_DEFAULT, defaultReadType);
   }
 
   /**
diff --git a/tests/src/test/java/alluxio/client/keyvalue/KeyValuePartitionIntegrationTest.java b/tests/src/test/java/alluxio/client/keyvalue/KeyValuePartitionIntegrationTest.java
index b9e138ea37..4cfc8ffbee 100644
--- a/tests/src/test/java/alluxio/client/keyvalue/KeyValuePartitionIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/keyvalue/KeyValuePartitionIntegrationTest.java
@@ -13,8 +13,9 @@ package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.testutils.BaseIntegrationTest;
 import alluxio.testutils.LocalAlluxioClusterResource;
@@ -104,13 +105,15 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
    */
   @Test
   public void readerWriter() throws Exception {
-    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri);
+    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     mKeyValuePartitionWriter.put(KEY1, VALUE1);
     mKeyValuePartitionWriter.put(KEY2, VALUE2);
     mKeyValuePartitionWriter.close();
     // Expect the key-value partition exists as an Alluxio file
     Assert.assertTrue(sFileSystem.exists(mPartitionUri));
-    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri);
+    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     Assert.assertArrayEquals(VALUE1, mKeyValuePartitionReader.get(KEY1));
     Assert.assertArrayEquals(VALUE2, mKeyValuePartitionReader.get(KEY2));
     Assert.assertNull(mKeyValuePartitionReader.get("NoSuchKey".getBytes()));
@@ -125,13 +128,15 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
     byte[][] keys = new byte[][]{KEY1, KEY2};
     byte[][] values = new byte[][]{VALUE1, VALUE2};
     for (int size = 0; size <= 2; size++) {
-      mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri);
+      mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri,
+          ServerConfiguration.global());
       for (int i = 0; i < size; i++) {
         mKeyValuePartitionWriter.put(keys[i], values[i]);
       }
       mKeyValuePartitionWriter.close();
 
-      mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri);
+      mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri,
+          ServerConfiguration.global());
       Assert.assertEquals(size, mKeyValuePartitionReader.size());
       mKeyValuePartitionReader.close();
 
@@ -146,8 +151,10 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
   @Test
   public void emptyPartitionIterator() throws Exception {
     // Creates an empty partition.
-    KeyValuePartitionWriter.Factory.create(mPartitionUri).close();
-    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri);
+    KeyValuePartitionWriter.Factory.create(mPartitionUri,
+        ServerConfiguration.global()).close();
+    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     Assert.assertFalse(mKeyValuePartitionReader.iterator().hasNext());
     mKeyValuePartitionReader.close();
   }
@@ -163,13 +170,15 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
     List<KeyValuePair> pairs = genKeyValuePairs(BASE_KEY_VALUE_NUMBER);
     List<KeyValuePair> iteratedPairs = Lists.newArrayListWithExpectedSize(pairs.size());
 
-    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri);
+    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     for (KeyValuePair pair : pairs) {
       mKeyValuePartitionWriter.put(pair.getKey().array(), pair.getValue().array());
     }
     mKeyValuePartitionWriter.close();
 
-    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri);
+    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     KeyValueIterator iterator = mKeyValuePartitionReader.iterator();
     while (iterator.hasNext()) {
       iteratedPairs.add(iterator.next());
@@ -190,7 +199,8 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
   @Test
   public void createWriterUriNotNull() throws IOException, AlluxioException {
     mThrown.expect(NullPointerException.class);
-    KeyValuePartitionWriter.Factory.create(null);
+    KeyValuePartitionWriter.Factory.create(null,
+        ServerConfiguration.global());
   }
 
   /**
@@ -198,7 +208,8 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
    */
   @Test
   public void createWriter() throws IOException, AlluxioException {
-    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri);
+    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     Assert.assertNotNull(mKeyValuePartitionWriter);
     mKeyValuePartitionWriter.close();
   }
@@ -210,7 +221,8 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
   @Test
   public void createReaderUriNotNull() throws IOException, AlluxioException {
     mThrown.expect(NullPointerException.class);
-    KeyValuePartitionReader.Factory.create(null);
+    KeyValuePartitionReader.Factory.create(null,
+        ServerConfiguration.global());
   }
 
   /**
@@ -219,10 +231,12 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
    */
   @Test
   public void createReaderWithUri() throws IOException, AlluxioException {
-    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri);
+    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     mKeyValuePartitionWriter.close();
 
-    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri);
+    mKeyValuePartitionReader = KeyValuePartitionReader.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     Assert.assertNotNull(mKeyValuePartitionReader);
     mKeyValuePartitionReader.close();
   }
@@ -233,12 +247,14 @@ public final class KeyValuePartitionIntegrationTest extends BaseIntegrationTest
    */
   @Test
   public void createReaderWithBlockId() throws IOException, AlluxioException {
-    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri);
+    mKeyValuePartitionWriter = KeyValuePartitionWriter.Factory.create(mPartitionUri,
+        ServerConfiguration.global());
     mKeyValuePartitionWriter.close();
 
     long blockId = sFileSystem.getStatus(mPartitionUri).getBlockIds().get(0);
 
-    KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId);
+    KeyValuePartitionReader reader = KeyValuePartitionReader.Factory.create(blockId,
+        ServerConfiguration.global());
     Assert.assertNotNull(reader);
     reader.close();
   }
diff --git a/tests/src/test/java/alluxio/client/keyvalue/KeyValueSystemIntegrationTest.java b/tests/src/test/java/alluxio/client/keyvalue/KeyValueSystemIntegrationTest.java
index e35b0997d0..ee437ca5ec 100644
--- a/tests/src/test/java/alluxio/client/keyvalue/KeyValueSystemIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/keyvalue/KeyValueSystemIntegrationTest.java
@@ -12,9 +12,9 @@
 package alluxio.client.keyvalue;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.exception.AlluxioException;
@@ -74,7 +74,7 @@ public final class KeyValueSystemIntegrationTest extends BaseIntegrationTest {
 
   @BeforeClass
   public static void beforeClass() throws Exception {
-    sKeyValueSystem = KeyValueSystem.Factory.create();
+    sKeyValueSystem = KeyValueSystem.Factory.create(ServerConfiguration.global());
   }
 
   @Before
@@ -262,7 +262,7 @@ public final class KeyValueSystemIntegrationTest extends BaseIntegrationTest {
     final int keyLength = 4; // 4Byte key
     final int valueLength = 500 * Constants.KB; // 500KB value
 
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(maxPartitionSize));
     try {
       mWriter = sKeyValueSystem.createStore(mStoreUri);
@@ -332,7 +332,9 @@ public final class KeyValueSystemIntegrationTest extends BaseIntegrationTest {
   }
 
   private int getPartitionNumber(AlluxioURI storeUri) throws Exception {
-    try (KeyValueMasterClient client = new KeyValueMasterClient(MasterClientConfig.defaults())) {
+    try (KeyValueMasterClient client =
+             new KeyValueMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()),
+              ServerConfiguration.global())) {
       return client.getPartitionInfo(storeUri).size();
     }
   }
@@ -351,7 +353,7 @@ public final class KeyValueSystemIntegrationTest extends BaseIntegrationTest {
       List<KeyValuePair> keyValuePairs) throws Exception {
     // These sizes are carefully selected, one partition holds only one key-value pair.
     final long maxPartitionSize = Constants.MB; // Each partition is at most 1 MB
-    Configuration
+    ServerConfiguration
         .set(PropertyKey.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(maxPartitionSize));
     final int keyLength = 4; // 4Byte key
     final int valueLength = 500 * Constants.KB; // 500KB value
@@ -512,7 +514,7 @@ public final class KeyValueSystemIntegrationTest extends BaseIntegrationTest {
    */
   @Test
   public void create() {
-    KeyValueSystem system = KeyValueSystem.Factory.create();
+    KeyValueSystem system = KeyValueSystem.Factory.create(ServerConfiguration.global());
     Assert.assertNotNull(system);
   }
 }
diff --git a/tests/src/test/java/alluxio/client/meta/MetaMasterIntegrationTest.java b/tests/src/test/java/alluxio/client/meta/MetaMasterIntegrationTest.java
index 042314aa7d..feee1c3ee7 100644
--- a/tests/src/test/java/alluxio/client/meta/MetaMasterIntegrationTest.java
+++ b/tests/src/test/java/alluxio/client/meta/MetaMasterIntegrationTest.java
@@ -13,10 +13,12 @@ package alluxio.client.meta;
 
 import static org.junit.Assert.assertEquals;
 
+import alluxio.Server;
 import alluxio.client.MetaMasterClient;
 import alluxio.client.MetaMasterConfigClient;
 import alluxio.client.RetryHandlingMetaMasterClient;
 import alluxio.client.RetryHandlingMetaMasterConfigClient;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.ConfigProperty;
 import alluxio.grpc.MasterInfo;
 import alluxio.grpc.MasterInfoField;
@@ -50,7 +52,8 @@ public final class MetaMasterIntegrationTest extends BaseIntegrationTest {
   @Test
   public void getInfoAllFields() throws Exception {
     try (MetaMasterClient client =
-        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults())) {
+        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global())) {
       MasterInfo info = client.getMasterInfo(Collections.emptySet());
       assertEquals(mWebPort, info.getWebPort());
     }
@@ -59,7 +62,8 @@ public final class MetaMasterIntegrationTest extends BaseIntegrationTest {
   @Test
   public void getMasterInfoWebPort() throws Exception {
     try (MetaMasterClient client =
-        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults())) {
+        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global())) {
       MasterInfo info = client.getMasterInfo(new HashSet<>(Arrays
           .asList(MasterInfoField.WEB_PORT)));
       assertEquals(mWebPort, info.getWebPort());
@@ -69,7 +73,8 @@ public final class MetaMasterIntegrationTest extends BaseIntegrationTest {
   @Test
   public void getConfigurationWebPort() throws Exception {
     try (MetaMasterConfigClient client =
-             new RetryHandlingMetaMasterConfigClient(MasterClientConfig.defaults())) {
+             new RetryHandlingMetaMasterConfigClient(MasterClientConfig.defaults(ServerConfiguration.global()),
+             ServerConfiguration.global())) {
       List<ConfigProperty> configList = client.getConfiguration();
       int configWebPort = -1;
       for (ConfigProperty info : configList) {
diff --git a/tests/src/test/java/alluxio/client/rest/AlluxioMasterRestApiTest.java b/tests/src/test/java/alluxio/client/rest/AlluxioMasterRestApiTest.java
index de391c4e45..5da9f37a9b 100644
--- a/tests/src/test/java/alluxio/client/rest/AlluxioMasterRestApiTest.java
+++ b/tests/src/test/java/alluxio/client/rest/AlluxioMasterRestApiTest.java
@@ -14,9 +14,8 @@ package alluxio.client.rest;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
-import alluxio.ConfigurationTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.master.meta.AlluxioMasterRestServiceHandler;
 import alluxio.master.file.FileSystemMaster;
@@ -61,7 +60,7 @@ public final class AlluxioMasterRestApiTest extends RestApiTest {
 
   @After
   public void after() {
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   private AlluxioMasterInfo getInfo(Map<String, String> params) throws Exception {
@@ -74,7 +73,7 @@ public final class AlluxioMasterRestApiTest extends RestApiTest {
 
   @Test
   public void getCapacity() throws Exception {
-    long total = Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
+    long total = ServerConfiguration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
     Capacity capacity = getInfo(NO_PARAMS).getCapacity();
     assertEquals(total, capacity.getTotal());
     assertEquals(0, capacity.getUsed());
@@ -85,8 +84,8 @@ public final class AlluxioMasterRestApiTest extends RestApiTest {
     String home = "home";
     String rawConfDir = String.format("${%s}/conf", PropertyKey.Name.HOME);
     String resolvedConfDir = String.format("%s/conf", home);
-    Configuration.set(PropertyKey.HOME, home);
-    Configuration.set(PropertyKey.CONF_DIR, rawConfDir);
+    ServerConfiguration.set(PropertyKey.HOME, home);
+    ServerConfiguration.set(PropertyKey.CONF_DIR, rawConfDir);
 
     // with out any query parameter, configuration values are resolved.
     checkConfiguration(PropertyKey.CONF_DIR, resolvedConfDir, NO_PARAMS);
@@ -134,7 +133,8 @@ public final class AlluxioMasterRestApiTest extends RestApiTest {
   @Test
   public void getRpcAddress() throws Exception {
     assertTrue(getInfo(NO_PARAMS).getRpcAddress()
-        .contains(String.valueOf(NetworkAddressUtils.getPort(ServiceType.MASTER_RPC))));
+        .contains(String.valueOf(NetworkAddressUtils.getPort(ServiceType.MASTER_RPC,
+            ServerConfiguration.global()))));
   }
 
   @Test
@@ -155,7 +155,7 @@ public final class AlluxioMasterRestApiTest extends RestApiTest {
 
   @Test
   public void getTierCapacity() throws Exception {
-    long total = Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
+    long total = ServerConfiguration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
     Capacity capacity = getInfo(NO_PARAMS).getTierCapacity().get("MEM");
     assertEquals(total, capacity.getTotal());
     assertEquals(0, capacity.getUsed());
@@ -183,7 +183,7 @@ public final class AlluxioMasterRestApiTest extends RestApiTest {
     assertEquals(1, workerInfos.size());
     WorkerInfo workerInfo = workerInfos.get(0);
     assertEquals(0, workerInfo.getUsedBytes());
-    long bytes = Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
+    long bytes = ServerConfiguration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
     assertEquals(bytes, workerInfo.getCapacityBytes());
   }
 
diff --git a/tests/src/test/java/alluxio/client/rest/AlluxioWorkerRestApiTest.java b/tests/src/test/java/alluxio/client/rest/AlluxioWorkerRestApiTest.java
index 6a15398414..c548b510f7 100644
--- a/tests/src/test/java/alluxio/client/rest/AlluxioWorkerRestApiTest.java
+++ b/tests/src/test/java/alluxio/client/rest/AlluxioWorkerRestApiTest.java
@@ -11,8 +11,8 @@
 
 package alluxio.client.rest;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.RuntimeConstants;
 import alluxio.metrics.MetricsSystem;
 import alluxio.util.network.NetworkAddressUtils;
@@ -49,7 +49,7 @@ public final class AlluxioWorkerRestApiTest extends RestApiTest {
 
   @Test
   public void getCapacity() throws Exception {
-    long total = Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
+    long total = ServerConfiguration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
     Capacity capacity = getInfo().getCapacity();
     Assert.assertEquals(total, capacity.getTotal());
     Assert.assertEquals(0, capacity.getUsed());
@@ -57,7 +57,7 @@ public final class AlluxioWorkerRestApiTest extends RestApiTest {
 
   @Test
   public void getConfiguration() throws Exception {
-    Configuration.set(PropertyKey.METRICS_CONF_FILE, "abc");
+    ServerConfiguration.set(PropertyKey.METRICS_CONF_FILE, "abc");
     Assert.assertEquals("abc",
         getInfo().getConfiguration().get(PropertyKey.METRICS_CONF_FILE.toString()));
   }
@@ -81,7 +81,7 @@ public final class AlluxioWorkerRestApiTest extends RestApiTest {
 
   @Test
   public void getTierCapacity() throws Exception {
-    long total = Configuration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
+    long total = ServerConfiguration.getBytes(PropertyKey.WORKER_MEMORY_SIZE);
     Capacity capacity = getInfo().getTierCapacity().get("MEM");
     Assert.assertEquals(total, capacity.getTotal());
     Assert.assertEquals(0, capacity.getUsed());
diff --git a/tests/src/test/java/alluxio/client/rest/JobMasterClientRestApiTest.java b/tests/src/test/java/alluxio/client/rest/JobMasterClientRestApiTest.java
index 395280444a..a4e5e3f0d9 100644
--- a/tests/src/test/java/alluxio/client/rest/JobMasterClientRestApiTest.java
+++ b/tests/src/test/java/alluxio/client/rest/JobMasterClientRestApiTest.java
@@ -16,6 +16,7 @@ import alluxio.Constants;
 import alluxio.client.rest.RestApiTest;
 import alluxio.client.rest.TestCase;
 import alluxio.client.rest.TestCaseOptions;
+import alluxio.conf.ServerConfiguration;
 import alluxio.job.JobConfig;
 import alluxio.job.ServiceConstants;
 import alluxio.job.SleepJobConfig;
@@ -65,7 +66,7 @@ public final class JobMasterClientRestApiTest extends RestApiTest {
   public void after() throws Exception {
     mJobCluster.stop();
     LoginUserTestUtils.resetLoginUser();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
diff --git a/tests/src/test/java/alluxio/client/rest/JobMasterRestApiTest.java b/tests/src/test/java/alluxio/client/rest/JobMasterRestApiTest.java
index 3cd1e5618a..ad46faf804 100644
--- a/tests/src/test/java/alluxio/client/rest/JobMasterRestApiTest.java
+++ b/tests/src/test/java/alluxio/client/rest/JobMasterRestApiTest.java
@@ -12,6 +12,7 @@
 package alluxio.client.rest;
 
 import alluxio.ConfigurationTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.AlluxioJobMasterRestServiceHandler;
 import alluxio.master.LocalAlluxioJobCluster;
 import alluxio.security.LoginUserTestUtils;
@@ -45,7 +46,7 @@ public final class JobMasterRestApiTest extends RestApiTest {
   public void after() throws Exception {
     mJobCluster.stop();
     LoginUserTestUtils.resetLoginUser();
-    ConfigurationTestUtils.resetConfiguration();
+    ServerConfiguration.reset();
   }
 
   @Test
diff --git a/tests/src/test/java/alluxio/client/rest/RestApiTest.java b/tests/src/test/java/alluxio/client/rest/RestApiTest.java
index 4e9bae9f54..552429eb41 100644
--- a/tests/src/test/java/alluxio/client/rest/RestApiTest.java
+++ b/tests/src/test/java/alluxio/client/rest/RestApiTest.java
@@ -11,7 +11,7 @@
 
 package alluxio.client.rest;
 
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.security.authentication.AuthType;
 import alluxio.testutils.BaseIntegrationTest;
 import alluxio.testutils.LocalAlluxioClusterResource;
diff --git a/tests/src/test/java/alluxio/client/rest/S3ClientRestApiTest.java b/tests/src/test/java/alluxio/client/rest/S3ClientRestApiTest.java
index 61ed24b2fd..b0460bb9c6 100644
--- a/tests/src/test/java/alluxio/client/rest/S3ClientRestApiTest.java
+++ b/tests/src/test/java/alluxio/client/rest/S3ClientRestApiTest.java
@@ -333,7 +333,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
 
   @Test
   public void getBucket() throws Exception {
-    final String bucket = "bucket-to-get";
+    final String bucket = "bucket-to-create";
     createBucketRestCall(bucket);
 
     AlluxioURI uri = new AlluxioURI(AlluxioURI.SEPARATOR + bucket + AlluxioURI.SEPARATOR);
@@ -380,7 +380,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
 
   @Test
   public void getBucketWithPrefix() throws Exception {
-    final String bucket = "bucket-to-get-with-prefix";
+    final String bucket = "bucket-to-create-with-prefix";
     createBucketRestCall(bucket);
 
     AlluxioURI uri = new AlluxioURI(AlluxioURI.SEPARATOR + bucket + AlluxioURI.SEPARATOR);
@@ -424,7 +424,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
 
   @Test
   public void getBucketWithMaxKeys() throws Exception {
-    final String bucket = "bucket-to-get-with-max-keys";
+    final String bucket = "bucket-to-create-with-max-keys";
     createBucketRestCall(bucket);
 
     AlluxioURI uri = new AlluxioURI(AlluxioURI.SEPARATOR + bucket + AlluxioURI.SEPARATOR);
@@ -459,7 +459,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
 
   @Test
   public void getBucketWithMaxKeysAndContinuationToken() throws Exception {
-    final String bucket = "bucket-to-get-with-max-keys-and-token";
+    final String bucket = "bucket-to-create-with-max-keys-and-token";
     createBucketRestCall(bucket);
 
     AlluxioURI uri = new AlluxioURI(AlluxioURI.SEPARATOR + bucket + AlluxioURI.SEPARATOR);
@@ -498,7 +498,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
 
   @Test
   public void getBucketWithNonExistingContinuationToken() throws Exception {
-    final String bucket = "bucket-to-get-with-non-existing-token";
+    final String bucket = "bucket-to-create-with-non-existing-token";
     createBucketRestCall(bucket);
 
     AlluxioURI uri = new AlluxioURI(AlluxioURI.SEPARATOR + bucket + AlluxioURI.SEPARATOR);
@@ -566,7 +566,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
       // expected
       return;
     }
-    Assert.fail("get a non-existing bucket should fail");
+    Assert.fail("create a non-existing bucket should fail");
   }
 
   private void getObjectTest(byte[] expectedObject) throws Exception {
@@ -596,7 +596,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
       // expected
       return;
     }
-    Assert.fail("get non-existent object should fail");
+    Assert.fail("create non-existent object should fail");
   }
 
   @Test
@@ -628,7 +628,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
       // expected
       return;
     }
-    Assert.fail("get metadata of non-existent object should fail");
+    Assert.fail("create metadata of non-existent object should fail");
   }
 
   @Test
@@ -799,7 +799,7 @@ public final class S3ClientRestApiTest extends RestApiTest {
     final String object = "object";
     final String objectKey = bucket + AlluxioURI.SEPARATOR + object;
 
-    // Initiate multipart upload to get upload ID.
+    // Initiate multipart upload to create upload ID.
     String result = initiateMultipartUploadRestCall(objectKey);
     InitiateMultipartUploadResult multipartUploadResult =
         XML_MAPPER.readValue(result, InitiateMultipartUploadResult.class);
diff --git a/tests/src/test/java/alluxio/job/JobIntegrationTest.java b/tests/src/test/java/alluxio/job/JobIntegrationTest.java
index 1aa4aa30d8..e8b1efd415 100644
--- a/tests/src/test/java/alluxio/job/JobIntegrationTest.java
+++ b/tests/src/test/java/alluxio/job/JobIntegrationTest.java
@@ -12,7 +12,7 @@
 package alluxio.job;
 
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.job.util.JobTestUtils;
 import alluxio.job.wire.JobInfo;
diff --git a/tests/src/test/java/alluxio/job/master/JobMasterIntegrationTest.java b/tests/src/test/java/alluxio/job/master/JobMasterIntegrationTest.java
index b310db846c..f254407f38 100644
--- a/tests/src/test/java/alluxio/job/master/JobMasterIntegrationTest.java
+++ b/tests/src/test/java/alluxio/job/master/JobMasterIntegrationTest.java
@@ -15,7 +15,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.status.ResourceExhaustedException;
 import alluxio.job.JobDefinitionRegistryRule;
 import alluxio.job.SleepJobConfig;
diff --git a/tests/src/test/java/alluxio/job/master/LostWorkerIntegrationTest.java b/tests/src/test/java/alluxio/job/master/LostWorkerIntegrationTest.java
index efba2d5bb1..84e2cd90d5 100644
--- a/tests/src/test/java/alluxio/job/master/LostWorkerIntegrationTest.java
+++ b/tests/src/test/java/alluxio/job/master/LostWorkerIntegrationTest.java
@@ -13,11 +13,12 @@ package alluxio.job.master;
 
 import static org.junit.Assert.assertTrue;
 
+import alluxio.conf.ServerConfiguration;
 import alluxio.testutils.BaseIntegrationTest;
 import alluxio.ConfigurationRule;
 import alluxio.Constants;
 import alluxio.testutils.LocalAlluxioClusterResource;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.heartbeat.HeartbeatContext;
 import alluxio.heartbeat.HeartbeatScheduler;
 import alluxio.heartbeat.ManuallyScheduleHeartbeat;
@@ -44,7 +45,8 @@ public class LostWorkerIntegrationTest extends BaseIntegrationTest {
 
   @Rule
   public ConfigurationRule mConfigurationRule = new ConfigurationRule(ImmutableMap.of(
-      PropertyKey.JOB_MASTER_WORKER_TIMEOUT_MS, Integer.toString(WORKER_HEARTBEAT_TIMEOUT_MS)));
+      PropertyKey.JOB_MASTER_WORKER_TIMEOUT_MS, Integer.toString(WORKER_HEARTBEAT_TIMEOUT_MS)),
+      ServerConfiguration.global());
 
   // We need this because LocalAlluxioJobCluster doesn't work without it.
   @Rule
diff --git a/tests/src/test/java/alluxio/job/persist/PersistIntegrationTest.java b/tests/src/test/java/alluxio/job/persist/PersistIntegrationTest.java
index 5fa500767c..4bae901390 100644
--- a/tests/src/test/java/alluxio/job/persist/PersistIntegrationTest.java
+++ b/tests/src/test/java/alluxio/job/persist/PersistIntegrationTest.java
@@ -17,6 +17,7 @@ import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystemContext;
 import alluxio.client.file.FileSystemMasterClient;
 import alluxio.client.file.URIStatus;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.WritePType;
 import alluxio.job.JobIntegrationTest;
@@ -56,7 +57,7 @@ public final class PersistIntegrationTest extends JobIntegrationTest {
     // run the persist job and check that it succeeds
     waitForJobToFinish(mJobMaster.run(new PersistConfig("/test", 1, true, status.getUfsPath())));
     String ufsPath = status.getUfsPath();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(ufsPath, ServerConfiguration.global());
     Assert.assertTrue(ufs.exists(ufsPath));
 
     // run the persist job again with the overwrite flag and check that it succeeds
diff --git a/tests/src/test/java/alluxio/job/replicate/EvictIntegrationTest.java b/tests/src/test/java/alluxio/job/replicate/EvictIntegrationTest.java
index b7fd7f5ec8..23ddad1301 100644
--- a/tests/src/test/java/alluxio/job/replicate/EvictIntegrationTest.java
+++ b/tests/src/test/java/alluxio/job/replicate/EvictIntegrationTest.java
@@ -53,8 +53,8 @@ public final class EvictIntegrationTest extends JobIntegrationTest {
     mBlockId1 = status.getBlockIds().get(0);
     mBlockId2 = status.getBlockIds().get(1);
 
-    BlockInfo blockInfo1 = AdjustJobTestUtils.getBlock(mBlockId1, FileSystemContext.get());
-    BlockInfo blockInfo2 = AdjustJobTestUtils.getBlock(mBlockId2, FileSystemContext.get());
+    BlockInfo blockInfo1 = AdjustJobTestUtils.getBlock(mBlockId1, FileSystemContext.create());
+    BlockInfo blockInfo2 = AdjustJobTestUtils.getBlock(mBlockId2, FileSystemContext.create());
     mWorker = blockInfo1.getLocations().get(0).getWorkerAddress();
   }
 
@@ -64,13 +64,13 @@ public final class EvictIntegrationTest extends JobIntegrationTest {
     waitForJobToFinish(mJobMaster.run(new EvictConfig(mBlockId1, 1)));
     CommonUtils.waitFor("block 1 to be evicted", () -> {
       try {
-        return !AdjustJobTestUtils.hasBlock(mBlockId1, mWorker, FileSystemContext.get());
+        return !AdjustJobTestUtils.hasBlock(mBlockId1, mWorker, FileSystemContext.create());
       } catch (Exception e) {
         throw new RuntimeException(e);
       }
     }, WaitForOptions.defaults().setTimeoutMs(5 * Constants.SECOND_MS));
     // block 2 should not be evicted
-    Assert.assertTrue(AdjustJobTestUtils.hasBlock(mBlockId2, mWorker, FileSystemContext.get()));
+    Assert.assertTrue(AdjustJobTestUtils.hasBlock(mBlockId2, mWorker, FileSystemContext.create()));
   }
 
   @Test
@@ -79,12 +79,12 @@ public final class EvictIntegrationTest extends JobIntegrationTest {
     waitForJobToFinish(mJobMaster.run(new EvictConfig(mBlockId2, 1)));
     CommonUtils.waitFor("block 2 to be evicted", () -> {
       try {
-        return !AdjustJobTestUtils.hasBlock(mBlockId2, mWorker, FileSystemContext.get());
+        return !AdjustJobTestUtils.hasBlock(mBlockId2, mWorker, FileSystemContext.create());
       } catch (Exception e) {
         throw new RuntimeException(e);
       }
     }, WaitForOptions.defaults().setTimeoutMs(5 * Constants.SECOND_MS));
     // block 1 should not be evicted
-    Assert.assertTrue(AdjustJobTestUtils.hasBlock(mBlockId1, mWorker, FileSystemContext.get()));
+    Assert.assertTrue(AdjustJobTestUtils.hasBlock(mBlockId1, mWorker, FileSystemContext.create()));
   }
 }
diff --git a/tests/src/test/java/alluxio/job/replicate/ReplicateIntegrationTest.java b/tests/src/test/java/alluxio/job/replicate/ReplicateIntegrationTest.java
index 43296527f9..58f966aac3 100644
--- a/tests/src/test/java/alluxio/job/replicate/ReplicateIntegrationTest.java
+++ b/tests/src/test/java/alluxio/job/replicate/ReplicateIntegrationTest.java
@@ -78,8 +78,8 @@ public final class ReplicateIntegrationTest extends JobIntegrationTest {
     // run the replicate job for mBlockId1
     waitForJobToFinish(mJobMaster.run(new ReplicateConfig(TEST_URI, mBlockId1, 1)));
 
-    BlockInfo blockInfo1 = AdjustJobTestUtils.getBlock(mBlockId1, FileSystemContext.get());
-    BlockInfo blockInfo2 = AdjustJobTestUtils.getBlock(mBlockId2, FileSystemContext.get());
+    BlockInfo blockInfo1 = AdjustJobTestUtils.getBlock(mBlockId1, FileSystemContext.create());
+    BlockInfo blockInfo2 = AdjustJobTestUtils.getBlock(mBlockId2, FileSystemContext.create());
     Assert.assertEquals(1, blockInfo1.getLocations().size());
     Assert.assertEquals(0, blockInfo2.getLocations().size());
     Assert.assertEquals(TEST_BLOCK_SIZE, blockInfo1.getLength());
@@ -91,8 +91,8 @@ public final class ReplicateIntegrationTest extends JobIntegrationTest {
     // run the replicate job for mBlockId2
     waitForJobToFinish(mJobMaster.run(new ReplicateConfig(TEST_URI, mBlockId2, 1)));
 
-    BlockInfo blockInfo1 = AdjustJobTestUtils.getBlock(mBlockId1, FileSystemContext.get());
-    BlockInfo blockInfo2 = AdjustJobTestUtils.getBlock(mBlockId2, FileSystemContext.get());
+    BlockInfo blockInfo1 = AdjustJobTestUtils.getBlock(mBlockId1, FileSystemContext.create());
+    BlockInfo blockInfo2 = AdjustJobTestUtils.getBlock(mBlockId2, FileSystemContext.create());
     Assert.assertEquals(0, blockInfo1.getLocations().size());
     Assert.assertEquals(1, blockInfo2.getLocations().size());
     Assert.assertEquals(TEST_BLOCK_SIZE, blockInfo1.getLength());
diff --git a/tests/src/test/java/alluxio/server/auth/ClusterInitializationIntegrationTest.java b/tests/src/test/java/alluxio/server/auth/ClusterInitializationIntegrationTest.java
index 2334165041..41b585d7a6 100644
--- a/tests/src/test/java/alluxio/server/auth/ClusterInitializationIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/auth/ClusterInitializationIntegrationTest.java
@@ -14,7 +14,7 @@ package alluxio.server.auth;
 import static org.junit.Assert.assertEquals;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.exception.ExceptionMessage;
diff --git a/tests/src/test/java/alluxio/server/auth/MasterClientAuthenticationIntegrationTest.java b/tests/src/test/java/alluxio/server/auth/MasterClientAuthenticationIntegrationTest.java
index 76cc150845..472a43ef20 100644
--- a/tests/src/test/java/alluxio/server/auth/MasterClientAuthenticationIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/auth/MasterClientAuthenticationIntegrationTest.java
@@ -12,10 +12,11 @@
 package alluxio.server.auth;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.GetStatusPOptions;
 import alluxio.security.LoginUserTestUtils;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystemMasterClient;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.MasterClientConfig;
@@ -92,7 +93,8 @@ public final class MasterClientAuthenticationIntegrationTest extends BaseIntegra
           PropertyKey.Name.SECURITY_LOGIN_USERNAME, "alluxio"})
   public void customAuthenticationDenyConnect() throws Exception {
     try (FileSystemMasterClient masterClient =
-        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults())) {
+        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global())) {
       Assert.assertFalse(masterClient.isConnected());
       // Using no-alluxio as loginUser to connect to Master, the IOException will be thrown
       LoginUserTestUtils.resetLoginUser("no-alluxio");
@@ -106,7 +108,8 @@ public final class MasterClientAuthenticationIntegrationTest extends BaseIntegra
       confParams = {PropertyKey.Name.SECURITY_AUTHENTICATION_TYPE, "SIMPLE"})
   public void simpleAuthenticationIsolatedClassLoader() throws Exception {
     FileSystemMasterClient masterClient =
-        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults());
+        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults(
+            ServerConfiguration.global()), ServerConfiguration.global());
     Assert.assertFalse(masterClient.isConnected());
 
     // Get the current context class loader to retrieve the classpath URLs.
@@ -134,7 +137,8 @@ public final class MasterClientAuthenticationIntegrationTest extends BaseIntegra
    */
   private void authenticationOperationTest(String filename) throws Exception {
     FileSystemMasterClient masterClient =
-        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults());
+        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults(
+            ServerConfiguration.global()), ServerConfiguration.global());
     Assert.assertFalse(masterClient.isConnected());
     masterClient.connect();
     Assert.assertTrue(masterClient.isConnected());
diff --git a/tests/src/test/java/alluxio/server/configuration/ConfigCheckerIntegrationTest.java b/tests/src/test/java/alluxio/server/configuration/ConfigCheckerIntegrationTest.java
index b0fe240598..ecbae3ea5d 100644
--- a/tests/src/test/java/alluxio/server/configuration/ConfigCheckerIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/configuration/ConfigCheckerIntegrationTest.java
@@ -15,9 +15,9 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.MetaMasterClient;
 import alluxio.grpc.ConfigStatus;
 import alluxio.grpc.Scope;
@@ -164,7 +164,7 @@ public class ConfigCheckerIntegrationTest extends BaseIntegrationTest {
     Map<Integer, Map<PropertyKey, String>> properties = new HashMap<>();
     for (int i = 0; i < nodeNum; i++) {
       Map<PropertyKey, String> prop = new HashMap<>();
-      prop.put(key, ((Configuration.getMs(key) / Constants.SECOND_MS) + i) + "sec");
+      prop.put(key, ((ServerConfiguration.getMs(key) / Constants.SECOND_MS) + i) + "sec");
       properties.put(i, prop);
     }
     return properties;
diff --git a/tests/src/test/java/alluxio/server/ft/BackwardsCompatibilityIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/BackwardsCompatibilityIntegrationTest.java
index 39c4eb0491..96b2ce86d0 100644
--- a/tests/src/test/java/alluxio/server/ft/BackwardsCompatibilityIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/BackwardsCompatibilityIntegrationTest.java
@@ -13,7 +13,8 @@ package alluxio.server.ft;
 
 import alluxio.AlluxioTestDirectory;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.backcompat.BackwardsCompatibilityJournalGenerator;
 import alluxio.master.backcompat.Journal;
 import alluxio.master.backcompat.TestOp;
@@ -87,7 +88,7 @@ public final class BackwardsCompatibilityIntegrationTest extends BaseIntegration
   @Test
   public void readOldJournals() throws Exception {
     Assume.assumeTrue("Journals must be replayed by the same user that generated them, so this "
-        + "test must be run as root", LoginUser.get().getName().equals("root"));
+        + "test must be run as root", LoginUser.get(ServerConfiguration.global()).getName().equals("root"));
     // Starts a cluster from each old journal, and checks that all operation checks pass.
     List<Journal> journals = Arrays
         .asList(new File(BackwardsCompatibilityJournalGenerator.OLD_JOURNALS_RESOURCE).listFiles())
diff --git a/tests/src/test/java/alluxio/server/ft/FlakyUfsIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/FlakyUfsIntegrationTest.java
index e418f1fb1e..8bf8f2990c 100644
--- a/tests/src/test/java/alluxio/server/ft/FlakyUfsIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/FlakyUfsIntegrationTest.java
@@ -16,11 +16,13 @@ import static org.junit.Assert.fail;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.Server;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.block.BlockMasterClient;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.AlluxioException;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.DeletePOptions;
@@ -50,7 +52,8 @@ public final class FlakyUfsIntegrationTest extends BaseIntegrationTest {
   private static final String LOCAL_UFS_PATH = Files.createTempDir().getAbsolutePath();
   // An under file system which fails 90% of its renames.
   private static final UnderFileSystem UFS =
-      new DelegatingUnderFileSystem(UnderFileSystem.Factory.create(LOCAL_UFS_PATH)) {
+      new DelegatingUnderFileSystem(UnderFileSystem.Factory.create(LOCAL_UFS_PATH,
+          ServerConfiguration.global())) {
         @Override
         public boolean deleteFile(String path) throws IOException {
           if (ThreadLocalRandom.current().nextBoolean()) {
@@ -101,7 +104,9 @@ public final class FlakyUfsIntegrationTest extends BaseIntegrationTest {
     assertThat(deleted, Matchers.greaterThan(10));
     assertThat(deleted, Matchers.lessThan(90));
     mFs.free(new AlluxioURI("/"), FreePOptions.newBuilder().setRecursive(true).build());
-    BlockMasterClient blockClient = BlockMasterClient.Factory.create(MasterClientConfig.defaults());
+    BlockMasterClient blockClient =
+        BlockMasterClient.Factory.create(MasterClientConfig.defaults(ServerConfiguration.global()),
+            ServerConfiguration.global());
     CommonUtils.waitFor("data to be freed", () -> {
       try {
         return blockClient.getUsedBytes() == 0;
diff --git a/tests/src/test/java/alluxio/server/ft/MasterFailoverIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/MasterFailoverIntegrationTest.java
index 2a8690da84..a862512809 100644
--- a/tests/src/test/java/alluxio/server/ft/MasterFailoverIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/MasterFailoverIntegrationTest.java
@@ -14,9 +14,9 @@ package alluxio.server.ft;
 import static org.junit.Assert.assertFalse;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.file.FileSystem;
 import alluxio.master.MultiMasterLocalAlluxioCluster;
@@ -48,7 +48,8 @@ public final class MasterFailoverIntegrationTest extends BaseIntegrationTest {
 
   // An under file system which has slow directory deletion.
   private static final UnderFileSystem UFS =
-      new DelegatingUnderFileSystem(UnderFileSystem.Factory.create(LOCAL_UFS_PATH)) {
+      new DelegatingUnderFileSystem(UnderFileSystem.Factory.create(LOCAL_UFS_PATH,
+          ServerConfiguration.global())) {
         @Override
         public boolean deleteDirectory(String path) throws IOException {
           CommonUtils.sleepMs(DELETE_DELAY);
@@ -71,9 +72,9 @@ public final class MasterFailoverIntegrationTest extends BaseIntegrationTest {
     mMultiMasterLocalAlluxioCluster =
         new MultiMasterLocalAlluxioCluster(2);
     mMultiMasterLocalAlluxioCluster.initConfiguration();
-    Configuration.set(PropertyKey.USER_RPC_RETRY_MAX_DURATION, "15sec");
-    Configuration.set(PropertyKey.MASTER_GRPC_SERVER_SHUTDOWN_TIMEOUT, "30sec");
-    Configuration.set(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS,
+    ServerConfiguration.set(PropertyKey.USER_RPC_RETRY_MAX_DURATION, "15sec");
+    ServerConfiguration.set(PropertyKey.MASTER_GRPC_SERVER_SHUTDOWN_TIMEOUT, "30sec");
+    ServerConfiguration.set(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS,
         DelegatingUnderFileSystemFactory.DELEGATING_SCHEME + "://" + LOCAL_UFS_PATH);
     mMultiMasterLocalAlluxioCluster.start();
     mFileSystem = mMultiMasterLocalAlluxioCluster.getClient();
diff --git a/tests/src/test/java/alluxio/server/ft/MasterFaultToleranceIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/MasterFaultToleranceIntegrationTest.java
index a00ac8fa3c..9d4b66b814 100644
--- a/tests/src/test/java/alluxio/server/ft/MasterFaultToleranceIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/MasterFaultToleranceIntegrationTest.java
@@ -16,9 +16,9 @@ import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertTrue;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
@@ -82,11 +82,11 @@ public class MasterFaultToleranceIntegrationTest extends BaseIntegrationTest {
     mMultiMasterLocalAlluxioCluster =
         new MultiMasterLocalAlluxioCluster(MASTERS);
     mMultiMasterLocalAlluxioCluster.initConfiguration();
-    Configuration.set(PropertyKey.WORKER_MEMORY_SIZE, WORKER_CAPACITY_BYTES);
-    Configuration.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, BLOCK_SIZE);
-    Configuration.set(PropertyKey.MASTER_JOURNAL_TAILER_SHUTDOWN_QUIET_WAIT_TIME_MS, 100);
-    Configuration.set(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, 2);
-    Configuration.set(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX, 32);
+    ServerConfiguration.set(PropertyKey.WORKER_MEMORY_SIZE, WORKER_CAPACITY_BYTES);
+    ServerConfiguration.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, BLOCK_SIZE);
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_TAILER_SHUTDOWN_QUIET_WAIT_TIME_MS, 100);
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, 2);
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX, 32);
     mMultiMasterLocalAlluxioCluster.start();
     mFileSystem = mMultiMasterLocalAlluxioCluster.getClient();
   }
@@ -159,7 +159,7 @@ public class MasterFaultToleranceIntegrationTest extends BaseIntegrationTest {
     for (int kills = 0; kills < MASTERS - 1; kills++) {
       assertTrue(mMultiMasterLocalAlluxioCluster.stopLeader());
       mMultiMasterLocalAlluxioCluster.waitForNewMaster(CLUSTER_WAIT_TIMEOUT_MS);
-      waitForWorkerRegistration(AlluxioBlockStore.create(), 1, CLUSTER_WAIT_TIMEOUT_MS);
+      waitForWorkerRegistration(AlluxioBlockStore.create(ServerConfiguration.global()), 1, CLUSTER_WAIT_TIMEOUT_MS);
       faultTestDataCheck(answer);
       faultTestDataCreation(new AlluxioURI("/data_kills_" + kills), answer);
     }
@@ -172,7 +172,7 @@ public class MasterFaultToleranceIntegrationTest extends BaseIntegrationTest {
     for (int kills = 0; kills < MASTERS - 1; kills++) {
       assertTrue(mMultiMasterLocalAlluxioCluster.stopLeader());
       mMultiMasterLocalAlluxioCluster.waitForNewMaster(CLUSTER_WAIT_TIMEOUT_MS);
-      waitForWorkerRegistration(AlluxioBlockStore.create(), 1, CLUSTER_WAIT_TIMEOUT_MS);
+      waitForWorkerRegistration(AlluxioBlockStore.create(ServerConfiguration.global()), 1, CLUSTER_WAIT_TIMEOUT_MS);
 
       if (kills % 2 != 0) {
         // Delete files.
@@ -244,7 +244,7 @@ public class MasterFaultToleranceIntegrationTest extends BaseIntegrationTest {
 
   @Test
   public void workerReRegister() throws Exception {
-    AlluxioBlockStore store = AlluxioBlockStore.create();
+    AlluxioBlockStore store = AlluxioBlockStore.create(ServerConfiguration.global());
     assertEquals(WORKER_CAPACITY_BYTES, store.getCapacityBytes());
 
     for (int kills = 0; kills < MASTERS - 1; kills++) {
@@ -302,7 +302,7 @@ public class MasterFaultToleranceIntegrationTest extends BaseIntegrationTest {
       BlockMaster blockMaster2 = cluster.getLocalAlluxioMaster().getMasterProcess()
           .getMaster(BlockMaster.class);
 
-      // Worker 2 tries to heartbeat (with original id), and should get "Register" in response.
+      // Worker 2 tries to heartbeat (with original id), and should create "Register" in response.
       assertEquals(CommandType.Register, blockMaster2
           .workerHeartbeat(workerId2a, null, Collections.EMPTY_MAP, Collections.EMPTY_LIST,
               Collections.EMPTY_MAP, Lists.newArrayList()).getCommandType());
diff --git a/tests/src/test/java/alluxio/server/ft/MultiWorkerIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/MultiWorkerIntegrationTest.java
index 48d9800a98..4d4dc73be3 100644
--- a/tests/src/test/java/alluxio/server/ft/MultiWorkerIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/MultiWorkerIntegrationTest.java
@@ -15,7 +15,8 @@ import static org.junit.Assert.assertEquals;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.client.ReadType;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.block.AlluxioBlockStore;
 import alluxio.client.block.BlockWorkerInfo;
@@ -27,6 +28,7 @@ import alluxio.client.file.options.InStreamOptions;
 import alluxio.client.file.options.OutStreamOptions;
 import alluxio.client.file.policy.FileWriteLocationPolicy;
 import alluxio.client.file.policy.RoundRobinPolicy;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateFilePOptions;
 import alluxio.grpc.OpenFilePOptions;
 import alluxio.grpc.WritePType;
@@ -179,7 +181,7 @@ public final class MultiWorkerIntegrationTest extends BaseIntegrationTest {
   }
 
   private void replicateFileBlocks(AlluxioURI filePath) throws Exception {
-    AlluxioBlockStore store = AlluxioBlockStore.create();
+    AlluxioBlockStore store = AlluxioBlockStore.create(ServerConfiguration.global());
     URIStatus status =  mResource.get().getClient().getStatus(filePath);
     List<FileBlockInfo> blocks = status.getFileBlockInfos();
     List<BlockWorkerInfo> workers = store.getAllWorkers();
@@ -193,10 +195,10 @@ public final class MultiWorkerIntegrationTest extends BaseIntegrationTest {
           .get()
           .getNetAddress();
       try (OutputStream outStream = store.getOutStream(blockInfo.getBlockId(),
-          blockInfo.getLength(), dest, OutStreamOptions.defaults()
+          blockInfo.getLength(), dest, OutStreamOptions.defaults(ServerConfiguration.global())
               .setBlockSizeBytes(8 * Constants.MB).setWriteType(WriteType.MUST_CACHE))) {
         try (InputStream inStream = store.getInStream(blockInfo.getBlockId(),
-            new InStreamOptions(status))) {
+            new InStreamOptions(status, ServerConfiguration.global()))) {
           ByteStreams.copy(inStream, outStream);
         }
       }
diff --git a/tests/src/test/java/alluxio/server/ft/ZookeeperFailureIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/ZookeeperFailureIntegrationTest.java
index 961a01d8fa..6120b6ea61 100644
--- a/tests/src/test/java/alluxio/server/ft/ZookeeperFailureIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/ZookeeperFailureIntegrationTest.java
@@ -14,7 +14,8 @@ package alluxio.server.ft;
 import static org.junit.Assert.assertFalse;
 
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.FileSystemMasterClientServiceGrpc;
 import alluxio.grpc.ListStatusPRequest;
 import alluxio.multi.process.MasterNetAddress;
@@ -48,7 +49,7 @@ public class ZookeeperFailureIntegrationTest extends BaseIntegrationTest {
       PropertyKey.USER_RPC_RETRY_MAX_NUM_RETRY, "5",
       PropertyKey.USER_RPC_RETRY_BASE_SLEEP_MS, "500",
       PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS, "500",
-      PropertyKey.USER_RPC_RETRY_MAX_DURATION, "2500")
+      PropertyKey.USER_RPC_RETRY_MAX_DURATION, "2500"), ServerConfiguration.global()
   );
 
   public MultiProcessCluster mCluster;
@@ -106,7 +107,7 @@ public class ZookeeperFailureIntegrationTest extends BaseIntegrationTest {
         new InetSocketAddress(netAddress.getHostname(), netAddress.getRpcPort());
     try {
       GrpcChannel channel = GrpcChannelBuilder
-              .forAddress(address)
+              .forAddress(address, ServerConfiguration.global())
               .build();
       FileSystemMasterClientServiceGrpc.FileSystemMasterClientServiceBlockingStub client =
           FileSystemMasterClientServiceGrpc.newBlockingStub(channel);
diff --git a/tests/src/test/java/alluxio/server/ft/journal/JournalBackupIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/journal/JournalBackupIntegrationTest.java
index 1d82d8300d..58f17adf33 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/JournalBackupIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/JournalBackupIntegrationTest.java
@@ -18,10 +18,11 @@ import alluxio.AlluxioTestDirectory;
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.MetaMasterClient;
 import alluxio.client.RetryHandlingMetaMasterClient;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.WritePType;
 import alluxio.master.MasterClientConfig;
@@ -52,7 +53,7 @@ public final class JournalBackupIntegrationTest extends BaseIntegrationTest {
     {
       put(PropertyKey.USER_METRICS_COLLECTION_ENABLED, "false");
     }
-  });
+  }, ServerConfiguration.global());
 
   @After
   public void after() throws Exception {
@@ -153,6 +154,8 @@ public final class JournalBackupIntegrationTest extends BaseIntegrationTest {
 
   private MetaMasterClient getMetaClient(MultiProcessCluster cluster) {
     return new RetryHandlingMetaMasterClient(
-        MasterClientConfig.defaults().withMasterInquireClient(cluster.getMasterInquireClient()));
+        MasterClientConfig.defaults(
+            ServerConfiguration.global()).withMasterInquireClient(cluster.getMasterInquireClient()),
+        ServerConfiguration.global());
   }
 }
diff --git a/tests/src/test/java/alluxio/server/ft/journal/JournalCheckpointIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/journal/JournalCheckpointIntegrationTest.java
index 8d4c119461..a15c55f78b 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/JournalCheckpointIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/JournalCheckpointIntegrationTest.java
@@ -15,8 +15,8 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.MetaMasterClient;
 import alluxio.client.RetryHandlingMetaMasterClient;
 import alluxio.client.file.FileSystemMasterClient;
@@ -73,13 +73,14 @@ public class JournalCheckpointIntegrationTest extends BaseIntegrationTest {
     assertEquals(3, mCluster.getClient().getMountTable().size());
     mCluster.getClient().unmount(alluxioMount1);
     assertEquals(2, mCluster.getClient().getMountTable().size());
-    Configuration.unset(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP);
+    ServerConfiguration.unset(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP);
   }
 
   @Test
   public void recoverUfsState() throws Exception {
     FileSystemMasterClient client =
-        new RetryHandlingFileSystemMasterClient(MasterClientConfig.defaults());
+        new RetryHandlingFileSystemMasterClient(MasterClientConfig.defaults(
+            ServerConfiguration.global()), ServerConfiguration.global());
     client.updateUfsMode(new AlluxioURI(""),
         UpdateUfsModePOptions.newBuilder().setUfsMode(UfsPMode.READ_ONLY).build());
 
@@ -95,9 +96,11 @@ public class JournalCheckpointIntegrationTest extends BaseIntegrationTest {
 
   private void backupAndRestore() throws Exception {
     File backup = mFolder.newFolder("backup");
-    MetaMasterClient metaClient = new RetryHandlingMetaMasterClient(MasterClientConfig.defaults());
+    MetaMasterClient metaClient =
+        new RetryHandlingMetaMasterClient(MasterClientConfig.defaults(
+            ServerConfiguration.global()), ServerConfiguration.global());
     AlluxioURI backupURI = metaClient.backup(backup.getAbsolutePath(), true).getBackupUri();
-    Configuration.set(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP, backupURI);
+    ServerConfiguration.set(PropertyKey.MASTER_JOURNAL_INIT_FROM_BACKUP, backupURI);
     mCluster.formatAndRestartMasters();
   }
 }
diff --git a/tests/src/test/java/alluxio/server/ft/journal/JournalIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/journal/JournalIntegrationTest.java
index 60f6f7aaaf..3aaece6597 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/JournalIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/JournalIntegrationTest.java
@@ -15,7 +15,7 @@ import static org.junit.Assert.assertTrue;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileSystem;
 import alluxio.exception.AlluxioException;
diff --git a/tests/src/test/java/alluxio/server/ft/journal/JournalReplayIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/journal/JournalReplayIntegrationTest.java
index e1d5357887..574eaf735e 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/JournalReplayIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/JournalReplayIntegrationTest.java
@@ -15,7 +15,7 @@ import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
 import alluxio.grpc.DeletePOptions;
diff --git a/tests/src/test/java/alluxio/server/ft/journal/JournalShutdownIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/journal/JournalShutdownIntegrationTest.java
index a5a9dbece1..8874e86e88 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/JournalShutdownIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/JournalShutdownIntegrationTest.java
@@ -19,11 +19,10 @@ import static org.mockito.Mockito.spy;
 
 import alluxio.AlluxioURI;
 import alluxio.AuthenticatedUserRule;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.ConfigurationRule;
-import alluxio.ConfigurationTestUtils;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.SystemPropertyRule;
 import alluxio.client.WriteType;
 import alluxio.client.file.FileSystem;
@@ -68,7 +67,8 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
       new SystemPropertyRule("fs.hdfs.impl.disable.cache", "true");
 
   @Rule
-  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule("test");
+  public AuthenticatedUserRule mAuthenticatedUser = new AuthenticatedUserRule("test",
+      ServerConfiguration.global());
 
   @Rule
   public ConfigurationRule mConfigRule =
@@ -76,7 +76,7 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
           .put(PropertyKey.MASTER_JOURNAL_TAILER_SHUTDOWN_QUIET_WAIT_TIME_MS, "100")
           .put(PropertyKey.MASTER_JOURNAL_CHECKPOINT_PERIOD_ENTRIES, "2")
           .put(PropertyKey.MASTER_JOURNAL_LOG_SIZE_BYTES_MAX, "32")
-          .put(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS, "1sec").build());
+          .put(PropertyKey.USER_RPC_RETRY_MAX_SLEEP_MS, "1sec").build(), ServerConfiguration.global());
 
   private static final long SHUTDOWN_TIME_MS = 15 * Constants.SECOND_MS;
   private static final String TEST_FILE_DIR = "/files/";
@@ -95,9 +95,9 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
   @After
   public final void after() throws Exception {
     mExecutorsForClient.shutdown();
-    ConfigurationTestUtils.resetConfiguration();
-    Configuration.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
-    FileSystemContext.get().reset(Configuration.global());
+    ServerConfiguration.reset();
+    ServerConfiguration.set(PropertyKey.USER_METRICS_COLLECTION_ENABLED, false);
+    FileSystemContext.create().reset();
   }
 
   @Test
@@ -171,7 +171,7 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
     awaitClientTermination();
     // Fail the creation of UFS
     doThrow(new RuntimeException()).when(factory).create(anyString(),
-        any(UnderFileSystemConfiguration.class));
+        any(UnderFileSystemConfiguration.class), ServerConfiguration.global());
     createFsMasterFromJournal();
   }
 
@@ -190,7 +190,7 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
     awaitClientTermination();
     // Fail the creation of UFS
     doThrow(new RuntimeException()).when(factory).create(anyString(),
-        any(UnderFileSystemConfiguration.class));
+        any(UnderFileSystemConfiguration.class), ServerConfiguration.global());
     createFsMasterFromJournal();
   }
 
@@ -200,7 +200,8 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
    */
   private UnderFileSystemFactory mountUnmount(FileSystem fs) throws Exception {
     SleepingUnderFileSystem sleepingUfs = new SleepingUnderFileSystem(new AlluxioURI("sleep:///"),
-        new SleepingUnderFileSystemOptions(), UnderFileSystemConfiguration.defaults());
+        new SleepingUnderFileSystemOptions(), UnderFileSystemConfiguration.defaults(),
+        ServerConfiguration.global());
     SleepingUnderFileSystemFactory sleepingUfsFactory =
         new SleepingUnderFileSystemFactory(sleepingUfs);
     UnderFileSystemFactoryRegistry.register(sleepingUfsFactory);
@@ -245,7 +246,7 @@ public class JournalShutdownIntegrationTest extends BaseIntegrationTest {
     // Setup and start the local alluxio cluster.
     LocalAlluxioCluster cluster = new LocalAlluxioCluster();
     cluster.initConfiguration();
-    Configuration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.MUST_CACHE);
+    ServerConfiguration.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.MUST_CACHE);
     cluster.start();
     return cluster;
   }
diff --git a/tests/src/test/java/alluxio/server/ft/journal/ufs/RenameFailureJournalTest.java b/tests/src/test/java/alluxio/server/ft/journal/ufs/RenameFailureJournalTest.java
index 669e252d76..4c062dd8bb 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/ufs/RenameFailureJournalTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/ufs/RenameFailureJournalTest.java
@@ -14,9 +14,10 @@ package alluxio.server.ft.journal.ufs;
 import static org.junit.Assert.assertTrue;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.UnderFileSystemFactoryRegistryRule;
 import alluxio.client.file.FileSystem;
+import alluxio.conf.ServerConfiguration;
 import alluxio.testutils.LocalAlluxioClusterResource;
 import alluxio.testutils.underfs.delegating.DelegatingUnderFileSystem;
 import alluxio.testutils.underfs.delegating.DelegatingUnderFileSystemFactory;
@@ -46,7 +47,7 @@ public class RenameFailureJournalTest {
 
   // An under file system which fails 90% of its renames.
   private static final UnderFileSystem UFS =
-      new DelegatingUnderFileSystem(Factory.create(LOCAL_UFS_PATH)) {
+      new DelegatingUnderFileSystem(Factory.create(LOCAL_UFS_PATH, ServerConfiguration.global())) {
         @Override
         public boolean renameFile(String src, String dst) throws IOException {
           if (ThreadLocalRandom.current().nextInt(10) == 0) {
diff --git a/tests/src/test/java/alluxio/server/ft/journal/ufs/UfsJournalIntegrationTest.java b/tests/src/test/java/alluxio/server/ft/journal/ufs/UfsJournalIntegrationTest.java
index c73d805a43..556981383a 100644
--- a/tests/src/test/java/alluxio/server/ft/journal/ufs/UfsJournalIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/ft/journal/ufs/UfsJournalIntegrationTest.java
@@ -12,9 +12,9 @@
 package alluxio.server.ft.journal.ufs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
@@ -139,7 +139,7 @@ public class UfsJournalIntegrationTest extends BaseIntegrationTest {
     journal.start();
     journal.gainPrimacy();
 
-    UfsStatus[] paths = UnderFileSystem.Factory.create(journalFolder)
+    UfsStatus[] paths = UnderFileSystem.Factory.create(journalFolder, ServerConfiguration.global())
         .listStatus(journal.getLogDir().toString());
     int expectedSize = paths == null ? 0 : paths.length;
 
@@ -147,7 +147,7 @@ public class UfsJournalIntegrationTest extends BaseIntegrationTest {
     journal.flush();
     journal.flush();
     journal.close();
-    paths = UnderFileSystem.Factory.create(journalFolder)
+    paths = UnderFileSystem.Factory.create(journalFolder, ServerConfiguration.global())
         .listStatus(journal.getLogDir().toString());
     int actualSize = paths == null ? 0 : paths.length;
     // No new files are created.
@@ -159,8 +159,8 @@ public class UfsJournalIntegrationTest extends BaseIntegrationTest {
    */
   @Test
   public void loadMetadata() throws Exception {
-    String ufsRoot = Configuration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
-    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot();
+    String ufsRoot = ServerConfiguration.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);
+    UnderFileSystem ufs = UnderFileSystem.Factory.createForRoot(ServerConfiguration.global());
     ufs.create(ufsRoot + "/xyz").close();
     mFileSystem.loadMetadata(new AlluxioURI("/xyz"));
     URIStatus status = mFileSystem.getStatus(new AlluxioURI("/xyz"));
@@ -206,10 +206,10 @@ public class UfsJournalIntegrationTest extends BaseIntegrationTest {
             Constants.FILE_SYSTEM_MASTER_NAME);
     UfsJournal journal = new UfsJournal(new URI(journalFolder), new NoopMaster(), 0);
     URI completedLocation = journal.getLogDir();
-    Assert.assertTrue(UnderFileSystem.Factory.create(completedLocation)
+    Assert.assertTrue(UnderFileSystem.Factory.create(completedLocation, ServerConfiguration.global())
         .listStatus(completedLocation.toString()).length > 1);
     multiEditLogTestUtil();
-    Assert.assertTrue(UnderFileSystem.Factory.create(completedLocation)
+    Assert.assertTrue(UnderFileSystem.Factory.create(completedLocation, ServerConfiguration.global())
         .listStatus(completedLocation.toString()).length > 1);
     multiEditLogTestUtil();
   }
@@ -597,7 +597,7 @@ public class UfsJournalIntegrationTest extends BaseIntegrationTest {
     AlluxioURI filePath = new AlluxioURI("/file");
 
     String user = "alluxio";
-    Configuration.set(PropertyKey.SECURITY_LOGIN_USERNAME, user);
+    ServerConfiguration.set(PropertyKey.SECURITY_LOGIN_USERNAME, user);
     CreateFilePOptions op = CreateFilePOptions.newBuilder().setBlockSizeBytes(64).build();
     mFileSystem.createFile(filePath, op).close();
 
@@ -633,7 +633,7 @@ public class UfsJournalIntegrationTest extends BaseIntegrationTest {
         new URI(PathUtils.concatPath(journalFolder, Constants.FILE_SYSTEM_MASTER_NAME)),
         new NoopMaster(), 0);
     if (UfsJournalSnapshot.getCurrentLog(journal) != null) {
-      UnderFileSystem.Factory.create(journalFolder)
+      UnderFileSystem.Factory.create(journalFolder, ServerConfiguration.global())
           .deleteFile(UfsJournalSnapshot.getCurrentLog(journal).getLocation().toString());
     }
   }
diff --git a/tests/src/test/java/alluxio/server/health/BlockMasterIntegrityIntegrationTest.java b/tests/src/test/java/alluxio/server/health/BlockMasterIntegrityIntegrationTest.java
index 1a59ba99aa..1d04e229c0 100644
--- a/tests/src/test/java/alluxio/server/health/BlockMasterIntegrityIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/health/BlockMasterIntegrityIntegrationTest.java
@@ -12,7 +12,7 @@
 package alluxio.server.health;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
 import alluxio.grpc.WritePType;
@@ -57,7 +57,7 @@ public class BlockMasterIntegrityIntegrationTest {
     mCluster.stopWorkers();
     fs.delete(uri);
     mCluster.restartMasters();
-    mCluster.startWorkers(); // creates a new worker, so need to get the new BlockWorker
+    mCluster.startWorkers(); // creates a new worker, so need to create the new BlockWorker
     BlockWorker newWorker = mCluster.getWorkerProcess().getWorker(BlockWorker.class);
     CommonUtils.waitFor("orphan blocks to be deleted",
         () -> newWorker.getStoreMetaFull().getNumberOfBlocks() == 0,
@@ -78,7 +78,7 @@ public class BlockMasterIntegrityIntegrationTest {
     removeFileMetadata(uri);
     mCluster.stopWorkers();
     mCluster.restartMasters();
-    mCluster.startWorkers(); // creates a new worker, so need to get the new BlockWorker
+    mCluster.startWorkers(); // creates a new worker, so need to create the new BlockWorker
     BlockWorker newWorker = mCluster.getWorkerProcess().getWorker(BlockWorker.class);
     CommonUtils.waitFor("invalid blocks to be deleted",
         () -> newWorker.getStoreMetaFull().getNumberOfBlocks() == 0,
diff --git a/tests/src/test/java/alluxio/server/health/JobMasterHealthCheckClientIntegrationTest.java b/tests/src/test/java/alluxio/server/health/JobMasterHealthCheckClientIntegrationTest.java
index c363599229..779d2e5aa5 100644
--- a/tests/src/test/java/alluxio/server/health/JobMasterHealthCheckClientIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/health/JobMasterHealthCheckClientIntegrationTest.java
@@ -12,7 +12,8 @@
 package alluxio.server.health;
 
 import alluxio.HealthCheckClient;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.jobmaster.JobMasterHealthCheckClient;
 import alluxio.master.LocalAlluxioJobCluster;
 import alluxio.retry.CountingRetry;
@@ -42,7 +43,8 @@ public class JobMasterHealthCheckClientIntegrationTest extends BaseIntegrationTe
     mLocalAlluxioJobCluster = new LocalAlluxioJobCluster();
     mLocalAlluxioJobCluster.start();
     InetSocketAddress address = mLocalAlluxioJobCluster.getMaster().getRpcAddress();
-    mHealthCheckClient = new JobMasterHealthCheckClient(address, () -> new CountingRetry(1));
+    mHealthCheckClient = new JobMasterHealthCheckClient(address, () -> new CountingRetry(1),
+        ServerConfiguration.global());
   }
 
   @After
diff --git a/tests/src/test/java/alluxio/server/health/JobWorkerHealthCheckClientIntegrationTest.java b/tests/src/test/java/alluxio/server/health/JobWorkerHealthCheckClientIntegrationTest.java
index 1781da0eb3..aa4e73af8a 100644
--- a/tests/src/test/java/alluxio/server/health/JobWorkerHealthCheckClientIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/health/JobWorkerHealthCheckClientIntegrationTest.java
@@ -12,7 +12,8 @@
 package alluxio.server.health;
 
 import alluxio.HealthCheckClient;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.jobworker.JobWorkerHealthCheckClient;
 import alluxio.master.LocalAlluxioJobCluster;
 import alluxio.retry.CountingRetry;
@@ -42,7 +43,8 @@ public class JobWorkerHealthCheckClientIntegrationTest extends BaseIntegrationTe
     mLocalAlluxioJobCluster = new LocalAlluxioJobCluster();
     mLocalAlluxioJobCluster.start();
     InetSocketAddress address = mLocalAlluxioJobCluster.getWorker().getRpcAddress();
-    mHealthCheckClient = new JobWorkerHealthCheckClient(address, () -> new CountingRetry(1));
+    mHealthCheckClient = new JobWorkerHealthCheckClient(address, () -> new CountingRetry(1),
+        ServerConfiguration.global());
   }
 
   @After
diff --git a/tests/src/test/java/alluxio/server/health/ProxyHealthCheckClientIntegrationTest.java b/tests/src/test/java/alluxio/server/health/ProxyHealthCheckClientIntegrationTest.java
index 31541e0067..d99989373c 100644
--- a/tests/src/test/java/alluxio/server/health/ProxyHealthCheckClientIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/health/ProxyHealthCheckClientIntegrationTest.java
@@ -12,8 +12,9 @@
 package alluxio.server.health;
 
 import alluxio.HealthCheckClient;
+import alluxio.conf.ServerConfiguration;
 import alluxio.testutils.LocalAlluxioClusterResource;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.master.LocalAlluxioCluster;
 import alluxio.proxy.ProxyHealthCheckClient;
 import alluxio.retry.CountingRetry;
@@ -39,7 +40,8 @@ public class ProxyHealthCheckClientIntegrationTest extends BaseIntegrationTest {
   public final void before() throws Exception {
     mLocalAlluxioCluster = mLocalAlluxioClusterResource.get();
     mHealthCheckClient = new ProxyHealthCheckClient(
-        NetworkAddressUtils.getBindAddress(NetworkAddressUtils.ServiceType.PROXY_WEB),
+        NetworkAddressUtils.getBindAddress(NetworkAddressUtils.ServiceType.PROXY_WEB,
+            ServerConfiguration.global()),
         () -> new CountingRetry(1));
   }
 
diff --git a/tests/src/test/java/alluxio/server/health/StartupConsistencyCheckIntegrationTest.java b/tests/src/test/java/alluxio/server/health/StartupConsistencyCheckIntegrationTest.java
index 0d06ffcc5c..3215904ca4 100644
--- a/tests/src/test/java/alluxio/server/health/StartupConsistencyCheckIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/health/StartupConsistencyCheckIntegrationTest.java
@@ -12,8 +12,8 @@
 package alluxio.server.health;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileSystem;
 import alluxio.grpc.CreateDirectoryPOptions;
 import alluxio.grpc.CreateFilePOptions;
@@ -97,7 +97,7 @@ public final class StartupConsistencyCheckIntegrationTest extends BaseIntegratio
     String topLevelFileUfsPath = mFileSystem.getStatus(TOP_LEVEL_FILE).getUfsPath();
     String secondLevelDirUfsPath = mFileSystem.getStatus(SECOND_LEVEL_DIR).getUfsPath();
     mCluster.stopFS();
-    UnderFileSystem ufs = UnderFileSystem.Factory.create(topLevelFileUfsPath);
+    UnderFileSystem ufs = UnderFileSystem.Factory.create(topLevelFileUfsPath, ServerConfiguration.global());
     ufs.deleteFile(topLevelFileUfsPath);
     ufs.deleteDirectory(secondLevelDirUfsPath, DeleteOptions.defaults().setRecursive(true));
     MasterRegistry registry = MasterTestUtils.createLeaderFileSystemMasterFromJournal();
@@ -116,7 +116,7 @@ public final class StartupConsistencyCheckIntegrationTest extends BaseIntegratio
   @Test
   public void disabled() throws Exception {
     mCluster.stopFS();
-    Configuration.set(PropertyKey.MASTER_STARTUP_CONSISTENCY_CHECK_ENABLED, false);
+    ServerConfiguration.set(PropertyKey.MASTER_STARTUP_CONSISTENCY_CHECK_ENABLED, false);
     MasterRegistry registry = MasterTestUtils.createLeaderFileSystemMasterFromJournal();
     FileSystemMaster master = registry.get(FileSystemMaster.class);
     MasterTestUtils.waitForStartupConsistencyCheck(master);
diff --git a/tests/src/test/java/alluxio/server/health/WorkerHealthCheckClientIntegrationTest.java b/tests/src/test/java/alluxio/server/health/WorkerHealthCheckClientIntegrationTest.java
index cafdb436ee..f4a13a5f50 100644
--- a/tests/src/test/java/alluxio/server/health/WorkerHealthCheckClientIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/health/WorkerHealthCheckClientIntegrationTest.java
@@ -12,7 +12,8 @@
 package alluxio.server.health;
 
 import alluxio.HealthCheckClient;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
+import alluxio.conf.ServerConfiguration;
 import alluxio.master.LocalAlluxioCluster;
 import alluxio.retry.CountingRetry;
 import alluxio.testutils.BaseIntegrationTest;
@@ -42,7 +43,8 @@ public class WorkerHealthCheckClientIntegrationTest extends BaseIntegrationTest
     InetSocketAddress address =
         new InetSocketAddress(mLocalAlluxioCluster.getWorkerAddress().getHost(),
             mLocalAlluxioCluster.getWorkerAddress().getRpcPort());
-    mHealthCheckClient = new WorkerHealthCheckClient(address, () -> new CountingRetry(1));
+    mHealthCheckClient = new WorkerHealthCheckClient(address, () -> new CountingRetry(1),
+        ServerConfiguration.global());
   }
 
   @Test
diff --git a/tests/src/test/java/alluxio/server/tieredstore/CapacityUsageIntegrationTest.java b/tests/src/test/java/alluxio/server/tieredstore/CapacityUsageIntegrationTest.java
index 59e2720f06..35fc684be5 100644
--- a/tests/src/test/java/alluxio/server/tieredstore/CapacityUsageIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/tieredstore/CapacityUsageIntegrationTest.java
@@ -13,7 +13,7 @@ package alluxio.server.tieredstore;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
diff --git a/tests/src/test/java/alluxio/server/tieredstore/SpecificTierWriteIntegrationTest.java b/tests/src/test/java/alluxio/server/tieredstore/SpecificTierWriteIntegrationTest.java
index d18a137b4a..9486cf729f 100644
--- a/tests/src/test/java/alluxio/server/tieredstore/SpecificTierWriteIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/tieredstore/SpecificTierWriteIntegrationTest.java
@@ -13,7 +13,7 @@ package alluxio.server.tieredstore;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.URIStatus;
diff --git a/tests/src/test/java/alluxio/server/tieredstore/TierPromoteIntegrationTest.java b/tests/src/test/java/alluxio/server/tieredstore/TierPromoteIntegrationTest.java
index 1b14373b62..5b167a8056 100644
--- a/tests/src/test/java/alluxio/server/tieredstore/TierPromoteIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/tieredstore/TierPromoteIntegrationTest.java
@@ -13,7 +13,7 @@ package alluxio.server.tieredstore;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileOutStream;
 import alluxio.client.file.FileSystem;
diff --git a/tests/src/test/java/alluxio/server/tieredstore/TieredStoreIntegrationTest.java b/tests/src/test/java/alluxio/server/tieredstore/TieredStoreIntegrationTest.java
index c99e15c123..b353e37ed5 100644
--- a/tests/src/test/java/alluxio/server/tieredstore/TieredStoreIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/tieredstore/TieredStoreIntegrationTest.java
@@ -12,7 +12,7 @@
 package alluxio.server.tieredstore;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.client.file.FileInStream;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemTestUtils;
diff --git a/tests/src/test/java/alluxio/server/web/ServiceSocketBindIntegrationTest.java b/tests/src/test/java/alluxio/server/web/ServiceSocketBindIntegrationTest.java
index 3e01dd2ed4..3a4c5fabba 100644
--- a/tests/src/test/java/alluxio/server/web/ServiceSocketBindIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/web/ServiceSocketBindIntegrationTest.java
@@ -12,6 +12,7 @@
 package alluxio.server.web;
 
 import alluxio.client.block.BlockMasterClient;
+import alluxio.conf.ServerConfiguration;
 import alluxio.exception.ConnectionFailedException;
 import alluxio.exception.status.UnavailableException;
 import alluxio.master.LocalAlluxioCluster;
@@ -65,7 +66,8 @@ public class ServiceSocketBindIntegrationTest extends BaseIntegrationTest {
    */
   private void connectServices() throws IOException, ConnectionFailedException {
     // connect Master RPC service
-    mBlockMasterClient = BlockMasterClient.Factory.create(MasterClientConfig.defaults());
+    mBlockMasterClient =
+        BlockMasterClient.Factory.create(MasterClientConfig.defaults(ServerConfiguration.global()), ServerConfiguration.global());
     mBlockMasterClient.connect();
 
     // connect Worker RPC service
@@ -77,7 +79,7 @@ public class ServiceSocketBindIntegrationTest extends BaseIntegrationTest {
 
     // connect Master Web service
     InetSocketAddress masterWebAddr =
-        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_WEB);
+        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_WEB, ServerConfiguration.global());
     mMasterWebService = (HttpURLConnection) new URL(
         "http://" + masterWebAddr.getAddress().getHostAddress() + ":" + masterWebAddr.getPort()
             + "/css/custom.min.css").openConnection();
@@ -160,8 +162,10 @@ public class ServiceSocketBindIntegrationTest extends BaseIntegrationTest {
     // Connect to Master RPC service on loopback, while Master is listening on local hostname.
     InetSocketAddress masterRpcAddr = new InetSocketAddress("127.0.0.1",
         mLocalAlluxioCluster.getLocalAlluxioMaster().getRpcLocalPort());
-    mBlockMasterClient = BlockMasterClient.Factory.create(MasterClientConfig.defaults()
-        .withMasterInquireClient(new SingleMasterInquireClient(masterRpcAddr)));
+    mBlockMasterClient = BlockMasterClient.Factory.create(MasterClientConfig.defaults(
+        ServerConfiguration.global()).withMasterInquireClient(
+            new SingleMasterInquireClient(masterRpcAddr)),
+        ServerConfiguration.global());
     try {
       mBlockMasterClient.connect();
       Assert.fail("Client should not have successfully connected to master RPC service.");
diff --git a/tests/src/test/java/alluxio/server/web/WebServerIntegrationTest.java b/tests/src/test/java/alluxio/server/web/WebServerIntegrationTest.java
index 4f016d7b74..1ee37cd2a8 100644
--- a/tests/src/test/java/alluxio/server/web/WebServerIntegrationTest.java
+++ b/tests/src/test/java/alluxio/server/web/WebServerIntegrationTest.java
@@ -13,6 +13,7 @@ package alluxio.server.web;
 
 import alluxio.client.rest.TestCase;
 import alluxio.client.rest.TestCaseOptions;
+import alluxio.conf.ServerConfiguration;
 import alluxio.testutils.LocalAlluxioClusterResource;
 import alluxio.testutils.BaseIntegrationTest;
 import alluxio.util.network.NetworkAddressUtils;
@@ -141,7 +142,7 @@ public class WebServerIntegrationTest extends BaseIntegrationTest {
       port = mLocalAlluxioClusterResource.get().getWorkerProcess().getWebLocalPort();
     }
     InetSocketAddress webAddr =
-        new InetSocketAddress(NetworkAddressUtils.getConnectHost(serviceType), port);
+        new InetSocketAddress(NetworkAddressUtils.getConnectHost(serviceType, ServerConfiguration.global()), port);
     return webAddr;
   }
 }
diff --git a/tests/src/test/java/alluxio/testutils/IntegrationTestUtils.java b/tests/src/test/java/alluxio/testutils/IntegrationTestUtils.java
index 052fbaddb0..8b7cbffe4e 100644
--- a/tests/src/test/java/alluxio/testutils/IntegrationTestUtils.java
+++ b/tests/src/test/java/alluxio/testutils/IntegrationTestUtils.java
@@ -15,6 +15,7 @@ import alluxio.AlluxioURI;
 import alluxio.Constants;
 import alluxio.client.file.FileSystem;
 import alluxio.client.file.FileSystemMasterClient;
+import alluxio.conf.ServerConfiguration;
 import alluxio.grpc.GetStatusPOptions;
 import alluxio.heartbeat.HeartbeatContext;
 import alluxio.heartbeat.HeartbeatScheduler;
@@ -58,7 +59,8 @@ public final class IntegrationTestUtils {
   public static void waitForPersist(final LocalAlluxioClusterResource localAlluxioClusterResource,
       final AlluxioURI uri, int timeoutMs) throws InterruptedException, TimeoutException {
     try (FileSystemMasterClient client =
-        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults())) {
+        FileSystemMasterClient.Factory.create(MasterClientConfig.defaults(
+            ServerConfiguration.global()), ServerConfiguration.global())) {
       CommonUtils.waitFor(uri + " to be persisted", () -> {
         try {
           return client.getStatus(uri, GetStatusPOptions.getDefaultInstance()).isPersisted();
diff --git a/tests/src/test/java/alluxio/testutils/LocalAlluxioClusterResource.java b/tests/src/test/java/alluxio/testutils/LocalAlluxioClusterResource.java
index 825c1364b0..76ced92d2e 100644
--- a/tests/src/test/java/alluxio/testutils/LocalAlluxioClusterResource.java
+++ b/tests/src/test/java/alluxio/testutils/LocalAlluxioClusterResource.java
@@ -11,8 +11,8 @@
 
 package alluxio.testutils;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.ServerConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.master.LocalAlluxioCluster;
 import alluxio.metrics.MetricsSystem;
 import alluxio.security.LoginUserTestUtils;
@@ -34,7 +34,7 @@ import javax.annotation.concurrent.NotThreadSafe;
 /**
  * A JUnit Rule resource for automatically managing a local alluxio cluster for testing. To use it,
  * create an instance of the class under a {@literal @}Rule annotation, with the required
- * configuration parameters, and any necessary explicit {@link Configuration} settings. The Alluxio
+ * configuration parameters, and any necessary explicit {@link ServerConfiguration} settings. The Alluxio
  * cluster will be set up from scratch at the end of every method (or at the start of every suite if
  * {@literal @}ClassRule is used), and destroyed at the end. Below is an example of declaring and
  * using it.
@@ -47,7 +47,7 @@ import javax.annotation.concurrent.NotThreadSafe;
  *
  *    {@literal @}Test
  *    public void testSomething() {
- *      localAlluxioClusterResource.get().getClient().create("/abced");
+ *      localAlluxioClusterResource.create().getClient().create("/abced");
  *      ...
  *    }
  *
@@ -55,7 +55,7 @@ import javax.annotation.concurrent.NotThreadSafe;
  *    {@literal @}LocalAlluxioClusterResource.Config(
  *        confParams = {CONF_KEY_1, CONF_VALUE_1, CONF_KEY_2, CONF_VALUE_2, ...})
  *    public void testSomethingWithDifferentConf() {
-  *      localAlluxioClusterResource.get().getClient().create("/efghi");
+  *      localAlluxioClusterResource.create().getClient().create("/efghi");
  *      ...
  *    }
  *
@@ -63,7 +63,7 @@ import javax.annotation.concurrent.NotThreadSafe;
  *    {@literal @}LocalAlluxioClusterResource.Config(startCluster = false)
  *    public void testSomethingWithClusterStartedManually() {
  *      localAlluxioClusterResource.start();
- *      localAlluxioClusterResource.get().getClient().create("/efghi");
+ *      localAlluxioClusterResource.create().getClient().create("/efghi");
  *      ...
  *    }
  *   }
@@ -80,7 +80,7 @@ public final class LocalAlluxioClusterResource implements TestRule {
    */
   private final boolean mStartCluster;
 
-  /** Configuration values for the cluster. */
+  /** ServerConfiguration values for the cluster. */
   private final Map<PropertyKey, String> mConfiguration = new HashMap<>();
 
   /** The Alluxio cluster being managed. */
@@ -136,9 +136,9 @@ public final class LocalAlluxioClusterResource implements TestRule {
     mLocalAlluxioCluster.initConfiguration();
     // Overwrite the test configuration with test specific parameters
     for (Entry<PropertyKey, String> entry : mConfiguration.entrySet()) {
-      Configuration.set(entry.getKey(), entry.getValue());
+      ServerConfiguration.set(entry.getKey(), entry.getValue());
     }
-    Configuration.validate();
+    ServerConfiguration.global().validate();
     // Start the cluster
     mLocalAlluxioCluster.start();
   }
diff --git a/tests/src/test/java/alluxio/testutils/master/MasterTestUtils.java b/tests/src/test/java/alluxio/testutils/master/MasterTestUtils.java
index 2130068d9c..c06918de69 100644
--- a/tests/src/test/java/alluxio/testutils/master/MasterTestUtils.java
+++ b/tests/src/test/java/alluxio/testutils/master/MasterTestUtils.java
@@ -13,9 +13,9 @@ package alluxio.testutils.master;
 
 import static org.mockito.Mockito.mock;
 
-import alluxio.Configuration;
+import alluxio.conf.ServerConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.master.BackupManager;
 import alluxio.master.CoreMasterContext;
 import alluxio.master.MasterRegistry;
@@ -64,11 +64,11 @@ public class MasterTestUtils {
    */
   private static MasterRegistry createFileSystemMasterFromJournal(boolean isLeader)
       throws Exception {
-    String masterJournal = Configuration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
+    String masterJournal = ServerConfiguration.get(PropertyKey.MASTER_JOURNAL_FOLDER);
     MasterRegistry registry = new MasterRegistry();
     SafeModeManager safeModeManager = new TestSafeModeManager();
     long startTimeMs = System.currentTimeMillis();
-    int port = Configuration.getInt(PropertyKey.MASTER_RPC_PORT);
+    int port = ServerConfiguration.getInt(PropertyKey.MASTER_RPC_PORT);
     JournalSystem journalSystem = JournalTestUtils.createJournalSystem(masterJournal);
     CoreMasterContext masterContext = CoreMasterContext.newBuilder()
         .setJournalSystem(journalSystem)
diff --git a/tests/src/test/java/alluxio/testutils/underfs/ConfExpectingUnderFileSystemFactory.java b/tests/src/test/java/alluxio/testutils/underfs/ConfExpectingUnderFileSystemFactory.java
index 247bda205f..edea7a9bef 100644
--- a/tests/src/test/java/alluxio/testutils/underfs/ConfExpectingUnderFileSystemFactory.java
+++ b/tests/src/test/java/alluxio/testutils/underfs/ConfExpectingUnderFileSystemFactory.java
@@ -12,6 +12,7 @@
 package alluxio.testutils.underfs;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -37,11 +38,12 @@ public final class ConfExpectingUnderFileSystemFactory implements UnderFileSyste
   }
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf,
+      AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
     Preconditions.checkArgument(mExpectedConf.equals(conf.getMountSpecificConf()),
         "ufs conf {} does not match expected {}", conf, mExpectedConf);
-    return new LocalUnderFileSystem(new AlluxioURI(new AlluxioURI(path).getPath()), conf);
+    return new LocalUnderFileSystem(new AlluxioURI(new AlluxioURI(path).getPath()), conf, alluxioConf);
   }
 
   @Override
diff --git a/tests/src/test/java/alluxio/testutils/underfs/delegating/DelegatingUnderFileSystemFactory.java b/tests/src/test/java/alluxio/testutils/underfs/delegating/DelegatingUnderFileSystemFactory.java
index 2e1cb2617e..5d6327d8a5 100644
--- a/tests/src/test/java/alluxio/testutils/underfs/delegating/DelegatingUnderFileSystemFactory.java
+++ b/tests/src/test/java/alluxio/testutils/underfs/delegating/DelegatingUnderFileSystemFactory.java
@@ -11,6 +11,7 @@
 
 package alluxio.testutils.underfs.delegating;
 
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -35,7 +36,8 @@ public class DelegatingUnderFileSystemFactory implements UnderFileSystemFactory
   }
 
   @Override
-  public UnderFileSystem create(String path, @Nullable UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, @Nullable UnderFileSystemConfiguration conf,
+      AlluxioConfiguration alluxioConf) {
     return mUfs;
   }
 
diff --git a/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystem.java b/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystem.java
index e21e22900f..b29a1dee30 100644
--- a/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystem.java
+++ b/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystem.java
@@ -12,6 +12,7 @@
 package alluxio.testutils.underfs.sleeping;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UfsDirectoryStatus;
 import alluxio.underfs.UfsFileStatus;
 import alluxio.underfs.UfsStatus;
@@ -46,8 +47,8 @@ public class SleepingUnderFileSystem extends LocalUnderFileSystem {
    * @param ufsConf UFS configuration
    */
   public SleepingUnderFileSystem(AlluxioURI uri, SleepingUnderFileSystemOptions options,
-      UnderFileSystemConfiguration ufsConf) {
-    super(uri, ufsConf);
+      UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
+    super(uri, ufsConf, alluxioConf);
     mOptions = options;
   }
 
diff --git a/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemFactory.java b/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemFactory.java
index c40e0a0f52..38328ef427 100644
--- a/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemFactory.java
+++ b/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemFactory.java
@@ -12,6 +12,7 @@
 package alluxio.testutils.underfs.sleeping;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -45,10 +46,11 @@ public class SleepingUnderFileSystemFactory implements UnderFileSystemFactory {
   }
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf,
+      AlluxioConfiguration alluxioConf) {
     if (mUfs == null) {
       Preconditions.checkArgument(path != null, "path may not be null");
-      return new SleepingUnderFileSystem(new AlluxioURI(path), mOptions, conf);
+      return new SleepingUnderFileSystem(new AlluxioURI(path), mOptions, conf, alluxioConf);
     } else {
       return mUfs;
     }
diff --git a/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemOptions.java b/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemOptions.java
index 64f521b229..0d175e0194 100644
--- a/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemOptions.java
+++ b/tests/src/test/java/alluxio/testutils/underfs/sleeping/SleepingUnderFileSystemOptions.java
@@ -176,14 +176,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get block size call
+   * @return milliseconds to sleep before executing a create block size call
    */
   public long getGetBlockSizeByteMs() {
     return mGetBlockSizeByteMs;
   }
 
   /**
-   * @param getBlockSizeByteMs milliseconds to sleep before executing a get block size call
+   * @param getBlockSizeByteMs milliseconds to sleep before executing a create block size call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetBlockSizeByteMs(long getBlockSizeByteMs) {
@@ -192,14 +192,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get conf call
+   * @return milliseconds to sleep before executing a create conf call
    */
   public long getGetConfMs() {
     return mGetConfMs;
   }
 
   /**
-   * @param getConfMs milliseconds to sleep before executing a get conf call
+   * @param getConfMs milliseconds to sleep before executing a create conf call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetConfMs(long getConfMs) {
@@ -208,14 +208,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get directory status call
+   * @return milliseconds to sleep before executing a create directory status call
    */
   public long getGetDirectoryStatusMs() {
     return mGetDirectoryStatusMs;
   }
 
   /**
-   * @param getDirectoryStatusMs milliseconds to sleep before executing a get directory status call
+   * @param getDirectoryStatusMs milliseconds to sleep before executing a create directory status call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetDirectoryStatusMs(long getDirectoryStatusMs) {
@@ -224,14 +224,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get file location call
+   * @return milliseconds to sleep before executing a create file location call
    */
   public long getGetFileLocationsMs() {
     return mGetFileLocationsMs;
   }
 
   /**
-   * @param getFileLocationsMs milliseconds to sleep before executing a get file location call
+   * @param getFileLocationsMs milliseconds to sleep before executing a create file location call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetFileLocationsMs(long getFileLocationsMs) {
@@ -240,14 +240,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get file status call
+   * @return milliseconds to sleep before executing a create file status call
    */
   public long getGetFileStatusMs() {
     return mGetFileStatusMs;
   }
 
   /**
-   * @param getFileStatusMs milliseconds to sleep before executing a get file status call
+   * @param getFileStatusMs milliseconds to sleep before executing a create file status call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetFileStatusMs(long getFileStatusMs) {
@@ -272,14 +272,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get space call
+   * @return milliseconds to sleep before executing a create space call
    */
   public long getGetSpaceMs() {
     return mGetSpaceMs;
   }
 
   /**
-   * @param getSpaceMs milliseconds to sleep before executing a get space call
+   * @param getSpaceMs milliseconds to sleep before executing a create space call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetSpaceMs(long getSpaceMs) {
@@ -288,14 +288,14 @@ public class SleepingUnderFileSystemOptions {
   }
 
   /**
-   * @return milliseconds to sleep before executing a get underfs type call
+   * @return milliseconds to sleep before executing a create underfs type call
    */
   public long getGetUnderFSTypeMs() {
     return mGetUnderFSTypeMs;
   }
 
   /**
-   * @param getUnderFSTypeMs milliseconds to sleep before executing a get underfs type call
+   * @param getUnderFSTypeMs milliseconds to sleep before executing a create underfs type call
    * @return the updated object
    */
   public SleepingUnderFileSystemOptions setGetUnderFSTypeMs(long getUnderFSTypeMs) {
diff --git a/underfs/cos/src/main/java/alluxio/underfs/cos/COSInputStream.java b/underfs/cos/src/main/java/alluxio/underfs/cos/COSInputStream.java
index 275fc457f7..e43c7e1f53 100644
--- a/underfs/cos/src/main/java/alluxio/underfs/cos/COSInputStream.java
+++ b/underfs/cos/src/main/java/alluxio/underfs/cos/COSInputStream.java
@@ -49,8 +49,8 @@ public class COSInputStream extends MultiRangeObjectInputStream {
    * @param key the key of the file
    * @param client the client for COS
    */
-  COSInputStream(String bucketName, String key, COSClient client) throws IOException {
-    this(bucketName, key, client, 0L);
+  COSInputStream(String bucketName, String key, COSClient client, long blockSize) throws IOException {
+    this(bucketName, key, client, 0L, blockSize);
   }
 
   /**
@@ -61,8 +61,9 @@ public class COSInputStream extends MultiRangeObjectInputStream {
    * @param client the client for COS
    * @param position the position to begin reading from
    */
-  COSInputStream(String bucketName, String key, COSClient client, long position)
+  COSInputStream(String bucketName, String key, COSClient client, long position, long blockSize)
       throws IOException {
+    mBlockSize = blockSize;
     mBucketName = bucketName;
     mKey = key;
     mCosClient = client;
@@ -72,7 +73,7 @@ public class COSInputStream extends MultiRangeObjectInputStream {
   }
 
   @Override
-  protected InputStream createStream(long startPos, long endPos) throws IOException {
+  protected InputStream createStream(long startPos, long endPos, long blockSize) throws IOException {
     GetObjectRequest req = new GetObjectRequest(mBucketName, mKey);
     // COS returns entire object if we read past the end
     req.setRange(startPos, endPos < mContentLength ? endPos - 1 : mContentLength - 1);
diff --git a/underfs/cos/src/main/java/alluxio/underfs/cos/COSOutputStream.java b/underfs/cos/src/main/java/alluxio/underfs/cos/COSOutputStream.java
index 9f2dba88f7..ef8cd8fc1b 100644
--- a/underfs/cos/src/main/java/alluxio/underfs/cos/COSOutputStream.java
+++ b/underfs/cos/src/main/java/alluxio/underfs/cos/COSOutputStream.java
@@ -33,6 +33,7 @@ import java.io.OutputStream;
 import java.security.DigestOutputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -70,7 +71,7 @@ public final class COSOutputStream extends OutputStream {
    * @param key the key of the file
    * @param client the client for COS
    */
-  public COSOutputStream(String bucketName, String key, COSClient client) throws IOException {
+  public COSOutputStream(String bucketName, String key, COSClient client, List<String> tmpDirs) throws IOException {
     Preconditions.checkArgument(bucketName != null && !bucketName.isEmpty(),
         "Bucket name must not be null or empty.");
     Preconditions.checkArgument(key != null && !key.isEmpty(),
@@ -80,7 +81,7 @@ public final class COSOutputStream extends OutputStream {
     mKey = key;
     mCosClient = client;
 
-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));
+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));
 
     try {
       mHash = MessageDigest.getInstance("MD5");
diff --git a/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystem.java b/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystem.java
index 080937b04e..b2db84520d 100644
--- a/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystem.java
+++ b/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystem.java
@@ -13,7 +13,8 @@ package alluxio.underfs.cos;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.ObjectUnderFileSystem;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -69,7 +70,8 @@ public class COSUnderFileSystem extends ObjectUnderFileSystem {
    * @param conf the configuration for this UFS
    * @return the created {@link COSUnderFileSystem} instance
    */
-  public static COSUnderFileSystem createInstance(AlluxioURI uri, UnderFileSystemConfiguration conf)
+  public static COSUnderFileSystem createInstance(AlluxioURI uri, UnderFileSystemConfiguration conf,
+                                                  AlluxioConfiguration alluxioConf)
       throws Exception {
     String bucketName = UnderFileSystemUtils.getBucketName(uri);
     Preconditions.checkArgument(conf.isSet(PropertyKey.COS_ACCESS_KEY),
@@ -89,7 +91,7 @@ public class COSUnderFileSystem extends ObjectUnderFileSystem {
     ClientConfig clientConfig = createCOSClientConfig(regionName, conf);
     COSClient client = new COSClient(cred, clientConfig);
 
-    return new COSUnderFileSystem(uri, client, bucketName, appId, conf);
+    return new COSUnderFileSystem(uri, client, bucketName, appId, conf, alluxioConf);
   }
 
   /**
@@ -101,8 +103,8 @@ public class COSUnderFileSystem extends ObjectUnderFileSystem {
    * @param conf configuration for this UFS
    */
   protected COSUnderFileSystem(AlluxioURI uri, COSClient client, String bucketName, String appId,
-      UnderFileSystemConfiguration conf) {
-    super(uri, conf);
+                               UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
+    super(uri, conf, alluxioConf);
     mClient = client;
     mBucketName = bucketName;
     mBucketNameInternal = bucketName + "-" + appId;
@@ -148,7 +150,7 @@ public class COSUnderFileSystem extends ObjectUnderFileSystem {
 
   @Override
   protected OutputStream createObject(String key) throws IOException {
-    return new COSOutputStream(mBucketNameInternal, key, mClient);
+    return new COSOutputStream(mBucketNameInternal, key, mClient, mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","));
   }
 
   @Override
@@ -177,7 +179,7 @@ public class COSUnderFileSystem extends ObjectUnderFileSystem {
     ListObjectsRequest request = new ListObjectsRequest();
     request.setBucketName(mBucketNameInternal);
     request.setPrefix(key);
-    request.setMaxKeys(getListingChunkLength());
+    request.setMaxKeys(getListingChunkLength(mAlluxioConf));
     request.setDelimiter(delimiter);
 
     ObjectListing result = getObjectListingChunk(request);
diff --git a/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystemFactory.java b/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystemFactory.java
index c094cacba4..4879feba1c 100644
--- a/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystemFactory.java
+++ b/underfs/cos/src/main/java/alluxio/underfs/cos/COSUnderFileSystemFactory.java
@@ -13,7 +13,8 @@ package alluxio.underfs.cos;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -37,12 +38,12 @@ public class COSUnderFileSystemFactory implements UnderFileSystemFactory {
   public COSUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
 
     if (checkCOSCredentials(conf)) {
       try {
-        return COSUnderFileSystem.createInstance(new AlluxioURI(path), conf);
+        return COSUnderFileSystem.createInstance(new AlluxioURI(path), conf, alluxioConf);
       } catch (Exception e) {
         throw Throwables.propagate(e);
       }
diff --git a/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSOutputStream.java b/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSOutputStream.java
index edf84e27aa..be57c6e210 100644
--- a/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSOutputStream.java
+++ b/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSOutputStream.java
@@ -30,6 +30,7 @@ import java.io.OutputStream;
 import java.security.DigestOutputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -71,14 +72,14 @@ public final class GCSOutputStream extends OutputStream {
    * @param key the key of the file
    * @param client the JetS3t client
    */
-  public GCSOutputStream(String bucketName, String key, GoogleStorageService client)
+  public GCSOutputStream(String bucketName, String key, GoogleStorageService client, List<String> tmpDirs)
       throws IOException {
     Preconditions.checkArgument(bucketName != null && !bucketName.isEmpty(), "Bucket name must "
         + "not be null or empty.");
     mBucketName = bucketName;
     mKey = key;
     mClient = client;
-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));
+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));
     try {
       mHash = MessageDigest.getInstance("MD5");
       mLocalOutputStream =
diff --git a/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystem.java b/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystem.java
index 0de480151f..c009073b47 100644
--- a/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystem.java
+++ b/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystem.java
@@ -13,7 +13,8 @@ package alluxio.underfs.gcs;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.ObjectUnderFileSystem;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -85,7 +86,7 @@ public class GCSUnderFileSystem extends ObjectUnderFileSystem {
    * @throws ServiceException when a connection to GCS could not be created
    */
   public static GCSUnderFileSystem createInstance(
-      AlluxioURI uri, UnderFileSystemConfiguration conf) throws ServiceException {
+      AlluxioURI uri, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) throws ServiceException {
     String bucketName = UnderFileSystemUtils.getBucketName(uri);
     Preconditions.checkArgument(conf.isSet(PropertyKey.GCS_ACCESS_KEY),
             "Property " + PropertyKey.GCS_ACCESS_KEY + " is required to connect to GCS");
@@ -122,7 +123,7 @@ public class GCSUnderFileSystem extends ObjectUnderFileSystem {
     short bucketMode = GCSUtils.translateBucketAcl(acl, accountOwnerId);
 
     return new GCSUnderFileSystem(uri, googleStorageService, bucketName, bucketMode, accountOwner,
-        conf);
+        conf, alluxioConf);
   }
 
   /**
@@ -136,8 +137,9 @@ public class GCSUnderFileSystem extends ObjectUnderFileSystem {
    * @param conf configuration for this UFS
    */
   protected GCSUnderFileSystem(AlluxioURI uri, GoogleStorageService googleStorageService,
-      String bucketName, short bucketMode, String accountOwner, UnderFileSystemConfiguration conf) {
-    super(uri, conf);
+                               String bucketName, short bucketMode, String accountOwner,
+                               UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
+    super(uri, conf, alluxioConf);
     mClient = googleStorageService;
     mBucketName = bucketName;
     mBucketMode = bucketMode;
@@ -196,7 +198,7 @@ public class GCSUnderFileSystem extends ObjectUnderFileSystem {
 
   @Override
   protected OutputStream createObject(String key) throws IOException {
-    return new GCSOutputStream(mBucketName, key, mClient);
+    return new GCSOutputStream(mBucketName, key, mClient, mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","));
   }
 
   @Override
@@ -235,7 +237,7 @@ public class GCSUnderFileSystem extends ObjectUnderFileSystem {
     StorageObjectsChunk res;
     try {
       res = mClient.listObjectsChunked(mBucketName, key, delimiter,
-          getListingChunkLength(), priorLastKey);
+          getListingChunkLength(mAlluxioConf), priorLastKey);
     } catch (ServiceException e) {
       LOG.error("Failed to list path {}", key, e);
       res = null;
diff --git a/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystemFactory.java b/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystemFactory.java
index e4f08cc695..d4fd132e0d 100644
--- a/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystemFactory.java
+++ b/underfs/gcs/src/main/java/alluxio/underfs/gcs/GCSUnderFileSystemFactory.java
@@ -13,7 +13,8 @@ package alluxio.underfs.gcs;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -42,12 +43,12 @@ public final class GCSUnderFileSystemFactory implements UnderFileSystemFactory {
   public GCSUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
 
     if (checkGoogleCredentials(conf)) {
       try {
-        return GCSUnderFileSystem.createInstance(new AlluxioURI(path), conf);
+        return GCSUnderFileSystem.createInstance(new AlluxioURI(path), conf, alluxioConf);
       } catch (ServiceException e) {
         LOG.error("Failed to create GCSUnderFileSystem.", e);
         throw Throwables.propagate(e);
diff --git a/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemContractTest.java b/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemContractTest.java
index e0ce7874f2..c7a736a105 100644
--- a/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemContractTest.java
+++ b/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemContractTest.java
@@ -11,6 +11,7 @@
 
 package alluxio.underfs.gcs;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.underfs.AbstractUnderFileSystemContractTest;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -35,7 +36,7 @@ public final class GCSUnderFileSystemContractTest extends AbstractUnderFileSyste
   @Override
   public UnderFileSystem createUfs(String path, UnderFileSystemConfiguration conf)
       throws Exception {
-    return new GCSUnderFileSystemFactory().create(path, conf);
+    return new GCSUnderFileSystemFactory().create(path, conf, ConfigurationTestUtils.defaults());
   }
 
   @Override
diff --git a/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemFactoryTest.java b/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemFactoryTest.java
index d94a905e40..a43cf9d49c 100644
--- a/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemFactoryTest.java
+++ b/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemFactoryTest.java
@@ -11,6 +11,7 @@
 
 package alluxio.underfs.gcs;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
@@ -27,7 +28,8 @@ public final class GCSUnderFileSystemFactoryTest {
    */
   @Test
   public void factory() {
-    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("gs://test-bucket/path");
+    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("gs://test-bucket/path",
+        ConfigurationTestUtils.defaults());
 
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for gs paths when using this module", factory);
diff --git a/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemTest.java b/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemTest.java
index e9d353adf5..e1c6476f4c 100644
--- a/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemTest.java
+++ b/underfs/gcs/src/test/java/alluxio/underfs/gcs/GCSUnderFileSystemTest.java
@@ -16,6 +16,7 @@ import static org.mockito.Mockito.when;
 import static org.junit.Assert.assertFalse;
 
 import alluxio.AlluxioURI;
+import alluxio.ConfigurationTestUtils;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.options.DeleteOptions;
 
@@ -50,7 +51,8 @@ public class GCSUnderFileSystemTest {
     mClient = mock(GoogleStorageService.class);
 
     mGCSUnderFileSystem = new GCSUnderFileSystem(new AlluxioURI(""), mClient, BUCKET_NAME,
-        BUCKET_MODE, ACCOUNT_OWNER, UnderFileSystemConfiguration.defaults());
+        BUCKET_MODE, ACCOUNT_OWNER, UnderFileSystemConfiguration.defaults(),
+        ConfigurationTestUtils.defaults());
   }
 
   /**
diff --git a/underfs/hdfs/src/main/java/alluxio/UfsConstants.java b/underfs/hdfs/src/main/java/alluxio/UfsConstants.java
new file mode 100644
index 0000000000..12d4b98479
--- /dev/null
+++ b/underfs/hdfs/src/main/java/alluxio/UfsConstants.java
@@ -0,0 +1,22 @@
+/*
+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0
+ * (the "License"). You may not use this work except in compliance with the License, which is
+ * available at www.apache.org/licenses/LICENSE-2.0
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied, as more fully set forth in the License.
+ *
+ * See the NOTICE file distributed with this work for information regarding copyright ownership.
+ */
+
+package alluxio;
+
+/**
+ * Ufs constants from compilation time by maven.
+ */
+public final class UfsConstants {
+  /* Hadoop version, specified in maven property. **/
+  public static final String UFS_HADOOP_VERSION = "2.2.0";
+
+  private UfsConstants() {} // prevent instantiation
+}
diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java
index bfbc0da93e..55bc8fe161 100644
--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java
+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java
@@ -13,8 +13,8 @@ package alluxio.underfs.hdfs;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
-import alluxio.SyncInfo;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.collections.Pair;
 import alluxio.retry.CountingRetry;
 import alluxio.retry.RetryPolicy;
@@ -102,9 +102,9 @@ public class HdfsUnderFileSystem extends BaseUnderFileSystem
    * @return a new HDFS {@link UnderFileSystem} instance
    */
   public static HdfsUnderFileSystem createInstance(
-      AlluxioURI ufsUri, UnderFileSystemConfiguration conf) {
+      AlluxioURI ufsUri, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Configuration hdfsConf = createConfiguration(conf);
-    return new HdfsUnderFileSystem(ufsUri, conf, hdfsConf);
+    return new HdfsUnderFileSystem(ufsUri, conf, hdfsConf, alluxioConf);
   }
 
   /**
@@ -115,8 +115,8 @@ public class HdfsUnderFileSystem extends BaseUnderFileSystem
    * @param hdfsConf the configuration for HDFS
    */
   public HdfsUnderFileSystem(AlluxioURI ufsUri, UnderFileSystemConfiguration conf,
-      Configuration hdfsConf) {
-    super(ufsUri, conf);
+      Configuration hdfsConf, AlluxioConfiguration alluxioConf) {
+    super(ufsUri, conf, alluxioConf);
 
     // Create the supported HdfsAclProvider if possible.
     HdfsAclProvider hdfsAclProvider = new NoopHdfsAclProvider();
diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactory.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactory.java
index 9227ec49ec..f86c7ddcf7 100644
--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactory.java
+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactory.java
@@ -12,12 +12,14 @@
 package alluxio.underfs.hdfs;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 
+import alluxio.util.ConfigurationUtils;
 import com.google.common.base.Preconditions;
 
 import javax.annotation.concurrent.ThreadSafe;
@@ -29,25 +31,32 @@ import javax.annotation.concurrent.ThreadSafe;
  */
 @ThreadSafe
 public final class HdfsUnderFileSystemFactory implements UnderFileSystemFactory {
+
   /**
    * Constructs a new {@link HdfsUnderFileSystemFactory}.
    */
-  public HdfsUnderFileSystemFactory() {}
+  public HdfsUnderFileSystemFactory() { }
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf,
+      AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
-    return HdfsUnderFileSystem.createInstance(new AlluxioURI(path), conf);
+    return HdfsUnderFileSystem.createInstance(new AlluxioURI(path), conf, alluxioConf);
   }
 
   @Override
   public boolean supportsPath(String path) {
+    // This loads the static configuration from the JVM's system properties and the site properties
+    // file at the time of instantiation. Because of this, setting the property
+    // UNDERFS_HDFS_PREFIXES programatically *not* work.
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+
     if (path != null) {
       // TODO(hy): In Hadoop 2.x this can be replaced with the simpler call to
       // FileSystem.getFileSystemClass() without any need for having users explicitly declare the
       // file system schemes to treat as being HDFS. However as long as pre 2.x versions of Hadoop
       // are supported this is not an option and we have to continue to use this method.
-      for (final String prefix : Configuration.getList(PropertyKey.UNDERFS_HDFS_PREFIXES, ",")) {
+      for (final String prefix : conf.getList(PropertyKey.UNDERFS_HDFS_PREFIXES, ",")) {
         if (path.startsWith(prefix)) {
           return true;
         }
diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemContractTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemContractTest.java
index 2760a1798e..46958be868 100644
--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemContractTest.java
+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemContractTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.underfs.hdfs;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.underfs.AbstractUnderFileSystemContractTest;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -35,7 +37,7 @@ public final class HdfsUnderFileSystemContractTest extends AbstractUnderFileSyst
   @Override
   public UnderFileSystem createUfs(String path, UnderFileSystemConfiguration conf)
       throws Exception {
-    return new HdfsUnderFileSystemFactory().create(path, conf);
+    return new HdfsUnderFileSystemFactory().create(path, conf, mConfiguration);
   }
 
   @Override
diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactoryTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactoryTest.java
index c93f73ccc3..74b48c36e5 100644
--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactoryTest.java
+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemFactoryTest.java
@@ -11,6 +11,7 @@
 
 package alluxio.underfs.hdfs;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
@@ -28,19 +29,20 @@ public class HdfsUnderFileSystemFactoryTest {
   @Test
   public void factory() {
     UnderFileSystemFactory factory =
-        UnderFileSystemFactoryRegistry.find("hdfs://localhost/test/path");
+        UnderFileSystemFactoryRegistry.find("hdfs://localhost/test/path",
+            ConfigurationTestUtils.defaults());
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for HDFS paths when using this module", factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("s3://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("s3://localhost/test/path", ConfigurationTestUtils.defaults());
     Assert.assertNull(
         "A UnderFileSystemFactory should not exist for S3 paths when using this module", factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("s3n://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("s3n://localhost/test/path", ConfigurationTestUtils.defaults());
     Assert.assertNull(
         "A UnderFileSystemFactory should not exist for S3 paths when using this module", factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("alluxio://localhost:19999/test");
+    factory = UnderFileSystemFactoryRegistry.find("alluxio://localhost:19999/test", ConfigurationTestUtils.defaults());
     Assert.assertNull("A UnderFileSystemFactory should not exist for non supported paths when "
         + "using this module", factory);
   }
diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java
index fc51357b34..6a204aa128 100644
--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java
+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java
@@ -12,7 +12,9 @@
 package alluxio.underfs.hdfs;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystemConfiguration;
 
 import com.google.common.collect.ImmutableMap;
@@ -26,14 +28,16 @@ import org.junit.Test;
 public final class HdfsUnderFileSystemTest {
 
   private HdfsUnderFileSystem mHdfsUnderFileSystem;
+  private final AlluxioConfiguration mAlluxioConf = ConfigurationTestUtils.defaults();
 
   @Before
   public final void before() throws Exception {
     UnderFileSystemConfiguration conf = UnderFileSystemConfiguration.defaults()
-        .setMountSpecificConf(ImmutableMap.of("hadoop.security.group.mapping",
+        .createMountSpecificConf(ImmutableMap.of("hadoop.security.group.mapping",
             "org.apache.hadoop.security.ShellBasedUnixGroupsMapping", "fs.hdfs.impl",
             PropertyKey.UNDERFS_HDFS_IMPL.getDefaultValue()));
-    mHdfsUnderFileSystem = HdfsUnderFileSystem.createInstance(new AlluxioURI("file:///"), conf);
+    mHdfsUnderFileSystem = HdfsUnderFileSystem.createInstance(new AlluxioURI("file:///"),
+        conf, mAlluxioConf);
   }
 
   /**
diff --git a/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystem.java b/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystem.java
index 4aa74965d7..cbb192f558 100644
--- a/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystem.java
+++ b/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystem.java
@@ -12,8 +12,8 @@
 package alluxio.underfs.local;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.security.authorization.Mode;
 import alluxio.underfs.AtomicFileOutputStream;
@@ -76,8 +76,8 @@ public class LocalUnderFileSystem extends BaseUnderFileSystem
    * @param uri the {@link AlluxioURI} for this UFS
    * @param ufsConf UFS configuration
    */
-  public LocalUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration ufsConf) {
-    super(uri, ufsConf);
+  public LocalUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration ufsConf, AlluxioConfiguration alluxioConf) {
+    super(uri, ufsConf, alluxioConf);
   }
 
   @Override
@@ -169,7 +169,7 @@ public class LocalUnderFileSystem extends BaseUnderFileSystem
     if (!file.exists()) {
       throw new FileNotFoundException(path);
     }
-    return Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+    return mAlluxioConf.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
   }
 
   @Override
@@ -185,7 +185,7 @@ public class LocalUnderFileSystem extends BaseUnderFileSystem
   @Override
   public List<String> getFileLocations(String path) throws IOException {
     List<String> ret = new ArrayList<>();
-    ret.add(NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC));
+    ret.add(NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC, mAlluxioConf));
     return ret;
   }
 
@@ -383,7 +383,7 @@ public class LocalUnderFileSystem extends BaseUnderFileSystem
       LOG.debug("Exception: ", e);
       LOG.warn("In order for Alluxio to modify ownership of local files, "
           + "Alluxio should be the local file system superuser.");
-      if (!Configuration.getBoolean(PropertyKey.UNDERFS_ALLOW_SET_OWNER_FAILURE)) {
+      if (!mAlluxioConf.getBoolean(PropertyKey.UNDERFS_ALLOW_SET_OWNER_FAILURE)) {
         throw e;
       } else {
         LOG.warn("Failure is ignored, which may cause permission inconsistency between "
diff --git a/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystemFactory.java b/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystemFactory.java
index 4d204b67d4..94e442f5d1 100644
--- a/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystemFactory.java
+++ b/underfs/local/src/main/java/alluxio/underfs/local/LocalUnderFileSystemFactory.java
@@ -12,6 +12,7 @@
 package alluxio.underfs.local;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -33,9 +34,9 @@ public class LocalUnderFileSystemFactory implements UnderFileSystemFactory {
   public LocalUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Preconditions.checkArgument(path != null, "path may not be null");
-    return new LocalUnderFileSystem(new AlluxioURI(path), conf);
+    return new LocalUnderFileSystem(new AlluxioURI(path), conf, alluxioConf);
   }
 
   @Override
diff --git a/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemFactoryTest.java b/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemFactoryTest.java
index dba442343c..36e6ed6fac 100644
--- a/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemFactoryTest.java
+++ b/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemFactoryTest.java
@@ -11,9 +11,12 @@
 
 package alluxio.underfs.local;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
+import alluxio.util.ConfigurationUtils;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -27,13 +30,14 @@ public class LocalUnderFileSystemFactoryTest {
    */
   @Test
   public void factory() {
-    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("/local/test/path");
-    UnderFileSystemFactory factory2 = UnderFileSystemFactoryRegistry.find("file://local/test/path");
+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());
+    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("/local/test/path", conf);
+    UnderFileSystemFactory factory2 = UnderFileSystemFactoryRegistry.find("file://local/test/path", conf);
     UnderFileSystemFactory factory3 =
-        UnderFileSystemFactoryRegistry.find("hdfs://test-bucket/path");
-    UnderFileSystemFactory factory4 = UnderFileSystemFactoryRegistry.find("R:\\ramfs\\");
-    UnderFileSystemFactory factory5 = UnderFileSystemFactoryRegistry.find("file://R:/famfs");
-    UnderFileSystemFactory factory6 = UnderFileSystemFactoryRegistry.find("R:/ramfs/");
+        UnderFileSystemFactoryRegistry.find("hdfs://test-bucket/path", conf);
+    UnderFileSystemFactory factory4 = UnderFileSystemFactoryRegistry.find("R:\\ramfs\\", conf);
+    UnderFileSystemFactory factory5 = UnderFileSystemFactoryRegistry.find("file://R:/famfs", conf);
+    UnderFileSystemFactory factory6 = UnderFileSystemFactoryRegistry.find("R:/ramfs/", conf);
 
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for local paths when using this module", factory);
diff --git a/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemTest.java b/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemTest.java
index 7244f04ca5..b2a52cd85a 100644
--- a/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemTest.java
+++ b/underfs/local/src/test/java/alluxio/underfs/local/LocalUnderFileSystemTest.java
@@ -16,10 +16,14 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UfsMode;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.options.DeleteOptions;
 import alluxio.underfs.options.MkdirsOptions;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.io.PathUtils;
 import alluxio.util.network.NetworkAddressUtils;
 
@@ -43,6 +47,8 @@ import java.util.Map;
 public class LocalUnderFileSystemTest {
   private String mLocalUfsRoot;
   private UnderFileSystem mLocalUfs;
+  private static AlluxioConfiguration mConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
 
   @Rule
   public TemporaryFolder mTemporaryFolder = new TemporaryFolder();
@@ -50,7 +56,7 @@ public class LocalUnderFileSystemTest {
   @Before
   public void before() throws IOException {
     mLocalUfsRoot = mTemporaryFolder.getRoot().getAbsolutePath();
-    mLocalUfs = UnderFileSystem.Factory.create(mLocalUfsRoot);
+    mLocalUfs = UnderFileSystem.Factory.create(mLocalUfsRoot, mConf);
   }
 
   @Test
@@ -133,7 +139,7 @@ public class LocalUnderFileSystemTest {
   public void mkdirsWithCreateParentEqualToFalse() throws IOException {
     String parentPath = PathUtils.concatPath(mLocalUfsRoot, getUniqueFileName());
     String dirpath = PathUtils.concatPath(parentPath, getUniqueFileName());
-    mLocalUfs.mkdirs(dirpath, MkdirsOptions.defaults().setCreateParent(false));
+    mLocalUfs.mkdirs(dirpath, MkdirsOptions.defaults(mConf).setCreateParent(false));
 
     assertFalse(mLocalUfs.isDirectory(dirpath));
 
@@ -169,7 +175,9 @@ public class LocalUnderFileSystemTest {
 
     List<String> fileLocations = mLocalUfs.getFileLocations(filepath);
     assertEquals(1, fileLocations.size());
-    assertEquals(NetworkAddressUtils.getLocalHostName(), fileLocations.get(0));
+    assertEquals(NetworkAddressUtils.getLocalHostName(
+        (int)mConf.getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS)),
+        fileLocations.get(0));
   }
 
   @Test
diff --git a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSInputStream.java b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSInputStream.java
index 8d9ff979ed..5cc6ed4c70 100644
--- a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSInputStream.java
+++ b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSInputStream.java
@@ -50,8 +50,8 @@ public class OSSInputStream extends MultiRangeObjectInputStream {
    * @param key the key of the file
    * @param client the client for OSS
    */
-  OSSInputStream(String bucketName, String key, OSSClient client) throws IOException {
-    this(bucketName, key, client, 0L);
+  OSSInputStream(String bucketName, String key, OSSClient client, long blockSize) throws IOException {
+    this(bucketName, key, client, 0L, blockSize);
   }
 
   /**
@@ -62,8 +62,9 @@ public class OSSInputStream extends MultiRangeObjectInputStream {
    * @param client the client for OSS
    * @param position the position to begin reading from
    */
-  OSSInputStream(String bucketName, String key, OSSClient client, long position)
+  OSSInputStream(String bucketName, String key, OSSClient client, long position, long blockSize)
       throws IOException {
+    mBlockSize = blockSize;
     mBucketName = bucketName;
     mKey = key;
     mOssClient = client;
@@ -73,7 +74,7 @@ public class OSSInputStream extends MultiRangeObjectInputStream {
   }
 
   @Override
-  protected InputStream createStream(long startPos, long endPos) throws IOException {
+  protected InputStream createStream(long startPos, long endPos, long blockSize) throws IOException {
     GetObjectRequest req = new GetObjectRequest(mBucketName, mKey);
     // OSS returns entire object if we read past the end
     req.setRange(startPos, endPos < mContentLength ? endPos - 1 : mContentLength - 1);
diff --git a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSOutputStream.java b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSOutputStream.java
index a928200169..f6b301bfec 100644
--- a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSOutputStream.java
+++ b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSOutputStream.java
@@ -32,6 +32,7 @@ import java.io.OutputStream;
 import java.security.DigestOutputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.List;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -69,7 +70,7 @@ public final class OSSOutputStream extends OutputStream {
    * @param key the key of the file
    * @param client the client for OSS
    */
-  public OSSOutputStream(String bucketName, String key, OSSClient client) throws IOException {
+  public OSSOutputStream(String bucketName, String key, OSSClient client, List<String> tmpDirs) throws IOException {
     Preconditions.checkArgument(bucketName != null && !bucketName.isEmpty(),
         "Bucket name must not be null or empty.");
     Preconditions.checkArgument(key != null && !key.isEmpty(),
@@ -79,7 +80,7 @@ public final class OSSOutputStream extends OutputStream {
     mKey = key;
     mOssClient = client;
 
-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));
+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));
 
     try {
       mHash = MessageDigest.getInstance("MD5");
diff --git a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystem.java b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystem.java
index 22ea75e27f..b57f919b37 100644
--- a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystem.java
+++ b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystem.java
@@ -12,9 +12,9 @@
 package alluxio.underfs.oss;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.ObjectUnderFileSystem;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -65,7 +65,7 @@ public class OSSUnderFileSystem extends ObjectUnderFileSystem {
    * @return the created {@link OSSUnderFileSystem} instance
    */
   public static OSSUnderFileSystem createInstance(AlluxioURI uri,
-      UnderFileSystemConfiguration conf) throws Exception {
+      UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) throws Exception {
     String bucketName = UnderFileSystemUtils.getBucketName(uri);
     Preconditions.checkArgument(conf.isSet(PropertyKey.OSS_ACCESS_KEY),
         "Property %s is required to connect to OSS", PropertyKey.OSS_ACCESS_KEY);
@@ -77,10 +77,10 @@ public class OSSUnderFileSystem extends ObjectUnderFileSystem {
     String accessKey = conf.get(PropertyKey.OSS_SECRET_KEY);
     String endPoint = conf.get(PropertyKey.OSS_ENDPOINT_KEY);
 
-    ClientConfiguration ossClientConf = initializeOSSClientConfig();
+    ClientConfiguration ossClientConf = initializeOSSClientConfig(alluxioConf);
     OSSClient ossClient = new OSSClient(endPoint, accessId, accessKey, ossClientConf);
 
-    return new OSSUnderFileSystem(uri, ossClient, bucketName, conf);
+    return new OSSUnderFileSystem(uri, ossClient, bucketName, conf, alluxioConf);
   }
 
   /**
@@ -92,8 +92,8 @@ public class OSSUnderFileSystem extends ObjectUnderFileSystem {
    * @param conf configuration for this UFS
    */
   protected OSSUnderFileSystem(AlluxioURI uri, OSSClient ossClient, String bucketName,
-      UnderFileSystemConfiguration conf) {
-    super(uri, conf);
+                               UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
+    super(uri, conf, alluxioConf);
     mClient = ossClient;
     mBucketName = bucketName;
   }
@@ -138,7 +138,7 @@ public class OSSUnderFileSystem extends ObjectUnderFileSystem {
 
   @Override
   protected OutputStream createObject(String key) throws IOException {
-    return new OSSOutputStream(mBucketName, key, mClient);
+    return new OSSOutputStream(mBucketName, key, mClient, mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","));
   }
 
   @Override
@@ -166,7 +166,7 @@ public class OSSUnderFileSystem extends ObjectUnderFileSystem {
     key = key.equals(PATH_SEPARATOR) ? "" : key;
     ListObjectsRequest request = new ListObjectsRequest(mBucketName);
     request.setPrefix(key);
-    request.setMaxKeys(getListingChunkLength());
+    request.setMaxKeys(getListingChunkLength(mAlluxioConf));
     request.setDelimiter(delimiter);
 
     ObjectListing result = getObjectListingChunk(request);
@@ -264,14 +264,14 @@ public class OSSUnderFileSystem extends ObjectUnderFileSystem {
    *
    * @return the OSS {@link ClientConfiguration}
    */
-  private static ClientConfiguration initializeOSSClientConfig() {
+  private static ClientConfiguration initializeOSSClientConfig(AlluxioConfiguration alluxioConf) {
     ClientConfiguration ossClientConf = new ClientConfiguration();
     ossClientConf
-        .setConnectionTimeout((int) Configuration.getMs(PropertyKey.UNDERFS_OSS_CONNECT_TIMEOUT));
+        .setConnectionTimeout((int) alluxioConf.getMs(PropertyKey.UNDERFS_OSS_CONNECT_TIMEOUT));
     ossClientConf
-        .setSocketTimeout((int) Configuration.getMs(PropertyKey.UNDERFS_OSS_SOCKET_TIMEOUT));
-    ossClientConf.setConnectionTTL(Configuration.getLong(PropertyKey.UNDERFS_OSS_CONNECT_TTL));
-    ossClientConf.setMaxConnections(Configuration.getInt(PropertyKey.UNDERFS_OSS_CONNECT_MAX));
+        .setSocketTimeout((int) alluxioConf.getMs(PropertyKey.UNDERFS_OSS_SOCKET_TIMEOUT));
+    ossClientConf.setConnectionTTL(alluxioConf.getLong(PropertyKey.UNDERFS_OSS_CONNECT_TTL));
+    ossClientConf.setMaxConnections(alluxioConf.getInt(PropertyKey.UNDERFS_OSS_CONNECT_MAX));
     return ossClientConf;
   }
 
diff --git a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystemFactory.java b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystemFactory.java
index 762a4922aa..71aea83b43 100644
--- a/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystemFactory.java
+++ b/underfs/oss/src/main/java/alluxio/underfs/oss/OSSUnderFileSystemFactory.java
@@ -13,7 +13,8 @@ package alluxio.underfs.oss;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -37,12 +38,12 @@ public class OSSUnderFileSystemFactory implements UnderFileSystemFactory {
   public OSSUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
 
     if (checkOSSCredentials(conf)) {
       try {
-        return OSSUnderFileSystem.createInstance(new AlluxioURI(path), conf);
+        return OSSUnderFileSystem.createInstance(new AlluxioURI(path), conf, alluxioConf);
       } catch (Exception e) {
         throw Throwables.propagate(e);
       }
diff --git a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSInputStreamTest.java b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSInputStreamTest.java
index cbe20e6d54..ed7127f38c 100644
--- a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSInputStreamTest.java
+++ b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSInputStreamTest.java
@@ -19,6 +19,10 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import com.aliyun.oss.OSSClient;
 import com.aliyun.oss.model.GetObjectRequest;
 import com.aliyun.oss.model.OSSObject;
@@ -41,6 +45,8 @@ public class OSSInputStreamTest {
 
   private static final String BUCKET_NAME = "testBucket";
   private static final String OBJECT_KEY = "testObjectKey";
+  private static final AlluxioConfiguration mConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
 
   private OSSInputStream mOssInputStream;
   private OSSClient mOssClient;
@@ -76,7 +82,8 @@ public class OSSInputStreamTest {
       mInputStreamSpy[i] = spy(new ByteArrayInputStream(mockInput));
       when(mOssObject[i].getObjectContent()).thenReturn(mInputStreamSpy[i]);
     }
-    mOssInputStream = new OSSInputStream(BUCKET_NAME, OBJECT_KEY, mOssClient);
+    mOssInputStream = new OSSInputStream(BUCKET_NAME, OBJECT_KEY, mOssClient,
+        mConf.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT));
   }
 
   @Test
diff --git a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSOutputStreamTest.java b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSOutputStreamTest.java
index 2e1b311161..d302091f5c 100644
--- a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSOutputStreamTest.java
+++ b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSOutputStreamTest.java
@@ -11,6 +11,10 @@
 
 package alluxio.underfs.oss;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import com.aliyun.oss.OSSClient;
 import com.aliyun.oss.OSSException;
 import com.aliyun.oss.model.ObjectMetadata;
@@ -42,6 +46,8 @@ public class OSSOutputStreamTest {
   private OSSClient mOssClient;
   private File mFile;
   private BufferedOutputStream mLocalOutputStream;
+  private static final AlluxioConfiguration mConf =
+      new InstancedConfiguration(ConfigurationUtils.defaults());
 
   /**
    * The exception expected to be thrown.
@@ -71,7 +77,8 @@ public class OSSOutputStreamTest {
             .thenThrow(new IOException(errorMessage));
     mThrown.expect(IOException.class);
     mThrown.expectMessage(errorMessage);
-    new OSSOutputStream("testBucketName", "testKey", mOssClient).close();
+    new OSSOutputStream("testBucketName", "testKey", mOssClient,
+        mConf.getList(PropertyKey.TMP_DIRS, ",")).close();
   }
 
   /**
@@ -84,7 +91,7 @@ public class OSSOutputStreamTest {
             .withArguments(Mockito.any(DigestOutputStream.class)).thenReturn(mLocalOutputStream);
     PowerMockito.whenNew(BufferedOutputStream.class)
             .withArguments(Mockito.any(FileOutputStream.class)).thenReturn(mLocalOutputStream);
-    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient);
+    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient, mConf.getList(PropertyKey.TMP_DIRS, ","));
     stream.write(1);
     stream.close();
     Mockito.verify(mLocalOutputStream).write(1);
@@ -101,7 +108,7 @@ public class OSSOutputStreamTest {
             .withArguments(Mockito.any(DigestOutputStream.class)).thenReturn(mLocalOutputStream);
     PowerMockito.whenNew(BufferedOutputStream.class)
             .withArguments(Mockito.any(FileOutputStream.class)).thenReturn(mLocalOutputStream);
-    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient);
+    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient, mConf.getList(PropertyKey.TMP_DIRS, ","));
     byte[] b = new byte[1];
     stream.write(b, 0, 1);
     stream.close();
@@ -118,7 +125,7 @@ public class OSSOutputStreamTest {
             .withArguments(Mockito.any(DigestOutputStream.class)).thenReturn(mLocalOutputStream);
     PowerMockito.whenNew(BufferedOutputStream.class)
             .withArguments(Mockito.any(FileOutputStream.class)).thenReturn(mLocalOutputStream);
-    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient);
+    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient, mConf.getList(PropertyKey.TMP_DIRS, ","));
     byte[] b = new byte[1];
     stream.write(b);
     stream.close();
@@ -141,7 +148,7 @@ public class OSSOutputStreamTest {
             .when(mOssClient.putObject(Mockito.anyString(), Mockito.anyString(),
                     Mockito.any(InputStream.class), Mockito.any(ObjectMetadata.class)))
             .thenThrow(new OSSException(errorMessage));
-    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient);
+    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient, mConf.getList(PropertyKey.TMP_DIRS, ","));
     mThrown.expect(IOException.class);
     mThrown.expectMessage(errorMessage);
     stream.close();
@@ -159,7 +166,7 @@ public class OSSOutputStreamTest {
     FileInputStream inputStream = PowerMockito.mock(FileInputStream.class);
     PowerMockito.whenNew(FileInputStream.class).withArguments(mFile).thenReturn(inputStream);
 
-    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient);
+    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient, mConf.getList(PropertyKey.TMP_DIRS, ","));
     stream.close();
     Mockito.verify(mFile).delete();
   }
@@ -172,7 +179,7 @@ public class OSSOutputStreamTest {
   public void testFlush() throws Exception {
     PowerMockito.whenNew(BufferedOutputStream.class)
             .withArguments(Mockito.any(DigestOutputStream.class)).thenReturn(mLocalOutputStream);
-    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient);
+    OSSOutputStream stream = new OSSOutputStream("testBucketName", "testKey", mOssClient, mConf.getList(PropertyKey.TMP_DIRS, ","));
     stream.flush();
     stream.close();
     Mockito.verify(mLocalOutputStream).flush();
diff --git a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemContractTest.java b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemContractTest.java
index 477490f1ef..df32147a27 100644
--- a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemContractTest.java
+++ b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemContractTest.java
@@ -15,6 +15,7 @@ import alluxio.underfs.AbstractUnderFileSystemContractTest;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 
+import alluxio.util.ConfigurationUtils;
 import com.google.common.base.Preconditions;
 import org.junit.BeforeClass;
 
@@ -35,7 +36,7 @@ public final class OSSUnderFileSystemContractTest extends AbstractUnderFileSyste
   @Override
   public UnderFileSystem createUfs(String path, UnderFileSystemConfiguration conf)
       throws Exception {
-    return new OSSUnderFileSystemFactory().create(path, conf);
+    return new OSSUnderFileSystemFactory().create(path, conf, mConfiguration);
   }
 
   @Override
diff --git a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemFactoryTest.java b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemFactoryTest.java
index 016e7b0b50..8bd2f38a45 100644
--- a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemFactoryTest.java
+++ b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemFactoryTest.java
@@ -11,9 +11,11 @@
 
 package alluxio.underfs.oss;
 
+import alluxio.conf.InstancedConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
+import alluxio.util.ConfigurationUtils;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -27,7 +29,8 @@ public class OSSUnderFileSystemFactoryTest {
    */
   @Test
   public void factory() {
-    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("oss://test-bucket/path");
+    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("oss://test-bucket/path"
+        , new InstancedConfiguration(ConfigurationUtils.defaults()));
 
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for oss paths when using this module", factory);
diff --git a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemTest.java b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemTest.java
index 51605267e7..37293401cf 100644
--- a/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemTest.java
+++ b/underfs/oss/src/test/java/alluxio/underfs/oss/OSSUnderFileSystemTest.java
@@ -12,9 +12,11 @@
 package alluxio.underfs.oss;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.options.DeleteOptions;
 
+import alluxio.util.ConfigurationUtils;
 import com.aliyun.oss.OSSClient;
 import com.aliyun.oss.ServiceException;
 import com.aliyun.oss.model.ListObjectsRequest;
@@ -48,7 +50,7 @@ public class OSSUnderFileSystemTest {
     mClient = Mockito.mock(OSSClient.class);
 
     mOSSUnderFileSystem = new OSSUnderFileSystem(new AlluxioURI(""), mClient, BUCKET_NAME,
-        UnderFileSystemConfiguration.defaults());
+        UnderFileSystemConfiguration.defaults(), new InstancedConfiguration(ConfigurationUtils.defaults()));
   }
 
   /**
diff --git a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3ALowLevelOutputStream.java b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3ALowLevelOutputStream.java
index ef4361b095..5c8f37b340 100644
--- a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3ALowLevelOutputStream.java
+++ b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3ALowLevelOutputStream.java
@@ -11,9 +11,8 @@
 
 package alluxio.underfs.s3a;
 
-import alluxio.Configuration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.retry.CountingRetry;
 import alluxio.retry.RetryPolicy;
 import alluxio.util.CommonUtils;
@@ -86,8 +85,9 @@ import javax.annotation.concurrent.NotThreadSafe;
 public class S3ALowLevelOutputStream extends OutputStream {
   private static final Logger LOG = LoggerFactory.getLogger(S3ALowLevelOutputStream.class);
 
-  private static final boolean SSE_ENABLED =
-      Configuration.getBoolean(PropertyKey.UNDERFS_S3A_SERVER_SIDE_ENCRYPTION_ENABLED);
+  private final boolean mSseEnabled;
+
+  private final List<String> mTmpDirs;
 
   /**
    * Only parts bigger than 5MB could be uploaded through S3A low-level multipart upload,
@@ -156,12 +156,15 @@ public class S3ALowLevelOutputStream extends OutputStream {
    * @param executor a thread pool executor
    */
   public S3ALowLevelOutputStream(String bucketName, String key, AmazonS3 s3Client,
-      ListeningExecutorService executor) {
+                                 ListeningExecutorService executor, long streamingUploadPartitionSize,
+                                 List<String> tmpDirs, boolean sseEnabled) {
     Preconditions.checkArgument(bucketName != null && !bucketName.isEmpty(), "Bucket name must "
         + "not be null or empty.");
     mBucketName = bucketName;
     mClient = s3Client;
     mExecutor = executor;
+    mTmpDirs = tmpDirs;
+    mSseEnabled = sseEnabled;
     try {
       mHash = MessageDigest.getInstance("MD5");
     } catch (NoSuchAlgorithmException e) {
@@ -171,8 +174,7 @@ public class S3ALowLevelOutputStream extends OutputStream {
     mKey = key;
     // Partition size should be at least 5 MB, since S3 low-level multipart upload does not
     // accept intermediate part smaller than 5 MB.
-    mPartitionSize = Math.max(UPLOAD_THRESHOLD,
-        Configuration.getBytes(PropertyKey.UNDERFS_S3A_STREAMING_UPLOAD_PARTITION_SIZE));
+    mPartitionSize = Math.max(UPLOAD_THRESHOLD, streamingUploadPartitionSize);
     mPartNumber = new AtomicInteger(1);
   }
 
@@ -274,7 +276,7 @@ public class S3ALowLevelOutputStream extends OutputStream {
     // Generate the object metadata by setting server side encryption, md5 checksum,
     // and encoding as octet stream since no assumptions are made about the file type
     ObjectMetadata meta = new ObjectMetadata();
-    if (SSE_ENABLED) {
+    if (mSseEnabled) {
       meta.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);
     }
     if (mHash != null) {
@@ -302,7 +304,7 @@ public class S3ALowLevelOutputStream extends OutputStream {
    * Creates a new temp file to write to.
    */
   private void initNewFile() throws IOException {
-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));
+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(mTmpDirs), UUID.randomUUID()));
     if (mHash != null) {
       mLocalOutputStream =
           new BufferedOutputStream(new DigestOutputStream(new FileOutputStream(mFile), mHash));
diff --git a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AOutputStream.java b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AOutputStream.java
index 1ab7a727a4..a440569612 100644
--- a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AOutputStream.java
+++ b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AOutputStream.java
@@ -11,8 +11,6 @@
 
 package alluxio.underfs.s3a;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
 import alluxio.util.CommonUtils;
 import alluxio.util.io.PathUtils;
 
@@ -33,6 +31,7 @@ import java.io.OutputStream;
 import java.security.DigestOutputStream;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.util.List;
 import java.util.UUID;
 
 import javax.annotation.concurrent.NotThreadSafe;
@@ -47,8 +46,7 @@ import javax.annotation.concurrent.NotThreadSafe;
 public class S3AOutputStream extends OutputStream {
   private static final Logger LOG = LoggerFactory.getLogger(S3AOutputStream.class);
 
-  private static final boolean SSE_ENABLED =
-      Configuration.getBoolean(PropertyKey.UNDERFS_S3A_SERVER_SIDE_ENCRYPTION_ENABLED);
+  private final boolean mSseEnabled;
 
   /** Bucket name of the Alluxio S3 bucket. */
   private final String mBucketName;
@@ -86,14 +84,15 @@ public class S3AOutputStream extends OutputStream {
    * @param key the key of the file
    * @param manager the transfer manager to upload the file with
    */
-  public S3AOutputStream(String bucketName, String key, TransferManager manager)
+  public S3AOutputStream(String bucketName, String key, TransferManager manager, List<String> tmpDirs, boolean sseEnabled)
       throws IOException {
     Preconditions.checkArgument(bucketName != null && !bucketName.isEmpty(), "Bucket name must "
         + "not be null or empty.");
     mBucketName = bucketName;
     mKey = key;
     mManager = manager;
-    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));
+    mSseEnabled = sseEnabled;
+    mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));
     try {
       mHash = MessageDigest.getInstance("MD5");
       mLocalOutputStream =
@@ -136,7 +135,7 @@ public class S3AOutputStream extends OutputStream {
       // Generate the object metadata by setting server side encryption, md5 checksum, the file
       // length, and encoding as octet stream since no assumptions are made about the file type
       ObjectMetadata meta = new ObjectMetadata();
-      if (SSE_ENABLED) {
+      if (mSseEnabled) {
         meta.setSSEAlgorithm(ObjectMetadata.AES_256_SERVER_SIDE_ENCRYPTION);
       }
       if (mHash != null) {
diff --git a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystem.java b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystem.java
index b3e3fb2c68..29cf594d1d 100644
--- a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystem.java
+++ b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystem.java
@@ -12,9 +12,9 @@
 package alluxio.underfs.s3a;
 
 import alluxio.AlluxioURI;
-import alluxio.Configuration;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.ObjectUnderFileSystem;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -162,7 +162,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
    * @return the created {@link S3AUnderFileSystem} instance
    */
   public static S3AUnderFileSystem createInstance(AlluxioURI uri,
-      UnderFileSystemConfiguration conf) {
+                                                  UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
 
     AWSCredentialsProvider credentials = createAwsCredentialsProvider(conf);
     String bucketName = UnderFileSystemUtils.getBucketName(uri);
@@ -172,7 +172,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
 
     // Socket timeout
     clientConf
-        .setSocketTimeout((int) Configuration.getMs(PropertyKey.UNDERFS_S3A_SOCKET_TIMEOUT_MS));
+        .setSocketTimeout((int) alluxioConf.getMs(PropertyKey.UNDERFS_S3A_SOCKET_TIMEOUT_MS));
 
     // HTTP protocol
     if (Boolean.parseBoolean(conf.get(PropertyKey.UNDERFS_S3A_SECURE_HTTP_ENABLED))) {
@@ -207,7 +207,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
     // Set client request timeout for all requests since multipart copy is used,
     // and copy parts can only be set with the client configuration.
     clientConf
-        .setRequestTimeout((int) Configuration.getMs(PropertyKey.UNDERFS_S3A_REQUEST_TIMEOUT));
+        .setRequestTimeout((int) alluxioConf.getMs(PropertyKey.UNDERFS_S3A_REQUEST_TIMEOUT));
 
     boolean streamingUploadEnabled =
         conf.getBoolean(PropertyKey.UNDERFS_S3A_STREAMING_UPLOAD_ENABLED);
@@ -240,7 +240,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
         .build();
 
     return new S3AUnderFileSystem(uri, amazonS3Client, bucketName,
-        service, transferManager, conf, streamingUploadEnabled);
+        service, transferManager, conf, alluxioConf, streamingUploadEnabled);
   }
 
   /**
@@ -256,8 +256,8 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
    */
   protected S3AUnderFileSystem(AlluxioURI uri, AmazonS3Client amazonS3Client, String bucketName,
       ExecutorService executor, TransferManager transferManager, UnderFileSystemConfiguration conf,
-      boolean streamingUploadEnabled) {
-    super(uri, conf);
+      AlluxioConfiguration alluxioConf, boolean streamingUploadEnabled) {
+    super(uri, conf, alluxioConf);
     mClient = amazonS3Client;
     mBucketName = bucketName;
     mExecutor = MoreExecutors.listeningDecorator(executor);
@@ -335,9 +335,14 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
   @Override
   protected OutputStream createObject(String key) throws IOException {
     if (mStreamingUploadEnabled) {
-      return new S3ALowLevelOutputStream(mBucketName, key, mClient, mExecutor);
+      return new S3ALowLevelOutputStream(mBucketName, key, mClient, mExecutor,
+          mAlluxioConf.getBytes(PropertyKey.UNDERFS_S3A_STREAMING_UPLOAD_PARTITION_SIZE),
+          mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","),
+          mAlluxioConf.getBoolean(PropertyKey.UNDERFS_S3A_SERVER_SIDE_ENCRYPTION_ENABLED));
     }
-    return new S3AOutputStream(mBucketName, key, mManager);
+    return new S3AOutputStream(mBucketName, key, mManager,
+            mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","),
+                    mAlluxioConf.getBoolean(PropertyKey.UNDERFS_S3A_SERVER_SIDE_ENCRYPTION_ENABLED));
   }
 
   @Override
@@ -353,7 +358,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
 
   @Override
   protected List<String> deleteObjects(List<String> keys) throws IOException {
-    if (!Configuration.getBoolean(PropertyKey.UNDERFS_S3A_BULK_DELETE_ENABLED)) {
+    if (!mAlluxioConf.getBoolean(PropertyKey.UNDERFS_S3A_BULK_DELETE_ENABLED)) {
       return super.deleteObjects(keys);
     }
     Preconditions.checkArgument(keys != null && keys.size() <= getListingChunkLengthMax());
@@ -392,7 +397,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
         .get(PropertyKey.UNDERFS_S3A_LIST_OBJECTS_VERSION_1).equals(Boolean.toString(true))) {
       ListObjectsRequest request =
           new ListObjectsRequest().withBucketName(mBucketName).withPrefix(key)
-              .withDelimiter(delimiter).withMaxKeys(getListingChunkLength());
+              .withDelimiter(delimiter).withMaxKeys(getListingChunkLength(mAlluxioConf));
       ObjectListing result = getObjectListingChunkV1(request);
       if (result != null) {
         return new S3AObjectListingChunkV1(request, result);
@@ -400,7 +405,7 @@ public class S3AUnderFileSystem extends ObjectUnderFileSystem {
     } else {
       ListObjectsV2Request request =
           new ListObjectsV2Request().withBucketName(mBucketName).withPrefix(key)
-              .withDelimiter(delimiter).withMaxKeys(getListingChunkLength());
+              .withDelimiter(delimiter).withMaxKeys(getListingChunkLength(mAlluxioConf));
       ListObjectsV2Result result = getObjectListingChunk(request);
       if (result != null) {
         return new S3AObjectListingChunk(request, result);
diff --git a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystemFactory.java b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystemFactory.java
index 179b49403d..c853e65b6f 100644
--- a/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystemFactory.java
+++ b/underfs/s3a/src/main/java/alluxio/underfs/s3a/S3AUnderFileSystemFactory.java
@@ -13,6 +13,7 @@ package alluxio.underfs.s3a;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -36,11 +37,11 @@ public class S3AUnderFileSystemFactory implements UnderFileSystemFactory {
   public S3AUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
 
     try {
-      return S3AUnderFileSystem.createInstance(new AlluxioURI(path), conf);
+      return S3AUnderFileSystem.createInstance(new AlluxioURI(path), conf, alluxioConf);
     } catch (AmazonClientException e) {
       throw Throwables.propagate(e);
     }
diff --git a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3ALowLevelOutputStreamTest.java b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3ALowLevelOutputStreamTest.java
index 694307295f..f1addbfc8e 100644
--- a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3ALowLevelOutputStreamTest.java
+++ b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3ALowLevelOutputStreamTest.java
@@ -16,8 +16,9 @@ import static org.mockito.Mockito.never;
 import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.when;
 
-import alluxio.Configuration;
-import alluxio.PropertyKey;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import alluxio.util.FormatUtils;
 
 import com.amazonaws.services.s3.AmazonS3;
@@ -56,6 +57,8 @@ public class S3ALowLevelOutputStreamTest {
   private static final String PARTITION_SIZE = "8MB";
   private static final String KEY = "testKey";
   private static final String UPLOAD_ID = "testUploadId";
+  private static final InstancedConfiguration mAlluxioConf = new InstancedConfiguration(
+      ConfigurationUtils.defaults());
 
   private AmazonS3 mMockS3Client;
   private ListeningExecutorService mMockExecutor;
@@ -71,8 +74,11 @@ public class S3ALowLevelOutputStreamTest {
   public void before() throws Exception {
     mockS3ClientAndExecutor();
     mockFileAndOutputStream();
-    Configuration.set(PropertyKey.UNDERFS_S3A_STREAMING_UPLOAD_PARTITION_SIZE, PARTITION_SIZE);
-    mStream = new S3ALowLevelOutputStream(BUCKET_NAME, KEY, mMockS3Client, mMockExecutor);
+    mAlluxioConf.set(PropertyKey.UNDERFS_S3A_STREAMING_UPLOAD_PARTITION_SIZE, PARTITION_SIZE);
+    mStream = new S3ALowLevelOutputStream(BUCKET_NAME, KEY, mMockS3Client, mMockExecutor,
+        mAlluxioConf.getBytes(PropertyKey.UNDERFS_S3A_STREAMING_UPLOAD_PARTITION_SIZE),
+        mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","),
+        mAlluxioConf.getBoolean(PropertyKey.UNDERFS_S3A_SERVER_SIDE_ENCRYPTION_ENABLED));
   }
 
   @Test
diff --git a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AOutputStreamTest.java b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AOutputStreamTest.java
index 83c17b933a..1ebdd94dc5 100644
--- a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AOutputStreamTest.java
+++ b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AOutputStreamTest.java
@@ -11,6 +11,10 @@
 
 package alluxio.underfs.s3a;
 
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
+import alluxio.util.ConfigurationUtils;
 import com.amazonaws.services.s3.model.PutObjectRequest;
 import com.amazonaws.services.s3.transfer.TransferManager;
 import com.amazonaws.services.s3.transfer.Upload;
@@ -35,6 +39,8 @@ import java.security.DigestOutputStream;
 public class S3AOutputStreamTest {
   private static final String BUCKET_NAME = "testBucket";
   private static final String KEY = "testKey";
+  private static final AlluxioConfiguration mAlluxioConf = new InstancedConfiguration(
+      ConfigurationUtils.defaults());
 
   private File mFile;
   private BufferedOutputStream mLocalOutputStream;
@@ -56,7 +62,9 @@ public class S3AOutputStreamTest {
     PowerMockito.whenNew(File.class).withArguments(Mockito.anyString()).thenReturn(mFile);
     FileOutputStream outputStream = PowerMockito.mock(FileOutputStream.class);
     PowerMockito.whenNew(FileOutputStream.class).withArguments(mFile).thenReturn(outputStream);
-    mStream = new S3AOutputStream(BUCKET_NAME, KEY, manager);
+    mStream = new S3AOutputStream(BUCKET_NAME, KEY, manager,
+        mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","),
+        mAlluxioConf.getBoolean(PropertyKey.UNDERFS_S3A_SERVER_SIDE_ENCRYPTION_ENABLED));
   }
 
   /**
diff --git a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemContractTest.java b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemContractTest.java
index 2ff765db72..973305d65e 100644
--- a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemContractTest.java
+++ b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemContractTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.underfs.s3a;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.exception.PreconditionMessage;
 import alluxio.underfs.AbstractUnderFileSystemContractTest;
 import alluxio.underfs.UnderFileSystem;
@@ -37,7 +39,8 @@ public final class S3AUnderFileSystemContractTest extends AbstractUnderFileSyste
   @Override
   public UnderFileSystem createUfs(String path, UnderFileSystemConfiguration conf)
       throws Exception {
-    return new S3AUnderFileSystemFactory().create(path, conf);
+    return new S3AUnderFileSystemFactory().create(path, conf,
+        new InstancedConfiguration(ConfigurationTestUtils.defaults()));
   }
 
   @Override
diff --git a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemFactoryTest.java b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemFactoryTest.java
index b688180324..3fb2041c9a 100644
--- a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemFactoryTest.java
+++ b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemFactoryTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.underfs.s3a;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
@@ -27,9 +29,13 @@ public class S3AUnderFileSystemFactoryTest {
    */
   @Test
   public void factory() {
-    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("s3a://test-bucket/path");
-    UnderFileSystemFactory factory2 = UnderFileSystemFactoryRegistry.find("s3n://test-bucket/path");
-    UnderFileSystemFactory factory3 = UnderFileSystemFactoryRegistry.find("s3://test-bucket/path");
+    AlluxioConfiguration conf = ConfigurationTestUtils.defaults();
+    UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find("s3a://test-bucket/path"
+        , conf);
+    UnderFileSystemFactory factory2 = UnderFileSystemFactoryRegistry.find("s3n://test-bucket/path",
+        conf);
+    UnderFileSystemFactory factory3 = UnderFileSystemFactoryRegistry.find("s3://test-bucket/path"
+        , conf);
 
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for s3a paths when using this module", factory);
diff --git a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemTest.java b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemTest.java
index 2b9ad5654e..9587e2ae94 100644
--- a/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemTest.java
+++ b/underfs/s3a/src/test/java/alluxio/underfs/s3a/S3AUnderFileSystemTest.java
@@ -13,7 +13,10 @@ package alluxio.underfs.s3a;
 
 import alluxio.AlluxioURI;
 import alluxio.ConfigurationRule;
-import alluxio.PropertyKey;
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.InstancedConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.ObjectUnderFileSystem;
 import alluxio.underfs.UfsMode;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -51,6 +54,7 @@ public class S3AUnderFileSystemTest {
   private static final String PATH = "path";
   private static final String SRC = "src";
   private static final String DST = "dst";
+  private static final InstancedConfiguration mAlluxioConf = ConfigurationTestUtils.defaults();
 
   private static final String BUCKET_NAME = "bucket";
   private static final String DEFAULT_OWNER = "";
@@ -70,7 +74,8 @@ public class S3AUnderFileSystemTest {
     mExecutor = Mockito.mock(ListeningExecutorService.class);
     mManager = Mockito.mock(TransferManager.class);
     mS3UnderFileSystem = new S3AUnderFileSystem(new AlluxioURI("s3a://" + BUCKET_NAME), mClient,
-        BUCKET_NAME, mExecutor, mManager, UnderFileSystemConfiguration.defaults(), false);
+        BUCKET_NAME, mExecutor, mManager, UnderFileSystemConfiguration.defaults(),
+        mAlluxioConf, false);
   }
 
   @Test
@@ -126,8 +131,8 @@ public class S3AUnderFileSystemTest {
     Map<PropertyKey, String> conf = new HashMap<>();
     conf.put(PropertyKey.S3A_ACCESS_KEY, "key1");
     conf.put(PropertyKey.S3A_SECRET_KEY, "key2");
-    try (Closeable c = new ConfigurationRule(conf).toResource()) {
-      UnderFileSystemConfiguration ufsConf = UnderFileSystemConfiguration.defaults();
+    try (Closeable c = new ConfigurationRule(conf, mAlluxioConf).toResource()) {
+      UnderFileSystemConfiguration ufsConf = UnderFileSystemConfiguration.defaults(mAlluxioConf);
       AWSCredentialsProvider credentialsProvider =
           S3AUnderFileSystem.createAwsCredentialsProvider(ufsConf);
       Assert.assertEquals("key1", credentialsProvider.getCredentials().getAWSAccessKeyId());
@@ -142,7 +147,7 @@ public class S3AUnderFileSystemTest {
     Map<PropertyKey, String> conf = new HashMap<>();
     conf.put(PropertyKey.S3A_ACCESS_KEY, null);
     conf.put(PropertyKey.S3A_SECRET_KEY, null);
-    try (Closeable c = new ConfigurationRule(conf).toResource()) {
+    try (Closeable c = new ConfigurationRule(conf, mAlluxioConf).toResource()) {
       UnderFileSystemConfiguration ufsConf = UnderFileSystemConfiguration.defaults();
       AWSCredentialsProvider credentialsProvider =
           S3AUnderFileSystem.createAwsCredentialsProvider(ufsConf);
diff --git a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftInputStream.java b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftInputStream.java
index ff032b87f8..6d5134d643 100644
--- a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftInputStream.java
+++ b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftInputStream.java
@@ -44,8 +44,8 @@ public class SwiftInputStream extends MultiRangeObjectInputStream {
    * @param container the name of container where the object resides
    * @param object path of the object in the container
    */
-  public SwiftInputStream(Account account, String container, String object) {
-    this(account, container, object, 0L);
+  public SwiftInputStream(Account account, String container, String object, long blockSize) {
+    this(account, container, object, 0L, blockSize);
   }
 
   /**
@@ -56,7 +56,8 @@ public class SwiftInputStream extends MultiRangeObjectInputStream {
    * @param object path of the object in the container
    * @param position the position to begin reading from
    */
-  public SwiftInputStream(Account account, String container, String object, long position) {
+  public SwiftInputStream(Account account, String container, String object, long position, long blockSize) {
+    mBlockSize = blockSize;
     mAccount = account;
     mContainerName = container;
     mObjectPath = object;
@@ -64,7 +65,7 @@ public class SwiftInputStream extends MultiRangeObjectInputStream {
   }
 
   @Override
-  protected InputStream createStream(long startPos, long endPos) throws IOException {
+  protected InputStream createStream(long startPos, long endPos, long blockSize) throws IOException {
     StoredObject storedObject = mAccount.getContainer(mContainerName).getObject(mObjectPath);
     DownloadInstructions downloadInstructions  = new DownloadInstructions();
     downloadInstructions.setRange(new MidPartLongRange(startPos, endPos - 1));
diff --git a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftMockOutputStream.java b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftMockOutputStream.java
index 587d9270de..4a613374e0 100644
--- a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftMockOutputStream.java
+++ b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftMockOutputStream.java
@@ -25,6 +25,7 @@ import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import java.util.List;
 import java.util.UUID;
 
 import javax.annotation.concurrent.NotThreadSafe;
@@ -57,13 +58,13 @@ public class SwiftMockOutputStream extends OutputStream {
    * @param containerName container name
    * @param objectName name of file or folder to write
    */
-  public SwiftMockOutputStream(Account account, String containerName, String objectName)
+  public SwiftMockOutputStream(Account account, String containerName, String objectName, List<String> tmpDirs)
       throws IOException {
     try {
       mAccount = account;
       mContainerName = containerName;
       mObjectName = objectName;
-      mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(), UUID.randomUUID()));
+      mFile = new File(PathUtils.concatPath(CommonUtils.getTmpDir(tmpDirs), UUID.randomUUID()));
       mOutputStream  = new BufferedOutputStream(new FileOutputStream(mFile));
     } catch (Exception e) {
       LOG.error(e.getMessage());
diff --git a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystem.java b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystem.java
index 886ea94f7e..86aa462286 100644
--- a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystem.java
+++ b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystem.java
@@ -13,7 +13,8 @@ package alluxio.underfs.swift;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.exception.ExceptionMessage;
 import alluxio.exception.FileDoesNotExistException;
 import alluxio.underfs.ObjectUnderFileSystem;
@@ -92,9 +93,9 @@ public class SwiftUnderFileSystem extends ObjectUnderFileSystem {
    * @param conf the configuration for this UFS
    * @throws FileDoesNotExistException when specified container does not exist
    */
-  public SwiftUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration conf)
+  public SwiftUnderFileSystem(AlluxioURI uri, UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf)
       throws FileDoesNotExistException {
-    super(uri, conf);
+    super(uri, conf, alluxioConf);
     String containerName = UnderFileSystemUtils.getBucketName(uri);
     LOG.debug("Constructor init: {}", containerName);
     AccountConfig config = new AccountConfig();
@@ -244,7 +245,7 @@ public class SwiftUnderFileSystem extends ObjectUnderFileSystem {
   @Override
   protected OutputStream createObject(String key) throws IOException {
     if (mSimulationMode) {
-      return new SwiftMockOutputStream(mAccount, mContainerName, key);
+      return new SwiftMockOutputStream(mAccount, mContainerName, key, mAlluxioConf.getList(PropertyKey.TMP_DIRS, ","));
     }
 
     return SwiftDirectClient.put(mAccess,
@@ -278,7 +279,7 @@ public class SwiftUnderFileSystem extends ObjectUnderFileSystem {
     String prefix = PathUtils.normalizePath(key, PATH_SEPARATOR);
     // In case key is root (empty string) do not normalize prefix
     prefix = prefix.equals(PATH_SEPARATOR) ? "" : prefix;
-    PaginationMap paginationMap = container.getPaginationMap(prefix, getListingChunkLength());
+    PaginationMap paginationMap = container.getPaginationMap(prefix, getListingChunkLength(mAlluxioConf));
     if (paginationMap != null && paginationMap.getNumberOfPages() > 0) {
       return new SwiftObjectListingChunk(paginationMap, 0, recursive);
     }
diff --git a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystemFactory.java b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystemFactory.java
index 5545b60924..3bbfaf38b1 100644
--- a/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystemFactory.java
+++ b/underfs/swift/src/main/java/alluxio/underfs/swift/SwiftUnderFileSystemFactory.java
@@ -13,7 +13,8 @@ package alluxio.underfs.swift;
 
 import alluxio.AlluxioURI;
 import alluxio.Constants;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -40,12 +41,13 @@ public class SwiftUnderFileSystemFactory implements UnderFileSystemFactory {
   public SwiftUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf,
+      AlluxioConfiguration alluxioConf) {
     Preconditions.checkNotNull(path, "path");
 
     if (checkSwiftCredentials(conf)) {
       try {
-        return new SwiftUnderFileSystem(new AlluxioURI(path), conf);
+        return new SwiftUnderFileSystem(new AlluxioURI(path), conf, alluxioConf);
       } catch (Exception e) {
         throw Throwables.propagate(e);
       }
diff --git a/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemContractTest.java b/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemContractTest.java
index 2b0a89a31b..252fddfaab 100644
--- a/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemContractTest.java
+++ b/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemContractTest.java
@@ -11,6 +11,7 @@
 
 package alluxio.underfs.swift;
 
+import alluxio.ConfigurationTestUtils;
 import alluxio.underfs.AbstractUnderFileSystemContractTest;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -35,7 +36,7 @@ public final class SwiftUnderFileSystemContractTest extends AbstractUnderFileSys
   @Override
   public UnderFileSystem createUfs(String path, UnderFileSystemConfiguration conf)
       throws Exception {
-    return new SwiftUnderFileSystemFactory().create(path, conf);
+    return new SwiftUnderFileSystemFactory().create(path, conf, ConfigurationTestUtils.defaults());
   }
 
   @Override
diff --git a/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemFactoryTest.java b/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemFactoryTest.java
index 04418e37cc..b405500257 100644
--- a/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemFactoryTest.java
+++ b/underfs/swift/src/test/java/alluxio/underfs/swift/SwiftUnderFileSystemFactoryTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.underfs.swift;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
@@ -27,10 +29,11 @@ public class SwiftUnderFileSystemFactoryTest {
    */
   @Test
   public void factory() {
+    AlluxioConfiguration conf = ConfigurationTestUtils.defaults();
     UnderFileSystemFactory factory =
-        UnderFileSystemFactoryRegistry.find("swift://localhost/test/path");
+        UnderFileSystemFactoryRegistry.find("swift://localhost/test/path", conf);
     UnderFileSystemFactory factory2 =
-        UnderFileSystemFactoryRegistry.find("file://localhost/test/path");
+        UnderFileSystemFactoryRegistry.find("file://localhost/test/path", conf);
 
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for swift paths when using this " + "module",
diff --git a/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystem.java b/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystem.java
index 6868e99acc..4aa0048d98 100644
--- a/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystem.java
+++ b/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystem.java
@@ -12,7 +12,8 @@
 package alluxio.underfs.wasb;
 
 import alluxio.AlluxioURI;
-import alluxio.PropertyKey;
+import alluxio.conf.AlluxioConfiguration;
+import alluxio.conf.PropertyKey;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.hdfs.HdfsUnderFileSystem;
@@ -66,9 +67,9 @@ public class WasbUnderFileSystem extends HdfsUnderFileSystem {
    * @return a new Wasb {@link UnderFileSystem} instance
    */
   public static WasbUnderFileSystem createInstance(AlluxioURI uri,
-      UnderFileSystemConfiguration conf) {
+      UnderFileSystemConfiguration conf, AlluxioConfiguration alluxioConf) {
     Configuration wasbConf = createConfiguration(conf);
-    return new WasbUnderFileSystem(uri, conf, wasbConf);
+    return new WasbUnderFileSystem(uri, conf, wasbConf, alluxioConf);
   }
 
   /**
@@ -79,8 +80,8 @@ public class WasbUnderFileSystem extends HdfsUnderFileSystem {
    * @param wasbConf the configuration for this Wasb UFS
    */
   public WasbUnderFileSystem(AlluxioURI ufsUri, UnderFileSystemConfiguration conf,
-      final Configuration wasbConf) {
-    super(ufsUri, conf, wasbConf);
+      final Configuration wasbConf, AlluxioConfiguration alluxioConf) {
+    super(ufsUri, conf, wasbConf, alluxioConf);
   }
 
   @Override
@@ -91,7 +92,7 @@ public class WasbUnderFileSystem extends HdfsUnderFileSystem {
   @Override
   public long getBlockSizeByte(String path) throws IOException {
     // wasb is an object store, so use the default block size, like other object stores.
-    return alluxio.Configuration.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
+    return mAlluxioConf.getBytes(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT);
   }
 
   // Not supported
diff --git a/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystemFactory.java b/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystemFactory.java
index 491b9fbbbe..fac27982ec 100644
--- a/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystemFactory.java
+++ b/underfs/wasb/src/main/java/alluxio/underfs/wasb/WasbUnderFileSystemFactory.java
@@ -12,6 +12,7 @@
 package alluxio.underfs.wasb;
 
 import alluxio.AlluxioURI;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
@@ -32,9 +33,10 @@ public class WasbUnderFileSystemFactory implements UnderFileSystemFactory {
   public WasbUnderFileSystemFactory() {}
 
   @Override
-  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf) {
+  public UnderFileSystem create(String path, UnderFileSystemConfiguration conf,
+      AlluxioConfiguration alluxioConf) {
     Preconditions.checkArgument(path != null, "path may not be null");
-    return WasbUnderFileSystem.createInstance(new AlluxioURI(path), conf);
+    return WasbUnderFileSystem.createInstance(new AlluxioURI(path), conf, alluxioConf);
   }
 
   @Override
diff --git a/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemContractTest.java b/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemContractTest.java
index 19b6649af6..c4f7f7ccde 100644
--- a/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemContractTest.java
+++ b/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemContractTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.underfs.wasb;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.InstancedConfiguration;
 import alluxio.underfs.AbstractUnderFileSystemContractTest;
 import alluxio.underfs.UnderFileSystem;
 import alluxio.underfs.UnderFileSystemConfiguration;
@@ -24,6 +26,7 @@ import org.junit.BeforeClass;
 public final class WasbUnderFileSystemContractTest extends AbstractUnderFileSystemContractTest {
   private static final String WASB_BASE_DIR_CONF = "testWasbBaseDir";
   private static final String WASB_BASE_DIR = System.getProperty(WASB_BASE_DIR_CONF);
+  private static final InstancedConfiguration sAlluxioConf = ConfigurationTestUtils.defaults();
 
   @BeforeClass
   public static void beforeClass() throws Exception {
@@ -35,7 +38,7 @@ public final class WasbUnderFileSystemContractTest extends AbstractUnderFileSyst
   @Override
   public UnderFileSystem createUfs(String path, UnderFileSystemConfiguration conf)
       throws Exception {
-    return new WasbUnderFileSystemFactory().create(path, conf);
+    return new WasbUnderFileSystemFactory().create(path, conf, sAlluxioConf);
   }
 
   @Override
diff --git a/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemFactoryTest.java b/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemFactoryTest.java
index ccce94ef68..f9ee9bad4e 100644
--- a/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemFactoryTest.java
+++ b/underfs/wasb/src/test/java/alluxio/underfs/wasb/WasbUnderFileSystemFactoryTest.java
@@ -11,6 +11,8 @@
 
 package alluxio.underfs.wasb;
 
+import alluxio.ConfigurationTestUtils;
+import alluxio.conf.AlluxioConfiguration;
 import alluxio.underfs.UnderFileSystemFactory;
 import alluxio.underfs.UnderFileSystemFactoryRegistry;
 
@@ -23,17 +25,18 @@ import org.junit.Test;
 public class WasbUnderFileSystemFactoryTest {
 
   /**
-   * Tests the {@link UnderFileSystemFactoryRegistry#find(String)} method.
+   * Tests the {@link UnderFileSystemFactoryRegistry#find(String, alluxio.conf.AlluxioConfiguration)} method.
    */
   @Test
   public void factory() {
+    AlluxioConfiguration conf = ConfigurationTestUtils.defaults();
     UnderFileSystemFactory factory =
-        UnderFileSystemFactoryRegistry.find("wasb://localhost/test/path");
+        UnderFileSystemFactoryRegistry.find("wasb://localhost/test/path", conf);
     Assert.assertNotNull(
         "A UnderFileSystemFactory should exist for wasb paths when using this module",
         factory);
 
-    factory = UnderFileSystemFactoryRegistry.find("alluxio://localhost/test/path");
+    factory = UnderFileSystemFactoryRegistry.find("alluxio://localhost/test/path", conf);
     Assert.assertNull("A UnderFileSystemFactory should not exist for unsupported paths when using"
         + " this module.", factory);
   }
